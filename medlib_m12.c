
//**********************************************************************************//
//*******************************  MED 1.0.2 C Library  ****************************//
//**********************************************************************************//


// Multiscale Electrophysiology Data (MED) Format Software Library, Version 1.0.2
// Written by Matt Stead


// LICENSE & COPYRIGHT:

// MED library source code (medlib) is copyrighted by Dark Horse Neuro Inc, 2021

// Medlib is free software:
// You can redistribute it and/or modify it under the terms of the Gnu General Public License (Gnu GPL),
// version 2, or any later version (as published by the Free Software Foundation).
// The Gnu GPL requires that any object code built and distributed using this software
// is accompanied by the FULL SOURCE CODE used to generate the object code.

// This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the Gnu GPL for more details.

// If you did not receive a copy of the Gnu GPL along with this code, you can find it on the GNU website ( http://www.gnu.org ).
// You may also obtain a copy by writing to the Free Software Foundation, Inc at:
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

// We kindly ask you to acknowledge medlib in any program or publication in which you use it, but you are not required to do so.

// Commercial versions of medlib may be licensed from Dark Horse Neuro Inc, Bozeman, MT, USA.
// Commercially licensed copies do not require object code using medlib to be accompanied by the corresponding full source code.
// Users interested in a commercial license may contact us through the medformat website ( http://www.medformat.org ).


// ACKNOWLEDGEMENTS:

// MED derives from the Multiscale Electrophysiology Format (MEF), versions 1-3.
// Many people contributed to the MEF effort, but special mention is owed to
// Greg Worrell, Casey Stengel, Andy Gardner, Mark Bower, Vince Vasoli, Ben Brinkmann,
// Dan Crepeau, Jan Cimb√°lnik, Jon Lange, and Jon Halford for their contributions
// in design, coding, testing, implementation, and adoption.

// The encryption / decryption algorithm is the 128-bit AES standard ( http://www.csrc.nist.gov/publications/fips/fips197/fips-197.pdf ).
// AES routines (128 bit only) are included in the library, with attribution, for convenience.

// The hash algorithm is the SHA-256 standard ( http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf ).
// Basic SHA-256 routines are included in the library, with attribution, for convenience.

// Strings are encoded in the Universal Character Set standard, ISO/IEC 10646:2012 otherwise known as UTF-8.
// ( http://standards.iso.org/ittf/PubliclyAvailableStandards/c056921_ISO_IEC_10646_2012.zip )
// Basic UTF-8 manipulation routines are included in the library, with attribution, for convenience.

// Error detection is implemented with 32-bit cyclic redundancy checksums (CRCs).
// Basic CRC-32 manipulation routines are included in the library, with attribution, for convenience.


// USAGE:

// The library is optimized for 64-bit operating systems on 64-bit processors with 64-bit words and addressing.
// However, it can be used with in 32-bit contexts without modification at a performance cost.

// The library is written with tab width = indent width = 8 spaces and a monospaced font.
// Tabs are tabs characters, not spaces.
// Set your editor preferences to these for intended alignment.

// The library contains some non-standard structures:
// 	required compiler option (gcc, clang): -fms-extensions
// 	suppress warnings with: -Wno-microsoft-anon-tag


// VERSIONING:

// All functions, constants, macros, and data types defined in the library are tagged
// with the suffix "_mFL" (for "MED major format 'F', library 'L'").

// MED_FORMAT_VERSION_MAJOR is restricted to single digits 1 through 9
// MED_FORMAT_VERSION_MINOR is restricted to 0 through 254, minor version resets to zero with new major format version
// MED_LIBRARY_VERSION is restricted to 1 through 255, library version resets to one with new major format version

// MED_FULL_FORMAT_NAME == "<MED_VERSION_MAJOR>.<MED_VERSION_MINOR>"
// MED_FULL_LIBRARY_NAME == "<MED_FULL_FORMAT_NAME>.<MED_LIBRARY_VERSION>"
// MED_LIBRARY_TAG == "<MED_VERSION_MAJOR>.<MED_LIBRARY_VERSION>"

// Tag Examples:
// "_m12" indicates "MED format major version 1, library version 2"
// "_m21" indicates "MED format major version 2, library version 1" (for MED 2)
// "_m213" indicates "MED format major version 2, library version 13" (for MED 2)

// All library versions associated with a particular major format version are guaranteed to work on MED files of that major version.
// Minor format versions may add fields to the format in protected regions, but no preexisting fields will be removed or moved.
// Only library versions released on or afer a minor version will make use of new fields, and only if the minor version of the files contains them.
// Backward compatibility will be maintained between major versions if practical.



#include "medlib_m12.h"

// Globals
#ifdef MATLAB_m12
// "static" qualifier necessary for Matlab to maintain values between mex calls
// limits scope to current file
static GLOBALS_m12		**globals_list_m12 = NULL;
static volatile si4		globals_list_len_m12 = 0;
static pthread_mutex_t_m12	globals_list_mutex_m12;
static GLOBAL_TABLES_m12	*global_tables_m12;
#else
// "static" qualifier prevents linking across compiled libraries
GLOBALS_m12		**globals_list_m12 = NULL;
volatile si4		globals_list_len_m12 = 0;
pthread_mutex_t_m12	globals_list_mutex_m12;
GLOBAL_TABLES_m12	*global_tables_m12;
#endif



//*********************************//
// MARK: GENERAL MED FUNCTIONS  (G)
//*********************************//


ui4 	G_add_level_extension_m12(si1 *directory_name)
{
	TERN_m12	from_root;
	si1		full_path[FULL_FILE_NAME_BYTES_m12], enclosing_dir[FULL_FILE_NAME_BYTES_m12];
	si1		base_name[SEGMENT_BASE_FILE_NAME_BYTES_m12], *extension;
	ui4		type_code;
	
	
	// returns type code of existing level
	// appends extension to passed directory_name (enough space assumed to be available)
	
	G_path_from_root_m12(directory_name, full_path);
	G_extract_path_parts_m12(full_path, enclosing_dir, base_name, NULL);
	
	from_root = FALSE_m12;
	if (*directory_name == *full_path) {
		#ifdef WINDOWS_m12
		// first character not necessarily enough in Windows: e.g. "Channel_1" & "C:\"
		if (*(directory_name + 1) == *(full_path + 1))
			from_root = TRUE_m12;
		#else
		from_root = TRUE_m12;
		#endif
	}
		
	// try session
	extension = SESSION_DIRECTORY_TYPE_STRING_m12;
	sprintf_m12(full_path, "%s/%s.%s", enclosing_dir, base_name, extension);
	if (G_file_exists_m12(full_path) == DIR_EXISTS_m12) {
		type_code = SESSION_DIRECTORY_TYPE_CODE_m12;
		goto ADD_LEVEL_EXTENSION_MATCH_m12;
	}

	// try time series channel
	extension = TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12;
	sprintf_m12(full_path, "%s/%s.%s", enclosing_dir, base_name, extension);
	if (G_file_exists_m12(full_path) == DIR_EXISTS_m12) {
		type_code = TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12;
		goto ADD_LEVEL_EXTENSION_MATCH_m12;
	}

	// try video series channel
	extension = VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12;
	sprintf_m12(full_path, "%s/%s.%s", enclosing_dir, base_name, extension);
	if (G_file_exists_m12(full_path) == DIR_EXISTS_m12) {
		type_code = VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12;
		goto ADD_LEVEL_EXTENSION_MATCH_m12;
	}

	// try time series segment
	extension = TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12;
	sprintf_m12(full_path, "%s/%s.%s", enclosing_dir, base_name, extension);
	if (G_file_exists_m12(full_path) == DIR_EXISTS_m12) {
		type_code = TIME_SERIES_SEGMENT_DIRECTORY_TYPE_CODE_m12;
		goto ADD_LEVEL_EXTENSION_MATCH_m12;
	}

	// try video series segment
	extension = VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12;
	sprintf_m12(full_path, "%s/%s.%s", enclosing_dir, base_name, extension);
	if (G_file_exists_m12(full_path) == DIR_EXISTS_m12) {
		type_code = VIDEO_SEGMENT_DIRECTORY_TYPE_CODE_m12;
		goto ADD_LEVEL_EXTENSION_MATCH_m12;
	}

	// try segmented session records
	extension = RECORD_DIRECTORY_TYPE_STRING_m12;
	sprintf_m12(full_path, "%s/%s.%s", enclosing_dir, base_name, extension);
	if (G_file_exists_m12(full_path) == DIR_EXISTS_m12) {
		type_code = RECORD_DIRECTORY_TYPE_CODE_m12;
		goto ADD_LEVEL_EXTENSION_MATCH_m12;
	}

	return(NO_TYPE_CODE_m12);
	
ADD_LEVEL_EXTENSION_MATCH_m12:
	
	// attempt to append extension (may cause seg fault or memory corruption)
	if (from_root == TRUE_m12)
		sprintf_m12(directory_name, "%s/%s.%s", enclosing_dir, base_name, extension);
	else
		sprintf_m12(directory_name, "%s.%s", base_name, extension);
	
	return(type_code);
}


TERN_m12	G_all_zeros_m12(ui1 *bytes, si4 field_length)
{
	while (field_length--)
		if (*bytes++)
			return(FALSE_m12);
	
	return(TRUE_m12);
}


CHANNEL_m12	*G_allocate_channel_m12(CHANNEL_m12 *chan, FILE_PROCESSING_STRUCT_m12 *proto_fps, si1 *enclosing_path, si1 *chan_name, ui4 type_code, si4 n_segs, TERN_m12 chan_recs, TERN_m12 seg_recs)
{
	si1				*type_str;
	si8				i;
	UNIVERSAL_HEADER_m12		*uh;
	SEGMENT_m12			*seg;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// enclosing_path is the path to the enclosing directory
	// chan_name is the base name, with no extension
	// if records are requested, enough memory for 1 record of size REC_LARGEST_RECORD_BYTES_m12 is allocated (FPS_reallocate_processing_struct_m12() to change this)
	// if records are requested, enough memory for 1 record index is allocated (FPS_reallocate_processing_struct_m12() to change this)
	
	// allocate channel
	if (chan == NULL)
		chan = (CHANNEL_m12 *) calloc_m12((size_t) 1, sizeof(CHANNEL_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

	switch (type_code) {
		case TIME_SERIES_CHANNEL_TYPE_m12:
			chan->type_code = LH_TIME_SERIES_CHANNEL_m12;
			break;
		case VIDEO_CHANNEL_TYPE_m12:
			chan->type_code = LH_VIDEO_CHANNEL_m12;
			break;
		default:
			G_error_message_m12("%s():: unrecognized channel type code \"0x%x\"\n", __FUNCTION__);
			return(NULL);
	}
	
	globals_m12->number_of_mapped_segments = n_segs;

	// make new prototype fps (don't modify original)
	if (type_code == TIME_SERIES_CHANNEL_TYPE_m12)
		proto_fps = FPS_allocate_processing_struct_m12(NULL, NULL, TIME_SERIES_METADATA_FILE_TYPE_CODE_m12, FPS_PROTOTYPE_BYTES_m12, NULL, proto_fps, FPS_PROTOTYPE_BYTES_m12);
	else // type_code == VIDEO_CHANNEL_TYPE_m12
		proto_fps = FPS_allocate_processing_struct_m12(NULL, NULL, VIDEO_METADATA_FILE_TYPE_CODE_m12, FPS_PROTOTYPE_BYTES_m12, NULL, proto_fps, FPS_PROTOTYPE_BYTES_m12);
	uh = proto_fps->universal_header;
	if (uh->channel_UID == UID_NO_ENTRY_m12)
		G_generate_UID_m12(&uh->channel_UID);
	uh->segment_number = UNIVERSAL_HEADER_CHANNEL_LEVEL_CODE_m12;
	strncpy_m12(uh->channel_name, chan_name, BASE_FILE_NAME_BYTES_m12);
	strncpy_m12(chan->name, chan_name, BASE_FILE_NAME_BYTES_m12);
	type_str = G_MED_type_string_from_code_m12(type_code);
	snprintf_m12(chan->path, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", enclosing_path, chan->name, type_str);

	// allocate channel records
	if (chan_recs == TRUE_m12) {
		chan->record_data_fps = FPS_allocate_processing_struct_m12(NULL, NULL, RECORD_DATA_FILE_TYPE_CODE_m12, REC_LARGEST_RECORD_BYTES_m12, (LEVEL_HEADER_m12 *) chan, proto_fps, 0);
		snprintf_m12(chan->record_data_fps->full_file_name, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", chan->path, chan->name, RECORD_DATA_FILE_TYPE_STRING_m12);
		chan->record_indices_fps = FPS_allocate_processing_struct_m12(NULL, NULL, RECORD_INDICES_FILE_TYPE_CODE_m12, RECORD_INDEX_BYTES_m12, (LEVEL_HEADER_m12 *) chan, proto_fps, 0);
		snprintf_m12(chan->record_indices_fps->full_file_name, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", chan->path, chan->name, RECORD_INDICES_FILE_TYPE_STRING_m12);
	} else {
		chan->record_data_fps = chan->record_indices_fps = NULL;
	}

	// allocate segments
	if (n_segs) {
		chan->segments = (SEGMENT_m12 **) calloc_2D_m12((size_t) n_segs, 1, sizeof(SEGMENT_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		for (i = 0; i < n_segs; ++i) {
			seg = chan->segments[i];
			seg = G_allocate_segment_m12(seg, proto_fps, chan->path, chan->name, type_code, (si4) i + 1, seg_recs);
			if (seg == NULL)
				return(NULL);
			seg->parent = (void *) chan;
			seg->en_bloc_allocation = TRUE_m12;
		}
	}

	// clean up
	FPS_free_processing_struct_m12(proto_fps, TRUE_m12);
	
	return(chan);
}


SEGMENT_m12	*G_allocate_segment_m12(SEGMENT_m12 *seg, FILE_PROCESSING_STRUCT_m12 *proto_fps, si1 *enclosing_path, si1 *chan_name, ui4 type_code, si4 seg_num, TERN_m12 seg_recs)
{
	si1                     num_str[FILE_NUMBERING_DIGITS_m12 + 1];
	UNIVERSAL_HEADER_m12	*uh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// enclosing_path is the path to the enclosing directory
	// chan_name is the base name, with no extension
	// if time series channels are requested, the CMP_PROCESSING_STRUCT_m12 structures must be allocated seperately.
	// if time series data are requested, enough memory for one time series index is allocated.
	// if records are requested, enough memory for 1 record of size REC_LARGEST_RECORD_BYTES_m12 is allocated (use FPS_reallocate_processing_struct_m12() to change this)
	// if records are requested, enough memory for 1 record index is allocated (FPS_reallocate_processing_struct_m12() to change this)
	
	if (seg == NULL)
		seg = (SEGMENT_m12 *) calloc_m12((size_t)1, sizeof(SEGMENT_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, seg_num);
	snprintf_m12(seg->name, SEGMENT_BASE_FILE_NAME_BYTES_m12, "%s_s%s", chan_name, num_str);
	
	// allocate metadata, data, & indices
	switch (type_code) {
		case TIME_SERIES_CHANNEL_TYPE_m12:
			seg->type_code = LH_TIME_SERIES_SEGMENT_m12;
			// metadata: used as prototype
			seg->metadata_fps = FPS_allocate_processing_struct_m12(NULL, NULL, TIME_SERIES_METADATA_FILE_TYPE_CODE_m12, METADATA_BYTES_m12, (LEVEL_HEADER_m12 *) seg, proto_fps, METADATA_BYTES_m12);
			uh = seg->metadata_fps->universal_header;
			if (uh->segment_UID == UID_NO_ENTRY_m12)
				G_generate_UID_m12(&uh->segment_UID);
			uh->segment_number = seg_num;
			snprintf_m12(seg->path, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", enclosing_path, seg->name, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12);
			snprintf_m12(seg->metadata_fps->full_file_name, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", seg->path, seg->name, TIME_SERIES_METADATA_FILE_TYPE_STRING_m12);
			// time series data
			seg->time_series_data_fps = FPS_allocate_processing_struct_m12(NULL, NULL, TIME_SERIES_DATA_FILE_TYPE_CODE_m12, 0, (LEVEL_HEADER_m12 *) seg, seg->metadata_fps, 0);
			snprintf_m12(seg->time_series_data_fps->full_file_name, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", seg->path, seg->name, TIME_SERIES_DATA_FILE_TYPE_STRING_m12);
			// time series indices
			seg->time_series_indices_fps = FPS_allocate_processing_struct_m12(NULL, NULL, TIME_SERIES_INDICES_FILE_TYPE_CODE_m12, TIME_SERIES_INDEX_BYTES_m12, (LEVEL_HEADER_m12 *) seg, seg->metadata_fps, 0);
			snprintf_m12(seg->time_series_indices_fps->full_file_name, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", seg->path, seg->name, TIME_SERIES_INDICES_FILE_TYPE_STRING_m12);
			break;
		case VIDEO_CHANNEL_TYPE_m12:
			seg->type_code = LH_VIDEO_SEGMENT_m12;
			// metadata: used as prototype
			seg->metadata_fps = FPS_allocate_processing_struct_m12(NULL, NULL, VIDEO_METADATA_FILE_TYPE_CODE_m12, METADATA_BYTES_m12, (LEVEL_HEADER_m12 *) seg, proto_fps, METADATA_BYTES_m12);
			uh = seg->metadata_fps->universal_header;
			if (uh->segment_UID == UID_NO_ENTRY_m12)
				G_generate_UID_m12(&uh->segment_UID);
			uh->segment_number = seg_num;
			snprintf_m12(seg->path, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", enclosing_path, seg->name, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12);
			snprintf_m12(seg->metadata_fps->full_file_name, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", seg->path, seg->name, VIDEO_METADATA_FILE_TYPE_STRING_m12);
			// video indices
			seg->video_indices_fps = FPS_allocate_processing_struct_m12(NULL, NULL, VIDEO_INDICES_FILE_TYPE_CODE_m12, VIDEO_INDEX_BYTES_m12, (LEVEL_HEADER_m12 *) seg, seg->metadata_fps, 0);
			snprintf_m12(seg->video_indices_fps->full_file_name, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", seg->path, seg->name, VIDEO_INDICES_FILE_TYPE_STRING_m12);
			break;
		default:
			G_error_message_m12("%s(): unrecognized type code \"0x%x\"\n", __FUNCTION__, type_code);
			return(NULL);
	}
	
	// allocate session records
	if (seg_recs == TRUE_m12) {
		seg->record_data_fps = FPS_allocate_processing_struct_m12(NULL, NULL, RECORD_DATA_FILE_TYPE_CODE_m12, REC_LARGEST_RECORD_BYTES_m12, (LEVEL_HEADER_m12 *) seg, seg->metadata_fps, 0);
		snprintf_m12(seg->record_data_fps->full_file_name, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", seg->path, seg->name, RECORD_DATA_FILE_TYPE_STRING_m12);
		seg->record_indices_fps = FPS_allocate_processing_struct_m12(NULL, NULL, RECORD_INDICES_FILE_TYPE_CODE_m12, RECORD_INDEX_BYTES_m12, (LEVEL_HEADER_m12 *) seg, seg->metadata_fps, 0);
		snprintf_m12(seg->record_indices_fps->full_file_name, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", seg->path, seg->name, RECORD_INDICES_FILE_TYPE_STRING_m12);
	} else {
		seg->record_data_fps = seg->record_indices_fps = NULL;
	}

	return(seg);
}


SESSION_m12	*G_allocate_session_m12(FILE_PROCESSING_STRUCT_m12 *proto_fps, si1 *enclosing_path, si1 *sess_name, si4 n_ts_chans, si4 n_vid_chans, si4 n_segs, si1 **ts_chan_names, si1 **vid_chan_names, TERN_m12 sess_recs, TERN_m12 segmented_sess_recs, TERN_m12 chan_recs, TERN_m12 seg_recs)
{
	si1                             free_names, number_str[FILE_NUMBERING_DIGITS_m12 + 1];
	si8                             i;
	SESSION_m12			*sess;
	UNIVERSAL_HEADER_m12		*uh;
	FILE_PROCESSING_STRUCT_m12	*gen_fps;
	SEGMENTED_SESS_RECS_m12		*ssr;
	CHANNEL_m12			*chan;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// enclosing_path is the path to the enclosing directory
	// sess_name is the base name, with no extension
	// if records are requested, enough memory for 1 record of data size REC_LARGEST_RECORD_BYTES_m12 is allocated (FPS_reallocate_processing_struct_m12() to change this)
	// if records are requested, enough memory for 1 record index is allocated (FPS_reallocate_processing_struct_m12() to change this)
	
	// allocate session
	sess = (SESSION_m12 *) calloc_m12((size_t)1, sizeof(SESSION_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	globals_m12->number_of_mapped_segments = n_segs;
	sess->number_of_time_series_channels = n_ts_chans;
	sess->number_of_video_channels = n_vid_chans;
	sess->type_code = LH_SESSION_m12;

	// create a prototype fps
	proto_fps = FPS_allocate_processing_struct_m12(NULL, NULL, FPS_PROTOTYPE_FILE_TYPE_CODE_m12, FPS_PROTOTYPE_BYTES_m12, NULL, proto_fps, FPS_PROTOTYPE_BYTES_m12);
	uh = proto_fps->universal_header;
	if (uh->session_UID == UID_NO_ENTRY_m12)
		G_generate_UID_m12(&uh->session_UID);
	uh->segment_number = UNIVERSAL_HEADER_SESSION_LEVEL_CODE_m12;;
	strncpy_m12(uh->session_name, sess_name, BASE_FILE_NAME_BYTES_m12);
	strncpy_m12(globals_m12->uh_session_name, sess_name, BASE_FILE_NAME_BYTES_m12);
	sess->name = globals_m12->session_name = globals_m12->uh_session_name;
	snprintf_m12(sess->path, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", enclosing_path, sess->name, SESSION_DIRECTORY_TYPE_STRING_m12);
		
	// allocate channels
	if (n_ts_chans) {
		free_names = FALSE_m12;
		if (ts_chan_names == NULL) {
			ts_chan_names = G_generate_numbered_names_m12(NULL, "tch_", n_ts_chans);
			free_names = TRUE_m12;
		}
		sess->time_series_channels = (CHANNEL_m12 **) calloc_2D_m12((size_t) n_ts_chans, 1, sizeof(CHANNEL_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		for (i = 0; i < n_ts_chans; ++i) {
			chan = sess->time_series_channels[i];
			chan = G_allocate_channel_m12(chan, proto_fps, sess->path, ts_chan_names[i], TIME_SERIES_CHANNEL_TYPE_m12, n_segs, chan_recs, seg_recs);
			if (chan == NULL)
				return(NULL);
			chan->parent = (void *) sess;
			chan->en_bloc_allocation = TRUE_m12;
		}
		if (free_names == TRUE_m12)
			free_m12((void *) ts_chan_names, __FUNCTION__);
	}
	
	if (n_vid_chans) {
		free_names = FALSE_m12;
		if (vid_chan_names == NULL) {
			vid_chan_names = G_generate_numbered_names_m12(NULL, "vch_", n_vid_chans);
			free_names = TRUE_m12;
		}
		sess->video_channels = (CHANNEL_m12 **) calloc_2D_m12((size_t) n_vid_chans, 1, sizeof(CHANNEL_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		for (i = 0; i < n_vid_chans; ++i) {
			chan = sess->video_channels[i];
			G_allocate_channel_m12(sess->video_channels[i], proto_fps, sess->path, vid_chan_names[i], VIDEO_CHANNEL_TYPE_m12, n_segs, chan_recs, seg_recs);
			if (chan == NULL)
				return(NULL);
			chan->parent = (void *) sess;
			chan->en_bloc_allocation = TRUE_m12;
		}
		if (free_names == TRUE_m12)
			free((void *) vid_chan_names);
	}

	// allocate session records
	if (sess_recs == TRUE_m12) {
		sess->record_data_fps = FPS_allocate_processing_struct_m12(NULL, NULL, RECORD_DATA_FILE_TYPE_CODE_m12, REC_LARGEST_RECORD_BYTES_m12, (LEVEL_HEADER_m12 *) sess, proto_fps, 0);
		snprintf_m12(sess->record_data_fps->full_file_name, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", sess->path, sess->name, RECORD_DATA_FILE_TYPE_STRING_m12);
		sess->record_indices_fps = FPS_allocate_processing_struct_m12(NULL, NULL, RECORD_INDICES_FILE_TYPE_CODE_m12, RECORD_INDEX_BYTES_m12, (LEVEL_HEADER_m12 *) sess, proto_fps, 0);
		snprintf_m12(sess->record_indices_fps->full_file_name, FULL_FILE_NAME_BYTES_m12, "%s/%s.%s", sess->path, sess->name, RECORD_INDICES_FILE_TYPE_STRING_m12);
	} else {
		sess->record_data_fps = sess->record_indices_fps = NULL;
	}
	FPS_free_processing_struct_m12(proto_fps, TRUE_m12);  // done with session prototype
	
	// allocate segmented session records
	if (segmented_sess_recs == TRUE_m12) {
		ssr = sess->segmented_sess_recs = (SEGMENTED_SESS_RECS_m12 *) calloc_m12((size_t) 1, sizeof(SEGMENTED_SESS_RECS_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		ssr->record_data_fps = (FILE_PROCESSING_STRUCT_m12 **) calloc_2D_m12((size_t) n_segs, 1, sizeof(FILE_PROCESSING_STRUCT_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		ssr->record_indices_fps = (FILE_PROCESSING_STRUCT_m12 **) calloc_2D_m12((size_t) n_segs, 1, sizeof(FILE_PROCESSING_STRUCT_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		sprintf_m12(ssr->path, "%s/%s.%s", sess->path, sess->name, RECORD_DIRECTORY_TYPE_STRING_m12);
		strcpy_m12(ssr->name, sess->name);
		ssr->type_code = LH_SEGMENTED_SESS_RECS_m12;
		ssr->flags = sess->flags;
		for (i = 0; i < n_segs; ++i) {
			// get an segment prototype
			if (n_ts_chans)
				proto_fps = sess->time_series_channels[0]->segments[i]->metadata_fps;
			else if (n_vid_chans)
				proto_fps = sess->video_channels[0]->segments[i]->metadata_fps;
			// record indices fps
			G_numerical_fixed_width_string_m12(number_str, FILE_NUMBERING_DIGITS_m12, (si4) i + 1); // segments numbered from 1
			snprintf_m12(ssr->record_indices_fps[i]->full_file_name, FULL_FILE_NAME_BYTES_m12, "%s/%s_s%s.%s", ssr->path, ssr->name, number_str, RECORD_INDICES_FILE_TYPE_STRING_m12);
			gen_fps = FPS_allocate_processing_struct_m12(ssr->record_indices_fps[i], NULL, RECORD_INDICES_FILE_TYPE_CODE_m12, RECORD_INDEX_BYTES_m12, (LEVEL_HEADER_m12 *) ssr, proto_fps, 0);
			if (gen_fps == NULL)
				return(NULL);
			uh = gen_fps->universal_header;
			memset((void *) uh->channel_name, 0, BASE_FILE_NAME_BYTES_m12);
			uh->channel_UID = UID_NO_ENTRY_m12;
			// record data fps
			snprintf_m12(ssr->record_data_fps[i]->full_file_name, FULL_FILE_NAME_BYTES_m12, "%s/%s_s%s.%s", ssr->path, ssr->name, number_str, RECORD_DATA_FILE_TYPE_STRING_m12);
			gen_fps = FPS_allocate_processing_struct_m12(ssr->record_data_fps[i], NULL, RECORD_DATA_FILE_TYPE_CODE_m12, REC_LARGEST_RECORD_BYTES_m12, (LEVEL_HEADER_m12 *) ssr, proto_fps, 0);
			if (gen_fps == NULL)
				return(NULL);
			uh = gen_fps->universal_header;
			memset((void *) uh->channel_name, 0, BASE_FILE_NAME_BYTES_m12);
			uh->channel_UID = UID_NO_ENTRY_m12;
		}
	} else {
		sess->segmented_sess_recs = NULL;
	}

	return(sess);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
TERN_m12	G_allocated_en_bloc_m12(LEVEL_HEADER_m12 *level_header)
{
	typedef void (*sig_handler_ptr)(int);
	
	sig_handler_ptr		current_handler;
	TERN_m12		en_bloc;
	size_t			struct_bytes;
	LEVEL_HEADER_m12	*test_ptr, **test_ptr_ptr;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	switch (level_header->type_code) {
		case LH_TIME_SERIES_CHANNEL_m12:
		case LH_VIDEO_CHANNEL_m12:
			struct_bytes = sizeof(CHANNEL_m12);
			break;
		case LH_TIME_SERIES_SEGMENT_m12:
		case LH_VIDEO_SEGMENT_m12:
			struct_bytes = sizeof(SEGMENT_m12);
			break;
		default:
			return(FALSE_m12);
	}
	
	// save current signal handler for SIGSEGV & set to ignore
	// NOTE: this is not thread-safe
	current_handler = signal(SIGSEGV, SIG_IGN);

	// check for structure before (will fail if first element)
	en_bloc = FALSE_m12;
	test_ptr = (LEVEL_HEADER_m12 *) ((ui1 *) level_header - struct_bytes);
	if (test_ptr->type_code == level_header->type_code) {
		en_bloc = TRUE_m12;
	} else {  // check for structure after (will fail if last element)
		test_ptr = (LEVEL_HEADER_m12 *) ((ui1 *) level_header + struct_bytes);
		if (test_ptr->type_code == level_header->type_code) {
			en_bloc = TRUE_m12;
		} else {  // check for pointer to structure before (i.e. one structure array - pointer must point to it, even if sorted)
			test_ptr_ptr = (LEVEL_HEADER_m12 **) ((ui1 *) level_header - sizeof(void *));
			if (*test_ptr_ptr == level_header)
				en_bloc = TRUE_m12;
			// else not allocated en bloc
		}
	}
	
	// restore previous signal handler
	signal(SIGSEGV, current_handler);

	return(en_bloc);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	G_apply_recording_time_offset_m12(si8 *time)
{
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (*time != UUTC_NO_ENTRY_m12)
		*time -= globals_m12->recording_time_offset;
	
	return;
}



si1	*G_behavior_string_m12(ui4 behavior, si1 *behavior_string)
{
	si8	len;
	
	
	if (behavior_string == NULL)  // caller responsible for freeing
		behavior_string = malloc_m12(256, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	*behavior_string = 0;
	
	if (behavior == USE_GLOBAL_BEHAVIOR_m12) {
		behavior = globals_m12->behavior_on_fail;
		strcat(behavior_string, "USE GLOBAL BEHAVIOR == ");
	}
	
	if (behavior & EXIT_ON_FAIL_m12)
		strcat(behavior_string, "EXIT ON FAIL | ");
	if (behavior & RETURN_ON_FAIL_m12)
		strcat(behavior_string, "RETURN ON FAIL | ");
	if (behavior & SUPPRESS_ERROR_OUTPUT_m12)
		strcat(behavior_string, "SUPPRESS ERROR OUTPUT | ");
	if (behavior & SUPPRESS_WARNING_OUTPUT_m12)
		strcat(behavior_string, "SUPPRESS WARNING OUTPUT | ");
	if (behavior & SUPPRESS_MESSAGE_OUTPUT_m12)
		strcat(behavior_string, "SUPPRESS MESSAGE OUTPUT | ");
	if (behavior & RETRY_ONCE_m12)
		strcat(behavior_string, "RETRY ONCE | ");

	len = strlen(behavior_string);
	if (len)
		behavior_string[len - 3] = 0;
		
	return(behavior_string);
}


si8	G_build_contigua_m12(LEVEL_HEADER_m12 *level_header)
{
	TERN_m12				force_discont, null_sample_numbers;
	si1					tmp_str[FULL_FILE_NAME_BYTES_m12];
	ui4					type_code;
	si4					n_segs, seg_idx, search_mode;
	si8					i, j, k, n_contigua, start_idx, end_idx, last_block_samples, last_block_frames;
	si8					last_block_usecs, new_bytes, absolute_numbering_offset;
	si8					last_segment_end_sample_number, last_segment_end_frame_number, last_segment_end_time, last_segment_number;
	sf8					samp_freq, frame_rate;
	SEGMENT_m12				*seg;
	CHANNEL_m12				*chan;
	SESSION_m12				*sess;
	TIME_SLICE_m12				*slice;
	TIME_SERIES_METADATA_SECTION_2_m12	*tmd2;
	VIDEO_METADATA_SECTION_2_m12		*vmd2;
	CONTIGUON_m12				*contigua, *contiguon;
	TIME_SERIES_INDEX_m12			*tsi;
	VIDEO_INDEX_m12				*vi;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// find contigua in current time slice, and set in level
	
	switch (level_header->type_code) {
		case LH_TIME_SERIES_SEGMENT_m12:
		case LH_VIDEO_SEGMENT_m12:
			seg = (SEGMENT_m12 *) level_header;
			slice = &seg->time_slice;
			chan = NULL;
			type_code = level_header->type_code;
			break;
		case LH_TIME_SERIES_CHANNEL_m12:
		case LH_VIDEO_CHANNEL_m12:
			chan = (CHANNEL_m12 *) level_header;
			slice = &chan->time_slice;
			type_code = level_header->type_code;
			break;
		case LH_SESSION_m12:
			sess = (SESSION_m12 *) level_header;
			chan = globals_m12->reference_channel;
			slice = &sess->time_slice;
			type_code = chan->type_code;
			break;
		default:
			G_warning_message_m12("%s(): invalid level type\n", __FUNCTION__);
			return(FALSE_m12);
	}
	
	seg_idx = G_get_segment_index_m12(slice->start_segment_number);
	if (seg_idx == FALSE_m12)
		return(FALSE_m12);
	n_segs = TIME_SLICE_SEGMENT_COUNT_m12(slice);
	if ((search_mode = G_get_search_mode_m12(slice)) == FALSE_m12)
		return(FALSE_m12);
	
	contigua = NULL;
	n_contigua = 0;
	force_discont = TRUE_m12;
	new_bytes = 0;
	if (type_code == LH_TIME_SERIES_CHANNEL_m12) {
		for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
			if (chan != NULL)  // segment level passed
				seg = chan->segments[j];
			if (seg == NULL) {  // segment missing
				force_discont = TRUE_m12;
				continue;
			}

			// get metadata
			if (seg->metadata_fps == NULL) {
				sprintf_m12(tmp_str, "%s/%s.%s", seg->path, seg->name, TIME_SERIES_METADATA_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12) {
					seg->metadata_fps = G_read_file_m12(NULL, tmp_str, 0, 0, FPS_FULL_FILE_m12, (LEVEL_HEADER_m12 *) seg, NULL, USE_GLOBAL_BEHAVIOR_m12);
				} else {
					force_discont = TRUE_m12;
					continue;
				}
			}
			tmd2 = &seg->metadata_fps->metadata->time_series_section_2;
			samp_freq = tmd2->sampling_frequency;
			absolute_numbering_offset = tmd2->absolute_start_sample_number;

			// get indices
			if (seg->time_series_indices_fps == NULL) {
				sprintf_m12(tmp_str, "%s/%s.%s", seg->path, seg->name, TIME_SERIES_INDICES_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12) {
					seg->time_series_indices_fps = G_read_file_m12(NULL, tmp_str, 0, 0, FPS_FULL_FILE_m12, (LEVEL_HEADER_m12 *) seg, NULL, USE_GLOBAL_BEHAVIOR_m12);
				} else {
					force_discont = TRUE_m12;
					continue;
				}
			}

			// build contigua
			tsi = seg->time_series_indices_fps->time_series_indices;
			if (search_mode == TIME_SEARCH_m12) {
				start_idx = G_find_index_m12(seg, slice->start_time, TIME_SEARCH_m12 | NO_OVERFLOWS_m12);
				end_idx = G_find_index_m12(seg, slice->end_time, TIME_SEARCH_m12 | NO_OVERFLOWS_m12);
			} else {  // SAMPLE_SEARCH_m12
				start_idx = G_find_index_m12(seg, slice->start_sample_number - absolute_numbering_offset, SAMPLE_SEARCH_m12 | NO_OVERFLOWS_m12);
				end_idx = G_find_index_m12(seg, slice->end_sample_number - absolute_numbering_offset, SAMPLE_SEARCH_m12 | NO_OVERFLOWS_m12);
			}

			for (k = start_idx; k <= end_idx; ++k) {
				if (tsi[k].file_offset < 0 || force_discont == TRUE_m12) {
					// close last contiguon
					if (n_contigua) {
						contiguon = contigua + (n_contigua - 1);
						contiguon->end_segment_number = (si4) j + 1;
						if (k) {
							contiguon->end_sample_number = (tsi[k].start_sample_number + absolute_numbering_offset) - 1;
							last_block_samples = tsi[k].start_sample_number - tsi[k - 1].start_sample_number;
							last_block_usecs = (si8) round(((sf8) last_block_samples / samp_freq) * (sf8) 1e6);
							contiguon->end_time = (tsi[k - 1].start_time + last_block_usecs) - 1;
						} else {  // discontinuity on segment transition
							contiguon->end_sample_number = last_segment_end_sample_number;
							contiguon->end_time = last_segment_end_time;
							contiguon->end_segment_number = (si4) last_segment_number;
						}
					}
					// open new contiguon
					new_bytes += sizeof(CONTIGUON_m12);
					contigua = (CONTIGUON_m12 *) realloc_m12((void *) contigua, new_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
					contiguon = contigua + n_contigua++;
					contiguon->start_sample_number = tsi[k].start_sample_number + absolute_numbering_offset;
					contiguon->start_time = tsi[k].start_time;
					contiguon->start_segment_number = (si4) j + 1;

					force_discont = FALSE_m12;
				}
			}
			last_segment_end_sample_number = (tsi[k].start_sample_number + absolute_numbering_offset) - 1;
			last_segment_end_time = tsi[k].start_time - 1;
			last_segment_number = j + 1;
		}
		
		// close final contiguon
		contiguon->end_sample_number = (tsi[k].start_sample_number + absolute_numbering_offset) - 1;  // k == next index of last set of indices
		contiguon->end_time = tsi[k].start_time - 1;  // next index start time
		contiguon->end_segment_number = (si4) j;
	} else {  // LH_VIDEO_CHANNEL_m12
		for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
			if (chan != NULL)  // segment level passed
				seg = chan->segments[j];
			if (seg == NULL) {  // segment missing
				force_discont = TRUE_m12;
				continue;
			}
			// get metadata
			if (seg->metadata_fps == NULL) {
				sprintf_m12(tmp_str, "%s/%s.%s", seg->path, seg->name, VIDEO_METADATA_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12) {
					seg->metadata_fps = G_read_file_m12(NULL, tmp_str, 0, 0, FPS_FULL_FILE_m12, (LEVEL_HEADER_m12 *) seg, NULL, USE_GLOBAL_BEHAVIOR_m12);
				} else {
					force_discont = TRUE_m12;
					continue;
				}
			}
			vmd2 = &seg->metadata_fps->metadata->video_section_2;
			frame_rate = vmd2->frame_rate;
			absolute_numbering_offset = vmd2->absolute_start_frame_number;
			
			// get indices
			if (seg->time_series_indices_fps == NULL) {
				sprintf_m12(tmp_str, "%s/%s.%s", seg->path, seg->name, VIDEO_INDICES_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12) {
					seg->video_indices_fps = G_read_file_m12(NULL, tmp_str, 0, 0, FPS_FULL_FILE_m12, (LEVEL_HEADER_m12 *) seg, NULL, USE_GLOBAL_BEHAVIOR_m12);
				} else {
					force_discont = TRUE_m12;
					continue;
				}
			}

			// build contigua
			vi = seg->video_indices_fps->video_indices;
			if (search_mode == TIME_SEARCH_m12) {
				start_idx = G_find_index_m12(seg, slice->start_time, TIME_SEARCH_m12 | NO_OVERFLOWS_m12);
				end_idx = G_find_index_m12(seg, slice->end_time, TIME_SEARCH_m12 | NO_OVERFLOWS_m12);
			} else {
				start_idx = G_find_index_m12(seg, slice->start_frame_number, SAMPLE_SEARCH_m12 | NO_OVERFLOWS_m12);
				end_idx = G_find_index_m12(seg, slice->end_frame_number, SAMPLE_SEARCH_m12 | NO_OVERFLOWS_m12);
			}
			for (k = start_idx; k <= end_idx; ++k) {
				if (vi[k].file_offset < 0 || force_discont == TRUE_m12) {
					// close last contiguon
					if (n_contigua) {
						contiguon = contigua + (n_contigua - 1);
						contiguon->end_segment_number = (si4) j + 1;
						// end time
						if (k) {
							contiguon->end_frame_number = ((si8) vi[k].start_frame_number + absolute_numbering_offset) - 1;
							last_block_frames = vi[k].start_frame_number - vi[k - 1].start_frame_number;
							last_block_usecs = (si8) round(((sf8) last_block_frames / frame_rate) * (sf8) 1e6);
							contiguon->end_time = (vi[k - 1].start_time + last_block_usecs) - 1;
						} else {  // discontinuity on segment transition
							contiguon->end_frame_number = last_segment_end_frame_number;
							contiguon->end_time = last_segment_end_time;
							contiguon->end_segment_number = (si4) last_segment_number;
						}
					}
					// open new contiguon
					new_bytes = (size_t) (n_contigua + 1) * sizeof(CONTIGUON_m12);
					contigua = (CONTIGUON_m12 *) realloc_m12((void *) contigua, new_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
					contiguon = contigua + n_contigua++;
					contiguon->start_frame_number = vi[k].start_frame_number + absolute_numbering_offset;
					contiguon->start_time = vi[k].start_time;
					contiguon->start_segment_number = (si4) j + 1;
					
					force_discont = FALSE_m12;
				}
			}
			last_segment_end_frame_number = (vi[k].start_frame_number + absolute_numbering_offset) - 1;
			last_segment_end_time = vi[k].start_time - 1;
			last_segment_number = (si4) j + 1;
		}
		
		// close final contiguon
		contiguon->end_frame_number = ((si8) vi[k].start_frame_number + absolute_numbering_offset) - 1;  // k == next index of last set of indices
		contiguon->end_time = vi[k].start_time - 1;  // next index start time
		contiguon->end_segment_number = (si4) j;
	}
	
	if (n_contigua == 0)
		return((si4) FALSE_m12);
	
	// trim contigua ends to slice (sample_number == frame_number)
	if (contigua[0].start_time < slice->start_time)
		contigua[0].start_time = slice->start_time;
	if (contigua[n_contigua - 1].end_time > slice->end_time)
		contigua[n_contigua - 1].end_time = slice->end_time;
	if (contigua[0].start_sample_number < slice->start_sample_number)
		contigua[0].start_sample_number = slice->start_sample_number;
	if (contigua[n_contigua - 1].end_sample_number > slice->end_sample_number)
		contigua[n_contigua - 1].end_sample_number = slice->end_sample_number;
	
	// set sample/frame numbers to NO ENTRY for variable frequency sessions
	if (level_header->type_code == LH_SESSION_m12) {
		null_sample_numbers = FALSE_m12;
		if (type_code == LH_TIME_SERIES_CHANNEL_m12 && globals_m12->time_series_frequencies_vary == TRUE_m12)
			null_sample_numbers = TRUE_m12;
		else if (type_code == LH_VIDEO_CHANNEL_m12 && globals_m12->video_frame_rates_vary == TRUE_m12)
			null_sample_numbers = TRUE_m12;
		if (null_sample_numbers == TRUE_m12) {
			for (i = 0; i < n_contigua; ++i)
				contigua[i].start_sample_number = contigua[i].end_sample_number = SAMPLE_NUMBER_NO_ENTRY_m12;  // sample_number == frame_number
		}
	}

	// assign to level
	switch (level_header->type_code) {  // type_code for session is ref channel type, so use original value
		case LH_TIME_SERIES_SEGMENT_m12:
		case LH_VIDEO_SEGMENT_m12:
			if (seg->contigua != NULL)
				free_m12((void *) seg->contigua, __FUNCTION__);
			seg->contigua = contigua;
			seg->number_of_contigua = n_contigua;
			break;
		case LH_TIME_SERIES_CHANNEL_m12:
		case LH_VIDEO_CHANNEL_m12:
			if (chan->contigua != NULL)
				free_m12((void *) chan->contigua, __FUNCTION__);
			chan->contigua = contigua;
			chan->number_of_contigua = n_contigua;
			break;
		case LH_SESSION_m12:
			if (sess->contigua != NULL)
				free_m12((void *) sess->contigua, __FUNCTION__);
			sess->contigua = contigua;
			sess->number_of_contigua = n_contigua;
			break;
	}
		
	return(n_contigua);
}


Sgmt_RECORD_m12	*G_build_Sgmt_records_array_m12(FILE_PROCESSING_STRUCT_m12 *ri_fps, FILE_PROCESSING_STRUCT_m12 *rd_fps, CHANNEL_m12 *chan)
{
	TERN_m12			seek_mode;
	si1				**seg_list, *metadata_ext, tmp_str[FULL_FILE_NAME_BYTES_m12], seg_name[SEGMENT_BASE_FILE_NAME_BYTES_m12];
	si4				n_segs;
	si8				i, file_offset, data_len, n_recs, seek_data_size;
	const si8			SEEK_THRESHOLD = 10;  // this factor is a guess, for now
	FILE_PROCESSING_STRUCT_m12	*md_fps;
	RECORD_INDEX_m12		*ri;
	Sgmt_RECORD_m12			*Sgmt_records, *Sgmt_rec;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (ri_fps == NULL && rd_fps == NULL) {
		if (chan == NULL ) {  // nothing passed - see if we can use global reference channel (can happen if no records read on open)
			if (globals_m12->reference_channel == NULL) {
				G_error_message_m12("%s(): no records or channel passed or found\n", __FUNCTION__);
				return(NULL);
			} else {
				chan = globals_m12->reference_channel;
			}
		}
		// use channel records
		if (chan != NULL) {
			if (ri_fps == NULL && rd_fps == NULL) {
				sprintf_m12(tmp_str, "%s/%s.%s", chan->path, chan->name, RECORD_INDICES_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12) {
					chan->record_indices_fps = G_read_file_m12(NULL, tmp_str, 0, 0, FPS_FULL_FILE_m12, NULL, NULL, USE_GLOBAL_BEHAVIOR_m12);
					sprintf_m12(tmp_str, "%s/%s.%s", chan->path, chan->name, RECORD_DATA_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12) {
						// read full file - this bypasses test below, needs to be fixed
						chan->record_data_fps = G_read_file_m12(NULL, tmp_str, 0, 0, FPS_FULL_FILE_m12, NULL, NULL, USE_GLOBAL_BEHAVIOR_m12);
						ri_fps = chan->record_indices_fps;
						rd_fps = chan->record_data_fps;
					}
				}
			}
		}
	}

	// use Sgmt records
	if (ri_fps != NULL) {  // assume rd_fps != NULL
		// full record index file already read in
		n_recs = ri_fps->universal_header->number_of_entries;
		if (globals_m12->number_of_session_segments == SEGMENT_NUMBER_NO_ENTRY_m12) {
			ri = ri_fps->record_indices;
			for (n_segs = 0, i = n_recs; i--; ++ri)
				if (ri->type_code == REC_Sgmt_TYPE_CODE_m12)
					++n_segs;
			globals_m12->number_of_session_segments = n_segs;
		} else {
			n_segs = globals_m12->number_of_session_segments;
		}
				
		// allocate Sgmt_records array
		Sgmt_records = (Sgmt_RECORD_m12 *) calloc_m12((size_t) n_segs, sizeof(Sgmt_RECORD_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

		// decide if more efficient to read full file, or seek to specific records
		seek_mode = FALSE_m12;
		if (rd_fps->parameters.full_file_read == FALSE_m12) {  // full file not already read in
			data_len = rd_fps->parameters.flen - UNIVERSAL_HEADER_BYTES_m12;
			seek_data_size = (si8) n_segs * sizeof(Sgmt_RECORD_m12);
			if ((data_len / seek_data_size) >= SEEK_THRESHOLD)
				seek_mode = TRUE_m12;
			else
				G_read_file_m12(rd_fps, NULL, 0, 0, FPS_FULL_FILE_m12, NULL, NULL, USE_GLOBAL_BEHAVIOR_m12); // read in full file
		}
		if (seek_mode == TRUE_m12) {  // ? more efficient to seek (large records files)
			ri = ri_fps->record_indices;
			for (i = 0; i < n_segs; ++ri) {
				if (ri->type_code == REC_Sgmt_TYPE_CODE_m12) {
					G_read_file_m12(rd_fps, NULL, ri->file_offset, sizeof(Sgmt_RECORD_m12), 1, NULL, NULL, USE_GLOBAL_BEHAVIOR_m12);
					Sgmt_records[i] = *((Sgmt_RECORD_m12 *) rd_fps->record_data);
					Sgmt_records[i++].total_record_bytes = sizeof(Sgmt_RECORD_m12);  // discard description, if any
				}
			}
		} else {  // ? more efficient to read full file (small records files)
			ri = ri_fps->record_indices;
			for (i = 0; i < n_segs; ++ri) {
				if (ri->type_code == REC_Sgmt_TYPE_CODE_m12) {
					file_offset = REMOVE_DISCONTINUITY_m12(ri->file_offset);
					Sgmt_records[i] = *((Sgmt_RECORD_m12 *) (rd_fps->parameters.raw_data + file_offset));
					Sgmt_records[i++].total_record_bytes = sizeof(Sgmt_RECORD_m12);  // discard description, if any
				}
			}
		}
	}
	
	// use metadata files (much less efficient)
	else {  // ri_fps == NULL
		seg_list = G_generate_file_list_m12(NULL, &n_segs, chan->path, NULL, "?isd", GFL_FULL_PATH_m12);
		globals_m12->number_of_session_segments = n_segs;
		
		// allocate Sgmt_records array
		Sgmt_records = (Sgmt_RECORD_m12 *) calloc_m12((size_t) n_segs, sizeof(Sgmt_RECORD_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

		switch (chan->type_code) {
			case LH_TIME_SERIES_CHANNEL_m12:
				metadata_ext = TIME_SERIES_METADATA_FILE_TYPE_STRING_m12;
				break;
			case LH_VIDEO_CHANNEL_m12:
				metadata_ext = VIDEO_METADATA_FILE_TYPE_STRING_m12;
				break;
		}
		
		for (i = 0; i < n_segs; ++i) {
			G_extract_path_parts_m12(seg_list[i], NULL, seg_name, NULL);
			sprintf_m12(tmp_str, "%s/%s.%s", seg_list[i], seg_name, metadata_ext);
			md_fps = G_read_file_m12(NULL, tmp_str, 0, 0, FPS_FULL_FILE_m12, NULL, NULL, USE_GLOBAL_BEHAVIOR_m12);
			Sgmt_rec = Sgmt_records + i;
			Sgmt_rec->record_CRC = CRC_NO_ENTRY_m12;
			Sgmt_rec->total_record_bytes = RECORD_HEADER_BYTES_m12 + REC_Sgmt_v10_BYTES_m12;  // no description
			Sgmt_rec->start_time = md_fps->universal_header->segment_start_time;
			Sgmt_rec->type_code = REC_Sgmt_TYPE_CODE_m12;
			Sgmt_rec->version_major = 1;
			Sgmt_rec->version_minor = 0;
			Sgmt_rec->encryption_level = NO_ENCRYPTION_m12;
			Sgmt_rec->end_time = md_fps->universal_header->segment_end_time;
			Sgmt_rec->segment_UID = md_fps->universal_header->segment_UID;
			Sgmt_rec->segment_number = md_fps->universal_header->segment_number;
			switch (chan->type_code) {
				case LH_TIME_SERIES_CHANNEL_m12:
					Sgmt_rec->start_sample_number = md_fps->metadata->time_series_section_2.absolute_start_sample_number;
					Sgmt_rec->end_sample_number = Sgmt_rec->start_sample_number + md_fps->metadata->time_series_section_2.number_of_samples - 1;
					Sgmt_rec->acquisition_channel_number = md_fps->metadata->time_series_section_2.acquisition_channel_number;
					Sgmt_rec->sampling_frequency = md_fps->metadata->time_series_section_2.sampling_frequency;
					break;
				case LH_VIDEO_CHANNEL_m12:
					Sgmt_rec->start_frame_number = md_fps->metadata->video_section_2.absolute_start_frame_number;
					Sgmt_rec->end_frame_number = Sgmt_rec->start_frame_number + md_fps->metadata->video_section_2.number_of_frames - 1;
					Sgmt_rec->acquisition_channel_number = md_fps->metadata->video_section_2.acquisition_channel_number;
					Sgmt_rec->frame_rate = md_fps->metadata->video_section_2.frame_rate;
					break;
			}
			FPS_free_processing_struct_m12(md_fps, TRUE_m12);
		}
		free_m12((void *) seg_list, __FUNCTION__);
	}

	// fill in global end fields
	globals_m12->session_end_time = Sgmt_records[n_segs - 1].end_time;
	if (Sgmt_records[n_segs - 1].end_sample_number != SAMPLE_NUMBER_NO_ENTRY_m12)
		globals_m12->number_of_session_samples = Sgmt_records[n_segs - 1].end_sample_number + 1;  // frame numbers are unioned

	return(Sgmt_records);
}


si8	G_bytes_for_items_m12(FILE_PROCESSING_STRUCT_m12 *fps, si8 *number_of_items, si8 read_file_offset)
{
	ui4				entry_size;
	si8				i, bytes, max_bytes;
	RECORD_HEADER_m12		*rh;
	CMP_BLOCK_FIXED_HEADER_m12	*bh;
	UNIVERSAL_HEADER_m12		*uh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// read_file_offset only needed for items with variable size data (TIME_SERIES_DATA_FILE_TYPE_CODE_m12 & RECORD_DATA_FILE_TYPE_CODE_m12)
	// read_file_offset == 0 for writing
	
	bytes = 0;
	uh = fps->universal_header;
	switch (uh->type_code) {
		case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
		case VIDEO_INDICES_FILE_TYPE_CODE_m12:
		case RECORD_INDICES_FILE_TYPE_CODE_m12:
			bytes = *number_of_items * INDEX_BYTES_m12;
			uh->maximum_entry_size = INDEX_BYTES_m12;
			break;
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
			bytes = METADATA_BYTES_m12;
			uh->maximum_entry_size = METADATA_BYTES_m12;
			*number_of_items = 1;
			break;
	}
	if (bytes)
		return(bytes);
	
	read_file_offset = REMOVE_DISCONTINUITY_m12(read_file_offset);
	if (read_file_offset == 0) {  // writing (data is in memory)
		switch (uh->type_code) {
			case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
				bh = fps->parameters.cps->block_header;
				for (i = 0; i < *number_of_items; ++i) {
					entry_size = (si8) bh->total_block_bytes;
					if (uh->maximum_entry_size < entry_size)  // caller should've done this, but just in case
						uh->maximum_entry_size = entry_size;
					bytes += entry_size;
					bh = (CMP_BLOCK_FIXED_HEADER_m12 *) ((ui1 *) bh + entry_size);
				}
				break;
			case RECORD_DATA_FILE_TYPE_CODE_m12:
				rh = (RECORD_HEADER_m12 *) fps->record_data;
				for (i = 0; i < *number_of_items; ++i) {
					entry_size = (si8) rh->total_record_bytes;
					if (uh->maximum_entry_size < entry_size)  // caller should've done this, but just in case
						uh->maximum_entry_size = entry_size;
					bytes += entry_size;
					rh = (RECORD_HEADER_m12 *) ((ui1 *) rh + entry_size);
				}
				break;
		}
		return(bytes);
	}
	
	// reading (this is why it's better to pass this value)
	max_bytes = (si8) uh->maximum_entry_size * *number_of_items;
	FPS_reallocate_processing_struct_m12(fps, max_bytes);
	max_bytes = FPS_read_m12(fps, read_file_offset, max_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	switch (uh->type_code) {
		case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
			bh = fps->parameters.cps->block_header;
			for (i = 0; i < *number_of_items; ++i) {
				entry_size = (si8) bh->total_block_bytes;
				bytes += entry_size;
				if (bytes > max_bytes) {
					*number_of_items = i;
					bytes -= entry_size;
					break;
				}
				bh = (CMP_BLOCK_FIXED_HEADER_m12 *) ((ui1 *) bh + entry_size);
			}
			break;
		case RECORD_DATA_FILE_TYPE_CODE_m12:
			rh = (RECORD_HEADER_m12 *) fps->record_data;;
			for (i = 0; i < *number_of_items; ++i) {
				entry_size = (si8) rh->total_record_bytes;
				bytes += entry_size;
				if (bytes > max_bytes) {
					*number_of_items = i;
					bytes -= entry_size;
					break;
				}
				rh = (RECORD_HEADER_m12 *) ((ui1 *) rh + entry_size);
			}
			break;
	}
	
	return(bytes);
}


void    G_calculate_indices_CRCs_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	si8     		i;
	INDEX_m12		*idx;
	UNIVERSAL_HEADER_m12	*uh;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	idx = (INDEX_m12 *) fps->data_pointers;
	uh = fps->universal_header;
	for (i = fps->number_of_items; i--; ++idx)
		uh->body_CRC = CRC_update_m12((ui1 *) idx, INDEX_BYTES_m12, uh->body_CRC);
	
	return;
}


void	G_calculate_metadata_CRC_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	fps->universal_header->body_CRC = CRC_calculate_m12((ui1 *) fps->data_pointers, METADATA_BYTES_m12);
	
	return;
}


void    G_calculate_record_data_CRCs_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	ui4			temp_CRC, full_record_CRC;
	si8			i;
	RECORD_HEADER_m12	*rh;
	UNIVERSAL_HEADER_m12	*uh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	uh = fps->universal_header;
	rh = (RECORD_HEADER_m12 *) fps->data_pointers;
	for (i = fps->number_of_items; i--;) {
		rh->record_CRC = CRC_calculate_m12((ui1 *) rh + RECORD_HEADER_CRC_START_OFFSET_m12, rh->total_record_bytes - RECORD_HEADER_CRC_START_OFFSET_m12);
		
		temp_CRC = CRC_calculate_m12((ui1 *) rh, RECORD_HEADER_CRC_START_OFFSET_m12);
		full_record_CRC = CRC_combine_m12(temp_CRC, rh->record_CRC, rh->total_record_bytes - RECORD_HEADER_CRC_START_OFFSET_m12);
		uh->body_CRC = CRC_combine_m12(uh->body_CRC, full_record_CRC, rh->total_record_bytes);
		
		rh = (RECORD_HEADER_m12 *) ((ui1 *) rh + rh->total_record_bytes);
	}
	
	return;
}


void    G_calculate_time_series_data_CRCs_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	ui4     			temp_CRC, full_block_CRC;
	si8     			i;
	UNIVERSAL_HEADER_m12		*uh;
	CMP_BLOCK_FIXED_HEADER_m12	*bh;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	bh = (CMP_BLOCK_FIXED_HEADER_m12 *) fps->data_pointers;
		
	uh = fps->universal_header;
	for (i = fps->number_of_items; i--;) {
		bh->block_CRC = CRC_calculate_m12((ui1 *) bh + CMP_BLOCK_CRC_START_OFFSET_m12, bh->total_block_bytes - CMP_BLOCK_CRC_START_OFFSET_m12);
		
		temp_CRC = CRC_calculate_m12((ui1 *) bh, CMP_BLOCK_CRC_START_OFFSET_m12);
		full_block_CRC = CRC_combine_m12(temp_CRC, bh->block_CRC, bh->total_block_bytes - CMP_BLOCK_CRC_START_OFFSET_m12);
		uh->body_CRC = CRC_combine_m12(uh->body_CRC, full_block_CRC, bh->total_block_bytes);
		
		bh = (CMP_BLOCK_FIXED_HEADER_m12 *) ((ui1 *) bh + bh->total_block_bytes);
	}
	
	return;
}


CHANNEL_m12	*G_change_reference_channel_m12(SESSION_m12 *sess, CHANNEL_m12 *channel, si1 *channel_name, si1 channel_type)
{
	TERN_m12	use_default_channel;
	si8		i, n_chans;
	CHANNEL_m12	*tmp_chan;
	size_t		bytes;

	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// pass either channel, or channel name (if both passed channel will be used)
	// if both NULL, use channel_type
	
	// reference channel already set
	if (channel != NULL) {
		if (channel == globals_m12->reference_channel) {
			if (*globals_m12->reference_channel_name == 0)
				strcpy(globals_m12->reference_channel_name, channel->name);
			return(channel);
		}
	}

	use_default_channel = FALSE_m12;
	if (channel == NULL) {
		if (G_empty_string_m12(channel_name) == TRUE_m12) {
			if (*globals_m12->reference_channel_name)
				channel_name = globals_m12->reference_channel_name;
			else
				use_default_channel = TRUE_m12;
		}
	}
	if (use_default_channel == FALSE_m12)  // if channel or channel_name passed, channel type options ignored
		channel_type = DEFAULT_CHANNEL_m12;

	if (use_default_channel == TRUE_m12) {
		switch (channel_type) {
			case DEFAULT_CHANNEL_m12:
			case DEFAULT_TIME_SERIES_CHANNEL_m12:
			case DEFAULT_VIDEO_CHANNEL_m12:
				break;
			case HIGHEST_RATE_TIME_SERIES_CHANNEL_m12:
				channel = globals_m12->maximum_time_series_frequency_channel;
				channel_type = DEFAULT_TIME_SERIES_CHANNEL_m12;
				break;
			case LOWEST_RATE_TIME_SERIES_CHANNEL_m12:
				channel = globals_m12->minimum_time_series_frequency_channel;
				channel_type = DEFAULT_TIME_SERIES_CHANNEL_m12;
				break;
			case HIGHEST_RATE_VIDEO_CHANNEL_m12:
				channel = globals_m12->maximum_video_frame_rate_channel;
				channel_type = DEFAULT_VIDEO_CHANNEL_m12;
				break;
			case LOWEST_RATE_VIDEO_CHANNEL_m12:
				channel = globals_m12->minimum_video_frame_rate_channel;
				channel_type = DEFAULT_VIDEO_CHANNEL_m12;
				break;
			default:
				channel_type = DEFAULT_CHANNEL_m12;
				break;
		}
	}
	
	// find channel from name
	globals_m12->reference_channel = NULL;
	if (channel == NULL) {
		if (use_default_channel == TRUE_m12) {
			if ((channel = G_get_active_channel_m12(sess, channel_type)) == NULL) {
				G_error_message_m12("%s(): no matching active channels\n", __FUNCTION__);
				return(NULL);
			}
			goto CHANGE_REF_MATCH_m12;
		}
		if (channel_type == DEFAULT_CHANNEL_m12 || channel_type == DEFAULT_TIME_SERIES_CHANNEL_m12) {
			n_chans = sess->number_of_time_series_channels;  // check for match in time_series_channels
			for (i = 0; i < n_chans; ++i) {
				tmp_chan = sess->time_series_channels[i];
				if (tmp_chan->flags & LH_CHANNEL_ACTIVE_m12) {
					if (strcmp(tmp_chan->name, channel_name) == 0) {
						channel = tmp_chan;
						goto CHANGE_REF_MATCH_m12;
					}
				}
			}
		}
		if (channel_type == DEFAULT_CHANNEL_m12 || channel_type == DEFAULT_VIDEO_CHANNEL_m12) {
			n_chans = sess->number_of_video_channels;
			for (i = 0; i < n_chans; ++i) {
				tmp_chan = sess->video_channels[i];
				if (tmp_chan->flags & LH_CHANNEL_ACTIVE_m12) {
					if (strcmp(tmp_chan->name, channel_name) == 0) {
						channel = tmp_chan;
						goto CHANGE_REF_MATCH_m12;
					}
				}
			}
		}
	} else {  // channel known
		if (channel->flags & LH_CHANNEL_ACTIVE_m12)
			goto CHANGE_REF_MATCH_m12;
		if ((channel = G_get_active_channel_m12(sess, channel_type)) != NULL)
			goto CHANGE_REF_MATCH_m12;
	}

	G_error_message_m12("%s(): no matching active channels\n", __FUNCTION__);
	return(NULL);
	
CHANGE_REF_MATCH_m12:
	globals_m12->reference_channel = channel;
	strcpy(globals_m12->reference_channel_name, channel->name);

	if (channel->Sgmt_records == NULL)
		channel->Sgmt_records = G_build_Sgmt_records_array_m12(NULL, NULL, channel);
	// copy to session Sgmt records
	if (sess->Sgmt_records == NULL) {
		bytes = (size_t) globals_m12->number_of_session_segments * sizeof(Sgmt_RECORD_m12);
		sess->Sgmt_records = (Sgmt_RECORD_m12 *) malloc_m12(bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		memcpy((void *) sess->Sgmt_records, (void *) channel->Sgmt_records, (size_t) bytes);
	}

	return(channel);
}


ui4	G_channel_type_from_path_m12(si1 *path)
{
	si1	*c, temp_path[FULL_FILE_NAME_BYTES_m12], name[SEGMENT_BASE_FILE_NAME_BYTES_m12], extension[TYPE_BYTES_m12];
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// move pointer to end of string
	c = path + strlen(path) - 1;
	
	// ignore terminal "/" if present
	if (*c == '/')
		c--;
	
	// copy extension
	c -= 4;
	if (*c != '.')
		return(UNKNOWN_CHANNEL_TYPE_m12);
	strncpy_m12(extension, ++c, TYPE_BYTES_m12);
	
	// compare extension: record types => get extension of next level up the hierarchy
	if (!(strcmp(extension, RECORD_DATA_FILE_TYPE_STRING_m12)) || !(strcmp(extension, RECORD_INDICES_FILE_TYPE_STRING_m12))) {
		G_extract_path_parts_m12(path, temp_path, NULL, NULL);
		G_extract_path_parts_m12(temp_path, temp_path, name, extension);
	}
	
	// compare extension: TIMES_SERIES_CHANNEL_TYPE
	if (!(strcmp(extension, TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12)))
		return(TIME_SERIES_CHANNEL_TYPE_m12);
	else if (!(strcmp(extension, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12)))
		return(TIME_SERIES_CHANNEL_TYPE_m12);
	else if (!(strcmp(extension, TIME_SERIES_METADATA_FILE_TYPE_STRING_m12)))
		return(TIME_SERIES_CHANNEL_TYPE_m12);
	else if (!(strcmp(extension, TIME_SERIES_DATA_FILE_TYPE_STRING_m12)))
		return(TIME_SERIES_CHANNEL_TYPE_m12);
	else if (!(strcmp(extension, TIME_SERIES_INDICES_FILE_TYPE_STRING_m12)))
		return(TIME_SERIES_CHANNEL_TYPE_m12);
	
	// compare extension: VIDEO_CHANNEL_TYPE
	else if (!(strcmp(extension, VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12)))
		return(VIDEO_CHANNEL_TYPE_m12);
	else if (!(strcmp(extension, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12)))
		return(VIDEO_CHANNEL_TYPE_m12);
	else if (!(strcmp(extension, VIDEO_METADATA_FILE_TYPE_STRING_m12)))
		return(VIDEO_CHANNEL_TYPE_m12);
	else if (!(strcmp(extension, VIDEO_INDICES_FILE_TYPE_STRING_m12)))
		return(VIDEO_CHANNEL_TYPE_m12);
	
	// unknown channel type
	return(UNKNOWN_CHANNEL_TYPE_m12);
}


TERN_m12	G_check_char_type_m12(void)
{
	char	c;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// check size of "char"
	if (sizeof(char) != 1)
		return(FALSE_m12);

	// check signedness of "char"
	c = -1;
	if ((si4) c != (si4) -1)
		return(FALSE_m12);
	
	return(TRUE_m12);
}


TERN_m12	G_check_file_list_m12(si1 **file_list, si4 n_files)
{
	si4	i;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// G_generate_file_list_m12() does a lot of stuff, but often just need to ensure list contains full paths with no regex
	
	if (file_list == NULL)
		return(FALSE_m12);
	if (file_list[0] == NULL)
		return(FALSE_m12);
	
	for (i = 0; i < n_files; ++i) {
		if (STR_contains_regex_m12(file_list[i]) == TRUE_m12)
			return(FALSE_m12);
		if (G_path_from_root_m12(file_list[i], NULL) == FALSE_m12)
			return(FALSE_m12);
	}

	return(TRUE_m12);
}


TERN_m12	G_check_file_system_m12(si1 *file_system_path, si4 is_cloud, ...)  // varargs: si1 *cloud_directory, si1 *cloud_service_name, si1 *cloud_utilities_directory
{
	si1		command[FULL_FILE_NAME_BYTES_m12 + 64], cloud_prefix[FULL_FILE_NAME_BYTES_m12];
	si1		full_path[FULL_FILE_NAME_BYTES_m12];
	si1		*cloud_directory, *cloud_service_name, *cloud_utilities_directory;
	si4		ret_val;
	va_list		args;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (file_system_path == NULL)
		file_system_path = ".";
	else if (*file_system_path == 0)
		file_system_path = ".";
	G_path_from_root_m12(file_system_path, full_path);
	
	// make directory if it doesn't exist
	#if defined MACOS_m12 || defined LINUX_m12
	sprintf_m12(command, "mkdir -p \"%s\"", full_path);
	#endif
	#ifdef WINDOWS_m12
	sprintf_m12(command, "mkdir \"%s\"", full_path);
	#endif
	system_m12(command, TRUE_m12, __FUNCTION__, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12);

	// check write ability on file system
	sprintf_m12(command, "echo x > \"%s/test_file-remove_me\"", full_path);  // create non-empty file in case file system is cloud
	ret_val = system_m12(command, TRUE_m12, __FUNCTION__, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12);
	if (ret_val) {
		G_error_message_m12("%s(): Cannot create files on \"%s\"\n", __FUNCTION__, full_path);
		return(FALSE_m12);
	}

	// check write ability on cloud
	if (is_cloud == TRUE_m12) {
		va_start(args, is_cloud);
		cloud_directory = va_arg(args, si1 *);
		cloud_service_name = va_arg(args, si1 *);
		cloud_utilities_directory = va_arg(args, si1 *);
		va_end(args);
		
		if (strcmp(cloud_service_name, "amazon") == 0)
			sprintf_m12(cloud_prefix, "%s/gustil ", cloud_utilities_directory);
		else if (strcmp(cloud_service_name, "google") == 0)
			sprintf_m12(cloud_prefix, "%s/aws s3 ", cloud_utilities_directory);
		
		// copy file system test file to cloud
		sprintf(command, "%scp %s/test_file-remove_me %s/test_file-remove_me", cloud_prefix, file_system_path, cloud_directory);
		system_m12(command, TRUE_m12, __FUNCTION__, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12);
		if (ret_val) {
			G_error_message_m12("%s(): Cannot create files on \"%s\"\n", __FUNCTION__, cloud_directory);
			return(FALSE_m12);
		} else {
			// clean up
			sprintf(command, "%srm %s/test_file-remove_me", cloud_prefix, cloud_directory);
			system_m12(command, TRUE_m12, __FUNCTION__, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12);
		}
	}
	
	// clean up
	#if defined MACOS_m12 || defined LINUX_m12
	sprintf(command, "rm \"%s/test_file-remove_me\"", full_path);
	#endif
	#ifdef WINDOWS_m12
	sprintf(command, "del \"%s\\test_file-remove_me\"", full_path);
	#endif
	system_m12(command, TRUE_m12, __FUNCTION__, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12);

	return(TRUE_m12);
}


TERN_m12	G_check_password_m12(si1 *password)
{
	si4	pw_len;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// check pointer: return FALSE_m12 for NULL
	if (password == NULL) {
		G_warning_message_m12("%s(): password is NULL\n", __FUNCTION__);
		return(FALSE_m12);
	}
		
	// check password length
	pw_len = UTF8_strlen_m12(password);
	if (pw_len == 0) {
		G_warning_message_m12("%s(): password has no characters\n", __FUNCTION__);
		return(FALSE_m12);
	}
	if (pw_len > MAX_PASSWORD_CHARACTERS_m12) {
		G_warning_message_m12("%s(): password too long (1 to  %d characters)\n", __FUNCTION__, MAX_PASSWORD_CHARACTERS_m12);
		return(FALSE_m12);
	}
	
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("Password is of valid form\n", __FUNCTION__);
	
	// return TRUE_m12 for valid password
	return(TRUE_m12);
}


si4	G_check_segment_map_m12(TIME_SLICE_m12 *slice, SESSION_m12 *sess)
{
	si4 		start_seg, end_seg, seg_idx, first_mapped_seg, last_mapped_seg;
	si4		remapped_start_seg, remapped_end_seg, remapped_seg_cnt;
	si4		i, j, offset, mapped_segs, sess_segs;
	CHANNEL_m12	*chan;
	SEGMENT_m12	**remapped_segs;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns offset of start_segment_number into segments array
	// if segment range needs to be remapped, this is done before return
	// call from read_session_m12() before any channel reading to avoid any conflicts with threads if remapping required
	// returns FALSE_m12 on error

	start_seg = slice->start_segment_number;
	end_seg = slice->end_segment_number;
	if (start_seg == SEGMENT_NUMBER_NO_ENTRY_m12 || end_seg == SEGMENT_NUMBER_NO_ENTRY_m12) {
		G_warning_message_m12("%s(): segment range not fully specified => returning false\n", __FUNCTION__);
		return((si4) FALSE_m12);
	}
	
	sess_segs = globals_m12->number_of_session_segments;
	if (start_seg < 1 || end_seg > sess_segs) {
		G_warning_message_m12("%s(): segment range not valid => returning false\n", __FUNCTION__);
		return((si4) FALSE_m12);
	}

	// all segments mapped
	mapped_segs = globals_m12->number_of_mapped_segments;
	if (mapped_segs == sess_segs) {
		if (start_seg >= 1 && end_seg <= sess_segs) {
			return(start_seg - 1);
		}
	}
	
	first_mapped_seg = globals_m12->first_mapped_segment_number;
	last_mapped_seg = (first_mapped_seg + mapped_segs) - 1;
	if (start_seg >= first_mapped_seg && end_seg <= last_mapped_seg)
		return(start_seg - first_mapped_seg);
	
	// remapping required
	remapped_start_seg = (start_seg < first_mapped_seg) ? start_seg : first_mapped_seg;
	remapped_end_seg = (end_seg > last_mapped_seg) ? end_seg : last_mapped_seg;
	remapped_seg_cnt = (remapped_end_seg - remapped_start_seg) + 1;
	for (i = 0; i < sess->number_of_time_series_channels; ++i) {
		chan = sess->time_series_channels[i];
		remapped_segs = (SEGMENT_m12 **) calloc_m12((size_t) remapped_seg_cnt, sizeof(SEGMENT_m12 *), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		offset = first_mapped_seg - remapped_start_seg;
		for (j = 0; j < mapped_segs; ++j, ++offset)
			remapped_segs[offset] = chan->segments[j];
		free_m12((void *) chan->segments, __FUNCTION__);
		chan->segments = remapped_segs;
	}
	for (i = 0; i < sess->number_of_video_channels; ++i) {
		chan = sess->video_channels[i];
		remapped_segs = (SEGMENT_m12 **) calloc_m12((size_t) remapped_seg_cnt, sizeof(SEGMENT_m12 *), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		offset = first_mapped_seg - remapped_start_seg;
		for (j = 0; j < mapped_segs; ++j, ++offset)
			remapped_segs[offset] = chan->segments[j];
		free_m12((void *) chan->segments, __FUNCTION__);
		chan->segments = remapped_segs;
	}

	globals_m12->first_mapped_segment_number = remapped_start_seg;
	globals_m12->number_of_mapped_segments = remapped_seg_cnt;
	seg_idx = first_mapped_seg - remapped_start_seg;

	return(seg_idx);
}


void	G_clear_terminal_m12(void)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

#if defined MACOS_m12 || defined LINUX_m12
	system_m12("clear", FALSE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
#endif
#ifdef WINDOWS_m12
	WN_clear_m12();
#endif
	
	return;
}


si4	G_compare_acq_nums_m12(const void *a, const void *b)
{
	ACQ_NUM_SORT_m12	*as, *bs;
	
	
	as = (ACQ_NUM_SORT_m12 *) a;
	bs = (ACQ_NUM_SORT_m12 *) b;
	
	if (as->acq_num > bs->acq_num)
		return(1);
	if (as->acq_num < bs->acq_num)
		return(-1);
	return(0);
}


si4	G_compare_record_index_times(const void *a, const void *b)
{
	si8			time_d;
	RECORD_INDEX_m12	*ria, *rib;
	
	
	ria = (RECORD_INDEX_m12 *) a;
	rib = (RECORD_INDEX_m12 *) b;
	time_d = ria->start_time - rib->start_time;
	
	// can't return time_d - cast to int may overflow
	if (time_d > 0)
		return(1);
	if (time_d < 0)
		return(-1);
	
	return(0);
}


void	G_condition_timezone_info_m12(TIMEZONE_INFO_m12 *tz_info)
{
	si4			i;
	si8			len;
	TIMEZONE_ALIAS_m12	*tz_aliases_table;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (global_tables_m12->timezone_table == NULL)
		G_initialize_timezone_tables_m12();

	// Country: at this time there are no 2 or 3 letter country names => user probably entered acronym
	if (*tz_info->country) {
		len = strlen(tz_info->country);
		if (len == 2) {
			strcpy(tz_info->country_acronym_2_letter, tz_info->country);
			*tz_info->country = 0;
		} else if (len == 3) {
			strcpy(tz_info->country_acronym_3_letter, tz_info->country);
			*tz_info->country = 0;
		}
	}
	
	// Territory: at this time there are no 2 letter territory names => user probably entered acronym
	if (*tz_info->territory) {
		len = strlen(tz_info->territory);
		if (len == 2) {
			strcpy(tz_info->territory_acronym, tz_info->territory);
			*tz_info->territory = 0;
		}
	}
	
	// change potentially matching strings to caps
	STR_to_upper_m12(tz_info->country);
	STR_to_upper_m12(tz_info->country_acronym_2_letter);
	STR_to_upper_m12(tz_info->country_acronym_3_letter);
	STR_to_upper_m12(tz_info->territory);
	STR_to_upper_m12(tz_info->territory_acronym);
	STR_to_upper_m12(tz_info->standard_timezone);
	STR_to_upper_m12(tz_info->standard_timezone_acronym);
	STR_to_upper_m12(tz_info->daylight_timezone);
	STR_to_upper_m12(tz_info->daylight_timezone_acronym);
	
	// check country aliases
	tz_aliases_table = global_tables_m12->country_aliases_table;
	
	if (*tz_info->country) {
		for (i = 0; i < TZ_COUNTRY_ALIASES_ENTRIES_m12; ++i) {
			if ((strcmp(tz_info->country, tz_aliases_table[i].alias)) == 0) {
				strcpy(tz_info->country, tz_aliases_table[i].table_name);
				break;
			}
		}
	}
	
	// check country acronyms
	tz_aliases_table = global_tables_m12->country_acronym_aliases_table;
	
	if (*tz_info->country_acronym_2_letter) {
		for (i = 0; i < TZ_COUNTRY_ACRONYM_ALIASES_ENTRIES_m12; ++i) {
			if ((strcmp(tz_info->country_acronym_2_letter, tz_aliases_table[i].alias)) == 0) {
				strcpy(tz_info->country_acronym_2_letter, tz_aliases_table[i].table_name);
				break;
			}
		}
	}
	
	if (*tz_info->country_acronym_3_letter) {
		for (i = 0; i < TZ_COUNTRY_ALIASES_ENTRIES_m12; ++i) {
			if ((strcmp(tz_info->country_acronym_3_letter, tz_aliases_table[i].alias)) == 0) {
				strcpy(tz_info->country_acronym_3_letter, tz_aliases_table[i].table_name);
				break;
			}
		}
	}

	return;
}


void	G_condition_time_slice_m12(TIME_SLICE_m12 *slice)
{
	si8		test_time;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (slice == NULL) {
		G_warning_message_m12("%s(): passed time slice is NULL\n");
		return;
	}
		
	if (globals_m12->recording_time_offset == FALSE_m12) {
		if (globals_m12->verbose == TRUE_m12)
			G_warning_message_m12("%s(): recording time offset is not known => assuming no offset\n", __FUNCTION__);
		globals_m12->recording_time_offset = GLOBALS_RECORDING_TIME_OFFSET_DEFAULT_m12;  // == 0
		if (globals_m12->session_start_time == UUTC_NO_ENTRY_m12)
			globals_m12->session_start_time = BEGINNING_OF_TIME_m12;
	}
	
	if (slice->start_time <= 0) {
		if (slice->start_time == UUTC_NO_ENTRY_m12) {
			if (slice->start_sample_number == SAMPLE_NUMBER_NO_ENTRY_m12)
				slice->start_time = BEGINNING_OF_TIME_m12;
		} else {  // relative time
			slice->start_time = globals_m12->session_start_time - slice->start_time;
		}
	} else {  // ? unoffset time
		test_time = slice->start_time - globals_m12->recording_time_offset;
		if (test_time > 0)  // start time is not offset
			slice->start_time = test_time;
	}
	
	if (slice->end_time <= 0) {
		if (slice->end_time == UUTC_NO_ENTRY_m12) {
			if (slice->end_sample_number == SAMPLE_NUMBER_NO_ENTRY_m12)
				slice->end_time = END_OF_TIME_m12;
		} else {  // relative time
			slice->end_time = (globals_m12->session_start_time - slice->end_time) - 1;  // slice end times are inclusive
		}
	} else {  // ? unoffset time
		test_time = slice->end_time - globals_m12->recording_time_offset;
		if (test_time > 0 && slice->end_time != END_OF_TIME_m12)  // END_OF_TIME_m12 is not offset
			slice->end_time = test_time;
	}
	
	slice->conditioned = TRUE_m12;
	
	return;
}


TERN_m12	G_correct_universal_header_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	static TERN_m12			warning_given = FALSE_m12;
	TERN_m12			free_fps2;
	si1				path[FULL_FILE_NAME_BYTES_m12], name[SEGMENT_BASE_FILE_NAME_BYTES_m12];
	si8				number_of_entries, file_offset, idx;
	ui4				maximum_entry_size;
	FILE_PROCESSING_STRUCT_m12	*fps2;
	UNIVERSAL_HEADER_m12		*uh, *uh2;
	SEGMENT_m12			*seg;
	SEGMENTED_SESS_RECS_m12		*ssr;
	LEVEL_HEADER_m12		*level_header;
	CMP_BLOCK_FIXED_HEADER_m12	block_header;
	
    	
	// called if universal_header->number_of_entries == 0 in live recording or improperly closed file
	
	if (fps->parameters.flen == UNIVERSAL_HEADER_BYTES_m12)  // no actual entries, zero is correct
		return(TRUE_m12);
	
	if (warning_given == FALSE_m12) {  // don't give this warning for every file
		G_warning_message_m12("%s(): file header not complete.\nThis can occur if the file is still being recorded, or was not closed properly.\n", __FUNCTION__);
		warning_given = TRUE_m12;
	}
	
	uh = fps->universal_header;
	number_of_entries = 0;
	maximum_entry_size = 0;
	free_fps2 = FALSE_m12;
	switch (uh->type_code) {
		case VIDEO_INDICES_FILE_TYPE_CODE_m12:
		case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
		case RECORD_INDICES_FILE_TYPE_CODE_m12:
			number_of_entries = (fps->parameters.flen - (si8) UNIVERSAL_HEADER_BYTES_m12) / (si8) INDEX_BYTES_m12;
			maximum_entry_size = (ui4) INDEX_BYTES_m12;
			break;
		case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
			// see if indices known
			fps2 = NULL;
			seg = (SEGMENT_m12 *) fps->parent;
			if (seg != NULL) {  // try using parent
				fps2 = seg->record_indices_fps;
			} else {  // try using file name
				G_extract_path_parts_m12(fps->full_file_name, path, name, NULL);
				sprintf_m12(path, "%s/%s.%s", path, name, TIME_SERIES_INDICES_FILE_TYPE_STRING_m12);
				fps2 = G_read_file_m12(NULL, path, 0, UNIVERSAL_HEADER_BYTES_m12, FPS_UNIVERSAL_HEADER_ONLY_m12, NULL, NULL, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12);
				free_fps2 = TRUE_m12;
			}
			if (fps2 != NULL) {
				uh2 = fps2->universal_header;
				if (uh2->number_of_entries != 0)
					number_of_entries = uh2->number_of_entries;
				else
					number_of_entries = (fps2->parameters.flen - (si8) UNIVERSAL_HEADER_BYTES_m12) / (si8) INDEX_BYTES_m12;
				--number_of_entries;  // don't include last index
				if (free_fps2 == TRUE_m12)
					FPS_free_processing_struct_m12(fps2, TRUE_m12);
			}
			if (number_of_entries > 0) {  // read second block header for maximum entry size (CPS will reallocate if needed, but first block often truncated)
				// read first block header
				file_offset = UNIVERSAL_HEADER_BYTES_m12;
				if (fseek_m12(fps->parameters.fp, file_offset, SEEK_SET, fps->full_file_name, __FUNCTION__, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12) == -1)
					break;
				if (fread_m12((void *) &block_header, sizeof(CMP_BLOCK_FIXED_HEADER_m12), (size_t) 1, fps->parameters.fp, fps->full_file_name, __FUNCTION__, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12) == (size_t) -1)
					break;
				// read second block header
				file_offset += block_header.total_block_bytes;
				if (fseek_m12(fps->parameters.fp, file_offset, SEEK_SET, fps->full_file_name, __FUNCTION__, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12) == -1)
					break;
				if (fread_m12((void *) &block_header, sizeof(CMP_BLOCK_FIXED_HEADER_m12), (size_t) 1, fps->parameters.fp, fps->full_file_name, __FUNCTION__, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12) == (size_t) -1)
					break;
				maximum_entry_size = block_header.total_block_bytes;
			}  // the only other option would be to read full data file counting blocks - will add this if need arises, but for now, just fail
			break;
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
			break;  // these are wirtten on close - there won't be anything to read except universal header
		case RECORD_DATA_FILE_TYPE_CODE_m12:
			// see if indices known
			level_header = (LEVEL_HEADER_m12 *) fps->parent;  // try using parent
			fps2 = NULL;
			if (level_header != NULL) {
				switch (level_header->type_code) {
					case LH_TIME_SERIES_SEGMENT_m12:
					case LH_VIDEO_SEGMENT_m12:
						fps2 = ((SEGMENT_m12 *) level_header)->record_indices_fps;
						break;
					case LH_TIME_SERIES_CHANNEL_m12:
					case LH_VIDEO_CHANNEL_m12:
						fps2 = ((CHANNEL_m12 *) level_header)->record_indices_fps;
						break;
					case LH_SESSION_m12:
						fps2 = ((SESSION_m12 *) level_header)->record_indices_fps;
						break;
					case LH_SEGMENTED_SESS_RECS_m12:
						ssr = (SEGMENTED_SESS_RECS_m12 *) level_header;
						if (ssr->record_indices_fps != NULL) {
							idx = fps - ssr->record_data_fps[0];
							fps2 = ssr->record_indices_fps[idx];
						}
						break;
				}
			}
			if (fps2 == NULL) {  // try using file name
				G_extract_path_parts_m12(fps->full_file_name, path, name, NULL);
				sprintf_m12(path, "%s/%s.%s", path, name, RECORD_INDICES_FILE_TYPE_STRING_m12);
				fps2 = G_read_file_m12(NULL, path, 0, UNIVERSAL_HEADER_BYTES_m12, FPS_UNIVERSAL_HEADER_ONLY_m12, NULL, NULL, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12);
				free_fps2 = TRUE_m12;
			}
			if (fps2 != NULL) {
				uh2 = fps2->universal_header;
				if (uh2->number_of_entries != 0)
					number_of_entries = uh2->number_of_entries;
				else
					number_of_entries = (fps2->parameters.flen - (si8) UNIVERSAL_HEADER_BYTES_m12) / (si8) INDEX_BYTES_m12;
				--number_of_entries;  // don't include last index
				if (free_fps2 == TRUE_m12)
					FPS_free_processing_struct_m12(fps2, TRUE_m12);
			}
			if (number_of_entries > 0)  // the only option to get true maximum record size be to read full record data (or index) file
				maximum_entry_size = REC_LARGEST_RECORD_BYTES_m12;
			// the only other option would be to read full record data file counting records - will add this if need arises, but for now, just fail
			break;
		default:
			G_warning_message_m12("%s(): unrecognized file type\n", __FUNCTION__);
			break;
	}
	
	if (number_of_entries <= 0 || maximum_entry_size <= 0)
		return(FALSE_m12);

	uh->number_of_entries = number_of_entries;
	uh->maximum_entry_size = maximum_entry_size;
	
	return(TRUE_m12);

}


#if defined MACOS_m12 || defined LINUX_m12
inline si8      G_current_uutc_m12(void)
{
	struct timeval  tv;
	si8             uutc;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	gettimeofday(&tv, NULL);
	uutc = (si8) tv.tv_sec * (si8) 1000000 + (si8) tv.tv_usec;
	
	return(uutc);
}
#endif


#ifdef WINDOWS_m12
si8      G_current_uutc_m12(void)
{
	static const ui8    EPOCH = (ui8) 116444736000000000;
	struct timeval      tv;
	si8                 uutc;
	SYSTEMTIME          system_time;
	FILETIME            file_time;
	ui8                 time;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	GetSystemTime(&system_time);
	SystemTimeToFileTime(&system_time, &file_time);
	time = ((ui8)file_time.dwLowDateTime);
	time += ((ui8)file_time.dwHighDateTime) << 32;
	
	tv.tv_sec = (si4)((time - EPOCH) / (ui8) 10000000);
	tv.tv_usec = (si4)(system_time.wMilliseconds * 1000);
	uutc = (si8)tv.tv_sec * (si8) 1000000 + (si8) tv.tv_usec;
	
	return(uutc);
}
#endif


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4      G_days_in_month_m12(si4 month, si4 year)
{
	static const si4        standard_days[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
	si4                     days;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// Note month is [0 - 11], January == 0, as in unix struct tm.tm_mon
	// Note struct tm.tm_year is (year - 1900), this function expects the full value

	days = standard_days[month];
	
	// leap years
	if (month == 1) {  // February
		if ((year % 4) == 0) {  // leap year
			++days;
			if ((year % 100) == 0) {  // centurial exception
				--days;
				if ((year % 400) == 0) {  // centurial exception exception
					++days;
				}
			}
		}
	}
	
	return(days);
}


TERN_m12	G_decrypt_metadata_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	ui1			*decryption_key;
	PASSWORD_DATA_m12	*pwd;
	METADATA_SECTION_3_m12	*section_3;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (fps == NULL) {
		G_error_message_m12("%s(): FILE_PROCESSING_STRUCT is NULL\n", __FUNCTION__);
		return(FALSE_m12);
	}
		
	pwd = fps->parameters.password_data;
	if (pwd == NULL)
		pwd = &globals_m12->password_data;
	
	// time series encryption global
	globals_m12->time_series_data_encryption_level = fps->metadata->section_1.time_series_data_encryption_level;
		
	// section 2 decryption
	if (fps->metadata->section_1.section_2_encryption_level > NO_ENCRYPTION_m12) {  // natively encrypted and currently encrypted
		if (pwd->access_level >= fps->metadata->section_1.section_2_encryption_level) {
			if (fps->metadata->section_1.section_2_encryption_level == LEVEL_1_ENCRYPTION_m12)
				decryption_key = pwd->level_1_encryption_key;
			else
				decryption_key = pwd->level_2_encryption_key;
			AES_decrypt_m12(fps->parameters.raw_data + METADATA_SECTION_2_OFFSET_m12, METADATA_SECTION_2_BYTES_m12, NULL, decryption_key);
			fps->metadata->section_1.section_2_encryption_level = -fps->metadata->section_1.section_2_encryption_level;  // mark as currently decrypted
		} else {
			G_error_message_m12("%s(): Section 2 of the Metadata is encrypted at level %hhd => cannot decrypt\n", __FUNCTION__, fps->metadata->section_1.section_2_encryption_level);
			G_show_password_hints_m12(pwd);
			G_set_error_m12(E_BAD_PASSWORD_m12, __FUNCTION__, __LINE__);
			return(FALSE_m12);  // can't do anything without section 2, so fail
		}
	}
	
	// section 3 decryption
	if (fps->metadata->section_1.section_3_encryption_level > NO_ENCRYPTION_m12) {  // natively encrypted and currently encrypted
		if (pwd->access_level >= fps->metadata->section_1.section_3_encryption_level) {
			if (fps->metadata->section_1.section_3_encryption_level == LEVEL_1_ENCRYPTION_m12)
				decryption_key = pwd->level_1_encryption_key;
			else
				decryption_key = pwd->level_2_encryption_key;
			AES_decrypt_m12(fps->parameters.raw_data + METADATA_SECTION_3_OFFSET_m12, METADATA_SECTION_3_BYTES_m12, NULL, decryption_key);
			fps->metadata->section_1.section_3_encryption_level = -fps->metadata->section_1.section_3_encryption_level;  // mark as currently decrypted
		} else {
			if (globals_m12->verbose == TRUE_m12) {
				G_warning_message_m12("%s(): Metadata section 3 encrypted at level %hhd => cannot decrypt\n", __FUNCTION__, fps->metadata->section_1.section_3_encryption_level);
				G_show_password_hints_m12(pwd);
			}
			globals_m12->RTO_known = FALSE_m12;
			globals_m12->time_constants_set = TRUE_m12;  // set to defaults
			return(TRUE_m12);  // can function without section 3, so return TRUE_m12
		}
	}
	
	// set global time data
	if (globals_m12->RTO_known != TRUE_m12) {  // UNKNOWN || FALSE
		section_3 = &fps->metadata->section_3;
		globals_m12->recording_time_offset = section_3->recording_time_offset;
		globals_m12->standard_UTC_offset = section_3->standard_UTC_offset;
		strncpy_m12(globals_m12->standard_timezone_acronym, section_3->standard_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m12);
		strncpy_m12(globals_m12->standard_timezone_string, section_3->standard_timezone_string, TIMEZONE_STRING_BYTES_m12);
		strncpy_m12(globals_m12->daylight_timezone_acronym, section_3->daylight_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m12);
		strncpy_m12(globals_m12->daylight_timezone_string, section_3->daylight_timezone_string, TIMEZONE_STRING_BYTES_m12);
		if ((globals_m12->daylight_time_start_code.value = section_3->daylight_time_start_code.value) == DTCC_VALUE_NOT_OBSERVED_m12)
			globals_m12->observe_DST = FALSE_m12;
		else
			globals_m12->observe_DST = TRUE_m12;
		globals_m12->RTO_known = TRUE_m12;
		globals_m12->daylight_time_end_code.value = section_3->daylight_time_end_code.value;
		globals_m12->time_constants_set = TRUE_m12;
	}

	return(TRUE_m12);
}


TERN_m12	G_decrypt_record_data_m12(FILE_PROCESSING_STRUCT_m12 *fps, ...)  // varargs (fps == NULL): RECORD_HEADER_m12 *rh, si8 number_of_records
{
	ui1			*encryption_key;
	si8			i, failed_decryption_count, number_of_records;
	va_list			args;
	RECORD_HEADER_m12	*rh;
	PASSWORD_DATA_m12	*pwd;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (fps == NULL) {
		va_start(args, fps);
		rh = va_arg(args, RECORD_HEADER_m12 *);
		number_of_records = va_arg(args, si8);
		va_end(args);
		pwd = NULL;
	} else {
		rh = (RECORD_HEADER_m12 *) fps->record_data;
		number_of_records = fps->number_of_items;
		pwd = fps->parameters.password_data;
	}
	if (number_of_records == 0)  // failure == all records unreadable
		return(TRUE_m12);
	if (pwd == NULL)
		pwd = &globals_m12->password_data;

	for (i = failed_decryption_count = 0; i < number_of_records; ++i) {
		if (rh->encryption_level > NO_ENCRYPTION_m12) {
			if (pwd->access_level >= rh->encryption_level) {
				if (rh->encryption_level == LEVEL_1_ENCRYPTION_m12)
					encryption_key = pwd->level_1_encryption_key;
				else
					encryption_key = pwd->level_2_encryption_key;
				AES_decrypt_m12((ui1 *) rh + RECORD_HEADER_BYTES_m12, rh->total_record_bytes - RECORD_HEADER_BYTES_m12, NULL, encryption_key);
				rh->encryption_level = -rh->encryption_level;  // mark as currently decrypted
			} else {
				++failed_decryption_count;
				if (globals_m12->verbose == TRUE_m12)
					G_warning_message_m12("%s(): Cannot decrypt record => skipping\n", __FUNCTION__);
			}
		}
		rh = (RECORD_HEADER_m12 *) ((ui1 *) rh + rh->total_record_bytes);
	}

	if (failed_decryption_count == number_of_records)  // failure == all records unreadable
		return(FALSE_m12);
	
	return(TRUE_m12);
}


TERN_m12     G_decrypt_time_series_data_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	ui1				*key = NULL;
	si8                             i, encryption_bytes, encryptable_bytes, number_of_items;
	CMP_BLOCK_FIXED_HEADER_m12	*bh;
	PASSWORD_DATA_m12		*pwd;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (fps->metadata->section_1.time_series_data_encryption_level == NO_ENCRYPTION_m12)
		return(TRUE_m12);
	
	// get decryption key - assume all blocks encrypted at same level
	pwd = fps->parameters.password_data;
	if (pwd == NULL)
		pwd = &globals_m12->password_data;
	bh = fps->parameters.cps->block_header;
	
	number_of_items = fps->number_of_items;	// looks like big loop but breaks out as soon as encrypted block encountered
	for (i = 0; i < number_of_items; ++i) {	// if none encountered, function done
		// check if already decrypted
		if ((bh->block_flags & CMP_BF_ENCRYPTION_MASK_m12) == 0) {
			bh = (CMP_BLOCK_FIXED_HEADER_m12 *) ((ui1 *)bh + bh->total_block_bytes);
			continue;
		}
		if (bh->block_flags & CMP_BF_LEVEL_1_ENCRYPTION_MASK_m12) {
			if (bh->block_flags & CMP_BF_LEVEL_2_ENCRYPTION_MASK_m12) {
				G_error_message_m12("%s(): Cannot decrypt data: flags indicate both level 1 & level 2 encryption\n", __FUNCTION__);
				return(FALSE_m12);
			}
			if (pwd->access_level >= LEVEL_1_ENCRYPTION_m12) {
				key = pwd->level_1_encryption_key;
				break;
			} else {
				G_error_message_m12("%s(): Cannot decrypt data: insufficient access\n", __FUNCTION__);
				return(FALSE_m12);
			}
		} else {  // level 2 bit is set
			if (pwd->access_level == LEVEL_2_ENCRYPTION_m12) {
				key = pwd->level_2_encryption_key;
				break;
			} else {
				G_error_message_m12("%s(): Cannot decrypt data: insufficient access\n", __FUNCTION__);
				return(FALSE_m12);
			}
		}
		bh = (CMP_BLOCK_FIXED_HEADER_m12 *) ((ui1 *) bh + bh->total_block_bytes);
	}
	
	// no blocks encrypted
	if (i == number_of_items)
		return(TRUE_m12);
	
	// decrypt
	bh = fps->parameters.cps->block_header;
	for (i = number_of_items; i--;) {
		
		// block if already decrypted
		if ((bh->block_flags & CMP_BF_ENCRYPTION_MASK_m12) == 0) {
			bh = (CMP_BLOCK_FIXED_HEADER_m12 *) ((ui1 *) bh + bh->total_block_bytes);
			continue;
		}
		
		// calculate encryption bytes
		encryptable_bytes = bh->total_block_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m12;
		if (bh->block_flags | CMP_BF_MBE_ENCODING_MASK_m12) {
			encryption_bytes = encryptable_bytes;
		} else {
			encryption_bytes = (bh->total_header_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m12) + ENCRYPTION_BLOCK_BYTES_m12;
			if (encryption_bytes > encryptable_bytes)
				encryption_bytes = encryptable_bytes;
		}
		
		// decrypt
		AES_decrypt_m12((ui1 *) bh + CMP_BLOCK_ENCRYPTION_START_OFFSET_m12, encryption_bytes, NULL, key);
		
		// set block flag to decrypted
		bh->block_flags &= ~CMP_BF_ENCRYPTION_MASK_m12;
		
		// set pointer to next block
		bh = (CMP_BLOCK_FIXED_HEADER_m12 *) ((ui1 *) bh + bh->total_block_bytes);
	}
	
	return(TRUE_m12);
}


si4     G_DST_offset_m12(si8 uutc)
{
	si4                             i, month, DST_start_month, DST_end_month;
	si4                             first_weekday_of_month, target_day_of_month, last_day_of_month;
	time_t                          utc, local_utc, change_utc;
	struct tm                       time_info = { 0 }, change_time_info = { 0 };
	DAYLIGHT_TIME_CHANGE_CODE_m12	*first_DTCC, *last_DTCC, *change_DTCC;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns seconds to add to standard time (as UUTC) to adjust for DST on that date, in the globally specified timezone
	
	if (globals_m12->time_constants_set == FALSE_m12) {
		G_warning_message_m12("%s(): library time constants not set\n", __FUNCTION__);
		return(0);
	}
	if (globals_m12->observe_DST < TRUE_m12)
		return(0);
	if (globals_m12->daylight_time_start_code.value == DTCC_VALUE_NO_ENTRY_m12) {
		G_warning_message_m12("%s(): daylight change data not available\n", __FUNCTION__);
		return(0);
	}

	utc = uutc / (si8) 1000000;
	
	// get broken out time info
#if defined MACOS_m12 || defined LINUX_m12
	if (globals_m12->daylight_time_start_code.reference_time == DTCC_LOCAL_REFERENCE_TIME) {
		local_utc = utc + (si8) globals_m12->standard_UTC_offset;
		gmtime_r(&local_utc, &time_info);
	}
	else {
		gmtime_r(&utc, &time_info);
	}
#endif
#ifdef WINDOWS_m12
	if (globals_m12->daylight_time_start_code.reference_time == DTCC_LOCAL_REFERENCE_TIME) {
		local_utc = utc + (si8) globals_m12->standard_UTC_offset;
		time_info = *(gmtime(&local_utc));
	}
	else {
		time_info = *(gmtime(&utc));
	}
#endif
	
	month = time_info.tm_mon;
	DST_start_month = globals_m12->daylight_time_start_code.month;
	DST_end_month = globals_m12->daylight_time_end_code.month;
	if (DST_start_month < DST_end_month) {
		first_DTCC = &globals_m12->daylight_time_start_code;
		last_DTCC = &globals_m12->daylight_time_end_code;
	}
	else {
		first_DTCC = &globals_m12->daylight_time_end_code;
		last_DTCC = &globals_m12->daylight_time_start_code;
	}
	
	// take care of dates not in change months
	if (month != DST_start_month && month != DST_end_month) {
		if (month > first_DTCC->month && month < last_DTCC->month) {
			if (first_DTCC->month == DST_start_month)
				return((si4)first_DTCC->shift_minutes * (si4)60);
			else
				return(0);
		} else if (month < first_DTCC->month) {
			if (first_DTCC->month == DST_start_month)
				return(0);
			else
				return((si4)first_DTCC->shift_minutes * (si4)60);
		} else {  // month > last_DTCC->month
			if (last_DTCC->month == DST_end_month)
				return(0);
			else
				return((si4)first_DTCC->shift_minutes * (si4)60);
		}
	}
	
	// get change utc
	if (month == first_DTCC->month)
		change_DTCC = first_DTCC;
	else
		change_DTCC = last_DTCC;
	
	change_time_info.tm_hour = change_DTCC->hours_of_day;
	change_time_info.tm_mon = month;
	change_time_info.tm_year = time_info.tm_year;
	
	if (change_DTCC->day_of_month == DTCC_DAY_OF_MONTH_NO_ENTRY) {   // get target day of month
		first_weekday_of_month = time_info.tm_wday - ((time_info.tm_mday - 1) % 7);
		target_day_of_month = (change_DTCC->day_of_week - first_weekday_of_month) + 1;
		if (target_day_of_month < 1)
			target_day_of_month += 7;
		if (change_DTCC->relative_weekday_of_month == DTCC_LAST_RELATIVE_WEEKDAY_OF_MONTH) {
			last_day_of_month = G_days_in_month_m12(month, time_info.tm_year + 1900);
			while (target_day_of_month <= last_day_of_month)
				target_day_of_month += 7;
			target_day_of_month -= 7;
		} else {
			for (i = 1; i < change_DTCC->relative_weekday_of_month; ++i)
				target_day_of_month += 7;
		}
		change_time_info.tm_mday = target_day_of_month;
	} else {
		change_time_info.tm_mday = change_DTCC->day_of_month;
	}
	
#if defined MACOS_m12 || defined LINUX_m12
	change_utc = timegm(&change_time_info);
#endif
#ifdef WINDOWS_m12
	change_utc = _mkgmtime(&change_time_info);
#endif
	if (globals_m12->daylight_time_start_code.reference_time == DTCC_LOCAL_REFERENCE_TIME)
		change_utc -= globals_m12->standard_UTC_offset;
	
	if (change_DTCC->month == DST_start_month) {
		if (utc >= change_utc)
			return((si4)change_DTCC->shift_minutes * (si4)60);
		else
			return(0);
	} else {  // change_DTCC->month == DST_end_month
		if (utc < change_utc)
			return((si4)change_DTCC->shift_minutes * (si4)-60);
		else
			return(0);
	}
	
	return(0);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
TERN_m12	G_empty_string_m12(si1 *string)
{
	if (string == NULL)
		return(TRUE_m12);
	
	if (*string)
		return(FALSE_m12);
	
	return(TRUE_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
TERN_m12	G_en_bloc_allocation_m12(LEVEL_HEADER_m12 *level_header)
{
	TERN_m12		en_bloc;
	size_t			struct_bytes;
	LEVEL_HEADER_m12	*test_ptr, **test_ptr_ptr;
	sig_handler_t_m12	current_handler;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (level_header->en_bloc_allocation != UNKNOWN_m12)
		return(level_header->en_bloc_allocation);
	
	switch (level_header->type_code) {
		case LH_TIME_SERIES_CHANNEL_m12:
		case LH_VIDEO_CHANNEL_m12:
			struct_bytes = sizeof(CHANNEL_m12);
			break;
		case LH_TIME_SERIES_SEGMENT_m12:
		case LH_VIDEO_SEGMENT_m12:
			struct_bytes = sizeof(SEGMENT_m12);
			break;
		default:
			return(FALSE_m12);
	}
	
	// save current signal handler for SIGSEGV & set to ignore
	current_handler = signal(SIGSEGV, SIG_IGN);

	// check for structure before (will fail if first element)
	en_bloc = FALSE_m12;
	test_ptr = (LEVEL_HEADER_m12 *) ((ui1 *) level_header - struct_bytes);
	if (test_ptr->type_code == level_header->type_code) {
		en_bloc = TRUE_m12;
	} else {  // check for structure after (will fail if last element)
		test_ptr = (LEVEL_HEADER_m12 *) ((ui1 *) level_header + struct_bytes);
		if (test_ptr->type_code == level_header->type_code) {
			en_bloc = TRUE_m12;
		} else {  // check for pointer to structure before (i.e. one structure array - pointer must point to it, even if sorted)
			test_ptr_ptr = (LEVEL_HEADER_m12 **) ((ui1 *) level_header - sizeof(void *));
			if (*test_ptr_ptr == level_header)
				en_bloc = TRUE_m12;
			// else not allocated en bloc
		}
	}
	
	// restore previous signal handler
	signal(SIGSEGV, current_handler);

	level_header->en_bloc_allocation = en_bloc;
	
	return(en_bloc);
}


TERN_m12	G_encrypt_metadata_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	ui1			*encryption_key;
	PASSWORD_DATA_m12	*pwd;
	METADATA_m12		*md;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	pwd = fps->parameters.password_data;
	if (pwd == NULL)
		pwd = &globals_m12->password_data;
	md = (METADATA_m12 *) fps->data_pointers;

	// section 2 encrypt
	if (md->section_1.section_2_encryption_level < NO_ENCRYPTION_m12) {  // natively encrypted and currently decrypted
		if (pwd->access_level >= -md->section_1.section_2_encryption_level) {
			md->section_1.section_2_encryption_level = -md->section_1.section_2_encryption_level;  // mark as currently encrypted
			if (md->section_1.section_2_encryption_level == LEVEL_1_ENCRYPTION_m12)
				encryption_key = pwd->level_1_encryption_key;
			else
				encryption_key = pwd->level_2_encryption_key;
			AES_encrypt_m12((ui1 *) &md->section_2, METADATA_SECTION_2_BYTES_m12, NULL, encryption_key);
		}
	}
	
	// section 3 encrypt
	if (md->section_1.section_3_encryption_level < NO_ENCRYPTION_m12) {  // natively encrypted and currently decrypted
		if (pwd->access_level >= -md->section_1.section_3_encryption_level) {
			md->section_1.section_3_encryption_level = -md->section_1.section_3_encryption_level;  // mark as currently encrypted
			if (fps->metadata->section_1.section_3_encryption_level == LEVEL_1_ENCRYPTION_m12)
				encryption_key = pwd->level_1_encryption_key;
			else
				encryption_key = pwd->level_2_encryption_key;
			AES_encrypt_m12((ui1 *) &md->section_3, METADATA_SECTION_3_BYTES_m12, NULL, encryption_key);
		}
	}
	
	return(TRUE_m12);
}


TERN_m12	G_encrypt_record_data_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	ui1			*encryption_key;
	si8			i;
	PASSWORD_DATA_m12	*pwd;
	RECORD_HEADER_m12	*rh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	pwd = fps->parameters.password_data;
	if (pwd == NULL)
		pwd = &globals_m12->password_data;
	rh = (RECORD_HEADER_m12 *) fps->data_pointers;
		
	for (i = fps->number_of_items; i--;) {
		if (rh->encryption_level < NO_ENCRYPTION_m12) {
			rh->encryption_level = -rh->encryption_level;  // mark as currently encrypted
			if (rh->encryption_level == LEVEL_1_ENCRYPTION_m12)
				encryption_key = pwd->level_1_encryption_key;
			else
				encryption_key = pwd->level_2_encryption_key;
			AES_encrypt_m12((ui1 *) rh + RECORD_HEADER_BYTES_m12, rh->total_record_bytes - RECORD_HEADER_BYTES_m12, NULL, encryption_key);
		}
		rh = (RECORD_HEADER_m12 *) ((ui1 *) rh + rh->total_record_bytes);
	}
	
	return(TRUE_m12);
}
		
		
TERN_m12     G_encrypt_time_series_data_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	ui1				*key;
	si1				encryption_level;
	ui4				encryption_mask;
	si8				i, encryptable_bytes, encryption_bytes;
	PASSWORD_DATA_m12		*pwd;
	CMP_BLOCK_FIXED_HEADER_m12	*bh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	encryption_level = fps->parameters.cps->directives.encryption_level;
	if (encryption_level == NO_ENCRYPTION_m12)
		return(TRUE_m12);
	
	pwd = fps->parameters.password_data;
	if (pwd == NULL)
		pwd = &globals_m12->password_data;

	if (pwd->access_level >= encryption_level) {
		if (encryption_level == LEVEL_1_ENCRYPTION_m12) {
			key = pwd->level_1_encryption_key;
			encryption_mask = CMP_BF_LEVEL_1_ENCRYPTION_MASK_m12;
		} else {
			key = pwd->level_2_encryption_key;
			encryption_mask = CMP_BF_LEVEL_2_ENCRYPTION_MASK_m12;
		}
	} else {
		G_error_message_m12("%s(): Cannot encrypt data => returning without encrypting\n", __FUNCTION__);
		fps->parameters.cps->directives.encryption_level = NO_ENCRYPTION_m12;
		return(FALSE_m12);
	}
	
	bh = (CMP_BLOCK_FIXED_HEADER_m12 *) fps->data_pointers;
	for (i = fps->number_of_items; i--;) {
		if (!(bh->block_flags & CMP_BF_ENCRYPTION_MASK_m12)) {  // already encrypted
			
			// calculate encryption bytes
			encryptable_bytes = bh->total_block_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m12;
			if (bh->block_flags | CMP_BF_MBE_ENCODING_MASK_m12) {
				encryption_bytes = encryptable_bytes;
			} else {
				encryption_bytes = (bh->total_header_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m12) + ENCRYPTION_BLOCK_BYTES_m12;
				if (encryption_bytes > encryptable_bytes)
					encryption_bytes = encryptable_bytes;
			}
			
			// encrypt
			AES_encrypt_m12((ui1 *) bh + CMP_BLOCK_ENCRYPTION_START_OFFSET_m12, encryption_bytes, NULL, key);

			// set block flag to encyrpted
			bh->block_flags |= encryption_mask;
		}
		bh = (CMP_BLOCK_FIXED_HEADER_m12 *) ((ui1 *) bh + bh->total_block_bytes);
	}
	
	return(TRUE_m12);
}
		
		
#if defined MACOS_m12 || defined LINUX_m12
TERN_m12	G_enter_ascii_password_m12(si1 *password, si1 *prompt, TERN_m12 confirm_no_entry, sf8 timeout_secs, TERN_m12 create_password)
{
	si1		pw_copy[MAX_ASCII_PASSWORD_STRING_BYTES_m12], dc[8];
	const si4	MAX_ATTEMPTS = 3;
	si4		i, c, attempts;
	struct termios	term, saved_term;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// pass timeout_secs == 0.0 for no timeout

	if (password == NULL) {
		G_warning_message_m12("password is NULL\n");
		return(FALSE_m12);
	}
		
	if (prompt == NULL)
		prompt = "Enter Password";
	else if (*prompt == 0)
		prompt = "Enter Password";
	
	// get settings of STDIN_FILENO and copy for resetting
	tcgetattr(STDIN_FILENO, &term);
	saved_term = term;
	
	// unset the echo bit in the termios struct (displays "key" character)
	term.c_lflag &= ~(ECHO);
	
	// set the new bits
	tcsetattr(STDIN_FILENO, TCSANOW, &term);
	
	
ENTER_ASCII_PASSWORD_RETRY_1_m12:
		
	if (timeout_secs > (sf8) 0.0) {
		struct timeval	tv;
		fd_set		fds;
		si4		fds_ready;
		
		printf_m12("%s %s[%0.1lfs timeout]%s: ", prompt, TC_GREEN_m12, timeout_secs, TC_RESET_m12);
		fflush(stdout);

		// set timeout
		tv.tv_sec = (time_t) timeout_secs;
		timeout_secs -= (sf8) tv.tv_sec;
		tv.tv_usec = (time_t) (timeout_secs * (sf8) 1e6);

		// wait for keyboard entry
		FD_ZERO(&fds);
		FD_SET(0, &fds);
		fds_ready = select(1, &fds, NULL, NULL, &tv);  // just the stdin read descriptor
		if (fds_ready <= 0) {  // timed out
			putchar_m12('\n'); fflush(stdout);
			tcsetattr(STDIN_FILENO, TCSANOW, &saved_term);  // reset terminal
			return(FALSE_m12);
		}
	} else {
		printf_m12("%s: ", prompt); fflush(stdout);
	}

	// read password from the console
	i = 0;
	while ((c = getchar()) != '\n' && c != EOF && i < MAX_PASSWORD_CHARACTERS_m12) {
		// check that it is acceptable character
		if (c < 33 || c > 126 || c == '\"' || c == '\'') {
			putchar_m12(7);  // beep
			continue;
		}
		password[i++] = c;
	}
	password[i] = 0;
	putchar_m12('\n');
	if (*password == 0) {
		if (confirm_no_entry == TRUE_m12) {
			printf_m12("\tIs %s<no entry>%s correct (y/n): ", TC_RED_m12, TC_RESET_m12);
			fflush(stdout);
			*dc = 0;
			scanf("%[^\n]", dc);
			getchar();  // clear '\n' from stdin
			putchar_m12(*dc);
		} else {
			*dc = 'y';
		}
		if (*dc == 'y' || *dc == 'Y') {
			putchar_m12('\n');
			tcsetattr(STDIN_FILENO, TCSANOW, &saved_term);
			return(TRUE_m12);  // user intends no entry so return TRUE. Calling function should decide what to do with no password.
		} else {
			putchar_m12('\n');
			goto ENTER_ASCII_PASSWORD_RETRY_1_m12;
		}
	}
	
	// confirm
	attempts = 0;
	if (create_password == TRUE_m12) {
		
	ENTER_ASCII_PASSWORD_RETRY_2_m12:
		
		printf_m12("Re-enter password: ");
		i = 0;
		while ((c = getchar())!= '\n' && c != EOF && i < MAX_PASSWORD_CHARACTERS_m12){
			// check that it is acceptable character
			if (c < 33 || c > 126 || c == '\"' || c == '\'') {
				putchar_m12(7);  // beep
				continue;
			}
			pw_copy[i++] = c;
		}
		pw_copy[i] = 0;
		putchar_m12('\n');
		if (strcmp(password, pw_copy)) {
			if (++attempts == MAX_ATTEMPTS) {
				printf_m12("%sPasswords do not match. Maximum attempts made.\n%s", TC_RED_m12, TC_RESET_m12);
				tcsetattr(STDIN_FILENO, TCSANOW, &saved_term);
				return(FALSE_m12);
			}
			printf_m12("%sPasswords do not match. Try again.\n%s", TC_RED_m12, TC_RESET_m12);
			goto ENTER_ASCII_PASSWORD_RETRY_2_m12;
		}
	}
	
	// reset terminal
	tcsetattr(STDIN_FILENO, TCSANOW, &saved_term);
	
	return(TRUE_m12);
}
#endif  // MACOS_m12 || LINUX_m12


#ifdef WINDOWS_m12
TERN_m12	G_enter_ascii_password_m12(si1* password, si1* prompt, TERN_m12 confirm_no_entry, sf8 timeout_secs, TERN_m12 create_password)
{
	si1		pw_copy[MAX_ASCII_PASSWORD_STRING_BYTES_m12];
	const si4	MAX_ATTEMPTS = 3;
	si4		i, c, dc, primary_attempts, match_attempts;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// pass timeout_secs == 0.0 for no timeout
	if (password == NULL) {
		G_warning_message_m12("password is NULL\n");
		return(FALSE_m12);
	}
	
	if (prompt == NULL)
		prompt = "Enter password";
	else if (*prompt == 0)
		prompt = "Enter password";
	
	primary_attempts = 0;
	ENTER_ASCII_PASSWORD_RETRY_1_m12:
	
	if (timeout_secs > (sf8) 0.0) {
		struct timeval	tv;
		fd_set		fds;
		si4		fds_ready;
		
		printf_m12("%s %s[%0.1lfs timeout]%s: ", prompt, TC_GREEN_m12, timeout_secs, TC_RESET_m12);
		fflush(stdout);
		
		// set timeout
		tv.tv_sec = (time_t) timeout_secs;
		timeout_secs -= (sf8) tv.tv_sec;
		tv.tv_usec = (time_t) (timeout_secs * (sf8) 1e6);

		// wait for keyboard entry
		FD_ZERO(&fds);
		FD_SET(0, &fds);
		fds_ready = select(1, &fds, NULL, NULL, &tv);  // just the read descriptor
		if (fds_ready <= 0)
			return(FALSE_m12);
	} else {
		printf_m12("%s: ", prompt); fflush(stdout);
	}
	
	// read password from the console
	*password = 0;
	i = 0;
	while (i < MAX_PASSWORD_CHARACTERS_m12) {
		c = _getch();
		// carriage return or CTRL-C (finished)
		if (c == '\r' || c == 3) {
			putch_m12('\r'); putch_m12('\n');
			password[i] = 0;
			break;
		}
		// backspace
		if (c == '\b') {
			if (i) {
				putch_m12('\b'); putch_m12(' '); putch_m12('\b');
				password[--i] = 0;
				continue;
			}
			// else fall through to bad character
		}
		// check that it is acceptable character
		if (c < 33 || c > 126 || c == '\"' || c == '\'') {
			putch_m12(7);  // beep
			continue;
		}
		putch_m12(c);
		Sleep(300);
		putch_m12('\b'); putch_m12('*');
		password[i++] = c;
	}
	
	if (*password == 0) {
		if (confirm_no_entry == TRUE_m12) {
			printf_m12("\tIs %s<no entry>%s correct (y/n): ", TC_RED_m12, TC_RESET_m12);
			fflush(stdout);
			dc = _getch();
			putch_m12(dc); putch_m12('\r'); putch_m12('\n');
		} else {
			dc = 'y';
		}
		if (dc == 'y' || dc == 'Y') {
			return(TRUE_m12);  // user intends no entry so return TRUE. Calling function should decide what to do with no password.
		} else if (++primary_attempts < MAX_ATTEMPTS) {
			goto ENTER_ASCII_PASSWORD_RETRY_1_m12;
		} else {
			printf_m12("%sMaximum attempts made.\n%s", TC_RED_m12, TC_RESET_m12);
			return(FALSE_m12);
		}
	}

	// confirm
	match_attempts = 0;
	if (create_password == TRUE_m12) {

	ENTER_ASCII_PASSWORD_RETRY_2_m12:

		printf_m12("Re-enter password: ");
		i = 0;

		pw_copy[0] = 0;
		i = 0;
		while (i < MAX_PASSWORD_CHARACTERS_m12) {
			c = _getch();
			// carriage return or CTRL-C (finished)
			if (c == '\r' || c == 3) {
				putch_m12('\r'); putch_m12('\n');
				pw_copy[i] = 0;
				break;
			}
			// backspace
			if (c == '\b') {
				if (i) {
					putch_m12('\b'); putch_m12(' '); putch_m12('\b');
					password[--i] = 0;
					continue;
				}
				// else fall through to bad character
			}
			// check that it is acceptable character
			if (c < 33 || c > 126 || c == '\"' || c == '\'') {
				putch_m12(7);  // beep
				continue;
			}
			putch_m12(c);
			Sleep(300);
			putch_m12('\b'); putch_m12('*');
			pw_copy[i++] = c;
		}

		if (strcmp(password, pw_copy)) {
			if (++match_attempts == MAX_ATTEMPTS) {
				if (++primary_attempts < MAX_ATTEMPTS) {
					printf_m12("%sPasswords do not match. Re-enter password.\n%s", TC_RED_m12, TC_RESET_m12);
					goto ENTER_ASCII_PASSWORD_RETRY_1_m12;
				} else {
					printf_m12("%sPasswords do not match. Maximum attempts made.\n%s", TC_RED_m12, TC_RESET_m12);
					return(FALSE_m12);
				}
			}
			printf_m12("%sPasswords do not match. Try again.\n%s", TC_RED_m12, TC_RESET_m12);
			goto ENTER_ASCII_PASSWORD_RETRY_2_m12;
		}
	}

	return(TRUE_m12);
}
#endif  // WINDOWS_m12


void    G_error_message_m12(si1 *fmt, ...)
{
	va_list		args;
	
	
	// RED suppressible text to stderr with option to exit program
	if (!(globals_m12->behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
		#ifndef MATLAB_m12
		fprintf(stderr, TC_RED_m12);
		#endif
		
		va_start(args, fmt);
		UTF8_vfprintf_m12(stderr, fmt, args);
		va_end(args);
			
		#ifndef MATLAB_m12
		fprintf(stderr, TC_RESET_m12);
		fflush(stderr);
		#endif
	}
	
	if (globals_m12->behavior_on_fail & EXIT_ON_FAIL_m12) {
		#ifdef MATLAB_m12
		mexPrintf("Exiting.\n\n");
		#else
		fprintf(stderr, "Exiting.\n\n");
		#endif
		exit_m12(-1);
	}
	
	return;
}


void	G_error_string_m12(void)
{
	si1	*str;
	
#ifdef FN_DEBUG_m12
	#ifdef MATLAB_m12
	mexPrintf("%s()\n", __FUNCTION__);
	#else
	fprintf(stderr, "%s()\n", __FUNCTION__);
	#endif
#endif

	switch (globals_m12->err_code) {
		case E_NO_ERR_m12:
			str = E_NO_ERR_STR_m12;
			break;
		case E_NO_FILE_m12:
			str = E_NO_FILE_STR_m12;
			break;
		case E_READ_ERR_m12:
			str = E_READ_ERR_STR_m12;
			break;
		case E_WRITE_ERR_m12:
			str = E_WRITE_ERR_STR_m12;
			break;
		case E_NOT_MED_m12:
			str = E_NOT_MED_STR_m12;
			break;
		case E_BAD_PASSWORD_m12:
			str = E_BAD_PASSWORD_STR_m12;
			break;
		case E_NO_METADATA_m12:
			str = E_NO_METADATA_STR_m12;
			break;
		case E_NO_INET_m12:
			str = E_NO_INET_STR_m12;
			break;
		default:
			str = "unknown error";
			break;
	}
	
	if (globals_m12->err_func != NULL) {
		#ifdef MATLAB_m12
		mexPrintf("%s  (code %d, func %s, line %d)\n\n", str, globals_m12->err_code, globals_m12->err_func, globals_m12->err_line);
		#else
		fprintf(stderr, "%s%s%s  (code %d, func %s, line %d)\n\n", TC_RED_m12, str, TC_RESET_m12, globals_m12->err_code, globals_m12->err_func, globals_m12->err_line);
		#endif
	} else {
		#ifdef MATLAB_m12
		mexPrintf("%s  (code %d, line %d)\n\n", str, globals_m12->err_code, globals_m12->err_line);
		#else
		fprintf(stderr, "%s%s%s  (code %d, line %d)\n\n", TC_RED_m12, str, TC_RESET_m12, globals_m12->err_code, globals_m12->err_line);
		#endif
	}

	return;
}
		
		
void	G_extract_path_parts_m12(si1 *full_file_name, si1 *path, si1 *name, si1 *extension)
{
	si1	*c, *cc, temp_full_file_name[FULL_FILE_NAME_BYTES_m12], dir_break;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// handle bad calls
	if (G_empty_string_m12(full_file_name) == TRUE_m12) {
		G_warning_message_m12("%s(): full_file_name is empty => returning\n", __FUNCTION__);
		return;
	}
		
	// get path from root
	G_path_from_root_m12(full_file_name, temp_full_file_name);

	// move pointer to end of string
	c = temp_full_file_name + strlen(temp_full_file_name) - 1;
	
#ifdef WINDOWS_m12
	dir_break = '\\';
#endif
#if defined MACOS_m12 || defined LINUX_m12
	dir_break = '/';
#endif
	// step back to first extension
	cc = c;
	while (*--c != '.') {
		if (*c == dir_break) {
			c = cc;
			break;
		}
	}

	// copy extension if allocated
	if (extension != NULL) {
		if (*c == '.') {
			strcpy(extension, c + 1);
			*c-- = 0;
		} else {
			*extension = 0;
		}
	} else if (*c == '.') {
		*c-- = 0;
	}

	// step back to next directory break
	while (*--c != dir_break);
	
	// copy name if allocated
	if (name != NULL)
		strncpy_m12(name, c + 1, BASE_FILE_NAME_BYTES_m12);
	*c = 0;
	
	// copy path if allocated
	if (path != NULL)
		strncpy_m12(path, temp_full_file_name, FULL_FILE_NAME_BYTES_m12);
	
	return;
}
		
		
void	G_extract_terminal_password_bytes_m12(si1 *password, si1 *password_bytes)
{
	si1	*s;     // terminal (most unique) bytes of UTF-8 password
	si4     i, j;
	ui4     ch;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	s = password;
	for (i = j = 0; (ch = UTF8_next_char_m12(s, &i)); ++j)  // "i" modified in UTF8_next_char_m12()
		password_bytes[j] = (ui1) (ch & 0x000000FF);
	
	for (; j < PASSWORD_BYTES_m12; ++j)
		password_bytes[j] = 0;
	
	return;
}
		
		
ui4     G_file_exists_m12(si1 *path)  // can be used for directories also
{
	si1			tmp_path[FULL_FILE_NAME_BYTES_m12];
	si4             	err;
#if defined MACOS_m12 || defined LINUX_m12
	struct stat     	sb;
#endif
#ifdef WINDOWS_m12
	struct _stat64		sb;
#endif
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (path == NULL)
		return(DOES_NOT_EXIST_m12);
	
	if (*path == 0)
		return(DOES_NOT_EXIST_m12);
	
	tmp_path[0] = 0;
	G_path_from_root_m12(path, tmp_path);
	
	errno_reset_m12();
#if defined MACOS_m12 || defined LINUX_m12
	err = stat(tmp_path, &sb);
	if (err == -1) {
		err = errno_m12();
		if (err == ENOENT)
			return(DOES_NOT_EXIST_m12);
		return(FILE_EXISTS_ERROR_m12);
	} else if (S_ISDIR(sb.st_mode)) {
		return(DIR_EXISTS_m12);
	}
#endif
#ifdef WINDOWS_m12
	err = _stat64(tmp_path, &sb);
	if (err == -1) {
		err = errno_m12();
		if (err == ENOENT)
			return(DOES_NOT_EXIST_m12);
		return(FILE_EXISTS_ERROR_m12);
	} else if ((sb.st_mode & S_IFMT) == S_IFDIR) {
		return(DIR_EXISTS_m12);
	}
#endif
	
	return(FILE_EXISTS_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si8	G_file_length_m12(FILE *fp, si1 *path)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// pass either FILE pointer, or path to file
	
	if (fp == NULL && path == NULL)
		return(-1);

#if defined MACOS_m12 || defined LINUX_m12
	si4		fd;
	struct stat	sb;
	
	if (fp == NULL) {
		stat(path, &sb);
	} else {
		fd = fileno(fp);
		fstat(fd, &sb);
	}
#endif

#ifdef WINDOWS_m12
	si4		fd;
	struct _stat64	sb;
	
	if (fp == NULL) {
		_stat64(path, &sb);
	} else {
		fd = _fileno(fp);
		_fstat64(fd, &sb);
	}
#endif
	
	return((si8) sb.st_size);
}
		
		
FILE_TIMES_m12	*G_file_times_m12(FILE *fp, si1 *path, FILE_TIMES_m12 *ft, TERN_m12 set_time)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// pass either FILE pointer, or path to file
	if (fp == NULL && path == NULL)
		return(NULL);

	// caller must free
	if (ft == NULL)
		ft = (FILE_TIMES_m12 *) malloc_m12(sizeof(FILE_TIMES_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

#if defined MACOS_m12 || defined LINUX_m12
	si4		fd;
	struct stat	sb;
	struct timeval 	set_times[2] = {0};
	
	
	// set times: access and modification only
	if (set_time == TRUE_m12) {
		// set access & modification times to current time
		if (ft == NULL) {
			gettimeofday(set_times, NULL);
			set_times[1] = set_times[0];
		} else {  // use passed times (if non-zero)
			if (ft->access) {
				set_times[0].tv_sec = ft->access / (si8) 1000000;
				set_times[0].tv_usec = ft->access % (si8) 1000000;
			}
			if (ft->modification) {
				set_times[1].tv_sec = ft->modification / (si8) 1000000;
				set_times[1].tv_usec = ft->modification % (si8) 1000000;
			}
		}
	}
	
	if (fp == NULL) {
		stat(path, &sb);
	} else {
		fd = fileno(fp);
		fstat(fd, &sb);
	}

	#ifdef MACOS_m12
		#ifdef _DARWIN_FEATURE_64_BIT_INODE
			ft->creation = ((si8) sb.st_birthtimespec.tv_sec * (si8) 1000000) + ((si8) sb.st_birthtimespec.tv_nsec / (si8) 1000);
		#else
			ft->creation = ((si8) sb.st_ctimespec.tv_sec * (si8) 1000000) + ((si8) sb.st_ctim.tv_nsec / (si8) 1000);  // time of last status change - may be creation time - not guaranteed
		#endif
		ft->access = ((si8) sb.st_atimespec.tv_sec * (si8) 1000000) + ((si8) sb.st_atimespec.tv_nsec / (si8) 1000);
		ft->modification = ((si8) sb.st_mtimespec.tv_sec * (si8) 1000000) + ((si8) sb.st_mtimespec.tv_nsec / (si8) 1000);
	#endif
	#ifdef LINUX_m12
		ft->creation = ((si8) sb.st_ctim.tv_sec * (si8) 1000000) + ((si8) sb.st_ctim.tv_nsec / (si8) 1000);  // time of last status change - may be creation time - not guaranteed
		ft->access = ((si8) sb.st_atim.tv_sec * (si8) 1000000) + ((si8) sb.st_atim.tv_nsec / (si8) 1000);
		ft->modification = ((si8) sb.st_mtim.tv_sec * (si8) 1000000) + ((si8) sb.st_mtim.tv_nsec / (si8) 1000);
	#endif

	// set times: access and modification only
	if (set_time == TRUE_m12) {
		if (set_times[0].tv_sec == 0) {
			set_times[0].tv_sec = ft->access / (si8) 1000000;
			set_times[0].tv_usec = ft->access % (si8) 1000000;
		}
		if (set_times[1].tv_sec == 0) {
			set_times[1].tv_sec = ft->modification / (si8) 1000000;
			set_times[1].tv_usec = ft->modification % (si8) 1000000;
		}
		utimes(path, set_times);
	}
	
	return(ft);
#endif  // MACOS_m12 || LINUX_m12

#ifdef WINDOWS_m12
	si4		fd;
	HANDLE		file_h;
	FILETIME	win_create_time, win_access_time, win_modify_time;
	FILETIME	set_access_time, set_modify_time;
	SYSTEMTIME 	sys_time;
	
	
	if (set_time == TRUE_m12) {
		if (ft == NULL) {
			GetSystemTime(&sys_time);
			SystemTimeToFileTime(&sys_time, &set_access_time);
			set_modify_time = set_access_time;
		}
		set_access_time = WN_uutc_to_win_time_m12(ft->access);
		set_modify_time = WN_uutc_to_win_time_m12(ft->modification);
	}

	if (fp == NULL) {
		if ((file_h = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE) {
		    G_warning_message_m12("%s(): CreateFile failed with error %d\n", __FUNCTION__, GetLastError());
		    return(NULL);
		}
	} else {
		fd = _fileno(fp);
		if ((file_h = (HANDLE) _get_osfhandle(fd)) == INVALID_HANDLE_VALUE) {
		    G_warning_message_m12("%s(): get_osfhandle failed with error %d\n", __FUNCTION__, GetLastError());
		    return(NULL);
		}
	}

	if (!GetFileTime(file_h, &win_create_time, &win_access_time, &win_modify_time)) {
		G_warning_message_m12("%s(): GetFileTime failed with error %d\n", __FUNCTION__, GetLastError());
		return(NULL);
	}
	
	if (ft == NULL)
		ft = (FILE_TIMES_m12 *) malloc_m12(sizeof(FILE_TIMES_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

	ft->creation = WN_time_to_uutc_m12(win_create_time);
	ft->access = WN_time_to_uutc_m12(win_access_time);
	ft->modification = WN_time_to_uutc_m12(win_modify_time);
	
	if (set_time == TRUE_m12) {
		if (!SetFileTime(file_h, NULL, &set_access_time, &set_modify_time))
			G_warning_message_m12("%s(): SetFileTime failed with error %d\n", __FUNCTION__, GetLastError());
	}

	if (fp == NULL)
		CloseHandle(file_h);
	
	return(ft);
#endif
}


void	G_fill_empty_password_bytes_m12(si1 *password_bytes)
{
	ui4	m_w, m_z;
	si4	i;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// initialize random number generator
	m_w = m_z = 0;
	for (i = 0; i < PASSWORD_BYTES_m12; ++i) {
		if (password_bytes[i] == 0)
			break;
		m_w += password_bytes[i];
		m_z -= password_bytes[i];
	}
	if (m_w == 0 || m_w == 0x464FFFFF)
		m_w = 0x01020304;
	if (m_z == 0 || m_z == 0x9068FFFF)
		m_z = 0x05060708;
	
	// fill in bytes
	for (; i < PASSWORD_BYTES_m12; ++i)
		password_bytes[i] = CMP_random_byte_m12(&m_w, &m_z);
  
	return;
}


CONTIGUON_m12	*G_find_discontinuities_m12(LEVEL_HEADER_m12 *level_header, si8 *num_contigua)
{
	si1				seg_num_str[FILE_NUMBERING_DIGITS_m12 + 1], temp_str[FULL_FILE_NAME_BYTES_m12];
	si4				i, start_seg_num, end_seg_num, n_segs, last_seg_num;
	si8				j, k, n_contigua, n_indices, *sample_offsets;
	sf8				samp_period, sf8_samps;
	FILE_PROCESSING_STRUCT_m12	**tsi_fps, *md_fps;
	TIME_SERIES_INDEX_m12		*tsi, *last_tsi;
	SEGMENT_m12			*seg;
	CHANNEL_m12			*chan;
	SESSION_m12			*sess;
	CONTIGUON_m12			*contigua;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// The difference between this function & G_build_contigua_m12(), is that this does not use time slice as delimiter for returned contigua.
	// Caller is responsible for freeing contigua.
	
	switch (level_header->type_code) {
		case LH_TIME_SERIES_SEGMENT_m12:
			seg = (SEGMENT_m12 *) level_header;
			chan = NULL;
			start_seg_num = end_seg_num = seg->metadata_fps->universal_header->segment_number;
			break;
		case LH_TIME_SERIES_CHANNEL_m12:
		case LH_SESSION_m12:
			if (level_header->type_code == LH_TIME_SERIES_CHANNEL_m12) {
				chan = (CHANNEL_m12 *) level_header;
			} else {
				chan = globals_m12->reference_channel;
				if (chan->type_code != LH_TIME_SERIES_CHANNEL_m12) {
					sess = (SESSION_m12 *) level_header;
					chan = sess->time_series_channels[0];
				}
			}
			start_seg_num = 1;
			end_seg_num = globals_m12->number_of_session_segments;
			break;
		case LH_VIDEO_CHANNEL_m12:
		case LH_VIDEO_SEGMENT_m12:
			G_warning_message_m12("%s(): not coded for video channels yet\n", __FUNCTION__);
			return(NULL);
		default:
			G_warning_message_m12("%s(): invalid level type\n", __FUNCTION__);
			return(NULL);
	}

	n_segs = (end_seg_num - start_seg_num) + 1;
	tsi_fps = (FILE_PROCESSING_STRUCT_m12 **) malloc(n_segs * sizeof(FILE_PROCESSING_STRUCT_m12 *));
	sample_offsets = (si8 *) malloc(n_segs * sizeof(si8));
	
	// get time series indices & sample offsets
	for (i = start_seg_num, j = 0; i <= end_seg_num; ++i, ++j) {
		if (chan != NULL) {
			G_numerical_fixed_width_string_m12(seg_num_str, FILE_NUMBERING_DIGITS_m12, i);
			sprintf_m12(temp_str, "%s/%s_s%s.tisd/%s_s%s.tidx", chan->path, chan->name, seg_num_str, chan->name, seg_num_str);
			tsi_fps[j] = G_read_file_m12(NULL, temp_str, 0, 0, FPS_FULL_FILE_m12, NULL, NULL, USE_GLOBAL_BEHAVIOR_m12);
			sprintf_m12(temp_str, "%s/%s_s%s.tisd/%s_s%s.tmet", chan->path, chan->name, seg_num_str, chan->name, seg_num_str);
			md_fps = G_read_file_m12(NULL, temp_str, 0, 0, FPS_FULL_FILE_m12, NULL, NULL, USE_GLOBAL_BEHAVIOR_m12);
			sample_offsets[j] = md_fps->metadata->time_series_section_2.absolute_start_sample_number;
			samp_period = (sf8)1e6 / md_fps->metadata->time_series_section_2.sampling_frequency;
			FPS_free_processing_struct_m12(md_fps, TRUE_m12);
		} else {
			tsi_fps[j] = seg->time_series_indices_fps;
			sample_offsets[j] = seg->metadata_fps->metadata->time_series_section_2.absolute_start_sample_number;
		}
	}
	
	// count contigua
	n_contigua = 0;
	for (i = 0; i < n_segs; ++i) {
		tsi = tsi_fps[i]->time_series_indices;
		n_indices = tsi_fps[i]->universal_header->number_of_entries - 1;  // exclude terminal index
		for (j = 0; j < n_indices; ++j)
			if (tsi[j].file_offset < 0)
				++n_contigua;
	}
	contigua = (CONTIGUON_m12 *) calloc_m12((size_t) n_contigua, sizeof(CONTIGUON_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	// start first contiguon
	tsi = tsi_fps[0]->time_series_indices;
	contigua[0].start_time = tsi[0].start_time;
	contigua[0].start_sample_number = 0;
	contigua[0].start_segment_number = start_seg_num;
	n_contigua = 0;
	last_tsi = tsi;
	last_seg_num = 1;

	// fill in contigua
	for (i = start_seg_num, j = 0; i <= end_seg_num; ++i, ++j) {
		tsi = tsi_fps[j]->time_series_indices;
		n_indices = tsi_fps[j]->universal_header->number_of_entries - 1;  // exclude terminal index
		for (k = 0; k < n_indices; ++k) {
			// make sample numbers global
			tsi[k].start_sample_number += sample_offsets[j];
			if (tsi[k].file_offset < 0) {
				// skip first block encountered, as it is a duplicate of contigua[0]'s start info
				if (k == 0 && j == 0) {
					last_tsi = tsi + k;
					last_seg_num = i;
					continue;
				}
				// finish last contiguon
				sf8_samps = (sf8) (tsi[k].start_sample_number - last_tsi->start_sample_number);
				contigua[n_contigua].end_time = last_tsi->start_time + (si8) ((sf8_samps * samp_period) + (sf8) 0.5);
				contigua[n_contigua].end_sample_number = tsi[k].start_sample_number - 1;
				contigua[n_contigua].end_segment_number = last_seg_num;
				// start new contiguon
				++n_contigua;
				contigua[n_contigua].start_time = tsi[k].start_time;
				contigua[n_contigua].start_sample_number = tsi[k].start_sample_number;
				contigua[n_contigua].start_segment_number = i;
				// n_contigua = 0;
			}
		    last_tsi = tsi + k;
		    last_seg_num = i;
		}
	}
	// finish last contiguon (using terminal index values)
	contigua[n_contigua].end_time = tsi[k].start_time;
	contigua[n_contigua].end_sample_number = tsi[k].start_sample_number + sample_offsets[j - 1] - 1;
	contigua[n_contigua].end_segment_number = last_seg_num;
	
	// clean up
	if (level_header->type_code == LH_TIME_SERIES_SEGMENT_m12)
		for (i = 0; i < n_segs; ++i)
			FPS_free_processing_struct_m12(tsi_fps[i], TRUE_m12);
	free((void *) tsi_fps);
	free((void *) sample_offsets);
	
	*num_contigua = n_contigua + 1;
	
	return(contigua);
}
	
		
si8	G_find_index_m12(SEGMENT_m12 *seg, si8 target, ui4 mode)
{
	ui4			target_frame_number;
	si8			i, n_inds, seg_start_time, seg_end_time;
	si8			block_samples, block_duration, seg_samples, clip_frames, clip_duration, seg_frames;
	TIME_SERIES_INDEX_m12	*tsi_base, *tsi;
	VIDEO_INDEX_m12		*vi_base, *vi;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns index containing requested time/sample
	// returns -1 if before first index
	// returns n_inds - 1 (terminal index index) if after last index
	// NO_OVERFLOWS_m12: restrict returned index to valid segment values (ORed with search type)
	// SAMPLE_SEARCH_m12: indices must be session-relative (global indexing)
	// TIME_SEARCH_m12: times must be offset uutc

	n_inds = seg->time_series_indices_fps->universal_header->number_of_entries - 1;  // account for terminal index here - cleaner code below
	
	if (seg->type_code == LH_TIME_SERIES_SEGMENT_m12) {
		tsi_base = seg->time_series_indices_fps->time_series_indices;
		if (mode & TIME_SEARCH_m12) {
			seg_start_time = seg->time_series_indices_fps->universal_header->segment_start_time;
			if (target < seg_start_time) {
				if (mode & NO_OVERFLOWS_m12)
					return(0);
				return(-1);
			}
			seg_end_time = seg->time_series_indices_fps->universal_header->segment_end_time;
			if (target > seg_end_time) {
				if (mode & NO_OVERFLOWS_m12)
					return(n_inds - 1);
				return(n_inds);
			}
			// estimate index
			block_duration = (si8) (seg->metadata_fps->metadata->time_series_section_2.maximum_block_duration + (sf8) 0.5);
			i = (target - seg_start_time) / block_duration;
			if (i > n_inds)
				i = n_inds;
			// search: exit at first index <= target
			tsi = tsi_base + i;
			if (tsi->start_time <= target) {  // forward linear search
				while (tsi->start_time <= target)
					++tsi;
				--tsi;
			} else {  // backward linear search
				while (tsi->start_time > target)
					--tsi;
			}
		} else {  //  SAMPLE_SEARCH_m12
			target -= seg->metadata_fps->metadata->time_series_section_2.absolute_start_sample_number;  // convert target to local indexing
			if (target < 0) {
				if (mode & NO_OVERFLOWS_m12)
					return(0);
				return(-1);
			}
			seg_samples = seg->metadata_fps->metadata->time_series_section_2.number_of_samples;
			if (target >= seg_samples) {
				if (mode & NO_OVERFLOWS_m12)
					return(n_inds - 1);
				return(n_inds);
			}
			// estimate index
			block_samples = (si8) seg->metadata_fps->metadata->time_series_section_2.maximum_block_samples;
			i = target / block_samples;
			if (i > n_inds)
				i = n_inds;
			// search: exit at first index <= target
			tsi = tsi_base + i;
			if (tsi->start_sample_number <= target) {  // forward linear search
				while (tsi->start_sample_number <= target)
					++tsi;
				--tsi;
			} else {  // backward linear search
				while (tsi->start_sample_number > target)
					--tsi;
			}
		}
		i = tsi - tsi_base;
	} else {  // LEVEL_VIDEO_SEGMENT_m12
		vi_base = seg->video_indices_fps->video_indices;
		if (mode & TIME_SEARCH_m12) {
			seg_start_time = seg->video_indices_fps->universal_header->segment_start_time;
			if (target < seg_start_time) {
				if (mode & NO_OVERFLOWS_m12)
					return(0);
				return(-1);
			}
			seg_end_time = seg->video_indices_fps->universal_header->segment_end_time;
			if (target > seg_end_time) {
				if (mode & NO_OVERFLOWS_m12)
					return(n_inds - 1);
				return(n_inds);
			}
			// estimate index
			clip_duration = (si8) (seg->metadata_fps->metadata->video_section_2.maximum_clip_duration + (sf8) 0.5);
			i = (target - seg_start_time) / clip_duration;
			if (i > n_inds)
				i = n_inds;
			// search: exit at first index <= target
			vi = vi_base + i;
			if (vi->start_time <= target) {  // forward linear search
				while (vi->start_time <= target)
					++vi;
				--vi;
			} else {  // backward linear search
				while (vi->start_time > target)
					--vi;
			}
		} else {  //  SAMPLE_SEARCH_m12  (target frame numbers must be in absolute frame)
			target -= seg->metadata_fps->metadata->video_section_2.absolute_start_frame_number;  // convert target to local indexing
			if (target < 0) {
				if (mode & NO_OVERFLOWS_m12)
					return(0);
				return(-1);
			}
			seg_frames = seg->metadata_fps->metadata->video_section_2.number_of_frames;
			if (target >= seg_frames) {
				if (mode & NO_OVERFLOWS_m12)
					return(n_inds - 1);
				return(n_inds);
			}
			// estimate index
			clip_frames = (si8) seg->metadata_fps->metadata->video_section_2.maximum_clip_frames;
			i = target / clip_frames;
			// search: exit at first index <= target
			vi = vi_base + i;
			target_frame_number = (ui4) target;
			if (vi->start_frame_number <= target_frame_number) {  // forward linear search
				while (vi->start_frame_number <= target_frame_number)
					++vi;
				--vi;
			} else {  // backward linear search
				while (vi->start_frame_number > target_frame_number)
					--vi;
			}
		}
		i = vi - vi_base;
	}
	
	if (mode & NO_OVERFLOWS_m12) {
		if (i == -1)
			return(0);
		else if (i == n_inds)
			return(n_inds - 1);
	}
	
	return(i);
}


#if defined MACOS_m12 || defined LINUX_m12
si1	*G_find_metadata_file_m12(si1 *path, si1 *md_path)
{
	TERN_m12	match;
	si1		*c, *name;
	ui4		code;
	size_t		len;
	DIR		*dir;
	struct dirent	*entry;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// large directory trees can take a long time to search with "find" or "ls"
	// cumbersome code => function unrolled for speed

	// caller responsible for freeing, if allocated
	if (md_path == NULL)
		md_path = (si1 *) malloc_m12((size_t) FULL_FILE_NAME_BYTES_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	// find entry level
	G_path_from_root_m12(path, md_path);
	code = G_MED_type_code_from_string_m12(md_path);
	switch(code) {
		case SESSION_DIRECTORY_TYPE_CODE_m12:
			break;
		case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:
			goto FIND_MDF_CHAN_LEVEL_m12;
		case TIME_SERIES_SEGMENT_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_SEGMENT_DIRECTORY_TYPE_CODE_m12:
			goto FIND_MDF_SEG_LEVEL_m12;
		default:
			G_warning_message_m12("%s(): input path must be a MED session, channel, or segment directory\n", __FUNCTION__);
			G_set_error_m12(E_NOT_MED_m12, __FUNCTION__, __LINE__);
			return(NULL);
	}
	
	// session level
	dir = opendir(md_path);
	if (dir == NULL)
		return(NULL);
	match = FALSE_m12;
	while ((entry = readdir(dir)) != NULL) {
		if (entry->d_type != DT_DIR)
			continue;
		name = entry->d_name;
		if (*name == '.')
			continue;
		len = strlen(name);
		if (len < 6)  // min 1 letter channel name + 5 chars for extension
			continue;
		c = name + len - 5;
		if (*c++ != '.')
			continue;
		// check for MED channel ([tv]icd extension)
		if (*c == 't' || *c == 'v') {
			if (*++c == 'i') {
				if (*++c == 'c') {
					if (*++c == 'd') {
						match = TRUE_m12;
						break;
					}
				}
			}
		}
	}
	
	if (match == FALSE_m12) {
		G_set_error_m12(E_NO_METADATA_m12, __FUNCTION__, __LINE__);
		return(NULL);
	}
	
	len = strlen(md_path);
	md_path[len++] = '/';
	strcpy(md_path + len, name);
	closedir(dir);
	
FIND_MDF_CHAN_LEVEL_m12:
	dir = opendir(md_path);
	if (dir == NULL)
		return(NULL);
	match = FALSE_m12;
	while ((entry = readdir(dir)) != NULL) {
		if (entry->d_type != DT_DIR)
			continue;
		name = entry->d_name;
		if (*name == '.')
			continue;
		len = strlen(name);
		if (len < 12)  // min 1 letter channel name + 6 chars for segment designation + 5 chars for extension
			continue;
		c = name + len - 5;
		if (*c++ != '.')
			continue;
		// check for MED segment ([tv]isd extension)
		if (*c == 't' || *c == 'v') {
			if (*++c == 'i') {
				if (*++c == 's') {
					if (*++c == 'd') {
						match = TRUE_m12;
						break;
					}
				}
			}
		}
	}
	
	if (match == FALSE_m12) {
		G_set_error_m12(E_NO_METADATA_m12, __FUNCTION__, __LINE__);
		return(NULL);
	}
	
	len = strlen(md_path);
	md_path[len++] = '/';
	strcpy(md_path + len, name);
	closedir(dir);

FIND_MDF_SEG_LEVEL_m12:
	dir = opendir(md_path); // open the path
	if (dir == NULL) {
		G_set_error_m12(E_NO_METADATA_m12, __FUNCTION__, __LINE__);
		return(NULL); // if was not able, return
	}
	match = FALSE_m12;
	while ((entry = readdir(dir)) != NULL) {  // if we were able to read something from the directory
		if (entry->d_type != DT_REG && entry->d_type != DT_LNK)
			continue;
		name = entry->d_name;
		if (*name == '.')
			continue;
		len = strlen(name);
		if (len < 12)  // min 1 letter channel name + 6 chars for segment desiognation + 5 chars for extension
			continue;
		c = name + len - 5;
		if (*c++ != '.')
			continue;
		// check for MED metadata ([tv]met extension)
		if (*c == 't' || *c == 'v') {
			if (*++c == 'm') {
				if (*++c == 'e') {
					if (*++c == 't') {
						match = TRUE_m12;
						break;
					}
				}
			}
		}
	}
	
	if (match == FALSE_m12) {
		G_set_error_m12(E_NO_METADATA_m12, __FUNCTION__, __LINE__);
		return(NULL);
	}
	
	len = strlen(md_path);
	md_path[len++] = '/';
	strcpy(md_path + len, name);
	closedir(dir);

	return(md_path);
}
#endif  // MACOS_m12 || LINUX_m12


#ifdef WINDOWS_m12
si1	*G_find_metadata_file_m12(si1 *path, si1 *md_path)
{
	si1			*name;
	ui4			code;
	size_t			len;
	WIN32_FIND_DATAA 	ffd;
	HANDLE 		        find_h;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// large directory trees can take a long time to search with "find" or "ls"
	// cumbersome code => function unrolled for speed

	// caller responsible for freeing, if allocated
	if (md_path == NULL)
		md_path = (si1 *) malloc_m12((size_t) FULL_FILE_NAME_BYTES_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	// find entry level
	G_path_from_root_m12(path, md_path);
	code = G_MED_type_code_from_string_m12(path);
	switch(code) {
		case SESSION_DIRECTORY_TYPE_CODE_m12:
			break;
		case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:
			goto WIN_FIND_MDF_CHAN_LEVEL_m12;
		case TIME_SERIES_SEGMENT_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_SEGMENT_DIRECTORY_TYPE_CODE_m12:
			goto WIN_FIND_MDF_SEG_LEVEL_m12;
		default:
			G_warning_message_m12("%s(): input path must be a MED session, channel, or segment directory\n", __FUNCTION__);
			return(NULL);
	}
	
	// session level
	len = strlen(md_path);
	strcpy(md_path + len, "\\*.?icd");
	find_h = FindFirstFileA((LPCSTR) md_path, &ffd);
	if (find_h == INVALID_HANDLE_VALUE)
		return(NULL);
	name = ffd.cFileName;
	while (*name == '.') {
		if (FindNextFileA(find_h, &ffd) == 0)
			return(NULL);
		name = ffd.cFileName;
	}
	strcpy(md_path + len + 1, name);
	FindClose(find_h);
	
	// channel level
WIN_FIND_MDF_CHAN_LEVEL_m12:
	len = strlen(md_path);
	strcpy(md_path + len, "\\*.?isd");
	find_h = FindFirstFileA((LPCSTR) md_path, &ffd);
	if (find_h == INVALID_HANDLE_VALUE)
		return(NULL);
	name = ffd.cFileName;
	while (*name == '.') {
		if (FindNextFileA(find_h, &ffd) == 0)
			return(NULL);
		name = ffd.cFileName;
	}
	strcpy(md_path + len + 1, name);
	FindClose(find_h);

	// segment level
WIN_FIND_MDF_SEG_LEVEL_m12:
	len = strlen(md_path);
	strcpy(md_path + len, "\\*.?met");
	find_h = FindFirstFileA((LPCSTR) md_path, &ffd);
	if (find_h == INVALID_HANDLE_VALUE)
		return(NULL);
	name = ffd.cFileName;
	while (*name == '.') {
		if (FindNextFileA(find_h, &ffd) == 0)
			return(NULL);
		name = ffd.cFileName;
	}
	strcpy(md_path + len + 1, name);
	FindClose(find_h);

	return(md_path);
}
#endif  // WINDOWS_m12


si8	G_find_record_index_m12(FILE_PROCESSING_STRUCT_m12 *record_indices_fps, si8 target_time, ui4 mode, si8 low_idx)
{
	si8				i, idx, n_inds, high_idx, high_time_diff, low_time_diff;
	RECORD_INDEX_m12		*ri;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Modes (note there can be multiple records with the same start time):
	//	FIND_CLOSEST_m12: If target_time == start_time, and there are multiple indices with the
	//			  same start time, the function will return the first of these indices.
	//			  If they are equally close, the lower index will be returned.
	//	FIND_LAST_BEFORE_m12
	//	FIND_FIRST_ON_OR_AFTER_m12
	//	FIND_LAST_ON_OR_BEFORE_m12
	//	FIND_FIRST_AFTER_m12
	//
	//	low_idx: as indices are often needed in pairs, pass low_idx to reduce search time if known (if not, pass zero)

	// NOTE: this function does not currently handle record files with no terminal index
	// needs to be updated

	ri = record_indices_fps->record_indices;
	n_inds = record_indices_fps->universal_header->number_of_entries;
	if (n_inds <= 1) {
		if (n_inds == 1) {
			if (ri->type_code == REC_Term_TYPE_CODE_m12)
				return(NO_INDEX_m12);  // only a terminal index, no records
		} else {
			return(NO_INDEX_m12); // no records
		}
	}

	if (target_time < ri[low_idx].start_time) {
		switch (mode) {
			case FIND_FIRST_AFTER_m12:
			case FIND_CLOSEST_m12:
			case FIND_FIRST_ON_OR_AFTER_m12:
				return(low_idx);
			// "on" or "before" condition impossible
			case FIND_LAST_ON_OR_BEFORE_m12:
			case FIND_LAST_BEFORE_m12:
				return(NO_INDEX_m12);
			default:
				G_warning_message_m12("%s(): unsupported mode (%u)\n", __FUNCTION__, mode);
				return(NO_INDEX_m12);
		}
	}
	high_idx = n_inds - 1;
	if (ri[high_idx].type_code == REC_Term_TYPE_CODE_m12)
		--high_idx;    // last true index (only a terminal index handled above)
	if (target_time >= ri[high_idx].start_time) {
		switch (mode) {
			case FIND_CLOSEST_m12:
			case FIND_LAST_BEFORE_m12:
			case FIND_LAST_ON_OR_BEFORE_m12:
				return(high_idx);
			// "on" or "after" condition impossible
			case FIND_FIRST_ON_OR_AFTER_m12:
			case FIND_FIRST_AFTER_m12:
				return(NO_INDEX_m12);
		}
	}
	if (low_idx == high_idx)
		return(low_idx);
	
	// binary search
	do {
		idx = (low_idx + high_idx) >> 1;
		// NOTE: Sgmt indices have start time of segment start but are last records written in segment -  could screw up binary search
		// This should be addressed in future MED version - start time should be in body (they need to be last records in segment for CRCs)
		// header start time could be segment end time, body end time could be start time
//		if (ri[idx].type_code == REC_Sgmt_TYPE_CODE_m12) {  // switch to linear search
//			for (i = low_idx; i <= high_idx; ++i) {
//				if (ri[i].type_code == REC_Sgmt_TYPE_CODE_m12)
//					continue;
//				if (ri[i].start_time > target_time) {
//					high_idx = i - 1;
//					break;
//				}
//			}
//			low_idx = high_idx;
//			break;
//		}
		if (ri[idx].start_time > target_time)
			high_idx = idx;
		else
			low_idx = idx;
	} while ((high_idx - low_idx) > 1);
	if (target_time >= ri[high_idx].start_time)
		idx = high_idx;
	else if (target_time < ri[high_idx].start_time)
		idx = low_idx;
	// search exits with idx == FIND_LAST_ON_OR_BEFORE_m12 condition
	// i.e. where:  ri[idx].start_time <= target_time < ri[idx + 1].start_time
	// i.e. the last index where target_time >= index start_time

	switch (mode) {
		case FIND_CLOSEST_m12:
			low_time_diff = target_time - ri[idx].start_time;
			high_time_diff = ri[idx + 1].start_time - target_time;
			if (high_time_diff < low_time_diff)
				++idx;  // advance to first record of next time
			else
				for (i = idx - 1; ri[i].start_time == ri[idx].start_time; idx = i--);  // rewind to first record of this time
			break;
		case FIND_LAST_BEFORE_m12:
			if (target_time == ri[idx].start_time) {
				for (i = idx - 1; ri[i].start_time == ri[idx].start_time; idx = i--);  // rewind to first record of this time
				--idx;  // step back to last record of last time
			}
			// there may be other records with the same time preceding this one
			break;
		case FIND_FIRST_ON_OR_AFTER_m12:
			if (target_time == ri[idx].start_time)  // "on" condition
				for (i = idx - 1; ri[i].start_time == ri[idx].start_time; idx = i--);  // rewind to first record of this time
			else
				++idx;  // advance to first record of next time
		case FIND_LAST_ON_OR_BEFORE_m12:
			break;  // no rewind: there may be other records with the same time preceding this one
		case FIND_FIRST_AFTER_m12:
			++idx;  // advance to first record of next time
			break;
	}
	
	return(idx);
}


si8     G_frame_number_for_uutc_m12(LEVEL_HEADER_m12 *level_header, si8 target_uutc, ui4 mode, ...)  // varargs: si8 ref_frame_number, si8 ref_uutc, sf8 frame_rate
{
	si1			tmp_str[FULL_FILE_NAME_BYTES_m12], num_str[FILE_NUMBERING_DIGITS_m12 + 1];
	si4			seg_num, seg_idx;
	si8                     n_inds, i, absolute_numbering_offset;
	si8			ref_frame_number, ref_uutc, test_time;
	sf8                     tmp_sf8, frame_rate, rounded_frame_num, frame_num_eps;
	ui4			mask;
	va_list			args;
	SEGMENT_m12		*seg;
	CHANNEL_m12		*chan;
	SESSION_m12		*sess;
	VIDEO_INDEX_m12		*vi;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// G_frame_number_for_uutc_m12(NULL, si8 target_uutc, ui4 mode, si8 ref_index, si8 ref_uutc, sf8 frame_rate);
	// returns frame number extrapolated from ref_frame_number (relative / absolute is determined by magnitude of reference values)
	
	// G_frame_number_for_uutc_m12(seg, target_uutc, mode);
	// returns frame number extrapolated from closest video index in reference frame specified by mode
	
	// mode FIND_ABSOLUTE_m12 (default): session relative frame numbering
	// mode FIND_RELATIVE_m12: segment relative frame numbering
	// mode FIND_CURRENT_m12 (default): frame period within which the target_uutc falls
	// mode FIND_CLOSEST_m12: frame number closest to the target_uutc
	// mode FIND_NEXT_m12: frame number following the frame period within which the target_uutc falls ( == FIND_CURRENT_m12 + 1)
	// mode FIND_PREVIOUS_m12: frame number preceding the frame period within which the target_uutc falls ( == FIND_CURRENT_m12 - 1)

	if (level_header == NULL) {  // reference points passed
		va_start(args, mode);
		ref_frame_number = va_arg(args, si8);
		ref_uutc = va_arg(args, si8);
		frame_rate = va_arg(args, sf8);
		va_end(args);
		absolute_numbering_offset = 0;
		vi = NULL;
	} else {  // level header passed
		switch (level_header->type_code) {
			case LH_VIDEO_SEGMENT_m12:
				seg = (SEGMENT_m12 *) level_header;
				break;
			case LH_VIDEO_CHANNEL_m12:
			case LH_SESSION_m12:
				seg_num = G_segment_for_uutc_m12(level_header, target_uutc);
				seg_idx = G_get_segment_index_m12(seg_num);
				if (seg_idx == FALSE_m12)
					return(FRAME_NUMBER_NO_ENTRY_m12);
				if (level_header->type_code == LH_VIDEO_CHANNEL_m12) {
					chan = (CHANNEL_m12 *) level_header;
				} else {
					chan = globals_m12->reference_channel;
					if (chan->type_code != LH_VIDEO_CHANNEL_m12) {
						sess = (SESSION_m12 *) level_header;
						chan = sess->video_channels[0];
					}
				}
				seg = chan->segments[seg_idx];
				break;
			case LH_TIME_SERIES_CHANNEL_m12:
			case LH_TIME_SERIES_SEGMENT_m12:
				return(G_sample_number_for_uutc_m12(level_header, target_uutc, mode));
			default:
				G_error_message_m12("%s(): invalid level type\n", __FUNCTION__);
				return(FRAME_NUMBER_NO_ENTRY_m12);
		}
		if (seg == NULL) {  // channel or session
			G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, seg_num);
			sprintf_m12(tmp_str, "%s/%s_s%s.%s", chan->path, chan->name, num_str, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12);
			seg = chan->segments[seg_idx] = G_open_segment_m12(NULL, NULL, tmp_str, chan->flags, NULL);
		} else if (!(seg->flags & LH_OPEN_m12)) {  // closed segment
			G_open_segment_m12(seg, NULL, NULL, seg->flags, NULL);
		}
		if (seg == NULL) {
			G_warning_message_m12("%s(): can't open segment\n", __FUNCTION__);
			return(FRAME_NUMBER_NO_ENTRY_m12);
		}

		vi = seg->video_indices_fps->video_indices;
		if (vi == NULL) {
			G_warning_message_m12("%s(): video indices are NULL => returning FRAME_NUMBER_NO_ENTRY_m12\n", __FUNCTION__);
			return(FRAME_NUMBER_NO_ENTRY_m12);
		}
		n_inds = seg->video_indices_fps->universal_header->number_of_entries - 1;  // account for terminal index here - cleaner code below
		if (mode & FIND_RELATIVE_m12)
			absolute_numbering_offset = 0;
		else  // FIND_ABSOLUTE_m12 (default)
			absolute_numbering_offset = seg->metadata_fps->metadata->video_section_2.absolute_start_frame_number;

		// condition target
		if (target_uutc < 0)  // relative time
			target_uutc = globals_m12->session_start_time - target_uutc;
		test_time = target_uutc - globals_m12->recording_time_offset;
		if (test_time > 0 && target_uutc != END_OF_TIME_m12)  // end time is not offset
			target_uutc = test_time;

		// get index
		i = G_find_index_m12(seg, target_uutc, TIME_SEARCH_m12);
		if (i == -1)  // target time earlier than segment start => return segment start sample
			return(absolute_numbering_offset);

		ref_frame_number = (vi += i)->start_frame_number;
		if (i == n_inds)  // target time later than segment end => return segment end sample number
			return((ref_frame_number - 1) + absolute_numbering_offset);
		ref_uutc = vi->start_time;

		frame_rate = seg->metadata_fps->metadata->time_series_section_2.sampling_frequency;
	}
	
	// round up if very close to next frame
	tmp_sf8 = ((sf8) (target_uutc - ref_uutc) / (sf8) 1e6) * frame_rate;
	rounded_frame_num = (sf8) ((si8) (tmp_sf8 + (sf8) 0.5));
	frame_num_eps = rounded_frame_num - tmp_sf8;
	if (frame_num_eps > (sf8) 0.0)
		if (frame_num_eps < FRAME_NUMBER_EPS_m12)
			tmp_sf8 = rounded_frame_num;
	
	mask = (ui4) (FIND_CLOSEST_m12 | FIND_NEXT_m12 | FIND_CURRENT_m12 | FIND_PREVIOUS_m12);
	switch (mode & mask) {
		case FIND_CLOSEST_m12:
			tmp_sf8 += (sf8) 0.5;
			break;
		case FIND_NEXT_m12:
			tmp_sf8 += (sf8) 1.0;
			break;
		case FIND_PREVIOUS_m12:
			if (tmp_sf8 >= (sf8) 1.0)
				tmp_sf8 -= (sf8) 1.0;
			break;
		case FIND_CURRENT_m12:
		default:
			break;
	}
	
	return(ref_frame_number + (si8) tmp_sf8 + absolute_numbering_offset);
}


TERN_m12	G_free_channel_m12(CHANNEL_m12 *channel, TERN_m12 free_channel_structure)
{
	si4		i;
	SEGMENT_m12	*seg;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns FALSE_m12 if cannot free channel structure
	
	if (channel == NULL) {
		G_warning_message_m12("%s(): trying to free a NULL CHANNEL_m12 structure => returning with no action\n", __FUNCTION__);
		return(FALSE_m12);
	}
	if (channel->segments != NULL) {
		for (i = 0; i < globals_m12->number_of_mapped_segments; ++i) {
			seg = channel->segments[i];
			if (seg != NULL)
				G_free_segment_m12(seg, TRUE_m12);
		}
		free_m12((void *) channel->segments, __FUNCTION__);  // ok whether allocated en bloc or not
	}
	if (channel->metadata_fps != NULL)
		FPS_free_processing_struct_m12(channel->metadata_fps, TRUE_m12);
	if (channel->Sgmt_records != NULL)
		free_m12((void *) channel->Sgmt_records, __FUNCTION__);
	if (channel->record_data_fps != NULL)
		FPS_free_processing_struct_m12(channel->record_data_fps, TRUE_m12);
	if (channel->record_indices_fps != NULL)
		FPS_free_processing_struct_m12(channel->record_indices_fps, TRUE_m12);
	if (channel->contigua != NULL)
		free_m12(channel->contigua, __FUNCTION__);

	if (free_channel_structure == TRUE_m12) {
		if (channel->en_bloc_allocation == FALSE_m12)
			free_m12((void *) channel, __FUNCTION__);
		return(FALSE_m12);
	} else {  // leave name, path, flags, & slice intact (i.e. clear everything with allocated memory)
		channel->flags &= ~(LH_OPEN_m12 | LH_CHANNEL_ACTIVE_m12);
		channel->last_access_time = UUTC_NO_ENTRY_m12;
		channel->metadata_fps = NULL;
		channel->record_data_fps = NULL;
		channel->record_indices_fps = NULL;
		channel->segments = NULL;
		channel->contigua = NULL;
		channel->number_of_contigua = 0;
	}

	return(TRUE_m12);
}


void	G_free_global_tables_m12(void)
{
	if (global_tables_m12 == NULL)
		return;
	
	if (global_tables_m12->timezone_table != NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) global_tables_m12->timezone_table);
	#else
		free((void *) global_tables_m12->timezone_table);
	#endif
	}
	
	if (global_tables_m12->country_aliases_table != NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) global_tables_m12->country_aliases_table);
	#else
		free((void *) global_tables_m12->country_aliases_table);
	#endif
	}
	
	if (global_tables_m12->country_acronym_aliases_table != NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) global_tables_m12->country_acronym_aliases_table);
	#else
		free((void *) global_tables_m12->country_acronym_aliases_table);
	#endif
	}
	
	if (global_tables_m12->CRC_table != NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) global_tables_m12->CRC_table);
	#else
		free((void *) global_tables_m12->CRC_table);
	#endif
	}
	
	if (global_tables_m12->AES_sbox_table != NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) global_tables_m12->AES_sbox_table);
	#else
		free((void *) global_tables_m12->AES_sbox_table);
	#endif
	}
	
	if (global_tables_m12->AES_rsbox_table != NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) global_tables_m12->AES_rsbox_table);
	#else
		free((void *) global_tables_m12->AES_rsbox_table);
	#endif
	}
	
	if (global_tables_m12->AES_rcon_table != NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) global_tables_m12->AES_rcon_table);
	#else
		free((void *) global_tables_m12->AES_rcon_table);
	#endif
	}
	
	if (global_tables_m12->SHA_h0_table != NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) global_tables_m12->SHA_h0_table);
	#else
		free((void *) global_tables_m12->SHA_h0_table);
	#endif
	}
	
	if (global_tables_m12->SHA_k_table != NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) global_tables_m12->SHA_k_table);
	#else
		free((void *) global_tables_m12->SHA_k_table);
	#endif
	}

	if (global_tables_m12->UTF8_offsets_table != NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) global_tables_m12->UTF8_offsets_table);
	#else
		free((void *) global_tables_m12->UTF8_offsets_table);
	#endif
	}

	if (global_tables_m12->UTF8_trailing_bytes_table != NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) global_tables_m12->UTF8_trailing_bytes_table);
	#else
		free((void *) global_tables_m12->UTF8_trailing_bytes_table);
	#endif
	}

	if (global_tables_m12->CMP_normal_CDF_table != NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) global_tables_m12->CMP_normal_CDF_table);
	#else
		free((void *) global_tables_m12->CMP_normal_CDF_table);
	#endif
	}

	if (global_tables_m12->CMP_VDS_threshold_map != NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) global_tables_m12->CMP_VDS_threshold_map);
	#else
		free((void *) global_tables_m12->CMP_VDS_threshold_map);
	#endif
	}

	#ifdef WINDOWS_m12
	if (global_tables_m12->hNTdll != NULL)
		FreeLibrary(global_tables_m12->hNTdll);
	#endif
	
	// destroy muticies
	PROC_pthread_mutex_destroy_m12(&global_tables_m12->TZ_mutex);
	PROC_pthread_mutex_destroy_m12(&global_tables_m12->CRC_mutex);
	PROC_pthread_mutex_destroy_m12(&global_tables_m12->AES_mutex);
	PROC_pthread_mutex_destroy_m12(&global_tables_m12->SHA_mutex);
	PROC_pthread_mutex_destroy_m12(&global_tables_m12->UTF8_mutex);
	PROC_pthread_mutex_destroy_m12(&global_tables_m12->CMP_mutex);
	PROC_pthread_mutex_destroy_m12(&global_tables_m12->NET_mutex);
	PROC_pthread_mutex_destroy_m12(&global_tables_m12->HW_mutex);
	
#ifdef MATLAB_PERSISTENT_m12
	mxFree((void *) global_tables_m12);
#else
	free((void *) global_tables_m12);
#endif
	global_tables_m12 = NULL;
	
	return;
}


void    G_free_globals_m12(TERN_m12 cleanup_for_exit)
{
	si4		i;
	GLOBALS_m12	*globals;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	globals = globals_m12;
	if (globals == NULL)
		return;
	
	if (cleanup_for_exit == TRUE_m12) {
		si1	command[FULL_FILE_NAME_BYTES_m12];

		#if defined MACOS_m12 || defined LINUX_m12
		sprintf_m12(command, "rm -f %s", globals->temp_file);
		#endif
		#ifdef WINDOWS_m12
		WN_cleanup_m12();
		sprintf_m12(command, "del %s", globals->temp_file);
		#endif
		system_m12(command, TRUE_m12, __FUNCTION__, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12);
	}
	
	// often statically allocated, so can't just free()
	// e.g. si4 rec_filts = { REC_Seiz_TYPE_CODE_m12, REC_Note_TYPE_CODE_m12, NO_TYPE_CODE_m12 };
	// globals_m12->record_filters = rec_filts;
	if (globals->record_filters != NULL)
		if (freeable_m12((void *) globals->record_filters) == TRUE_m12)
			free_m12((void *) globals->record_filters, __FUNCTION__);
			
	if (globals->behavior_stack != NULL) {
#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) globals->behavior_stack);
#else
		free((void *) globals->behavior_stack);
#endif
	}
	PROC_pthread_mutex_destroy_m12(&globals->behavior_mutex);

#ifdef AT_DEBUG_m12
	if (globals->AT_nodes != NULL) {
		AT_free_all_m12();  // display memory still allocated & free it
#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) globals->AT_nodes);  // AT nodes are not allocted with AT functions
#else
		free((void *) globals->AT_nodes);  // AT nodes are not allocated with AT functions
#endif
	}
	PROC_pthread_mutex_destroy_m12(&globals->AT_mutex);
#endif
	
	// remove current globals from global list
	PROC_pthread_mutex_lock_m12(&globals_list_mutex_m12);
	for (i = 0; i < globals_list_len_m12; ++i)
		if (globals_list_m12[i] == globals)
			break;
	for (++i; i < globals_list_len_m12; ++i)
		globals_list_m12[i - 1] = globals_list_m12[i];
	if (--globals_list_len_m12 == 0) {
		#ifdef MATLAB_PERSISTENT_m12
		mxFree((void *) globals_list_m12);
		#else
		free((void *) globals_list_m12);
		#endif
		globals_list_m12 = NULL;
		PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12);
		PROC_pthread_mutex_destroy_m12(&globals_list_mutex_m12);
		G_free_global_tables_m12();  // if no remaining globals, free tables
	} else {
		PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12);
	}
	
	// free current globals structure
#ifdef MATLAB_PERSISTENT_m12
	mxFree((void *) globals);
#else
	free((void *) globals);
#endif
	
	return;
}


TERN_m12	G_free_segment_m12(SEGMENT_m12 *segment, TERN_m12 free_segment_structure)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	// returns FALSE_m12 if cannot free segment structure

	if (segment == NULL) {
		G_warning_message_m12("$s(): trying to free a NULL SEGMENT_m12 structure => returning with no action\n", __FUNCTION__);
		return(FALSE_m12);
	}
	if (segment->metadata_fps != NULL)
		FPS_free_processing_struct_m12(segment->metadata_fps, TRUE_m12);
	if (segment->time_series_data_fps != NULL)  // also does video data fps (when it exists), due to union
		FPS_free_processing_struct_m12(segment->time_series_data_fps, TRUE_m12);
	if (segment->time_series_indices_fps != NULL)  // also does video indices, due to union
		FPS_free_processing_struct_m12(segment->time_series_indices_fps, TRUE_m12);
	if (segment->record_data_fps != NULL)
		FPS_free_processing_struct_m12(segment->record_data_fps, TRUE_m12);
	if (segment->record_indices_fps != NULL)
		FPS_free_processing_struct_m12(segment->record_indices_fps, TRUE_m12);
	if (segment->contigua != NULL)
		free_m12(segment->contigua, __FUNCTION__);

	if (free_segment_structure == TRUE_m12) {
		if (segment->en_bloc_allocation == FALSE_m12)
			free_m12((void *) segment, __FUNCTION__);  // not allocated en bloc
		return(FALSE_m12);
	} else {
		// leave name, path, & slice intact (i.e. clear everything with allocated memory)
		segment->flags &= ~(LH_OPEN_m12 | LH_CHANNEL_ACTIVE_m12);
		segment->last_access_time = UUTC_NO_ENTRY_m12;
		segment->metadata_fps = NULL;
		segment->time_series_data_fps = NULL;
		segment->time_series_indices_fps = NULL;  // == video_indices_fps;
		segment->record_data_fps = NULL;
		segment->record_indices_fps = NULL;
		segment->contigua = NULL;
		segment->number_of_contigua = 0;
	}

	return(TRUE_m12);
}


void	G_free_segmented_sess_recs_m12(SEGMENTED_SESS_RECS_m12 *ssr, TERN_m12 free_segmented_sess_rec_structure)
{
	si4				i, n_segs;
	FILE_PROCESSING_STRUCT_m12	*gen_fps;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (ssr == NULL) {
		G_warning_message_m12("%s(): trying to free a NULL SEGMENTED_SESS_RECS_m12 structure => returning with no action\n", __FUNCTION__);
		return;
	}
	
	n_segs = globals_m12->number_of_mapped_segments;
	for (i = 0; i < n_segs; ++i) {
		gen_fps = ssr->record_indices_fps[i];
		if (gen_fps != NULL)
			FPS_free_processing_struct_m12(gen_fps, TRUE_m12);
		gen_fps = ssr->record_data_fps[i];
		if (gen_fps != NULL)
			FPS_free_processing_struct_m12(gen_fps, TRUE_m12);
	}
	free_m12((void *) ssr->record_indices_fps, __FUNCTION__);
	free_m12((void *) ssr->record_data_fps, __FUNCTION__);

	if (free_segmented_sess_rec_structure == TRUE_m12)
		free_m12((void *) ssr, __FUNCTION__);
	else
		ssr->record_indices_fps = ssr->record_data_fps = NULL;
	
	return;
}


void	G_free_session_m12(SESSION_m12 *session, TERN_m12 free_session_structure)
{
	si4		i;
	CHANNEL_m12	*chan;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (session == NULL) {
		G_warning_message_m12("%s(): trying to free a NULL SESSION_m12 structure => returning with no action\n", __FUNCTION__);
		return;
	}
	if (session->time_series_metadata_fps != NULL)
		FPS_free_processing_struct_m12(session->time_series_metadata_fps, TRUE_m12);
	if (session->video_metadata_fps != NULL)
		FPS_free_processing_struct_m12(session->video_metadata_fps, TRUE_m12);
	if (session->Sgmt_records != NULL)
		free_m12((void *) session->Sgmt_records, __FUNCTION__);
	if (session->record_data_fps != NULL)
		FPS_free_processing_struct_m12(session->record_data_fps, TRUE_m12);
	if (session->record_indices_fps != NULL)
		FPS_free_processing_struct_m12(session->record_indices_fps, TRUE_m12);
	if (session->time_series_channels != NULL) {
		for (i = 0; i < session->number_of_time_series_channels; ++i) {
			chan = session->time_series_channels[i];
			if (chan != NULL)
				G_free_channel_m12(chan, TRUE_m12);
		}
		free_m12((void *) session->time_series_channels, __FUNCTION__);  // ok whether allocated en bloc or not
	}
	if (session->video_channels != NULL) {
		for (i = 0; i < session->number_of_video_channels; ++i) {
			chan = session->video_channels[i];
			if (chan != NULL)
				G_free_channel_m12(chan, TRUE_m12);
		}
		free_m12((void *) session->video_channels, __FUNCTION__);
	}
	if (session->segmented_sess_recs != NULL)
		G_free_segmented_sess_recs_m12(session->segmented_sess_recs, TRUE_m12);

	if (session->contigua != NULL)
		free_m12(session->contigua, __FUNCTION__);

	if (free_session_structure == TRUE_m12) {
		GLOBALS_m12	*globals;
		
		
		free_m12((void *) session, __FUNCTION__);
		
		// current session constants
		globals = globals_m12;
		globals->session_UID = UID_NO_ENTRY_m12;
		*globals->session_directory = 0;
		globals->session_start_time = GLOBALS_SESSION_START_TIME_DEFAULT_m12;
		globals->session_end_time = GLOBALS_SESSION_END_TIME_DEFAULT_m12;
		globals->session_name = NULL;
		*globals->uh_session_name = 0;
		*globals->fs_session_name = 0;
		globals->session_start_time = UUTC_NO_ENTRY_m12;
		globals->session_end_time = UUTC_NO_ENTRY_m12;
		globals->number_of_session_samples = SAMPLE_NUMBER_NO_ENTRY_m12;  // == number_of_session_frames
		globals->number_of_session_segments = SEGMENT_NUMBER_NO_ENTRY_m12;
		globals->number_of_mapped_segments = SEGMENT_NUMBER_NO_ENTRY_m12;
		globals->reference_channel = NULL;
		*globals->reference_channel_name = 0;

		// active channel constants
		globals->time_series_frequencies_vary = UNKNOWN_m12;
		globals->minimum_time_series_frequency = FREQUENCY_NO_ENTRY_m12;
		globals->maximum_time_series_frequency = FREQUENCY_NO_ENTRY_m12;
		globals->minimum_time_series_frequency_channel = NULL;
		globals->maximum_time_series_frequency_channel = NULL;
		globals->video_frame_rates_vary = UNKNOWN_m12;;
		globals->minimum_video_frame_rate = FREQUENCY_NO_ENTRY_m12;
		globals->maximum_video_frame_rate = FREQUENCY_NO_ENTRY_m12;
		globals->minimum_video_frame_rate_channel = NULL;
		globals->maximum_video_frame_rate_channel = NULL;
		
		// Time Constants
		globals->time_constants_set = FALSE_m12;
		globals->RTO_known = GLOBALS_RTO_KNOWN_DEFAULT_m12;
		globals->observe_DST = GLOBALS_OBSERVE_DST_DEFAULT_m12;
		globals->recording_time_offset = GLOBALS_RECORDING_TIME_OFFSET_DEFAULT_m12;
		globals->standard_UTC_offset = GLOBALS_STANDARD_UTC_OFFSET_DEFAULT_m12;
		globals->daylight_time_start_code.value = DTCC_VALUE_NO_ENTRY_m12;
		globals->daylight_time_end_code.value = DTCC_VALUE_NO_ENTRY_m12;
		strcpy(globals->standard_timezone_acronym, GLOBALS_STANDARD_TIMEZONE_ACRONYM_DEFAULT_m12);
		strcpy(globals->standard_timezone_string, GLOBALS_STANDARD_TIMEZONE_STRING_DEFAULT_m12);
		strcpy(globals->daylight_timezone_acronym, GLOBALS_DAYLIGHT_TIMEZONE_ACRONYM_DEFAULT_m12);
		strcpy(globals->daylight_timezone_string, GLOBALS_DAYLIGHT_TIMEZONE_STRING_DEFAULT_m12);

		// reset miscellaneous globals
		globals->mmap_block_bytes = GLOBALS_MMAP_BLOCK_BYTES_NO_ENTRY_m12;
		globals->password_data.processed = 0;  // don't zero password hints can be shown, if they exist

	} else {  // leave name, path, slice, & globals intact (i.e. clear everything with allocated memory)
		session->flags &= ~LH_OPEN_m12;
		session->last_access_time = UUTC_NO_ENTRY_m12;
		session->number_of_time_series_channels = 0;
		session->time_series_channels = NULL;
		session->time_series_metadata_fps = NULL;
		session->number_of_video_channels = 0;
		session->video_channels = NULL;
		session->video_metadata_fps = NULL;
		session->record_data_fps = NULL;
		session->record_indices_fps = NULL;
		session->segmented_sess_recs = NULL;
		session->contigua = NULL;
		session->number_of_contigua = 0;
	}

	return;
}


TERN_m12	G_frequencies_vary_m12(SESSION_m12 *sess)
{
	si4					i, n_chans, seg_idx;
	sf8					rate, min_rate, max_rate;
	CHANNEL_m12				*chan, *max_chan, *min_chan;
	SEGMENT_m12				*seg;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns TRUE_m12 if any frequencies vary
	
	// check time series channels
	seg_idx = G_get_segment_index_m12(FIRST_OPEN_SEGMENT_m12);
	n_chans = sess->number_of_time_series_channels;
	globals_m12->time_series_frequencies_vary = UNKNOWN_m12;
	globals_m12->minimum_time_series_frequency = globals_m12->maximum_time_series_frequency = FREQUENCY_NO_ENTRY_m12;
	globals_m12->minimum_time_series_frequency_channel = globals_m12->maximum_time_series_frequency_channel = NULL;
	if (n_chans) {
		for (i = 0; i < n_chans; ++i) {
			chan = sess->time_series_channels[i];
			if (chan->flags & LH_CHANNEL_ACTIVE_m12)
				break;
		}
		if (i < n_chans) {
			min_chan = max_chan = chan;
			seg = chan->segments[seg_idx];
			min_rate = max_rate = seg->metadata_fps->metadata->time_series_section_2.sampling_frequency;
			for (++i; i < n_chans; ++i) {
				chan = sess->time_series_channels[i];
				if (chan->flags & LH_CHANNEL_ACTIVE_m12) {
					seg = chan->segments[seg_idx];
					rate = seg->metadata_fps->metadata->time_series_section_2.sampling_frequency;
					if (min_rate > rate) {
						min_rate = rate;
						min_chan = chan;
					} else if (max_rate < rate) {
						max_rate = rate;
						max_chan = chan;
					}
				}
			}
			if (min_rate == max_rate)
				globals_m12->time_series_frequencies_vary = FALSE_m12;
			else
				globals_m12->time_series_frequencies_vary = TRUE_m12;
			globals_m12->minimum_time_series_frequency = min_rate;
			globals_m12->maximum_time_series_frequency = max_rate;
			globals_m12->minimum_time_series_frequency_channel = min_chan;
			globals_m12->maximum_time_series_frequency_channel = max_chan;
		}
	}

	// check video channels
	n_chans = sess->number_of_video_channels;
	globals_m12->video_frame_rates_vary = UNKNOWN_m12;
	globals_m12->minimum_video_frame_rate = globals_m12->maximum_video_frame_rate = FREQUENCY_NO_ENTRY_m12;
	globals_m12->minimum_video_frame_rate_channel = globals_m12->maximum_video_frame_rate_channel = NULL;
	if (n_chans) {
		for (i = 0; i < n_chans; ++i) {
			chan = sess->video_channels[i];
			if (chan->flags & LH_CHANNEL_ACTIVE_m12)
				break;
		}
		if (i < n_chans) {
			min_chan = max_chan = chan;
			seg = chan->segments[seg_idx];
			min_rate = max_rate = seg->metadata_fps->metadata->video_section_2.frame_rate;
			for (++i; i < n_chans; ++i) {
				chan = sess->video_channels[i];
				if (chan->flags & LH_CHANNEL_ACTIVE_m12) {
					seg = chan->segments[seg_idx];
					rate = seg->metadata_fps->metadata->video_section_2.frame_rate;
					if (min_rate > rate) {
						min_rate = rate;
						min_chan = chan;
					} else if (max_rate < rate) {
						max_rate = rate;
						max_chan = chan;
					}
				}
				if (min_rate == max_rate)
					globals_m12->video_frame_rates_vary = FALSE_m12;
				else
					globals_m12->video_frame_rates_vary = TRUE_m12;
				globals_m12->minimum_video_frame_rate = min_rate;
				globals_m12->maximum_video_frame_rate = max_rate;
				globals_m12->minimum_video_frame_rate_channel = min_chan;
				globals_m12->maximum_video_frame_rate_channel = max_chan;
			}
		}
	}
	
	if (globals_m12->time_series_frequencies_vary == TRUE_m12 || globals_m12->video_frame_rates_vary == TRUE_m12)
		return(TRUE_m12);

	return(FALSE_m12);
}


si1	**G_generate_file_list_m12(si1 **file_list, si4 *n_files, si1 *enclosing_directory, si1 *name, si1 *extension, ui4 flags)
{
	TERN_m12	regex;
	si1		tmp_enclosing_directory[FULL_FILE_NAME_BYTES_m12], tmp_path[FULL_FILE_NAME_BYTES_m12];
	si1		tmp_name[FULL_FILE_NAME_BYTES_m12], tmp_extension[16], tmp_ext[16], *buffer, *c, *c2;
	si1		**tmp_ptr_ptr;
	ui4		path_parts;
	si4		i, j, n_in_files, *n_out_files;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// can be used to get a directory list also
	// file_list entries, enclosing_directory, name, & extension can contain regexp
	// if file_list is NULL it will be allocated
	
	n_in_files = *n_files;
	n_out_files = n_files;
	path_parts = flags & GFL_PATH_PARTS_MASK_m12;
	
	// quick bailout for nothing to do (file_list passed, paths are from root, & contain no regex)
	if (file_list != NULL && n_in_files > 0) {
		if (G_check_file_list_m12(file_list, n_in_files) == TRUE_m12) {
			if ((flags & GFL_FREE_INPUT_LIST_m12) == 0) {  // caller expects a copy to be returned
				tmp_ptr_ptr = (si1 **) calloc_2D_m12((size_t) n_in_files, FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
				for (i = 0; i < n_in_files; ++i)
					strcpy(tmp_ptr_ptr[i], file_list[i]);
				file_list = tmp_ptr_ptr;
			}
			goto GFL_CONDITION_RETURN_DATA_m12;
		}
	}
	
	// copy incoming arguments so as not to modify, and in case they are const type
	if (enclosing_directory == NULL)
		*tmp_enclosing_directory = 0;
	else
		strcpy(tmp_enclosing_directory, enclosing_directory);
	enclosing_directory = tmp_enclosing_directory;
				
	if (name == NULL)
		*tmp_name = 0;
	else
		strcpy(tmp_name, name);
	name = tmp_name;
	
	if (extension == NULL)
		*tmp_extension = 0;
	else
		strcpy(tmp_extension, extension);
	extension = tmp_extension;
	
	// file list passed:
	// If list components do not have a file name, and one is passed, it is used.
	// If list components do not have a file name, and none is passed, "*" is used.
	// If list components do not have an enclosing directory, and one is passed, it is used.
	// If list components do not have an enclosing directory, and none is passed, G_path_from_root_m12() is used.
	// If list components do not have an extension, and one is passed, it is used.
	// If list components do not have an extension, and none is passed, none is used.
	regex = FALSE_m12;
	if (file_list != NULL) {
		tmp_ptr_ptr = (si1 **) calloc_2D_m12((size_t) n_in_files, FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		// copy file_list
		for (i = 0; i < n_in_files; ++i) {
			// check for regex
			if (regex == FALSE_m12)
				regex = STR_contains_regex_m12(file_list[i]);
			// fill in list entry path components
			G_extract_path_parts_m12(file_list[i], tmp_path, NULL, tmp_ext);
			if (*tmp_path == 0) {
				if (*enclosing_directory == 0)
					sprintf_m12(tmp_ptr_ptr[i], "%s/%s", enclosing_directory, file_list[i]);
				else
					G_path_from_root_m12(file_list[i], file_list[i]);
				
			} else {
				strcpy(tmp_ptr_ptr[i], file_list[i]);
			}
			if (*tmp_ext == 0 && *extension)
				sprintf_m12(tmp_ptr_ptr[i], "%s.%s", tmp_ptr_ptr[i], extension);
		}
		if (flags & GFL_FREE_INPUT_LIST_m12)
			free_2D_m12((void **) file_list, n_in_files, __FUNCTION__);
		file_list = tmp_ptr_ptr;
	}

	// no file_list passed (+/- enclosing_directory, +/- name, +/- extension, are passed instead)
	// If no enclosing_directory passed, G_path_from_root_m120() is used.
	// If no name is passed, "*" is used.
	// If no extension is passed, none is used.
	else {  // file_list == NULL
		file_list = (si1 **) calloc_2D_m12((size_t) 1, FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		G_path_from_root_m12(enclosing_directory, enclosing_directory);
		if (*name)
			sprintf_m12(file_list[0], "%s/%s", enclosing_directory, name);
		else
			sprintf_m12(file_list[0], "%s/*", enclosing_directory);
		if (*extension)
			sprintf_m12(file_list[0], "%s.%s", file_list[0], extension);
		n_in_files = 1;
		if (STR_contains_regex_m12(file_list[0]) == TRUE_m12)
			regex = TRUE_m12;
	}

	// expand regex (use system shell to expand regex)
	if (regex == TRUE_m12) {
		
	#if defined MACOS_m12 || defined LINUX_m12
		TERN_m12	no_match;
		si1		*command, *tmp_command;
		si4		ret_val;
		size_t		len;

		// alternating with tmp_command here because of a quirk in sprintf_m12(), that needs to be looked at
		
		len = n_in_files * FULL_FILE_NAME_BYTES_m12;
		if (flags & GFL_INCLUDE_INVISIBLE_m12)
			len <<= 1;
		len += 16;
		command = (si1 *) malloc((size_t) len);
		tmp_command = (si1 *) malloc((size_t) len);
		#ifdef MACOS_m12
		strcpy(command, "/bin/ls -1d");
		#endif
		#ifdef LINUX_m12
		strcpy(command, "/usr/bin/ls -1d");
		#endif
		for (i = 0; i < n_in_files; ++i) {
			STR_escape_chars_m12(file_list[i], (si1) 0x20, FULL_FILE_NAME_BYTES_m12);  // escape spaces
			STR_escape_chars_m12(file_list[i], (si1) 0x27, FULL_FILE_NAME_BYTES_m12);  // escape apostrophes
			STR_escape_chars_m12(file_list[i], (si1) 0x60, FULL_FILE_NAME_BYTES_m12);  // escape graves
			len = sprintf(tmp_command, "%s %s", command, file_list[i]);
			memcpy((void *) command, (void *) tmp_command, ++len);
			if (flags & GFL_INCLUDE_INVISIBLE_m12) {
				G_extract_path_parts_m12(file_list[i], NULL, name, extension);
				len = sprintf(tmp_command, "%s %s/.%s", command, enclosing_directory, name);  // explicitly include hidden files & directories with a prepended "."
				memcpy((void *) command, (void *) tmp_command, ++len);
				if (*extension) {
					len = sprintf(tmp_command, "%s.%s", command, extension);
					memcpy((void *) command, (void *) tmp_command, ++len);
				}
			}
		}
		free((void *) tmp_command);
		free_2D_m12((void *) file_list, n_in_files, __FUNCTION__);
		
		buffer = NULL;
		ret_val = system_pipe_m12(&buffer, 0, command, SP_DEFAULT_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free((void *) command);
		if (ret_val < 0) {
			// system_pipe_m12() error return frees buffer
			*n_out_files = 0;
			return(NULL);
		}
		if (G_empty_string_m12(buffer) == TRUE_m12) {
			*n_out_files = 0;
			free_m12((void *) buffer, __FUNCTION__);
			return(NULL);
		}
		// system_pipe_m12() can distinguish between stderr & stdout, but this is not well tested yet
		// this is a terrible solution, but works for now
		no_match = FALSE_m12;
		#ifdef LINUX_m12
		if (strncmp(buffer, "/usr/bin/ls: ", 13) == 0)
			no_match = TRUE_m12;
		#endif
		#ifdef MACOS_m12
		if (strncmp(buffer, "ls: ", 4) == 0)
			no_match = TRUE_m12;
		#endif
		if (no_match == TRUE_m12) {
			*n_out_files = 0;
			free_m12((void *) buffer, __FUNCTION__);
			return(NULL);
		}
				
		// count expanded file list
		c = buffer;
		*n_out_files = 0;
		while (*c++) {
			if (*c == '\n')
				++(*n_out_files);
		}
		if (*n_out_files == 0) {
			free_m12((void *) buffer, __FUNCTION__);
			return(NULL);
		}
	#endif  // MACOS_m12 || LINUX_m12
		
	#ifdef WINDOWS_m12
		buffer = NULL;
		*n_out_files = WN_ls_1d_to_buf_m12(file_list, n_in_files, TRUE_m12, &buffer);
		free_m12((void *) file_list, __FUNCTION__);
		if (*n_out_files <= 0) {  // error
			*n_out_files = 0;
			return(NULL);
		}
	#endif  // WINDOWS_m12

		// re-allocate
		file_list = (si1 **) calloc_2D_m12((size_t) *n_out_files, FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		
		// build file list
		c = buffer;
		for (i = 0; i < *n_out_files; ++i) {
			c2 = file_list[i];
			while (*c != '\n' && *c != '\r')
				*c2++ = *c++;
			*c2 = 0;
			if (*c == '\r')
				++c;
			++c;
		}
		free_m12((void *) buffer, __FUNCTION__);
	}

GFL_CONDITION_RETURN_DATA_m12:
	
	// return requested path parts
	for (i = j = 0; i < *n_out_files; ++i) {
		G_extract_path_parts_m12(file_list[i], enclosing_directory, tmp_name, tmp_extension);
		if ((flags & GFL_INCLUDE_INVISIBLE_m12) == 0)
			if (*tmp_name == '.')  // exclude invisible files
				continue;
		if ((flags & GFL_INCLUDE_PARITY_m12) == 0)
			if (strncmp(tmp_name, "parity", 6) == 0)  // exclude parity files
				continue;
		switch (path_parts) {
			case (GFL_FULL_PATH_m12):
				if (i != j)
					strcpy(file_list[j], file_list[i]);
				break;
			case (GFL_PATH_m12 | GFL_NAME_m12):
				sprintf_m12(file_list[j], "%s/%s", enclosing_directory, tmp_name);
				break;
			case (GFL_NAME_m12 | GFL_EXTENSION_m12):
				sprintf_m12(file_list[j], "%s.%s", tmp_name, tmp_extension);
				break;
			case GFL_NAME_m12:
				strcpy(file_list[j], tmp_name);
				break;
			default:
				G_error_message_m12("%s(): unrecognized path component combination (path_parts == %hhu)\n", __FUNCTION__, path_parts);
				break;
		}
		++j;
	}
	*n_out_files = j;
		
	// sort file list (so results are consistent across operating systems)
	STR_sort_m12(file_list, *n_out_files);

	return(file_list);
}


ui4    G_generate_MED_path_components_m12(si1 *path, si1 *MED_dir, si1 *MED_name)
{
	si1     extension[TYPE_BYTES_m12], local_MED_name[SEGMENT_BASE_FILE_NAME_BYTES_m12];
	si1     local_MED_dir[FULL_FILE_NAME_BYTES_m12];;
	si4     fe, name_bytes;
	ui4     code;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (MED_dir == NULL)
		*(MED_dir = local_MED_dir) = 0;
	if (MED_name == NULL)
		*(MED_name = local_MED_name) = 0;
	
	// copy & condition path
	strcpy(local_MED_dir, path);
	// escaped characters can happen if string with escaped chars is also quoted (e.g. by a shell script) => pretty uncommon
	STR_unescape_chars_m12(local_MED_dir, (si1) 0x20);  // spaces
	STR_unescape_chars_m12(local_MED_dir, (si1) 0x27);  // apostrophes
	STR_unescape_chars_m12(local_MED_dir, (si1) 0x60);  // graves
	G_path_from_root_m12(local_MED_dir, local_MED_dir);

	// check path: if file passed, get enclosing directory
	fe = G_file_exists_m12(local_MED_dir);
	if (fe == FILE_EXISTS_m12) {
		G_extract_path_parts_m12(local_MED_dir, local_MED_dir, NULL, NULL);
	} else if (fe == DOES_NOT_EXIST_m12) {
		G_error_message_m12("%s(): passed path \"%s\" does not exist => returning\n", __FUNCTION__, local_MED_dir);
		return(NO_TYPE_CODE_m12);
	} else if (fe == FILE_EXISTS_ERROR_m12) {
		G_error_message_m12("%s(): G_file_exists_m12 error() => returning\n", __FUNCTION__);
		return(NO_TYPE_CODE_m12);
	}

	// get name & extension
	G_extract_path_parts_m12(local_MED_dir, NULL, local_MED_name, extension);

	code = G_MED_type_code_from_string_m12(extension);
	switch (code) {
		case SESSION_DIRECTORY_TYPE_CODE_m12:
		case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:
		case RECORD_DIRECTORY_TYPE_CODE_m12:
			name_bytes = BASE_FILE_NAME_BYTES_m12;
			break;
		case TIME_SERIES_SEGMENT_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_SEGMENT_DIRECTORY_TYPE_CODE_m12:
			name_bytes = SEGMENT_BASE_FILE_NAME_BYTES_m12;
			break;
		default:
			G_error_message_m12("%s(): passed path \"%s\" is not a MED directory\n", __FUNCTION__, local_MED_dir);
			return(NO_TYPE_CODE_m12);
	}

	// copy to outputs, if provided
	if (MED_dir != NULL)
		snprintf_m12(MED_dir, FULL_FILE_NAME_BYTES_m12, "%s", local_MED_dir);
	if (MED_name != NULL)
		snprintf_m12(MED_name, name_bytes, "%s", local_MED_name);

	return(code);
}


si1	**G_generate_numbered_names_m12(si1 **names, si1 *prefix, si4 number_of_names)
{
	si8     i;
	si1     number_str[FILE_NUMBERING_DIGITS_m12 + 1];
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (names == NULL)
		names = (si1 **) calloc_2D_m12((size_t) number_of_names, SEGMENT_BASE_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	for (i = 0; i < number_of_names; ++i) {
		G_numerical_fixed_width_string_m12(number_str, FILE_NUMBERING_DIGITS_m12, i + 1);
		snprintf_m12(names[i], SEGMENT_BASE_FILE_NAME_BYTES_m12, "%s%s", prefix, number_str);
	}
	
	return(names);
}


TERN_m12	G_generate_password_data_m12(FILE_PROCESSING_STRUCT_m12* fps, si1 *L1_pw, si1 *L2_pw, si1 *L3_pw, si1 *L1_pw_hint, si1 *L2_pw_hint)
{
	PASSWORD_DATA_m12	*pwd;
	ui1			hash[SHA_HASH_BYTES_m12];
	si1			L1_pw_bytes[PASSWORD_BYTES_m12] = { 0 }, L2_pw_bytes[PASSWORD_BYTES_m12] = { 0 }, L3_pw_bytes[PASSWORD_BYTES_m12] = { 0 };
	si4			i;
	METADATA_SECTION_1_m12	*md1;
	UNIVERSAL_HEADER_m12	*uh;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (L1_pw != NULL)
		if (*L1_pw == 0)
			L1_pw = NULL;
	if (L1_pw == NULL)  // need at least a level 1 password to generate any password data fields
		return(FALSE_m12);
	if (L2_pw != NULL)
		if (*L2_pw == 0)
			L2_pw = NULL;
	if (L3_pw != NULL)
		if (*L3_pw == 0)
			L3_pw = NULL;
	if (L1_pw_hint != NULL)
		if (*L1_pw_hint == 0)
			L1_pw_hint = NULL;
	if (L2_pw_hint != NULL)
		if (*L2_pw_hint == 0)
			L2_pw_hint = NULL;

	if (fps == NULL)
		pwd = &globals_m12->password_data;
	else
		pwd = fps->parameters.password_data;
	memset((void *) pwd, 0, sizeof(PASSWORD_DATA_m12));
	pwd->processed = TRUE_m12;

	// copy password hints to password data
	if (L1_pw_hint != NULL)
		strncpy_m12(pwd->level_1_password_hint, L1_pw_hint, PASSWORD_HINT_BYTES_m12);
	if (L2_pw_hint != NULL)
		strncpy_m12(pwd->level_2_password_hint, L2_pw_hint, PASSWORD_HINT_BYTES_m12);

	// copy password hints to metadata if possible
	if (fps != NULL) {
		uh = fps->universal_header;
		if (uh->type_code == TIME_SERIES_METADATA_FILE_TYPE_CODE_m12 || uh->type_code == VIDEO_METADATA_FILE_TYPE_CODE_m12) {
			md1 = &fps->metadata->section_1;
			if (L1_pw_hint != NULL)
				strncpy_m12(md1->level_1_password_hint, L1_pw_hint, PASSWORD_HINT_BYTES_m12);
			if (L2_pw_hint != NULL)
				strncpy_m12(md1->level_2_password_hint, L2_pw_hint, PASSWORD_HINT_BYTES_m12);
		}
	}

	// user passed level 1 password: generate validation field and encryption key
	if (G_check_password_m12(L1_pw) == FALSE_m12)
		return(FALSE_m12);
	
	// passed a level 1 password - at least level 1 access
	pwd->access_level = LEVEL_1_ACCESS_m12;
	
	// get terminal bytes
	G_extract_terminal_password_bytes_m12(L1_pw, L1_pw_bytes);
	
	// generate Level 1 password validation field
	SHA_hash_m12((ui1 *) L1_pw_bytes, PASSWORD_BYTES_m12, hash);
	memcpy(uh->level_1_password_validation_field, hash, PASSWORD_VALIDATION_FIELD_BYTES_m12);
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("Level 1 password validation field generated");
	
	// generate encryption key
	AES_key_expansion_m12(pwd->level_1_encryption_key, L1_pw_bytes);
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("Level 1 encryption key generated");
	
	// user also passed level 2 password: generate validation field and encryption key
	// level 2 encryption requires a level 1 password, even if level 1 encryption is not used
	if (L2_pw != NULL) {
		if (G_check_password_m12(L2_pw) == TRUE_m12) {
			
			// passed a level 2 password - level 2 access
			pwd->access_level = LEVEL_2_ACCESS_m12;
			
			// get terminal bytes
			G_extract_terminal_password_bytes_m12(L2_pw, L2_pw_bytes);
			
			// generate Level 2 password validation field
			SHA_hash_m12((ui1 *) L2_pw_bytes, PASSWORD_BYTES_m12, hash);
			memcpy(uh->level_2_password_validation_field, hash, PASSWORD_VALIDATION_FIELD_BYTES_m12);
			
			// exclusive or with level 1 password bytes
			for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m12; ++i)
				uh->level_2_password_validation_field[i] ^= L1_pw_bytes[i];
			if (globals_m12->verbose == TRUE_m12)
				G_message_m12("Level 2 password validation field generated");
			
			// generate encryption key
			AES_key_expansion_m12(pwd->level_2_encryption_key, L2_pw_bytes);
			if (globals_m12->verbose == TRUE_m12)
				G_message_m12("Level 2 encryption key generated");
		} else {  // G_check_password_m12() == FALSE_m12
			return(FALSE_m12);
		}
	}
	
	// user also passed level 3 password for recovery: generate validation field
	if (L3_pw != NULL) {
		if (G_check_password_m12(L3_pw) == TRUE_m12) {
			
			// get terminal bytes
			G_extract_terminal_password_bytes_m12(L3_pw, L3_pw_bytes);
			
			// generate Level 3 password validation field
			SHA_hash_m12((ui1 *) L3_pw_bytes, PASSWORD_BYTES_m12, hash);
			memcpy(uh->level_3_password_validation_field, hash, PASSWORD_VALIDATION_FIELD_BYTES_m12);
			if (pwd->access_level == LEVEL_1_ACCESS_m12) {  // only level 1 password passed
				for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m12; ++i) // exclusive or with level 1 password bytes
					uh->level_3_password_validation_field[i] ^= L1_pw_bytes[i];
			} else {  // level 1 & level 2 passwords passed
				for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m12; ++i) // exclusive or with level 2 password bytes
					uh->level_3_password_validation_field[i] ^= L2_pw_bytes[i];
			}
			if (globals_m12->verbose == TRUE_m12)
				G_message_m12("Level 3 password validation field generated");
		} else {  // G_check_password_m12() == FALSE_m12
			return(FALSE_m12);
		}
	}

	return(TRUE_m12);
}


si8	G_generate_recording_time_offset_m12(si8 recording_start_time_uutc)
{
	time_t		recording_start_time_utc, offset_utc_time, UTC_offset, secs_since_midnight;
	struct tm	time_info;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// receives UNOFFSET recording start time (or CURRENT_TIME_m12)
	// returns OFFSET recording start time
	
	if (recording_start_time_uutc == CURRENT_TIME_m12) // use current system time
		recording_start_time_uutc = G_current_uutc_m12();
	
	recording_start_time_utc = recording_start_time_uutc / (si8) 1000000;
	
	// convert to same time of day in GMT (ignoring DST)
	// (prefer not to use localtime() because might system may not be in timezone of recording, as in conversions)
	if (globals_m12->time_constants_set == TRUE_m12) {
		UTC_offset = globals_m12->standard_UTC_offset;
	} else {
		G_warning_message_m12("%s(): global time constants not set, using local UTC offset\n", __FUNCTION__);
#if defined MACOS_m12 || defined LINUX_m12
		localtime_r(&recording_start_time_utc, &time_info);
		UTC_offset = time_info.tm_gmtoff;  // this is offset to standard time regardless of DST status (same number if tm_isdst true or false)
#endif
#ifdef WINDOWS_m12
		TIME_ZONE_INFORMATION	win_tz_info;
		
		time_info = *(localtime(&recording_start_time_utc));
				
		GetTimeZoneInformation(&win_tz_info);
		UTC_offset = (win_tz_info.Bias + win_tz_info.StandardBias) * -60;
#endif
	}
	offset_utc_time = recording_start_time_utc + UTC_offset;
	
	// get GMT time structure
#if defined MACOS_m12 || defined LINUX_m12
	gmtime_r(&offset_utc_time, &time_info);
#endif
#ifdef WINDOWS_m12
	time_info = *(gmtime(&offset_utc_time));
#endif
	// get time from midnight, same day in GMT
	secs_since_midnight = (time_info.tm_hour * 3600) + (time_info.tm_min * 60) + time_info.tm_sec;

	// set global offset
	globals_m12->recording_time_offset = (recording_start_time_utc - secs_since_midnight) * (si8) 1000000;
	
	if (recording_start_time_uutc == globals_m12->recording_time_offset)	// recording started at exactly midnight local standard time
		--globals_m12->recording_time_offset;				// this can cause problems with oUTC and BEGINNING_OF_TIME_m12 (== 0)
	
	globals_m12->RTO_known = TRUE_m12;

	return(recording_start_time_uutc - globals_m12->recording_time_offset);
}


si1	*G_generate_segment_name_m12(FILE_PROCESSING_STRUCT_m12 *fps, si1 *segment_name)
{
	si1	segment_number_str[FILE_NUMBERING_DIGITS_m12 + 1];
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (segment_name == NULL)  // if NULL is passed, this will be allocated, but the calling function has the responsibility to free it.
		segment_name = (si1 *) malloc_m12((size_t) SEGMENT_BASE_FILE_NAME_BYTES_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	G_numerical_fixed_width_string_m12(segment_number_str, FILE_NUMBERING_DIGITS_m12, fps->universal_header->segment_number);
	
	snprintf_m12(segment_name, SEGMENT_BASE_FILE_NAME_BYTES_m12, "%s_s%s", fps->universal_header->channel_name, segment_number_str);
	
	return(segment_name);
}


ui8	G_generate_UID_m12(ui8 *uid)
{
	si4	        i;
	ui1		*ui1_p;
	static ui8      local_UID;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Note if NULL is passed for uid, this function is not thread-safe
	if (uid == NULL)
		uid = (ui8 *)&local_UID;
	ui1_p = (ui1 *) uid;
	
RESERVED_UID_VALUE_m12:
#if defined MACOS_m12 || defined LINUX_m12
	for (i = 0; i < UID_BYTES_m12; ++i)
		ui1_p[i] = (ui1) (random() % (ui8) 0x100);
#endif
#ifdef WINDOWS_m12
	for (i = 0; i < UID_BYTES_m12; ++i)
		ui1_p[i] = (ui1) ((ui4) rand() % (ui4) 0x100);
#endif
	switch (*uid) {
		case UID_NO_ENTRY_m12:
			goto RESERVED_UID_VALUE_m12;
		case CMP_BLOCK_START_UID_m12:
			goto RESERVED_UID_VALUE_m12;
	}
	
	return(*uid);
}


CHANNEL_m12	*G_get_active_channel_m12(SESSION_m12 *sess, si1 chan_type)
{
	si4		i, n_chans;
	CHANNEL_m12	*chan;


	// check time series channels
	if (chan_type == DEFAULT_CHANNEL_m12 || chan_type == DEFAULT_TIME_SERIES_CHANNEL_m12) {
		n_chans = sess->number_of_time_series_channels;
		for (i = 0; i < n_chans; ++i) {
			chan = sess->time_series_channels[i];
			if (chan->flags & LH_CHANNEL_ACTIVE_m12)
				return(chan);
		}
	}

	// check video channels
	if (chan_type == DEFAULT_CHANNEL_m12 || chan_type == DEFAULT_VIDEO_CHANNEL_m12) {
		n_chans = sess->number_of_video_channels;
		for (i = 0; i < n_chans; ++i) {
			chan = sess->video_channels[i];
			if (chan->flags & LH_CHANNEL_ACTIVE_m12)
				return(chan);
		}
	}
	
	G_warning_message_m12("%s(): no active channels\n", __FUNCTION__);
	
	return(NULL);
}


ui4	G_get_level_m12(si1 *full_file_name, ui4 *input_type_code)
{
	si1	enclosing_directory[FULL_FILE_NAME_BYTES_m12];
	ui4	code;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	code = G_MED_type_code_from_string_m12(full_file_name);
	if (input_type_code != NULL)  // e.g. file type - function returns level
		*input_type_code = code;
	
	// Note: if code == RECORD_DIRECTORY_TYPE_CODE_m12, this is session level, but from segmented session records; return this code so caller knows it was not global session records
	switch (code) {
		case NO_FILE_TYPE_CODE_m12:
		case SESSION_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:
		case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
		case TIME_SERIES_SEGMENT_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_SEGMENT_DIRECTORY_TYPE_CODE_m12:
			return(code);
		case RECORD_DIRECTORY_TYPE_CODE_m12:
			return(LH_SESSION_m12);
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
		case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
		case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
			return(LH_TIME_SERIES_SEGMENT_m12);
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
		case VIDEO_INDICES_FILE_TYPE_CODE_m12:
			return(LH_VIDEO_SEGMENT_m12);
	}
	
	// record data or indices file
	G_extract_path_parts_m12(full_file_name, enclosing_directory, NULL, NULL);
	code = G_MED_type_code_from_string_m12(enclosing_directory);

	return(code);
}


LOCATION_INFO_m12	*G_get_location_info_m12(LOCATION_INFO_m12 *loc_info, TERN_m12 set_timezone_globals, TERN_m12 prompt)
{
	TERN_m12	free_loc_info = FALSE_m12;
	si1		*command, *buffer, *pattern, *c;
	si4		ret_val;
	time_t 		curr_time;
	struct tm 	loc_time;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
		
	if (loc_info == NULL) {
		loc_info = (LOCATION_INFO_m12 *) calloc((size_t) 1, sizeof(LOCATION_INFO_m12));
		free_loc_info = TRUE_m12;
	} else {
		memset((void *) loc_info, 0, sizeof(LOCATION_INFO_m12));
	}
	
#if defined MACOS_m12 || defined LINUX_m12
	command = "/usr/bin/curl --connect-timeout 5.0 -s ipinfo.io";
#endif
#ifdef WINDOWS_m12
	command = "curl.exe --connect-timeout 5.0 .exe -s ipinfo.io";
#endif
	buffer = NULL;
	ret_val = system_pipe_m12(&buffer, 0, command, SP_DEFAULT_m12,  __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	if (ret_val < 0)
		return(NULL);
	
	// condition output
	STR_strip_character_m12(buffer, '"');
	
	// parse output
	pattern = "ip: ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL)
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%[^,]", loc_info->WAN_IPv4_address);
	
	pattern = "city: ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL)
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%[^,]", loc_info->locality);
	
	pattern = "region: ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL)
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%[^,]", loc_info->timezone_info.territory);
	
	pattern = "country: ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL)
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%[^,]", loc_info->timezone_info.country_acronym_2_letter);
	
	pattern = "loc: ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL)
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%lf,%lf", &loc_info->latitude, &loc_info->longitude);
	
	pattern = "postal: ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL)
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%[^,]", loc_info->postal_code);
	
	pattern = "timezone: ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL)
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%[^, ]", loc_info->timezone_description);
	
	free((void *) buffer);
	
	// get timezone acronym from system
	curr_time = time(NULL);
#if defined MACOS_m12 || defined LINUX_m12
	si8	len;
	
	localtime_r(&curr_time, &loc_time);
	len = strlen(loc_time.tm_zone);
	if (len >= 3) { // the table does not contain 2 letter timezone acronyms (e.g. MT for MST)
		if (loc_time.tm_isdst)
			strcpy(loc_info->timezone_info.daylight_timezone_acronym, loc_time.tm_zone);
		else
			strcpy(loc_info->timezone_info.standard_timezone_acronym, loc_time.tm_zone);
	}
#endif
#ifdef WINDOWS_m12
	loc_time = *(localtime(&curr_time));
	if (*_tzname[0])
		strcpy(loc_info->timezone_info.standard_timezone, _tzname[0]);
	if (*_tzname[1])
		strcpy(loc_info->timezone_info.daylight_timezone, _tzname[1]);
#endif

	if (G_set_global_time_constants_m12(&loc_info->timezone_info, 0, prompt) == FALSE_m12)
		G_warning_message_m12("%s(): could not set timezone globals => returning NULL\n", __FUNCTION__);
	
	if (free_loc_info == TRUE_m12) {
		free((void *) loc_info);
		return(NULL);
	}

	return(loc_info);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	G_get_search_mode_m12(TIME_SLICE_m12 *slice)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// time takes priority
	if (slice->start_time != UUTC_NO_ENTRY_m12 && slice->end_time != UUTC_NO_ENTRY_m12)
		return(TIME_SEARCH_m12);
	
	if (slice->start_sample_number != SAMPLE_NUMBER_NO_ENTRY_m12 && slice->end_sample_number != SAMPLE_NUMBER_NO_ENTRY_m12)
		return(SAMPLE_SEARCH_m12);
	
	G_warning_message_m12("%s(): no valid limit pair\n", __FUNCTION__);
	
	return(FALSE_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	G_get_segment_index_m12(si4 segment_number)
{
	si4		i, mapped_segs, sess_segs, first_seg, seg_idx;
	CHANNEL_m12	*chan;
	SEGMENT_m12	*seg;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns offset of segment_number into segments array
	// FIRST_OPEN_SEGMENT_m12 returns the first open segment in the reference channel
	// returns FALSE_m12 on error

	mapped_segs = globals_m12->number_of_mapped_segments;
	if (mapped_segs == 0) {
		G_warning_message_m12("%s(): no mapped segments\n", __FUNCTION__);
		return((si4) FALSE_m12);
	}

	if (segment_number == FIRST_OPEN_SEGMENT_m12 || segment_number == SEGMENT_NUMBER_NO_ENTRY_m12) {
		chan = globals_m12->reference_channel;
		if (chan == NULL) {
			G_warning_message_m12("%s(): reference channel not set\n", __FUNCTION__);
			return((si4) FALSE_m12);
		}
		for (i = 0; i < mapped_segs; ++i) {
			seg = chan->segments[i];
			if (seg != NULL)
				if (seg->flags & LH_OPEN_m12)
					break;
		}
		if (i == mapped_segs) {
			G_warning_message_m12("%s(): no open segments\n", __FUNCTION__);
			return((si4) FALSE_m12);
		}
		if (segment_number == SEGMENT_NUMBER_NO_ENTRY_m12)
			G_warning_message_m12("%s(): segment not specified => returning first open segment from reference channel\n", __FUNCTION__);
		return(i);
	}
	
	sess_segs = globals_m12->number_of_session_segments;
	
	// all segments mapped
	if (mapped_segs == sess_segs) {
		if (segment_number >= 1 && segment_number <= mapped_segs) {
			return(segment_number - 1);
		} else {
			G_warning_message_m12("%s(): invalid segment number\n", __FUNCTION__);
			return((si4) FALSE_m12);
		}
	}
	
	// slice segments mapped
	first_seg = globals_m12->first_mapped_segment_number;
	seg_idx = segment_number - first_seg;
	if (seg_idx < 0 || seg_idx >= mapped_segs) {
		G_warning_message_m12("%s(): unmapped segment\n", __FUNCTION__);
		return((si4) FALSE_m12);
	}
	
	return(seg_idx);
}


si4     G_get_segment_range_m12(LEVEL_HEADER_m12 *level_header, TIME_SLICE_m12 *slice)
{
	TERN_m12			Sgmts_adequate;
	si1				tmp_str[FULL_FILE_NAME_BYTES_m12], sess_path[FULL_FILE_NAME_BYTES_m12], *sess_name;
	ui4				file_exists;
	si4				search_mode, n_segs, last_seg_idx;
	si8				i, n_recs;
	size_t				n_bytes;
	SESSION_m12			*sess;
	CHANNEL_m12			*chan;
	FILE_PROCESSING_STRUCT_m12	*ri_fps, *rd_fps, *md_fps;
	RECORD_INDEX_m12		*ri;
	Sgmt_RECORD_m12			*Sgmt_records, *Sgmt_rec;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (slice->conditioned == FALSE_m12)
		G_condition_time_slice_m12(slice);
	slice->start_segment_number = slice->end_segment_number = SEGMENT_NUMBER_NO_ENTRY_m12;
	slice->number_of_segments = UNKNOWN_m12;

	switch (level_header->type_code) {
		case LH_SESSION_m12:
			sess = (SESSION_m12 *) level_header;
			chan = globals_m12->reference_channel;
			if (chan == NULL)
				chan = G_change_reference_channel_m12(sess, NULL, NULL, DEFAULT_CHANNEL_m12);
			Sgmt_records = sess->Sgmt_records;
			break;
		case LH_TIME_SERIES_CHANNEL_m12:
		case LH_VIDEO_CHANNEL_m12:
			chan = (CHANNEL_m12 *) level_header;
			sess = (SESSION_m12 *) chan->parent;
			Sgmt_records = chan->Sgmt_records;
			break;
		default:
			G_error_message_m12("%s(): invalid level\n", __FUNCTION__);
			return(0);
	}
	
	// check for valid limit pair (time takes priority)
	if ((search_mode = G_get_search_mode_m12(slice)) == FALSE_m12)
		return(0);

	if (Sgmt_records == NULL) {
		// check for channel level Sgmt records (typically most efficient: usually small files & always contain sample number references)
		sprintf_m12(tmp_str, "%s/%s.%s", chan->path, chan->name, RECORD_INDICES_FILE_TYPE_STRING_m12);
		file_exists = G_file_exists_m12(tmp_str);
		if (file_exists == FILE_EXISTS_m12) {
			ri_fps = chan->record_indices_fps = G_read_file_m12(chan->record_indices_fps, tmp_str, 0, 0, FPS_FULL_FILE_m12, level_header, NULL, USE_GLOBAL_BEHAVIOR_m12);
			chan->record_indices_fps->parent = (void *) chan;
			n_recs = ri_fps->universal_header->number_of_entries;
			ri = ri_fps->record_indices;
			for (i = n_recs; i--; ++ri)
				if (ri->type_code == REC_Sgmt_TYPE_CODE_m12)
					break;
			if (i >= 0) {
				sprintf_m12(tmp_str, "%s/%s.%s", chan->path, chan->name, RECORD_DATA_FILE_TYPE_STRING_m12);
				rd_fps = chan->record_data_fps = G_read_file_m12(chan->record_data_fps, tmp_str, 0, 0, FPS_UNIVERSAL_HEADER_ONLY_m12, level_header, NULL, USE_GLOBAL_BEHAVIOR_m12);
				chan->record_data_fps->parent = (void *) chan;
				Sgmt_records = G_build_Sgmt_records_array_m12(ri_fps, rd_fps, NULL);
				if (Sgmt_records != NULL && level_header->type_code == LH_SESSION_m12) {  // copy ref chan Sgmt records into ref chan, if used for session
					n_bytes = (size_t) globals_m12->number_of_session_segments * sizeof(Sgmt_RECORD_m12);
					chan->Sgmt_records = (Sgmt_RECORD_m12 *) malloc_m12(n_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
					memcpy((void *) chan->Sgmt_records, (void *) Sgmt_records, n_bytes);
				}
			}
		}
		
		// no channel level Sgmt records => check session level (may not contain sample numbers, but may not need them)
		if (Sgmt_records == NULL) {
			// get global session name(s)
			if (globals_m12->session_UID == UID_NO_ENTRY_m12) {
				G_find_metadata_file_m12(chan->path, tmp_str);
				md_fps = G_read_file_m12(NULL, tmp_str, 0, 0, FPS_FULL_FILE_m12, NULL, NULL, USE_GLOBAL_BEHAVIOR_m12);
				FPS_free_processing_struct_m12(md_fps, TRUE_m12);
			}
			sess_name = globals_m12->session_name;
			if (sess != NULL) {
				strcpy(sess_path, sess->path);
				ri_fps = sess->record_indices_fps;
				rd_fps = sess->record_data_fps;
			} else {
				G_extract_path_parts_m12(chan->path, sess_path, NULL, NULL);
				ri_fps = NULL;
				rd_fps = NULL;
			}
			if (ri_fps == NULL)
				sprintf_m12(tmp_str, "%s/%s.%s", sess_path, sess_name, RECORD_INDICES_FILE_TYPE_STRING_m12);
			else if (*ri_fps->full_file_name)
				strcpy(tmp_str, ri_fps->full_file_name);
			else
				sprintf_m12(tmp_str, "%s/%s.%s", sess_path, sess_name, RECORD_INDICES_FILE_TYPE_STRING_m12);
			file_exists = G_file_exists_m12(tmp_str);
			if (file_exists == DOES_NOT_EXIST_m12) {  // uh session name is default, try fs session name (e.g. a channel subset)
				if (globals_m12->session_name == globals_m12->uh_session_name) {
					G_extract_path_parts_m12(sess_path, tmp_str, NULL, NULL);
					sprintf_m12(sess_path, "%s/%s", tmp_str, globals_m12->fs_session_name);
					sprintf_m12(tmp_str, "%s/%s.%s", sess_path, sess_name, RECORD_INDICES_FILE_TYPE_STRING_m12);
					file_exists = G_file_exists_m12(tmp_str);
				}
			}
			if (file_exists == FILE_EXISTS_m12) {
				ri_fps = G_read_file_m12(ri_fps, tmp_str, 0, 0, FPS_FULL_FILE_m12, level_header, NULL, USE_GLOBAL_BEHAVIOR_m12);
				n_recs = ri_fps->universal_header->number_of_entries;
				ri = ri_fps->record_indices;
				for (i = n_recs; i--; ++ri)
					if (ri->type_code == REC_Sgmt_TYPE_CODE_m12)
						break;
				if (i >= 0) {  // check that session Sgmt records contain sampling frequency
					sprintf_m12(tmp_str, "%s/%s.%s", sess_path, sess_name, RECORD_DATA_FILE_TYPE_STRING_m12);
					rd_fps = G_read_file_m12(rd_fps, tmp_str, 0, 0, FPS_UNIVERSAL_HEADER_ONLY_m12, level_header, NULL, USE_GLOBAL_BEHAVIOR_m12);
					Sgmts_adequate = TRUE_m12;
					if (search_mode == SAMPLE_SEARCH_m12) {
						G_read_file_m12(rd_fps, NULL, ri->file_offset, 0, 1, 0, NULL, USE_GLOBAL_BEHAVIOR_m12);
						Sgmt_rec = (Sgmt_RECORD_m12 *) rd_fps->record_data;
						if (Sgmt_rec->end_sample_number == SAMPLE_NUMBER_NO_ENTRY_m12 || Sgmt_rec->end_sample_number == 0)
							Sgmts_adequate = FALSE_m12;
					}
				} else {
					Sgmts_adequate = FALSE_m12;
				}
				if (Sgmts_adequate == TRUE_m12)
					Sgmt_records = G_build_Sgmt_records_array_m12(ri_fps, rd_fps, NULL);
			}
		}

		// no adequate session level Sgmt records => build from reference channel metadata (least efficient option)
		if (Sgmt_records == NULL)
			Sgmt_records = G_build_Sgmt_records_array_m12(NULL, NULL, chan);

		// assign level Sgmt_records pointer
		switch (level_header->type_code) {
			case LH_SESSION_m12:
				sess->Sgmt_records = Sgmt_records;
				break;
			case LH_TIME_SERIES_CHANNEL_m12:
			case LH_VIDEO_CHANNEL_m12:
				chan->Sgmt_records = Sgmt_records;
				break;
		}
	}

	// search Sgmt_records array for segments
	n_segs = G_search_Sgmt_records_m12(Sgmt_records, slice, search_mode);
	if (n_segs) {
		slice->number_of_segments = n_segs;
		if (level_header->flags & LH_MAP_ALL_SEGMENTS_m12) {
			globals_m12->number_of_mapped_segments = globals_m12->number_of_session_segments;
			globals_m12->first_mapped_segment_number = 1;
		} else {
			globals_m12->number_of_mapped_segments = n_segs;
			globals_m12->first_mapped_segment_number = slice->start_segment_number;
		}
	} else {
		slice->number_of_segments = UNKNOWN_m12;
		globals_m12->number_of_mapped_segments = 0;
		globals_m12->first_mapped_segment_number = 0;
	}

	if (slice->start_time == BEGINNING_OF_TIME_m12)
		slice->start_time = Sgmt_records[0].start_time;
	if (slice->start_time == Sgmt_records[0].start_time)
		slice->start_sample_number = Sgmt_records[0].start_sample_number;
	last_seg_idx = globals_m12->number_of_session_segments - 1;
	if (slice->end_time == END_OF_TIME_m12)
		slice->end_time = Sgmt_records[last_seg_idx].end_time;
	if (slice->end_time == Sgmt_records[last_seg_idx].end_time)
		slice->end_sample_number = Sgmt_records[last_seg_idx].end_sample_number;

	return(n_segs);
}


ui4	*G_get_segment_video_start_frames_m12(FILE_PROCESSING_STRUCT_m12 *video_indices_fps, ui4 *number_of_video_files)
{
	ui4			j, *start_frames, local_number_of_video_files;
	si8			i, n_inds;
	VIDEO_INDEX_m12		*vidx;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// NOTE: start frame numbers are inserted into array at their video file number offset, so array can be used as start_frames[vidx->video_file_number], rather than subtracting 1
	// So start_frames[0] == start_frames[1] == 0
	// pass NULL for number_of_video_files if you don't need the value
	// to get global frame numbers add segment metadata absolute_start_frame_number to these numbers
	
	if (number_of_video_files == NULL)
		number_of_video_files = &local_number_of_video_files;
	vidx = video_indices_fps->video_indices;
	n_inds = video_indices_fps->universal_header->number_of_entries - 1;
	*number_of_video_files = vidx[n_inds].video_file_number - 1;  // terminal index video file number is number of imaginary next file
	start_frames = (ui4 *) calloc_m12((size_t) (*number_of_video_files + 1), sizeof(ui4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);  // indexing from 1
	
	for (i = n_inds, j = 1; i--; ++vidx)
		if (vidx->video_file_number == j)
			start_frames[j++] = vidx->start_frame_number;
			
	return(start_frames);
}


si1	*G_get_session_directory_m12(si1 *session_directory, si1 *MED_file_name, FILE_PROCESSING_STRUCT_m12 *MED_fps)
{
	TERN_m12	set_global_session_name;
	si1		temp_str[FULL_FILE_NAME_BYTES_m12];
	ui4		code;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// session_directory is return vehicle. MED_file_name is input vehicle.
	// If NULL passed for session directory, sets global session directory and session name from
	// file path, not global original session name which comes from universal header.
	
	
	if (MED_file_name == NULL) {
		if (MED_fps == NULL)
			return(NULL);
		if (*MED_fps->full_file_name)
			MED_file_name = MED_fps->full_file_name;
		else
			return(NULL);
	}
	
	if (session_directory == NULL || session_directory == globals_m12->session_directory) {
		set_global_session_name = TRUE_m12;
		session_directory = globals_m12->session_directory;
	} else {
		set_global_session_name = FALSE_m12;
	}
	
	memset(session_directory, 0, FULL_FILE_NAME_BYTES_m12);
	G_path_from_root_m12(MED_file_name, session_directory);
	code = G_MED_type_code_from_string_m12(session_directory);

	switch (code) {
		case NO_FILE_TYPE_CODE_m12:
			return(NULL);
			
		// up zero levels
		case SESSION_DIRECTORY_TYPE_CODE_m12:
			break;
			
		// up one level
		case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:
		case RECORD_DIRECTORY_TYPE_CODE_m12:  // segmented session records is only MED component that uses a diectory - session level
			G_extract_path_parts_m12(session_directory, session_directory, NULL, NULL);
			break;
			
		// up two levels
		case TIME_SERIES_SEGMENT_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_SEGMENT_DIRECTORY_TYPE_CODE_m12:
			G_extract_path_parts_m12(session_directory, session_directory, NULL, NULL);
			G_extract_path_parts_m12(session_directory, session_directory, NULL, NULL);
			break;
			
		// up 3 levels
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
		case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
		case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
		case VIDEO_INDICES_FILE_TYPE_CODE_m12:
			G_extract_path_parts_m12(session_directory, session_directory, NULL, NULL);
			G_extract_path_parts_m12(session_directory, session_directory, NULL, NULL);
			G_extract_path_parts_m12(session_directory, session_directory, NULL, NULL);
			break;
		
		// up variable number of levels (recursion - need local storage)
		case RECORD_DATA_FILE_TYPE_CODE_m12:
		case RECORD_INDICES_FILE_TYPE_CODE_m12:
			G_extract_path_parts_m12(session_directory, temp_str, NULL, NULL);
			return(G_get_session_directory_m12(session_directory, temp_str, MED_fps));
			break;
	}
	
	if (set_global_session_name == TRUE_m12) {
		G_extract_path_parts_m12(session_directory, NULL, globals_m12->fs_session_name, NULL);
		if (MED_fps != NULL) {
			globals_m12->session_UID = MED_fps->universal_header->session_UID;
			strcpy(globals_m12->uh_session_name, MED_fps->universal_header->session_name);
			globals_m12->session_name = globals_m12->uh_session_name;
		} else {
			globals_m12->session_name = globals_m12->fs_session_name;
		}
	}

	return(session_directory);
}


TERN_m12	G_get_terminal_entry_m12(si1 *prompt, si1 type, void *buffer, void *default_input, TERN_m12 required, TERN_m12 validate)
{
	si8	items;
	si1	local_buffer[128], local_prompt[128];
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (default_input != NULL) {
		if (type == RC_STRING_TYPE_m12)
			if (*((si1 *) default_input) == 0)
				default_input = NULL;
	}

GET_TERMINAL_ENTRY_RETRY_m12:
	
	if (required == TRUE_m12)
		sprintf_m12(local_prompt, "* %s", prompt);
	else
		strcpy(local_prompt, prompt);

	// clear
	if (buffer != default_input) {
		switch (type) {
			case RC_STRING_TYPE_m12:
				*((si1 *) buffer) = 0;
				break;
			case RC_FLOAT_TYPE_m12:
				*((sf8 *) buffer) = (sf8) 0;
				break;
			case RC_INTEGER_TYPE_m12:
				*((si8 *) buffer) = (si8) 0;
				break;
			case RC_TERNARY_TYPE_m12:
				*((si1 *) buffer) = (si1) 0;
				break;
			default:
				G_warning_message_m12("%s(): unrecognized data type => returning FALSE\n", __FUNCTION__);
				return(FALSE_m12);
		}
	}

	if (default_input != NULL) {
		switch (type) {
			case RC_STRING_TYPE_m12:
				sprintf_m12(local_prompt, "%s [%s]", local_prompt, (si1 *) default_input);
				break;
			case RC_FLOAT_TYPE_m12:
				sprintf_m12(local_prompt, "%s [%lf]", local_prompt, *((sf8 *) default_input));
				break;
			case RC_INTEGER_TYPE_m12:
				sprintf_m12(local_prompt, "%s [%ld]", local_prompt, *((si8 *) default_input));
				break;
			case RC_TERNARY_TYPE_m12:
				sprintf_m12(local_prompt, "%s [%hhd]", local_prompt, *((si1 *) default_input));
				break;
		}
	}
		
	printf_m12("%s: ", local_prompt);
	fflush(stdout);
	items = scanf("%[^\n]", (si1 *) local_buffer);
	if (items) {
		switch (type) {
			case RC_STRING_TYPE_m12:
				strcpy((si1 *) buffer, local_buffer);
				break;
			case RC_FLOAT_TYPE_m12:
				*((sf8 *) buffer) = strtod(local_buffer, NULL);
				break;
			case RC_INTEGER_TYPE_m12:
				*((si8 *) buffer) = (si8) strtol(local_buffer, NULL, 10);
				break;
			case RC_TERNARY_TYPE_m12:
				*((si1 *) buffer) = (si1) strtol(local_buffer, NULL, 10);
				break;
		}
	}
	getchar();  // clear '\n' from stdin
	
	if (items == 0 && default_input != NULL && buffer != default_input) {
		switch (type) {
			case RC_STRING_TYPE_m12:
				strcpy((si1 *) buffer, (si1 *) default_input);
				break;
			case RC_FLOAT_TYPE_m12:
				*((sf8 *) buffer) = *((sf8 *) default_input);
				break;
			case RC_INTEGER_TYPE_m12:
				*((si8 *) buffer) = *((si8 *) default_input);
				break;
			case RC_TERNARY_TYPE_m12:
				*((si1 *) buffer) = *((si1 *) default_input);
				break;
		}
	}

	if (validate == TRUE_m12) {
		if (items == 1 || default_input != NULL) {
			switch (type) {
				case RC_STRING_TYPE_m12:
					printf_m12("\tIs %s\"%s\"%s correct (y/n): ", TC_RED_m12, (si1 *) buffer, TC_RESET_m12);
					break;
				case RC_FLOAT_TYPE_m12:
					printf_m12("\tIs %s%lf%s correct (y/n): ", TC_RED_m12, *((sf8 *) buffer), TC_RESET_m12);
					break;
				case RC_INTEGER_TYPE_m12:
					printf_m12("\tIs %s%ld%s correct (y/n): ", TC_RED_m12, *((si8 *) buffer), TC_RESET_m12);
					break;
				case RC_TERNARY_TYPE_m12:
					printf_m12("\tIs %s%hhd%s correct (y/n): ", TC_RED_m12, *((si1 *) buffer), TC_RESET_m12);
					break;
			}
		} else {
			printf_m12("\tIs %s<no entry>%s correct (y/n): ", TC_RED_m12, TC_RESET_m12);
		}
		fflush(stdout);
		*local_buffer = 0;
		scanf("%[^\n]", local_buffer);
		getchar();  // clear '\n' from stdin
		if (*local_buffer == 'y' || *local_buffer == 'Y') {
			required = FALSE_m12;
		} else {
			default_input = NULL;  // in case user wanted no entry instead of default
			goto GET_TERMINAL_ENTRY_RETRY_m12;
		}
	}

	if (items == 0 && required == TRUE_m12) {
		*local_buffer = 0;
		G_warning_message_m12("No entry in required field\n");
		goto GET_TERMINAL_ENTRY_RETRY_m12;
	}
	
	putchar('\n');

	return(TRUE_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
GLOBALS_m12	*G_globals_pointer_m12(void)
{
	si4		i;
	pid_t_m12	_id;
	GLOBALS_m12	*globals;
	
	
	// return parent (or only) globals
	// most common usage, so check first
	if (globals_list_len_m12 == 1)
		return(globals_list_m12[0]);
	
	// no globals exist
	if (globals_list_len_m12 == 0)
		return(NULL);
	
	// return thread local globals
	_id = PROC_gettid_m12();
	
	// lock list
	PROC_pthread_mutex_lock_m12(&globals_list_mutex_m12);

	for (i = 0; i < globals_list_len_m12; ++i) {
		if (globals_list_m12[i]->_id == _id) {
			globals = globals_list_m12[i];
			PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12); // unlock list
			return(globals);
		}
	}

	// return process globals
	_id = PROC_getpid_m12();

	for (i = 0; i < globals_list_len_m12; ++i) {
		if (globals_list_m12[i]->_id == _id) {
			globals = globals_list_m12[i];
			PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12); // unlock list
			return(globals);
		}
	}

	// unlock list
	PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12);
	
	return(NULL);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
TERN_m12     G_include_record_m12(ui4 type_code, si4 *record_filters)
{
	si1			mode;
	const si1		INCLUDE_POSITIVE = 1, EXCLUDE_NEGATIVE = -1;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// record_filters is a signed, "NULL terminated" array version of MED record type codes to include or exclude when reading records.
	// The terminal entry is NO_TYPE_CODE_m12 (== zero). NULL or no filter codes includes all records (== no filters).
	// filter modes: match positive: include
	//		 match negative: exclude
	//		 no match:
	//			all filters positive: exclude
	//			else: include
	// Note: as type codes are composed of ascii bytes values (< 0x80), it is always possible to make them negative without promotion.
	//
	// Example usage: si4	my_rec_filters[] = { REC_Sgmt_TYPE_CODE_m12, REC_Note_TYPE_CODE_m12, NO_TYPE_CODE_m12 };
	//
	// If the passed record_filters is NULL, the global record_filters will be used.
	// If the global record_filters are NULL, all records will be accepted.
	// If record_filters is a "zero-length" array (i.e. record_filters = { NO_TYPE_CODE_m12 }), all records will be accepted.

	
	if (record_filters == NULL) {
		record_filters = globals_m12->record_filters;
		if (record_filters == NULL)
			return(TRUE_m12);
		if (*record_filters == NO_TYPE_CODE_m12)
			return(TRUE_m12);
	}

	for (mode = 0; *record_filters; ++record_filters) {
		if (*record_filters > 0) {
			if (type_code == (ui4) *record_filters)
				return(TRUE_m12);
			if (mode)
				continue;
			mode = INCLUDE_POSITIVE;
		} else {
			if (type_code == (ui4) -(*record_filters))
				return(FALSE_m12);
			mode = EXCLUDE_NEGATIVE;
		}
	}
	
	if (mode == INCLUDE_POSITIVE)
		return(FALSE_m12);
	
	return(TRUE_m12);
}


//***********************************************************************//
//****************************  MED GLOBALS  ****************************//
//***********************************************************************//


TERN_m12	G_initialize_global_tables_m12(TERN_m12 initialize_all_tables)
{
	TERN_m12	ret_val;
	
#ifdef FN_DEBUG_m12
	printf_m12("%s()\n", __FUNCTION__);
#endif

	ret_val = TRUE_m12;
	
	if (global_tables_m12 == NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		global_tables_m12 = (GLOBAL_TABLES_m12 *) mxCalloc((mwSize) 1, (mwSize) sizeof(GLOBAL_TABLES_m12));
	#else
		global_tables_m12 = (GLOBAL_TABLES_m12 *) calloc((size_t) 1, sizeof(GLOBAL_TABLES_m12));
	#endif
		if (global_tables_m12 == NULL)
			return(FALSE_m12);
	}
	
	// initialize all table muticies
	PROC_pthread_mutex_init_m12(&global_tables_m12->TZ_mutex, NULL);
	PROC_pthread_mutex_init_m12(&global_tables_m12->SHA_mutex, NULL);
	PROC_pthread_mutex_init_m12(&global_tables_m12->AES_mutex, NULL);
	PROC_pthread_mutex_init_m12(&global_tables_m12->CRC_mutex, NULL);
	PROC_pthread_mutex_init_m12(&global_tables_m12->UTF8_mutex, NULL);
	PROC_pthread_mutex_init_m12(&global_tables_m12->CMP_mutex, NULL);
	PROC_pthread_mutex_init_m12(&global_tables_m12->NET_mutex, NULL);
	PROC_pthread_mutex_init_m12(&global_tables_m12->HW_mutex, NULL);
	
	if (initialize_all_tables == TRUE_m12) {  // otherwise load on demand
		if (CRC_initialize_tables_m12() == FALSE_m12)  // do this before initializing hardware tables (CRC used to get machine code)
			ret_val = FALSE_m12;
		if (HW_initialize_tables_m12() == FALSE_m12)
			ret_val = FALSE_m12;
		if (UTF8_initialize_tables_m12() == FALSE_m12)
			ret_val = FALSE_m12;
		if (NET_initialize_tables_m12() == FALSE_m12)
			ret_val = FALSE_m12;
		if (AES_initialize_tables_m12() == FALSE_m12)
			ret_val = FALSE_m12;
		if (SHA_initialize_tables_m12() == FALSE_m12)
			ret_val = FALSE_m12;
		if (CMP_initialize_tables_m12() == FALSE_m12)
			ret_val = FALSE_m12;
		if (G_initialize_timezone_tables_m12() == FALSE_m12)
			ret_val = FALSE_m12;
	} else {
		HW_get_endianness_m12();  // the library is only written for little endian machines right now, so always done
		HW_get_memory_info_m12();  // this is needed for alloc operations, so always done
	}

	// NT dylib loaded by WN_nap_m12() if used
	#ifdef WINDOWS_m12
	global_tables_m12->hNTdll = NULL;
	#endif

	return(ret_val);
}


TERN_m12	G_initialize_globals_m12(TERN_m12 initialize_all_tables)
{
	GLOBALS_m12	*globals;

#ifdef FN_DEBUG_m12  // don't use message() until UTF8 tables initialized
	printf_m12("%s()\n", __FUNCTION__);
#endif
	
	// initialize global list mutex
	if (globals_list_m12 == NULL)
		PROC_pthread_mutex_init_m12(&globals_list_mutex_m12, NULL);
	PROC_pthread_mutex_lock_m12(&globals_list_mutex_m12);  // lock immediately - only this function initializes other global mutices

	// realloc global list
	#ifdef MATLAB_PERSISTENT_m12
	globals_list_m12 = (GLOBALS_m12 **) mxRealloc((void *) globals_list_m12, (mwSize) ((globals_list_len_m12 + 1) * sizeof(GLOBALS_m12 *)));
	#else
	globals_list_m12 = (GLOBALS_m12 **) realloc((void *) globals_list_m12, (size_t) ((globals_list_len_m12 + 1) * sizeof(GLOBALS_m12 *)));
	#endif
	if (globals_list_m12 == NULL) {
		PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12);
		return(FALSE_m12);
	}
	#ifdef MATLAB_PERSISTENT_m12
	globals = (GLOBALS_m12 *) mxCalloc((mwSize) 1, (mwSize) sizeof(GLOBALS_m12));
	#else
	globals = (GLOBALS_m12 *) calloc((size_t) 1, sizeof(GLOBALS_m12));
	#endif
	if (globals == NULL) {
		PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12);
		return(FALSE_m12);
	}
	if (globals_list_len_m12 == 0)
		globals->_id = PROC_getpid_m12();    // use process id for first entry, so threads without their own globals can share
	else
		globals->_id = PROC_gettid_m12();    // use thread id for subsequent entries - thread local
	globals_list_m12[globals_list_len_m12++] = globals;
	PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12);
	
	// initialize new globals mutices
	PROC_pthread_mutex_init_m12(&globals->behavior_mutex, NULL);

	// AT (do this as soon as possible)
#ifdef AT_DEBUG_m12
	PROC_pthread_mutex_init_m12(&globals->AT_mutex, NULL);
	#ifdef MATLAB_PERSISTENT_m12
		globals->AT_nodes = (AT_NODE *) mxCalloc((mwSize) GLOBALS_AT_LIST_SIZE_INCREMENT_m12, (mwSize) sizeof(AT_NODE));
	#else
		globals->AT_nodes = (AT_NODE *) calloc((size_t) GLOBALS_AT_LIST_SIZE_INCREMENT_m12, sizeof(AT_NODE));
	#endif
		if (globals->AT_nodes == NULL) {
			printf_m12("%s(): calloc failure for AT list => exiting\n", __FUNCTION__);
			exit(-1);
		}
		globals->AT_node_count = GLOBALS_AT_LIST_SIZE_INCREMENT_m12;
		globals->AT_used_node_count = 0;
#endif
	
	// password structure
	memset((void *) &globals->password_data, 0, sizeof(PASSWORD_DATA_m12));
	
	// record filters
	globals->record_filters = NULL;
	
	// current session constants
	globals->session_UID = UID_NO_ENTRY_m12;
	*globals->session_directory = 0;
	globals->session_start_time = GLOBALS_SESSION_START_TIME_DEFAULT_m12;
	globals->session_end_time = GLOBALS_SESSION_END_TIME_DEFAULT_m12;
	globals->session_name = NULL;
	*globals->uh_session_name = 0;
	*globals->fs_session_name = 0;
	globals->session_start_time = UUTC_NO_ENTRY_m12;
	globals->session_end_time = UUTC_NO_ENTRY_m12;
	globals->number_of_session_samples = SAMPLE_NUMBER_NO_ENTRY_m12;  // == number_of_session_frames
	globals->number_of_session_segments = SEGMENT_NUMBER_NO_ENTRY_m12;
	globals->number_of_mapped_segments = SEGMENT_NUMBER_NO_ENTRY_m12;
	globals->reference_channel = NULL;
	*globals->reference_channel_name = 0;
	
	// active channel constants
	globals->time_series_frequencies_vary = UNKNOWN_m12;
	globals->minimum_time_series_frequency = FREQUENCY_NO_ENTRY_m12;
	globals->maximum_time_series_frequency = FREQUENCY_NO_ENTRY_m12;
	globals->minimum_time_series_frequency_channel = NULL;
	globals->maximum_time_series_frequency_channel = NULL;
	globals->video_frame_rates_vary = UNKNOWN_m12;;
	globals->minimum_video_frame_rate = FREQUENCY_NO_ENTRY_m12;
	globals->maximum_video_frame_rate = FREQUENCY_NO_ENTRY_m12;
	globals->minimum_video_frame_rate_channel = NULL;
	globals->maximum_video_frame_rate_channel = NULL;

	// time constants
	globals->time_constants_set = FALSE_m12;
	globals->RTO_known = GLOBALS_RTO_KNOWN_DEFAULT_m12;
	globals->observe_DST = GLOBALS_OBSERVE_DST_DEFAULT_m12;
	globals->recording_time_offset = GLOBALS_RECORDING_TIME_OFFSET_DEFAULT_m12;
	globals->standard_UTC_offset = GLOBALS_STANDARD_UTC_OFFSET_DEFAULT_m12;
	globals->daylight_time_start_code.value = DTCC_VALUE_NO_ENTRY_m12;
	globals->daylight_time_end_code.value = DTCC_VALUE_NO_ENTRY_m12;
	strcpy(globals->standard_timezone_acronym, GLOBALS_STANDARD_TIMEZONE_ACRONYM_DEFAULT_m12);
	strcpy(globals->standard_timezone_string, GLOBALS_STANDARD_TIMEZONE_STRING_DEFAULT_m12);
	strcpy(globals->daylight_timezone_acronym, GLOBALS_DAYLIGHT_TIMEZONE_ACRONYM_DEFAULT_m12);
	strcpy(globals->daylight_timezone_string, GLOBALS_DAYLIGHT_TIMEZONE_STRING_DEFAULT_m12);
	
	// alignment fields
	globals->universal_header_aligned = UNKNOWN_m12;
	globals->metadata_section_1_aligned = UNKNOWN_m12;
	globals->time_series_metadata_section_2_aligned = UNKNOWN_m12;
	globals->video_metadata_section_2_aligned = UNKNOWN_m12;
	globals->metadata_section_3_aligned = UNKNOWN_m12;
	globals->all_metadata_structures_aligned = UNKNOWN_m12;
	globals->time_series_indices_aligned = UNKNOWN_m12;
	globals->video_indices_aligned = UNKNOWN_m12;
	globals->CMP_block_header_aligned = UNKNOWN_m12;
	globals->CMP_record_header_aligned = UNKNOWN_m12;
	globals->record_header_aligned = UNKNOWN_m12;
	globals->record_indices_aligned = UNKNOWN_m12;
	globals->all_record_structures_aligned = UNKNOWN_m12;
	globals->all_structures_aligned = UNKNOWN_m12;
	globals->transmission_header_aligned = UNKNOWN_m12;

	// errors
	globals->err_code = E_NO_ERR_m12;
	globals->err_func = NULL;
	globals->err_line = 0;

	// miscellaneous
	globals->verbose = GLOBALS_VERBOSE_DEFAULT_m12;
	globals->file_creation_umask = GLOBALS_FILE_CREATION_UMASK_DEFAULT_m12;
	globals->behavior_on_fail = GLOBALS_BEHAVIOR_ON_FAIL_DEFAULT_m12;
	if (globals->behavior_stack != NULL) {
		free_m12((void *) globals->behavior_stack, __FUNCTION__);
		globals->behavior_stack = NULL;
	}
	globals->behavior_stack_entries = globals->behavior_stack_size = 0;
	#if defined MACOS_m12 || defined LINUX_m12
	strcpy(globals->temp_dir, "/tmp");
	strcpy(globals->temp_file, "/tmp/junk");
	#endif
	#ifdef WINDOWS_m12
	si8	len;
	
	GetTempPathA(FULL_FILE_NAME_BYTES_m12, globals->temp_dir);
	sprintf(globals->temp_file, "%sjunk", globals->temp_dir);
	len = strlen(globals->temp_dir);
	globals->temp_dir[len] = 0;  // remove trailing '\'
	#endif
	globals->level_header_flags = LH_NO_FLAGS_m12;
	globals->mmap_block_bytes = GLOBALS_MMAP_BLOCK_BYTES_NO_ENTRY_m12;
	
	// tables
	if (global_tables_m12 == NULL)
		G_initialize_global_tables_m12(initialize_all_tables);
				
#ifdef AT_DEBUG_m12  // do this at end, because message() will load UTF8 tables
	printf_m12("%s(): %sAllocation tracking debug mode enabled%s\n", __FUNCTION__, TC_GREEN_m12, TC_RESET_m12);
#endif

	PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12);

	return(TRUE_m12);
}


TERN_m12	G_initialize_medlib_m12(TERN_m12 check_structure_alignments, TERN_m12 initialize_all_tables)
{
	TERN_m12	ret_val = TRUE_m12;

#ifdef FN_DEBUG_m12  // don't use MED print functions until UTF8 tables initialized
	printf_m12("%s()\n", __FUNCTION__);
#endif

	// set up globals
	if (globals_m12 == NULL) {
		if (G_initialize_globals_m12(initialize_all_tables) == FALSE_m12) {
			printf_m12("%s(): error initializing globals\n", __FUNCTION__);
			exit_m12(-1);
		}
	}
	
#if defined FN_DEBUG_m12 || defined AT_DEBUG_m12  // need UTF8 tables for G_message_m12()
	if (global_tables_m12->UTF8_offsets_table == NULL) {
		if (UTF8_initialize_tables_m12() == FALSE_m12)
			ret_val = FALSE_m12;
	}
#endif
	
	// check cpu endianness
	if (global_tables_m12->HW_params.endianness != LITTLE_ENDIAN_m12) {
		G_error_message_m12("%s(): Library only coded for little-endian machines currently\n", __FUNCTION__);
		exit_m12(-1);
	}
	
	// check "char" type
	if (G_check_char_type_m12() == FALSE_m12) {
		G_error_message_m12("%s(): Library only coded for 8-bit signed chars currently\n", __FUNCTION__);
		exit_m12(-1);
	}

	// check structure alignments
	if (check_structure_alignments == TRUE_m12)
		if (ALCK_all_m12() == FALSE_m12)
			ret_val = FALSE_m12;
	
	// umask
#if defined MACOS_m12 || defined LINUX_m12
	umask(globals_m12->file_creation_umask);
#endif
#ifdef WINDOWS_m12
	_umask(globals_m12->file_creation_umask);
#endif
		
	// seed random number generator
#if defined MACOS_m12 || defined LINUX_m12
	srandom((ui4) time(NULL));
#endif
#ifdef WINDOWS_m12
	srand((ui4) time(NULL));
#endif
	
#if defined WINDOWS_m12 && defined NEED_WIN_SOCKETS_m12
	// initialize Windows sockets DLL
	if (WN_socket_startup_m12() == FALSE_m12)
		ret_val = FALSE_m12;
#endif
	
#if defined WINDOWS_m12 && !defined MATLAB_m12
	// initialize Windows terminal
	if (WN_initialize_terminal_m12() == FALSE_m12)
		ret_val = FALSE_m12;
#endif
		
	return(ret_val);
}


void	G_initialize_metadata_m12(FILE_PROCESSING_STRUCT_m12 *fps, TERN_m12 initialize_for_update)
{
	METADATA_SECTION_1_m12			*md1;
	TIME_SERIES_METADATA_SECTION_2_m12	*tmd2;
	VIDEO_METADATA_SECTION_2_m12		*vmd2;
	METADATA_SECTION_3_m12			*md3;
	UNIVERSAL_HEADER_m12			*uh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	

	// shortcuts
	md1 = &fps->metadata->section_1;
	tmd2 = &fps->metadata->time_series_section_2;
	vmd2 = &fps->metadata->video_section_2;
	md3 = &fps->metadata->section_3;
	uh = fps->universal_header;
	
	// section 1 fields
	md1->section_2_encryption_level = METADATA_SECTION_2_ENCRYPTION_LEVEL_DEFAULT_m12;
	md1->section_3_encryption_level = METADATA_SECTION_3_ENCRYPTION_LEVEL_DEFAULT_m12;
	md1->time_series_data_encryption_level = METADATA_TIME_SERIES_DATA_ENCRYPTION_LEVEL_DEFAULT_m12;
	
	// section 2 fields
	
	// type independent fields
	memset(tmd2->session_description, 0, METADATA_SESSION_DESCRIPTION_BYTES_m12);
	memset(tmd2->channel_description, 0, METADATA_CHANNEL_DESCRIPTION_BYTES_m12);
	memset(tmd2->segment_description, 0, METADATA_SEGMENT_DESCRIPTION_BYTES_m12);
	memset(tmd2->equipment_description, 0, METADATA_EQUIPMENT_DESCRIPTION_BYTES_m12);
	tmd2->acquisition_channel_number = METADATA_ACQUISITION_CHANNEL_NUMBER_NO_ENTRY_m12;
	
	// type specific fields
	switch (uh->type_code) {
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
			tmd2->sampling_frequency = TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12;
			tmd2->low_frequency_filter_setting = TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12;
			tmd2->high_frequency_filter_setting = TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12;
			tmd2->notch_filter_frequency_setting = TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12;
			tmd2->AC_line_frequency = TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12;
			tmd2->amplitude_units_conversion_factor = TIME_SERIES_METADATA_AMPLITUDE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m12;
			tmd2->time_base_units_conversion_factor = TIME_SERIES_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m12;
			tmd2->absolute_start_sample_number = TIME_SERIES_METADATA_ABSOLUTE_START_SAMPLE_NUMBER_NO_ENTRY_m12;
			if (initialize_for_update == TRUE_m12) {
				tmd2->number_of_samples = 0;
				tmd2->number_of_blocks = 0;
				tmd2->maximum_block_bytes = 0;
				tmd2->maximum_block_samples = 0;
				tmd2->maximum_block_keysample_bytes = 0;
				tmd2->maximum_block_duration = 0.0;
				tmd2->number_of_discontinuities = 0;
				tmd2->maximum_contiguous_blocks = 0;
				tmd2->maximum_contiguous_block_bytes = 0;
				tmd2->maximum_contiguous_samples = 0;
			} else {
				tmd2->number_of_samples = TIME_SERIES_METADATA_NUMBER_OF_SAMPLES_NO_ENTRY_m12;
				tmd2->number_of_blocks = TIME_SERIES_METADATA_NUMBER_OF_BLOCKS_NO_ENTRY_m12;
				tmd2->maximum_block_bytes = TIME_SERIES_METADATA_MAXIMUM_BLOCK_BYTES_NO_ENTRY_m12;
				tmd2->maximum_block_samples = TIME_SERIES_METADATA_MAXIMUM_BLOCK_SAMPLES_NO_ENTRY_m12;
				tmd2->maximum_block_keysample_bytes = TIME_SERIES_METADATA_MAXIMUM_BLOCK_KEYSAMPLE_BYTES_NO_ENTRY_m12;
				tmd2->maximum_block_duration = TIME_SERIES_METADATA_MAXIMUM_BLOCK_DURATION_NO_ENTRY_m12;
				tmd2->number_of_discontinuities = TIME_SERIES_METADATA_NUMBER_OF_DISCONTINUITIES_NO_ENTRY_m12;
				tmd2->maximum_contiguous_blocks = TIME_SERIES_METADATA_MAXIMUM_CONTIGUOUS_BLOCKS_NO_ENTRY_m12;
				tmd2->maximum_contiguous_block_bytes = TIME_SERIES_METADATA_MAXIMUM_CONTIGUOUS_BLOCK_BYTES_NO_ENTRY_m12;
				tmd2->maximum_contiguous_samples = TIME_SERIES_METADATA_MAXIMUM_CONTIGUOUS_SAMPLES_NO_ENTRY_m12;
			}
			break;
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
			vmd2->time_base_units_conversion_factor = VIDEO_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m12;
			vmd2->absolute_start_frame_number = VIDEO_METADATA_ABSOLUTE_START_FRAME_NUMBER_NO_ENTRY_m12;
			vmd2->frame_rate = VIDEO_METADATA_FRAME_RATE_NO_ENTRY_m12;
			vmd2->horizontal_pixels = VIDEO_METADATA_HORIZONTAL_PIXELS_NO_ENTRY_m12;
			vmd2->vertical_pixels = VIDEO_METADATA_VERTICAL_PIXELS_NO_ENTRY_m12;
			if (initialize_for_update == TRUE_m12) {
				vmd2->number_of_frames = 0;
				vmd2->number_of_clips = 0;
				vmd2->maximum_clip_bytes = 0;
				vmd2->maximum_clip_frames = 0;
				vmd2->number_of_video_files = 0;
				vmd2->maximum_clip_duration = 0.0;
				vmd2->number_of_discontinuities = 0;
				vmd2->maximum_contiguous_clips = 0;
				vmd2->maximum_contiguous_clip_bytes = 0;
				vmd2->maximum_contiguous_frames = 0;
			} else {
				vmd2->number_of_frames = VIDEO_METADATA_NUMBER_OF_FRAMES_NO_ENTRY_m12;
				vmd2->number_of_clips = VIDEO_METADATA_NUMBER_OF_CLIPS_NO_ENTRY_m12;
				vmd2->maximum_clip_bytes = VIDEO_METADATA_MAXIMUM_CLIP_BYTES_NO_ENTRY_m12;
				vmd2->maximum_clip_frames = VIDEO_METADATA_MAXIMUM_CLIP_FRAMES_NO_ENTRY_m12;
				vmd2->number_of_video_files = VIDEO_METADATA_NUMBER_OF_VIDEO_FILES_NO_ENTRY_m12;
				vmd2->maximum_clip_duration = VIDEO_METADATA_MAXIMUM_CLIP_DURATION_NO_ENTRY_m12;
				vmd2->number_of_discontinuities = VIDEO_METADATA_NUMBER_OF_DISCONTINUITIES_NO_ENTRY_m12;
				vmd2->maximum_contiguous_clips = VIDEO_METADATA_MAXIMUM_CONTIGUOUS_CLIPS_NO_ENTRY_m12;
				vmd2->maximum_contiguous_clip_bytes = VIDEO_METADATA_MAXIMUM_CONTIGUOUS_CLIP_BYTES_NO_ENTRY_m12;
				vmd2->maximum_contiguous_frames = VIDEO_METADATA_MAXIMUM_CONTIGUOUS_FRAMES_NO_ENTRY_m12;
			}
			break;
		default:
			G_error_message_m12("%s(): Unrecognized METADATA SECTION 2 type in file \"%s\"\n", __FUNCTION__, fps->full_file_name);
			break;
	}
	
	// section 3 fields
	md3->recording_time_offset = globals_m12->recording_time_offset;
	md3->daylight_time_start_code = globals_m12->daylight_time_start_code;
	md3->daylight_time_end_code = globals_m12->daylight_time_end_code;
	strncpy_m12(md3->standard_timezone_acronym, globals_m12->standard_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m12);
	strncpy_m12(md3->standard_timezone_string, globals_m12->standard_timezone_string, TIMEZONE_STRING_BYTES_m12);
	strncpy_m12(md3->daylight_timezone_acronym, globals_m12->daylight_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m12);
	strncpy_m12(md3->daylight_timezone_string, globals_m12->daylight_timezone_string, TIMEZONE_STRING_BYTES_m12);
	memset(md3->subject_name_1, 0, METADATA_SUBJECT_NAME_BYTES_m12);
	memset(md3->subject_name_2, 0, METADATA_SUBJECT_NAME_BYTES_m12);
	memset(md3->subject_name_3, 0, METADATA_SUBJECT_NAME_BYTES_m12);
	memset(md3->subject_ID, 0, METADATA_SUBJECT_ID_BYTES_m12);
	memset(md3->recording_country, 0, METADATA_RECORDING_LOCATION_BYTES_m12);
	memset(md3->recording_territory, 0, METADATA_RECORDING_LOCATION_BYTES_m12);
	memset(md3->recording_locality, 0, METADATA_RECORDING_LOCATION_BYTES_m12);
	memset(md3->recording_institution, 0, METADATA_RECORDING_LOCATION_BYTES_m12);
	memset(md3->geotag_format, 0, METADATA_GEOTAG_FORMAT_BYTES_m12);
	memset(md3->geotag_data, 0, METADATA_GEOTAG_DATA_BYTES_m12);
	md3->standard_UTC_offset = globals_m12->standard_UTC_offset;
	
	return;
}


TIME_SLICE_m12	*G_initialize_time_slice_m12(TIME_SLICE_m12 *slice)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// NOTE: also initializes for frame numbers (via unions)
	
	if (slice == NULL)  // caller responsible for freeing
		slice = (TIME_SLICE_m12 *) malloc_m12(sizeof(TIME_SLICE_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	slice->conditioned = FALSE_m12;
	slice->number_of_segments = UNKNOWN_m12;  // number_of_segments == 0
	slice->start_time = slice->end_time = UUTC_NO_ENTRY_m12;
	slice->start_sample_number = slice->end_sample_number = SAMPLE_NUMBER_NO_ENTRY_m12;
	slice->start_segment_number = slice->end_segment_number = SEGMENT_NUMBER_NO_ENTRY_m12;

	return(slice);
}


TERN_m12	G_initialize_timezone_tables_m12(void)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (global_tables_m12->timezone_table != NULL)
		return(TRUE_m12);

	PROC_pthread_mutex_lock_m12(&global_tables_m12->TZ_mutex);
	if (global_tables_m12->timezone_table != NULL) {  // may have been done by another thread while waiting
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->TZ_mutex);
		return(TRUE_m12);
	}
	
	// timezone table
	if (global_tables_m12->timezone_table == NULL) {
#ifdef MATLAB_PERSISTENT_m12
		global_tables_m12->timezone_table = (TIMEZONE_INFO_m12 *) mxCalloc((mwSize) TZ_TABLE_ENTRIES_m12, (mwSize) sizeof(TIMEZONE_INFO_m12));
#else
		global_tables_m12->timezone_table = (TIMEZONE_INFO_m12 *) calloc((size_t) TZ_TABLE_ENTRIES_m12, sizeof(TIMEZONE_INFO_m12));
#endif
		{
			TIMEZONE_INFO_m12 temp[TZ_TABLE_ENTRIES_m12] = TZ_TABLE_m12;
			memcpy(global_tables_m12->timezone_table, temp, TZ_TABLE_ENTRIES_m12 * sizeof(TIMEZONE_INFO_m12));
		}
	}

	// country aliases
	if (global_tables_m12->country_aliases_table == NULL) {
#ifdef MATLAB_PERSISTENT_m12
		global_tables_m12->country_aliases_table = (TIMEZONE_ALIAS_m12 *) mxCalloc((mwSize) TZ_COUNTRY_ALIASES_ENTRIES_m12, (mwSize) sizeof(TIMEZONE_ALIAS_m12));
#else
		global_tables_m12->country_aliases_table = (TIMEZONE_ALIAS_m12 *) calloc((size_t) TZ_COUNTRY_ALIASES_ENTRIES_m12, sizeof(TIMEZONE_ALIAS_m12));
#endif
		{
			TIMEZONE_ALIAS_m12 temp[TZ_COUNTRY_ALIASES_ENTRIES_m12] = TZ_COUNTRY_ALIASES_TABLE_m12;
			memcpy(global_tables_m12->country_aliases_table, temp, TZ_COUNTRY_ALIASES_ENTRIES_m12 * sizeof(TIMEZONE_ALIAS_m12));
		}
	}

	// country acronym aliases
	if (global_tables_m12->country_acronym_aliases_table == NULL) {
#ifdef MATLAB_PERSISTENT_m12
		global_tables_m12->country_acronym_aliases_table = (TIMEZONE_ALIAS_m12 *) mxCalloc((mwSize) TZ_COUNTRY_ACRONYM_ALIASES_ENTRIES_m12, (mwSize) sizeof(TIMEZONE_ALIAS_m12));
#else
		global_tables_m12->country_acronym_aliases_table = (TIMEZONE_ALIAS_m12 *) calloc((size_t) TZ_COUNTRY_ACRONYM_ALIASES_ENTRIES_m12, sizeof(TIMEZONE_ALIAS_m12));
#endif
		{
			TIMEZONE_ALIAS_m12 temp[TZ_COUNTRY_ACRONYM_ALIASES_ENTRIES_m12] = TZ_COUNTRY_ACRONYM_ALIASES_TABLE_m12;
			memcpy(global_tables_m12->country_acronym_aliases_table, temp, TZ_COUNTRY_ACRONYM_ALIASES_ENTRIES_m12 * sizeof(TIMEZONE_ALIAS_m12));
		}
	}

	PROC_pthread_mutex_unlock_m12(&global_tables_m12->TZ_mutex);

	return(TRUE_m12);
}


void	G_initialize_universal_header_m12(FILE_PROCESSING_STRUCT_m12 *fps, ui4 type_code, TERN_m12 generate_file_UID, TERN_m12 originating_file)
{
	UNIVERSAL_HEADER_m12	*uh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	uh = fps->universal_header;
	
	uh->header_CRC = uh->body_CRC = CRC_START_VALUE_m12;
	uh->segment_number = UNIVERSAL_HEADER_SEGMENT_NUMBER_NO_ENTRY_m12;
	uh->type_code = type_code;
	uh->MED_version_major = MED_FORMAT_VERSION_MAJOR_m12;
	uh->MED_version_minor = MED_FORMAT_VERSION_MINOR_m12;
	uh->byte_order_code = LITTLE_ENDIAN_m12;
	uh->session_start_time = UUTC_NO_ENTRY_m12;
	uh->segment_start_time = UUTC_NO_ENTRY_m12;
	uh->segment_end_time = UUTC_NO_ENTRY_m12;
	uh->number_of_entries = 0;
	uh->maximum_entry_size = 0;
	
	if (generate_file_UID == TRUE_m12)
		G_generate_UID_m12(&uh->file_UID);
	if (originating_file == TRUE_m12)
		uh->provenance_UID = uh->file_UID;
	
	return;
}


si8	G_items_for_bytes_m12(FILE_PROCESSING_STRUCT_m12 *fps, si8 *number_of_bytes)
{
	si8				items, bytes;
	ui4				entry_size;
	UNIVERSAL_HEADER_m12		*uh;
	RECORD_HEADER_m12		*rh;
	CMP_BLOCK_FIXED_HEADER_m12	*bh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	items = 0;
	uh = fps->universal_header;
	switch (uh->type_code) {
		case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
		case VIDEO_INDICES_FILE_TYPE_CODE_m12:
		case RECORD_INDICES_FILE_TYPE_CODE_m12:
			items = *number_of_bytes / INDEX_BYTES_m12;
			uh->maximum_entry_size = INDEX_BYTES_m12;
			return(items);
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
			items = 1;
			*number_of_bytes = METADATA_BYTES_m12;
			uh->maximum_entry_size = METADATA_BYTES_m12;
			return(items);
	}
	
	switch (uh->type_code) {
		case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
			bh = fps->parameters.cps->block_header;
			for (bytes = 0; bytes < *number_of_bytes; ++items) {
				entry_size = bh->total_block_bytes;
				if (uh->maximum_entry_size < entry_size)  // caller should've done this, but just in case
					uh->maximum_entry_size = entry_size;
				bytes += (si8) entry_size;
				bh = (CMP_BLOCK_FIXED_HEADER_m12 *) ((ui1 *) bh + (si8) entry_size);
			}
			break;
		case RECORD_DATA_FILE_TYPE_CODE_m12:
			rh = (RECORD_HEADER_m12 *) fps->record_data;
			for (bytes = 0; bytes < *number_of_bytes; ++items) {
				entry_size = rh->total_record_bytes;
				if (uh->maximum_entry_size < entry_size)  // caller should've done this, but just in case
					uh->maximum_entry_size = entry_size;
				bytes += (si8) entry_size;
				rh = (RECORD_HEADER_m12 *) ((ui1 *) rh + (si8) entry_size);
			}
	}
	*number_of_bytes = bytes;
	
	return(items);
}


ui4	G_level_from_base_name_m12(si1 *path, si1 *level_path)
{
	si1	tmp_path[FULL_FILE_NAME_BYTES_m12], tmp_path2[FULL_FILE_NAME_BYTES_m12];
	ui4	level;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns level type code, or NO_TYPE_CODE_m12 on error
	
	// assumes level_path has adequate space for new path
	
	// if level_path == NULL : return type code on level_path, do not modify path
	// if level_path == path : return type code on level_path, do modify path
	// if level_path != path && level_path != NULL : return type code on level_path, return modified path in level_path, leaving path unmodified
	
	if (path == NULL)
		return(NO_TYPE_CODE_m12);
	
	// don't handle regex strings
	if (STR_contains_regex_m12(path) == TRUE_m12)
		return(NO_TYPE_CODE_m12);
	
	// get path from root
	G_path_from_root_m12(path, tmp_path);
	
	// see if it already has a level
	level = G_get_level_m12(tmp_path, NULL);
	if (level != NO_TYPE_CODE_m12) {
		if (level_path != NULL)
			strcpy(level_path, tmp_path);
		return(level);
	}
	
	// try session level
	sprintf_m12(tmp_path2, "%s.%s", tmp_path, SESSION_DIRECTORY_TYPE_STRING_m12);
	if (G_file_exists_m12(tmp_path2) == DIR_EXISTS_m12) {
		if (level_path != NULL)
			strcpy(level_path, tmp_path2);
		return(LH_SESSION_m12);
	}
	
	// try time series channel level
	sprintf_m12(tmp_path2, "%s.%s", tmp_path, TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12);
	if (G_file_exists_m12(tmp_path2) == DIR_EXISTS_m12) {
		if (level_path != NULL)
			strcpy(level_path, tmp_path2);
		return(LH_TIME_SERIES_CHANNEL_m12);
	}

	// try video channel level
	sprintf_m12(tmp_path2, "%s.%s", tmp_path, VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12);
	if (G_file_exists_m12(tmp_path2) == DIR_EXISTS_m12) {
		if (level_path != NULL)
			strcpy(level_path, tmp_path2);
		return(LH_VIDEO_CHANNEL_m12);
	}

	// try time series segment level
	sprintf_m12(tmp_path2, "%s.%s", tmp_path, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12);
	if (G_file_exists_m12(tmp_path2) == DIR_EXISTS_m12) {
		if (level_path != NULL)
			strcpy(level_path, tmp_path2);
		return(LH_TIME_SERIES_SEGMENT_m12);
	}

	// try video segment level
	sprintf_m12(tmp_path2, "%s.%s", tmp_path, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12);
	if (G_file_exists_m12(tmp_path2) == DIR_EXISTS_m12) {
		if (level_path != NULL)
			strcpy(level_path, tmp_path2);
		return(LH_VIDEO_SEGMENT_m12);
	}
	
	// doesn't exist
	if (level_path != NULL)
		if (level_path != path)
			*level_path = 0;

	return(NO_TYPE_CODE_m12);
}


void	G_lh_set_directives_m12(si1 *full_file_name, ui8 lh_flags, TERN_m12 *mmap_flag, TERN_m12 *close_flag, si8 *number_of_items)
{
	TERN_m12	read_flag, read_full_flag, tmp_mmap_flag;
	ui4		level_code, type_code;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if ((lh_flags & (LH_ALL_READ_FLAGS_MASK_m12 | LH_ALL_MEM_MAP_FLAGS_MASK_m12)) == 0)
		return;
	
	level_code = G_get_level_m12(full_file_name, &type_code);
	
	// all record types
	if (type_code == RECORD_DATA_FILE_TYPE_CODE_m12 || type_code == RECORD_INDICES_FILE_TYPE_CODE_m12) {
		read_flag = read_full_flag = tmp_mmap_flag = FALSE_m12;
		switch (level_code) {
			case LH_SESSION_m12:
				if (lh_flags & LH_READ_SLICE_SESSION_RECORDS_m12)
					read_flag = TRUE_m12;
				else if (lh_flags & LH_READ_FULL_SESSION_RECORDS_m12)
					read_full_flag = TRUE_m12;
				if (lh_flags & LH_MEM_MAP_SESSION_RECORDS_m12)
					tmp_mmap_flag = TRUE_m12;
				break;
			case LH_SEGMENTED_SESS_RECS_m12:
				if (lh_flags & LH_READ_SLICE_SEGMENTED_SESS_RECS_m12)
					read_flag = TRUE_m12;
				else if (lh_flags & LH_READ_FULL_SEGMENTED_SESS_RECS_m12)
					read_full_flag = TRUE_m12;
				if (lh_flags & LH_MEM_MAP_SEGMENTED_SESS_RECS_m12)
					tmp_mmap_flag = TRUE_m12;
				break;
			case LH_TIME_SERIES_CHANNEL_m12:
			case LH_VIDEO_CHANNEL_m12:
				if (lh_flags & LH_READ_SLICE_CHANNEL_RECORDS_m12)
					read_flag = TRUE_m12;
				else if (lh_flags & LH_READ_FULL_CHANNEL_RECORDS_m12)
					read_full_flag = TRUE_m12;
				if (lh_flags & LH_MEM_MAP_CHANNEL_RECORDS_m12)
					tmp_mmap_flag = TRUE_m12;
				break;
			case LH_TIME_SERIES_SEGMENT_m12:
			case LH_VIDEO_SEGMENT_m12:
				if (lh_flags & LH_READ_SLICE_SEGMENT_RECORDS_m12)
					read_flag = TRUE_m12;
				else if (lh_flags & LH_READ_FULL_SEGMENT_RECORDS_m12)
					read_full_flag = TRUE_m12;
				if (lh_flags & LH_MEM_MAP_SEGMENT_RECORDS_m12)
					tmp_mmap_flag = TRUE_m12;
				break;
		}
		if (type_code == RECORD_INDICES_FILE_TYPE_CODE_m12) {
			if (read_flag == TRUE_m12 || read_full_flag == TRUE_m12) {
				*number_of_items = FPS_FULL_FILE_m12;
				*close_flag = TRUE_m12;
				*mmap_flag = FALSE_m12;
			}
		} else if (type_code == RECORD_DATA_FILE_TYPE_CODE_m12) {
			if (read_flag == TRUE_m12) {
				*number_of_items = FPS_UNIVERSAL_HEADER_ONLY_m12;
				*close_flag = FALSE_m12;
				if (tmp_mmap_flag == TRUE_m12)
					*mmap_flag = TRUE_m12;
				else
					*mmap_flag = FALSE_m12;
			} else if (read_full_flag == TRUE_m12) {
				*number_of_items = FPS_FULL_FILE_m12;
				*close_flag = TRUE_m12;
				*mmap_flag = FALSE_m12;
			}
		}
	}
	
	// segment data types
	else if (level_code == LH_TIME_SERIES_SEGMENT_m12 || level_code == LH_VIDEO_SEGMENT_m12) {
		switch (type_code) {
			case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
			case VIDEO_INDICES_FILE_TYPE_CODE_m12:
				if (lh_flags & LH_READ_SEGMENT_DATA_MASK_m12) {
					*number_of_items = FPS_FULL_FILE_m12;
					*close_flag = TRUE_m12;
					*mmap_flag = FALSE_m12;
				}
				break;
			case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
				if (lh_flags & LH_READ_SLICE_SEGMENT_DATA_m12) {
					*number_of_items = FPS_UNIVERSAL_HEADER_ONLY_m12;
					*close_flag = FALSE_m12;
					if (lh_flags & LH_MEM_MAP_SEGMENT_DATA_m12)
						*mmap_flag = TRUE_m12;
					else
						*mmap_flag = FALSE_m12;
				} else if (lh_flags & LH_READ_FULL_SEGMENT_DATA_m12) {
					*number_of_items = FPS_FULL_FILE_m12;
					*close_flag = TRUE_m12;
					*mmap_flag = FALSE_m12;
				}
				break;
			case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
			case VIDEO_METADATA_FILE_TYPE_CODE_m12:
				if (lh_flags & LH_READ_SEGMENT_DATA_MASK_m12) {
					*number_of_items = FPS_FULL_FILE_m12;
					*close_flag = TRUE_m12;
					*mmap_flag = FALSE_m12;
				}
				break;
		}
	}
	
	return;
}
		    
		    
si1	*G_MED_type_string_from_code_m12(ui4 code)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// could have written this differently, since the string bytes are the code bytes, just NULL terminated
	// but would've required accounting for endianness, and handling thread safety
	
	switch (code) {
		case NO_FILE_TYPE_CODE_m12:
			return NO_FILE_TYPE_STRING_m12;
		case SESSION_DIRECTORY_TYPE_CODE_m12:
			return SESSION_DIRECTORY_TYPE_STRING_m12;
		case TIME_SERIES_SEGMENT_DIRECTORY_TYPE_CODE_m12:
			return TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12;
		case VIDEO_SEGMENT_DIRECTORY_TYPE_CODE_m12:
			return VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12;
		case RECORD_DIRECTORY_TYPE_CODE_m12:
			return RECORD_DIRECTORY_TYPE_STRING_m12;
		case RECORD_DATA_FILE_TYPE_CODE_m12:
			return RECORD_DATA_FILE_TYPE_STRING_m12;
		case RECORD_INDICES_FILE_TYPE_CODE_m12:
			return RECORD_INDICES_FILE_TYPE_STRING_m12;
		case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:
			return VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12;
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
			return VIDEO_METADATA_FILE_TYPE_STRING_m12;
		case VIDEO_INDICES_FILE_TYPE_CODE_m12:
			return VIDEO_INDICES_FILE_TYPE_STRING_m12;
		case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
			return TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12;
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
			return TIME_SERIES_METADATA_FILE_TYPE_STRING_m12;
		case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
			return TIME_SERIES_DATA_FILE_TYPE_STRING_m12;
		case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
			return TIME_SERIES_INDICES_FILE_TYPE_STRING_m12;
	}
	
	G_warning_message_m12("%s(): 0x%08x is not a recognized MED file type code\n", __FUNCTION__, code);

	return(NULL);
}


ui4     G_MED_type_code_from_string_m12(si1 *string)
{
	ui4     code;
	si4     len;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (string == NULL) {
		G_warning_message_m12("%s(): string is NULL\n", __FUNCTION__);
		return(NO_FILE_TYPE_CODE_m12);
	}
	
	// remove quotes if present
	if (*string == '"') {
		si1	tmp_str[FULL_FILE_NAME_BYTES_m12];
		
		strcpy(tmp_str, string);
		STR_strip_character_m12(tmp_str, '"');
		string = tmp_str;
	}

	len = (si4) strlen(string);
	
#if defined MACOS_m12 || defined LINUX_m12
	if (string[len - 1] == '/')
		--len;
#endif
#ifdef WINDOWS_m12
	if (string[len - 1] == '\\')
		--len;
#endif
	if (len < 5) {
		if (len != 4)
			return(NO_FILE_TYPE_CODE_m12);
	} else {
		string += (len - 5);
		if (*string++ != '.')
			return(NO_FILE_TYPE_CODE_m12);
	}
	
	memcpy((void *) &code, (void *) string, sizeof(ui4));
	
	switch (code) {
		case NO_FILE_TYPE_CODE_m12:
		case SESSION_DIRECTORY_TYPE_CODE_m12:
		case TIME_SERIES_SEGMENT_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_SEGMENT_DIRECTORY_TYPE_CODE_m12:
		case RECORD_DIRECTORY_TYPE_CODE_m12:
		case RECORD_DATA_FILE_TYPE_CODE_m12:
		case RECORD_INDICES_FILE_TYPE_CODE_m12:
		case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
		case VIDEO_INDICES_FILE_TYPE_CODE_m12:
		case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
		case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
		case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
			return code;
	}
	
	G_warning_message_m12("%s(): \"%s\" is not a recognized MED file type\n", __FUNCTION__, string);
	
	return(NO_FILE_TYPE_CODE_m12);
}



TERN_m12	G_merge_metadata_m12(FILE_PROCESSING_STRUCT_m12 *md_fps_1, FILE_PROCESSING_STRUCT_m12 *md_fps_2, FILE_PROCESSING_STRUCT_m12 *merged_md_fps)
{
	ui4                                     type_code;
	METADATA_SECTION_1_m12			*md1_1, *md1_2, *md1_m;
	TIME_SERIES_METADATA_SECTION_2_m12	*tmd2_1, *tmd2_2, *tmd2_m;
	VIDEO_METADATA_SECTION_2_m12		*vmd2_1, *vmd2_2, *vmd2_m;
	METADATA_SECTION_3_m12			*md3_1, *md3_2, *md3_m;
	TERN_m12                                equal;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// if merged_md_fps == NULL, comparison results will be placed in md_fps_1->metadata
	// returns TRUE_m12 if md_fps_1->metadata == md_fps_2->metadata, FALSE_m12 otherwise

	// decrypt if needed
	md1_1 = &md_fps_1->metadata->section_1;
	if (md1_1->section_2_encryption_level > NO_ENCRYPTION_m12 || md1_1->section_3_encryption_level > NO_ENCRYPTION_m12)
		G_decrypt_metadata_m12(md_fps_1);
	md1_2 = &md_fps_2->metadata->section_1;
	if (md1_2->section_2_encryption_level > NO_ENCRYPTION_m12 || md1_2->section_3_encryption_level > NO_ENCRYPTION_m12)
		G_decrypt_metadata_m12(md_fps_2);
	
	// setup
	if (merged_md_fps == NULL)
		merged_md_fps = md_fps_1;
	else
		memcpy(merged_md_fps->metadata, md_fps_1->metadata, METADATA_BYTES_m12);
	md1_m = &merged_md_fps->metadata->section_1;
	
	type_code = md_fps_1->universal_header->type_code;
	if (type_code != md_fps_2->universal_header->type_code) {
		G_error_message_m12("%s(): mismatched type codes\n", __FUNCTION__);
		return(UNKNOWN_m12);
	}
	
	switch (type_code) {
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
			break;
		default:
			G_error_message_m12("%s(): unrecognized type code 0x%x\n", __FUNCTION__, type_code);
			return(UNKNOWN_m12);
	}
	equal = TRUE_m12;
	
	// section 1
	if (memcmp(md1_1->level_1_password_hint, md1_2->level_1_password_hint, PASSWORD_HINT_BYTES_m12)) {
		memset(md1_m->level_1_password_hint, 0, PASSWORD_HINT_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md1_1->level_2_password_hint, md1_2->level_2_password_hint, PASSWORD_HINT_BYTES_m12)) {
		memset(md1_m->level_2_password_hint, 0, PASSWORD_HINT_BYTES_m12); equal = FALSE_m12;
	}
	if (md1_1->section_2_encryption_level != md1_2->section_2_encryption_level) {
		md1_m->section_2_encryption_level = ENCRYPTION_LEVEL_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (md1_1->section_3_encryption_level != md1_2->section_3_encryption_level) {
		md1_m->section_3_encryption_level = ENCRYPTION_LEVEL_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (memcmp(md1_1->protected_region, md1_2->protected_region, METADATA_SECTION_1_PROTECTED_REGION_BYTES_m12)) {
		memset(md1_m->protected_region, 0, METADATA_SECTION_1_PROTECTED_REGION_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md1_1->discretionary_region, md1_2->discretionary_region, METADATA_SECTION_1_DISCRETIONARY_REGION_BYTES_m12)) {
		memset(md1_m->discretionary_region, 0, METADATA_SECTION_1_DISCRETIONARY_REGION_BYTES_m12); equal = FALSE_m12;
	}
	
	// section 2: time series channel
	if (type_code == TIME_SERIES_METADATA_FILE_TYPE_CODE_m12) {
		tmd2_1 = &md_fps_1->metadata->time_series_section_2;
		tmd2_2 = &md_fps_2->metadata->time_series_section_2;
		tmd2_m = &merged_md_fps->metadata->time_series_section_2;
		if (memcmp(tmd2_1->session_description, tmd2_2->session_description, METADATA_SESSION_DESCRIPTION_BYTES_m12)) {
			memset(tmd2_m->session_description, 0, METADATA_SESSION_DESCRIPTION_BYTES_m12); equal = FALSE_m12;
		}
		if (memcmp(tmd2_1->channel_description, tmd2_2->channel_description, METADATA_CHANNEL_DESCRIPTION_BYTES_m12)) {
			memset(tmd2_m->channel_description, 0, METADATA_CHANNEL_DESCRIPTION_BYTES_m12); equal = FALSE_m12;
		}
		if (memcmp(tmd2_1->segment_description, tmd2_2->segment_description, METADATA_SEGMENT_DESCRIPTION_BYTES_m12)) {
			memset(tmd2_m->segment_description, 0, METADATA_SEGMENT_DESCRIPTION_BYTES_m12); equal = FALSE_m12;
		}
		if (memcmp(tmd2_1->equipment_description, tmd2_2->equipment_description, METADATA_EQUIPMENT_DESCRIPTION_BYTES_m12)) {
			memset(tmd2_m->equipment_description, 0, METADATA_EQUIPMENT_DESCRIPTION_BYTES_m12); equal = FALSE_m12;
		}
		if (tmd2_1->acquisition_channel_number != tmd2_2->acquisition_channel_number) {
			tmd2_m->acquisition_channel_number = METADATA_ACQUISITION_CHANNEL_NUMBER_NO_ENTRY_m12; equal = FALSE_m12;
		}
		if (memcmp(tmd2_1->reference_description, tmd2_2->reference_description, TIME_SERIES_METADATA_REFERENCE_DESCRIPTION_BYTES_m12)) {
			memset(tmd2_m->reference_description, 0, TIME_SERIES_METADATA_REFERENCE_DESCRIPTION_BYTES_m12); equal = FALSE_m12;
		}
		if (tmd2_1->sampling_frequency != tmd2_2->sampling_frequency) {
			if (tmd2_1->sampling_frequency == FREQUENCY_NO_ENTRY_m12 || tmd2_2->sampling_frequency == FREQUENCY_NO_ENTRY_m12)
				tmd2_m->sampling_frequency = FREQUENCY_NO_ENTRY_m12; // no entry supercedes variable frequency
			else
				tmd2_m->sampling_frequency = FREQUENCY_VARIABLE_m12;
			equal = FALSE_m12;
		}
		if (tmd2_1->low_frequency_filter_setting != tmd2_2->low_frequency_filter_setting) {
			tmd2_m->low_frequency_filter_setting = TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12; equal = FALSE_m12;
		}
		if (tmd2_1->high_frequency_filter_setting != tmd2_2->high_frequency_filter_setting) {
			tmd2_m->high_frequency_filter_setting = TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12; equal = FALSE_m12;
		}
		if (tmd2_1->notch_filter_frequency_setting != tmd2_2->notch_filter_frequency_setting) {
			tmd2_m->notch_filter_frequency_setting = TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12; equal = FALSE_m12;
		}
		if (tmd2_1->AC_line_frequency != tmd2_2->AC_line_frequency) {
			tmd2_m->AC_line_frequency = TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12; equal = FALSE_m12;
		}
		if (tmd2_1->amplitude_units_conversion_factor != tmd2_2->amplitude_units_conversion_factor) {
			tmd2_m->amplitude_units_conversion_factor = TIME_SERIES_METADATA_AMPLITUDE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m12; equal = FALSE_m12;
		}
		if (memcmp(tmd2_1->amplitude_units_description, tmd2_2->amplitude_units_description, TIME_SERIES_METADATA_AMPLITUDE_UNITS_DESCRIPTION_BYTES_m12)) {
			memset(tmd2_m->amplitude_units_description, 0, TIME_SERIES_METADATA_AMPLITUDE_UNITS_DESCRIPTION_BYTES_m12); equal = FALSE_m12;
		}
		if (tmd2_1->time_base_units_conversion_factor != tmd2_2->time_base_units_conversion_factor) {
			tmd2_m->time_base_units_conversion_factor = TIME_SERIES_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m12; equal = FALSE_m12;
		}
		if (memcmp(tmd2_1->time_base_units_description, tmd2_2->time_base_units_description, TIME_SERIES_METADATA_TIME_BASE_UNITS_DESCRIPTION_BYTES_m12)) {
			memset(tmd2_m->time_base_units_description, 0, TIME_SERIES_METADATA_TIME_BASE_UNITS_DESCRIPTION_BYTES_m12); equal = FALSE_m12;
		}
		if (tmd2_1->absolute_start_sample_number > tmd2_2->absolute_start_sample_number) {
			tmd2_m->absolute_start_sample_number = tmd2_2->absolute_start_sample_number; equal = FALSE_m12;
		}
		if (tmd2_1->number_of_samples < tmd2_2->number_of_samples) {
			tmd2_m->number_of_samples = tmd2_2->number_of_samples; equal = FALSE_m12;
		}
		if (tmd2_1->number_of_blocks < tmd2_2->number_of_blocks) {
			tmd2_m->number_of_blocks = tmd2_2->number_of_blocks; equal = FALSE_m12;
		}
		if (tmd2_1->maximum_block_bytes < tmd2_2->maximum_block_bytes) {
			tmd2_m->maximum_block_bytes = tmd2_2->maximum_block_bytes; equal = FALSE_m12;
		}
		if (tmd2_1->maximum_block_samples < tmd2_2->maximum_block_samples) {
			tmd2_m->maximum_block_samples = tmd2_2->maximum_block_samples; equal = FALSE_m12;
		}
		if (tmd2_1->maximum_block_keysample_bytes < tmd2_2->maximum_block_keysample_bytes) {
			tmd2_m->maximum_block_keysample_bytes = tmd2_2->maximum_block_keysample_bytes; equal = FALSE_m12;
		}
		if (tmd2_1->maximum_block_duration < tmd2_2->maximum_block_duration) {
			tmd2_m->maximum_block_duration = tmd2_2->maximum_block_duration; equal = FALSE_m12;
		}
		if (tmd2_1->number_of_discontinuities < tmd2_2->number_of_discontinuities) {
			tmd2_m->number_of_discontinuities = tmd2_2->number_of_discontinuities; equal = FALSE_m12;
		}
		if (tmd2_1->maximum_contiguous_blocks < tmd2_2->maximum_contiguous_blocks) {
			tmd2_m->maximum_contiguous_blocks = tmd2_2->maximum_contiguous_blocks; equal = FALSE_m12;
		}
		if (tmd2_1->maximum_contiguous_block_bytes < tmd2_2->maximum_contiguous_block_bytes) {
			tmd2_m->maximum_contiguous_block_bytes = tmd2_2->maximum_contiguous_block_bytes; equal = FALSE_m12;
		}
		if (tmd2_1->maximum_contiguous_samples < tmd2_2->maximum_contiguous_samples) {
			tmd2_m->maximum_contiguous_samples = tmd2_2->maximum_contiguous_samples; equal = FALSE_m12;
		}
		if (memcmp(tmd2_1->protected_region, tmd2_2->protected_region, TIME_SERIES_METADATA_SECTION_2_PROTECTED_REGION_BYTES_m12)) {
			memset(tmd2_m->protected_region, 0, TIME_SERIES_METADATA_SECTION_2_PROTECTED_REGION_BYTES_m12); equal = FALSE_m12;
		}
		if (memcmp(tmd2_1->discretionary_region, tmd2_2->discretionary_region, TIME_SERIES_METADATA_SECTION_2_DISCRETIONARY_REGION_BYTES_m12)) {
			memset(tmd2_m->discretionary_region, 0, TIME_SERIES_METADATA_SECTION_2_DISCRETIONARY_REGION_BYTES_m12); equal = FALSE_m12;
		}
		// end section 2: time series channel
	}
	// section 2: video channel
	else if (type_code == VIDEO_METADATA_FILE_TYPE_CODE_m12) {
		vmd2_1 = &md_fps_1->metadata->video_section_2;
		vmd2_2 = &md_fps_2->metadata->video_section_2;
		vmd2_m = &merged_md_fps->metadata->video_section_2;
		if (memcmp(vmd2_1->session_description, vmd2_2->session_description, METADATA_SESSION_DESCRIPTION_BYTES_m12)) {
			memset(vmd2_m->session_description, 0, METADATA_SESSION_DESCRIPTION_BYTES_m12); equal = FALSE_m12;
		}
		if (memcmp(vmd2_1->channel_description, vmd2_2->channel_description, METADATA_CHANNEL_DESCRIPTION_BYTES_m12)) {
			memset(vmd2_m->channel_description, 0, METADATA_CHANNEL_DESCRIPTION_BYTES_m12); equal = FALSE_m12;
		}
		if (memcmp(vmd2_1->segment_description, vmd2_2->segment_description, METADATA_SEGMENT_DESCRIPTION_BYTES_m12)) {
			memset(vmd2_m->segment_description, 0, METADATA_SEGMENT_DESCRIPTION_BYTES_m12); equal = FALSE_m12;
		}
		if (memcmp(vmd2_1->equipment_description, vmd2_2->equipment_description, METADATA_EQUIPMENT_DESCRIPTION_BYTES_m12)) {
			memset(vmd2_m->equipment_description, 0, METADATA_EQUIPMENT_DESCRIPTION_BYTES_m12); equal = FALSE_m12;
		}
		if (vmd2_1->acquisition_channel_number != vmd2_2->acquisition_channel_number) {
			vmd2_m->acquisition_channel_number = METADATA_ACQUISITION_CHANNEL_NUMBER_NO_ENTRY_m12; equal = FALSE_m12;
		}
		if (vmd2_1->time_base_units_conversion_factor != vmd2_2->time_base_units_conversion_factor) {
			vmd2_m->time_base_units_conversion_factor = VIDEO_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m12; equal = FALSE_m12;
		}
		if (memcmp(vmd2_1->time_base_units_description, vmd2_2->time_base_units_description, VIDEO_METADATA_TIME_BASE_UNITS_DESCRIPTION_BYTES_m12)) {
			memset(vmd2_m->time_base_units_description, 0, VIDEO_METADATA_TIME_BASE_UNITS_DESCRIPTION_BYTES_m12); equal = FALSE_m12;
		}
		if (vmd2_1->absolute_start_frame_number > vmd2_2->absolute_start_frame_number) {
			vmd2_m->absolute_start_frame_number = vmd2_2->absolute_start_frame_number; equal = FALSE_m12;
		}
		if (vmd2_1->number_of_frames < vmd2_2->number_of_frames) {
			vmd2_m->number_of_frames = vmd2_2->number_of_frames; equal = FALSE_m12;
		}
		if (vmd2_1->frame_rate != vmd2_2->frame_rate) {
			vmd2_m->frame_rate = VIDEO_METADATA_FRAME_RATE_NO_ENTRY_m12; equal = FALSE_m12;
		}
		if (vmd2_1->number_of_clips < vmd2_2->number_of_clips) {
			vmd2_m->number_of_clips = vmd2_2->number_of_clips; equal = FALSE_m12;
		}
		if (vmd2_1->maximum_clip_bytes < vmd2_2->maximum_clip_bytes) {
			vmd2_m->maximum_clip_bytes = vmd2_2->maximum_clip_bytes; equal = FALSE_m12;
		}
		if (vmd2_1->maximum_clip_frames < vmd2_2->maximum_clip_frames) {
			vmd2_m->maximum_clip_frames = vmd2_2->maximum_clip_frames; equal = FALSE_m12;
		}
		if (vmd2_1->number_of_video_files < vmd2_2->number_of_video_files) {
			vmd2_m->number_of_video_files = vmd2_2->number_of_video_files; equal = FALSE_m12;
		}
		if (vmd2_1->maximum_clip_duration < vmd2_2->maximum_clip_duration) {
			vmd2_m->maximum_clip_duration = vmd2_2->maximum_clip_duration; equal = FALSE_m12;
		}
		if (vmd2_1->number_of_discontinuities < vmd2_2->number_of_discontinuities) {
			vmd2_m->number_of_discontinuities = vmd2_2->number_of_discontinuities; equal = FALSE_m12;
		}
		if (vmd2_1->maximum_contiguous_clips < vmd2_2->maximum_contiguous_clips) {
			vmd2_m->maximum_contiguous_clips = vmd2_2->maximum_contiguous_clips; equal = FALSE_m12;
		}
		if (vmd2_1->maximum_contiguous_clip_bytes < vmd2_2->maximum_contiguous_clip_bytes) {
			vmd2_m->maximum_contiguous_clip_bytes = vmd2_2->maximum_contiguous_clip_bytes; equal = FALSE_m12;
		}
		if (vmd2_1->maximum_contiguous_frames < vmd2_2->maximum_contiguous_frames) {
			vmd2_m->maximum_contiguous_frames = vmd2_2->maximum_contiguous_frames; equal = FALSE_m12;
		}
		if (vmd2_1->horizontal_pixels != vmd2_2->horizontal_pixels) {
			vmd2_m->horizontal_pixels = VIDEO_METADATA_HORIZONTAL_PIXELS_NO_ENTRY_m12; equal = FALSE_m12;
		}
		if (vmd2_1->vertical_pixels != vmd2_2->vertical_pixels) {
			vmd2_m->vertical_pixels = VIDEO_METADATA_VERTICAL_PIXELS_NO_ENTRY_m12; equal = FALSE_m12;
		}
		if (memcmp(vmd2_1->video_format, vmd2_2->video_format, VIDEO_METADATA_VIDEO_FORMAT_BYTES_m12)) {
			memset(vmd2_1->video_format, 0, VIDEO_METADATA_VIDEO_FORMAT_BYTES_m12); equal = FALSE_m12;
		}
		if (memcmp(vmd2_1->protected_region, vmd2_2->protected_region, VIDEO_METADATA_SECTION_2_PROTECTED_REGION_BYTES_m12)) {
			memset(vmd2_m->protected_region, 0, VIDEO_METADATA_SECTION_2_PROTECTED_REGION_BYTES_m12); equal = FALSE_m12;
		}
		if (memcmp(vmd2_1->discretionary_region, vmd2_2->discretionary_region, VIDEO_METADATA_SECTION_2_DISCRETIONARY_REGION_BYTES_m12)) {
			memset(vmd2_m->discretionary_region, 0, VIDEO_METADATA_SECTION_2_DISCRETIONARY_REGION_BYTES_m12); equal = FALSE_m12;
		}
		// end section 2: video channel
	}
	
	// section 3
	md3_1 = &md_fps_1->metadata->section_3;
	md3_2 = &md_fps_2->metadata->section_3;
	md3_m = &merged_md_fps->metadata->section_3;
	if (md3_1->recording_time_offset != md3_2->recording_time_offset) {
		md3_m->recording_time_offset = UUTC_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (md3_1->daylight_time_start_code.value != md3_2->daylight_time_start_code.value) {
		md3_m->daylight_time_start_code.value = DTCC_VALUE_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (md3_1->daylight_time_end_code.value != md3_2->daylight_time_end_code.value) {
		md3_m->daylight_time_end_code.value = DTCC_VALUE_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (memcmp(md3_1->standard_timezone_acronym, md3_2->standard_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m12)) {
		memset(md3_m->standard_timezone_acronym, 0, TIMEZONE_ACRONYM_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->standard_timezone_string, md3_2->standard_timezone_string, TIMEZONE_STRING_BYTES_m12)) {
		memset(md3_m->standard_timezone_string, 0, TIMEZONE_STRING_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->daylight_timezone_acronym, md3_2->daylight_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m12)) {
		memset(md3_m->daylight_timezone_acronym, 0, TIMEZONE_ACRONYM_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->daylight_timezone_string, md3_2->daylight_timezone_string, TIMEZONE_STRING_BYTES_m12)) {
		memset(md3_m->daylight_timezone_string, 0, TIMEZONE_STRING_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->subject_name_1, md3_2->subject_name_1, METADATA_SUBJECT_NAME_BYTES_m12)) {
		memset(md3_m->subject_name_1, 0, METADATA_SUBJECT_NAME_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->subject_name_2, md3_2->subject_name_2, METADATA_SUBJECT_NAME_BYTES_m12)) {
		memset(md3_m->subject_name_2, 0, METADATA_SUBJECT_NAME_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->subject_name_3, md3_2->subject_name_3, METADATA_SUBJECT_NAME_BYTES_m12)) {
		memset(md3_m->subject_name_3, 0, METADATA_SUBJECT_NAME_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->subject_ID, md3_2->subject_ID, METADATA_SUBJECT_ID_BYTES_m12)) {
		memset(md3_m->subject_ID, 0, METADATA_SUBJECT_ID_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->recording_country, md3_2->recording_country, METADATA_RECORDING_LOCATION_BYTES_m12)) {
		memset(md3_m->recording_country, 0, METADATA_SUBJECT_ID_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->recording_territory, md3_2->recording_territory, METADATA_RECORDING_LOCATION_BYTES_m12)) {
		memset(md3_m->recording_territory, 0, METADATA_SUBJECT_ID_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->recording_locality, md3_2->recording_locality, METADATA_RECORDING_LOCATION_BYTES_m12)) {
		memset(md3_m->recording_locality, 0, METADATA_RECORDING_LOCATION_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->recording_institution, md3_2->recording_institution, METADATA_RECORDING_LOCATION_BYTES_m12)) {
		memset(md3_m->recording_institution, 0, METADATA_RECORDING_LOCATION_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->geotag_format, md3_2->geotag_format, METADATA_GEOTAG_FORMAT_BYTES_m12)) {
		memset(md3_m->geotag_format, 0, METADATA_GEOTAG_FORMAT_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->geotag_data, md3_2->geotag_data, METADATA_GEOTAG_DATA_BYTES_m12)) {
		memset(md3_m->geotag_data, 0, METADATA_GEOTAG_DATA_BYTES_m12); equal = FALSE_m12;
	}
	if (md3_1->standard_UTC_offset != md3_2->standard_UTC_offset) {
		md3_m->standard_UTC_offset = STANDARD_UTC_OFFSET_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (memcmp(md3_1->protected_region, md3_2->protected_region, METADATA_SECTION_3_PROTECTED_REGION_BYTES_m12)) {
		memset(md3_m->protected_region, 0, METADATA_SECTION_3_PROTECTED_REGION_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(md3_1->discretionary_region, md3_2->discretionary_region, METADATA_SECTION_3_DISCRETIONARY_REGION_BYTES_m12)) {
		memset(md3_m->discretionary_region, 0, METADATA_SECTION_3_DISCRETIONARY_REGION_BYTES_m12); equal = FALSE_m12;
	}
	
	if (globals_m12->verbose == TRUE_m12) {
		switch (type_code) {
			case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
				printf_m12("------------ Merged Time Series Metadata --------------\n");
				break;
			case VIDEO_METADATA_FILE_TYPE_CODE_m12:
				printf_m12("--------------- Merged Video Metadata -----------------\n");
				break;
		}
		G_show_metadata_m12(NULL, merged_md_fps->metadata, type_code);
	}
	
	return(equal);
}


TERN_m12        G_merge_universal_headers_m12(FILE_PROCESSING_STRUCT_m12 *fps_1, FILE_PROCESSING_STRUCT_m12 * fps_2, FILE_PROCESSING_STRUCT_m12 * merged_fps)
{
	UNIVERSAL_HEADER_m12	*uh_1, *uh_2, *merged_uh;
	TERN_m12                equal = TRUE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// if merged_fps == NULL, comparison results will be placed in fps_1->universal_header
	// returns TRUE_m12 if fps_1->universal_header == fps_2->universal_header, FALSE_m12 otherwise
	
	if (merged_fps == NULL)
		merged_fps = fps_1;
	else
		memcpy(merged_fps->universal_header, fps_1->universal_header, UNIVERSAL_HEADER_BYTES_m12);
	
	equal = TRUE_m12;
	uh_1 = fps_1->universal_header;
	uh_2 = fps_2->universal_header;
	merged_uh = merged_fps->universal_header;
	
	merged_uh->header_CRC = CRC_NO_ENTRY_m12; // CRCs not compared / merged
	merged_uh->body_CRC = CRC_NO_ENTRY_m12; // CRCs not compared / merged
	if (uh_1->type_code != uh_2->type_code) {
		// special case: merging metadata & record data universal headers for ephemeral data
		if ((uh_1->type_code == TIME_SERIES_METADATA_FILE_TYPE_CODE_m12 || uh_1->type_code == VIDEO_METADATA_FILE_TYPE_CODE_m12) && uh_2->type_code == RECORD_DATA_FILE_TYPE_CODE_m12) {
			merged_uh->type_code = uh_1->type_code;
		} else if ((uh_2->type_code == TIME_SERIES_METADATA_FILE_TYPE_CODE_m12 || uh_2->type_code == VIDEO_METADATA_FILE_TYPE_CODE_m12) && uh_1->type_code == RECORD_DATA_FILE_TYPE_CODE_m12) {
			merged_uh->type_code = uh_2->type_code;
		} else {
			merged_uh->type_code = NO_TYPE_CODE_m12; equal = FALSE_m12;
		}
	}
	if (uh_1->MED_version_major != uh_2->MED_version_major) {
		merged_uh->MED_version_major = UNIVERSAL_HEADER_MED_VERSION_MAJOR_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (uh_1->MED_version_minor != uh_2->MED_version_minor) {
		merged_uh->MED_version_minor = UNIVERSAL_HEADER_MED_VERSION_MINOR_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (uh_1->byte_order_code != uh_2->byte_order_code) {
		merged_uh->byte_order_code = UNIVERSAL_HEADER_BYTE_ORDER_CODE_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (uh_1->session_start_time == UUTC_NO_ENTRY_m12) {
		if (uh_2->session_start_time == UUTC_NO_ENTRY_m12)
			merged_uh->session_start_time = UUTC_NO_ENTRY_m12;
		else
			merged_uh->session_start_time = uh_2->session_start_time;
	} else if (uh_2->session_start_time == UUTC_NO_ENTRY_m12) {
		merged_uh->session_start_time = uh_1->session_start_time;
	} else if (uh_1->session_start_time > uh_2->session_start_time) {
		merged_uh->session_start_time = uh_2->session_start_time; equal = FALSE_m12;
	}
	if (uh_1->segment_start_time == UUTC_NO_ENTRY_m12) {
		if (uh_2->segment_start_time == UUTC_NO_ENTRY_m12)
			merged_uh->segment_start_time = UUTC_NO_ENTRY_m12;
		else
			merged_uh->segment_start_time = uh_2->segment_start_time;
	} else if (uh_2->segment_start_time == UUTC_NO_ENTRY_m12) {
		merged_uh->segment_start_time = uh_1->segment_start_time;
	} else if (uh_1->segment_start_time > uh_2->segment_start_time) {
		merged_uh->segment_start_time = uh_2->segment_start_time; equal = FALSE_m12;
	}
	if (uh_1->segment_end_time == UUTC_NO_ENTRY_m12) {
		if (uh_2->segment_end_time == UUTC_NO_ENTRY_m12)
			merged_uh->segment_end_time = UUTC_NO_ENTRY_m12;
		else
			merged_uh->segment_end_time = uh_2->segment_end_time;
	} else if (uh_2->segment_end_time == UUTC_NO_ENTRY_m12) {
		merged_uh->segment_end_time = uh_1->segment_start_time;
	} else if (uh_1->segment_end_time < uh_2->segment_end_time) {
		merged_uh->segment_end_time = uh_2->segment_end_time; equal = FALSE_m12;
	}
	if (uh_1->number_of_entries < uh_2->number_of_entries) {
		merged_uh->number_of_entries = uh_2->number_of_entries; equal = FALSE_m12;
	}
	if (uh_1->maximum_entry_size < uh_2->maximum_entry_size) {
		merged_uh->maximum_entry_size = uh_2->maximum_entry_size; equal = FALSE_m12;
	}
	if (uh_1->segment_number != uh_2->segment_number) {
		merged_uh->segment_number = UNIVERSAL_HEADER_SEGMENT_NUMBER_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (memcmp(uh_1->session_name, uh_2->session_name, BASE_FILE_NAME_BYTES_m12)) {
		memset(merged_uh->session_name, 0, BASE_FILE_NAME_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(uh_1->channel_name, uh_2->channel_name, BASE_FILE_NAME_BYTES_m12)) {
		memset(merged_uh->channel_name, 0, BASE_FILE_NAME_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(uh_1->anonymized_subject_ID, uh_2->anonymized_subject_ID, BASE_FILE_NAME_BYTES_m12)) {
		memset(merged_uh->anonymized_subject_ID, 0, UNIVERSAL_HEADER_ANONYMIZED_SUBJECT_ID_BYTES_m12); equal = FALSE_m12;
	}
	if (uh_1->session_UID != uh_2->session_UID) {
		merged_uh->session_UID = UID_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (uh_1->channel_UID != uh_2->channel_UID) {
		merged_uh->channel_UID = UID_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (uh_1->segment_UID != uh_2->segment_UID) {
		merged_uh->segment_UID = UID_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (uh_1->file_UID != uh_2->file_UID) {
		merged_uh->file_UID = UID_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (uh_1->provenance_UID != uh_2->provenance_UID) {
		merged_uh->provenance_UID = UID_NO_ENTRY_m12; equal = FALSE_m12;
	}
	if (memcmp(uh_1->level_1_password_validation_field, uh_2->level_1_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m12)) {
		memset(merged_uh->level_1_password_validation_field, 0, PASSWORD_VALIDATION_FIELD_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(uh_1->level_2_password_validation_field, uh_2->level_2_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m12)) {
		memset(merged_uh->level_2_password_validation_field, 0, PASSWORD_VALIDATION_FIELD_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(uh_1->level_3_password_validation_field, uh_2->level_3_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m12)) {
		memset(merged_uh->level_3_password_validation_field, 0, PASSWORD_VALIDATION_FIELD_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(uh_1->protected_region, uh_2->protected_region, UNIVERSAL_HEADER_PROTECTED_REGION_BYTES_m12)) {
		memset(merged_uh->protected_region, 0, UNIVERSAL_HEADER_PROTECTED_REGION_BYTES_m12); equal = FALSE_m12;
	}
	if (memcmp(uh_1->discretionary_region, uh_2->discretionary_region, UNIVERSAL_HEADER_DISCRETIONARY_REGION_BYTES_m12)) {
		memset(merged_uh->discretionary_region, 0, UNIVERSAL_HEADER_DISCRETIONARY_REGION_BYTES_m12); equal = FALSE_m12;
	}
	
	return(equal);
}


void    G_message_m12(si1 *fmt, ...)
{
	va_list		args;
	
	
	// uncolored suppressible text to stdout
	if (!(globals_m12->behavior_on_fail & SUPPRESS_MESSAGE_OUTPUT_m12)) {
		va_start(args, fmt);
		UTF8_vprintf_m12(fmt, args);
		va_end(args);
		#ifndef MATLAB_m12
		fflush(stdout);
		#endif
	}
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void     G_nap_m12(si1 *nap_str)
{
	si1             *c;
	struct timespec nap;
	si8             num;
	
	
	// string format: <number>[<space>]<unit letter(s)>
	// e.g. to sleep for 1 millisecond:
	// "1 millisecond" == "1millisecond" == "1 ms" == "1ms" == "1 m" == "1m"

	if (nap_str == NULL) {
		G_error_message_m12("%s(): NULL input string => not napping", __FUNCTION__, nap_str);
		return;
	}
	
	if (*nap_str == 0) {
		G_error_message_m12("%s(): no input string => not napping", __FUNCTION__, nap_str);
		return;
	}

	c = nap_str;
	num = *c++ - '0';
	while (*c >= '0' && *c <= '9' && *c) {
		num *= 10;
		num += *c++ - '0';
	}
	
	// optional space
	if (*c == 32)
		++c;

	// units: ns, us (or microseconds), ms (or milliseconds), sec, min, hours
	switch(*c) {
		case 'h':  // hours
			nap.tv_sec = num * (ui8) 3600;
			nap.tv_nsec = 0;
			break;
		case 'm':  // microseconds, milliseconds (default), or minutes
			if( *(c + 1) == 'i') {
				if (*(c + 2) == 'c') {  // microseconds
					nap.tv_sec = 0;
					nap.tv_nsec = num * (ui8) 1e3;
					break;
				}
				if (*(c + 2) == 'n') {  // minutes
					nap.tv_sec = num * (ui8) 60;
					nap.tv_nsec = 0;
					break;
				}
			}
			// milliseconds
			nap.tv_sec = 0;
			nap.tv_nsec = num * (ui8) 1e6;
			break;
		case 'n':  // nanoseconds
			nap.tv_sec = 0;
			nap.tv_nsec = num;
			break;
		case 's':  // seconds
			nap.tv_sec = num;
			nap.tv_nsec = 0;
			break;
		case 'u':  // microseconds
			nap.tv_sec = 0;
			nap.tv_nsec = num * (ui8) 1e3;
			break;
		default:
			G_warning_message_m12("%s(): \"%s\" is not a valid input string => not napping\n", __FUNCTION__, nap_str);
			return;
	}
	
	// overflow
	if (nap.tv_nsec >= (si8) 1e9) {
		nap.tv_sec = nap.tv_nsec / (si8) 1e9;
		nap.tv_nsec -= (nap.tv_sec * (si8) 1e9);
	}
	
	// sleep
#if defined MACOS_m12 || defined LINUX_m12
	nanosleep(&nap, NULL);
#endif
#ifdef WINDOWS_m12
	WN_nap_m12(&nap);
#endif
	
	return;
}


si1	*G_numerical_fixed_width_string_m12(si1 *string, si4 string_bytes, si4 number)
{
	si4	native_numerical_length, temp;
	si1	*c;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// string bytes does not include terminal zero
	
	if (string == NULL)
		string = (si1 *) calloc_m12((size_t)(string_bytes + 1), sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	native_numerical_length = 0;
	temp = number;
	while (temp) {
		temp /= 10;
		++native_numerical_length;
	}
	if (number <= 0)
		++native_numerical_length;
	
	c = string;
	temp = string_bytes - native_numerical_length;
	if (temp < 0)
		G_warning_message_m12("%s(): required digits exceed string length\n", __FUNCTION__);
	while (temp--)
		*c++ = '0';
	
	sprintf_m12(c, "%d", number);
	
	return(string);
}


CHANNEL_m12	*G_open_channel_m12(CHANNEL_m12 *chan, TIME_SLICE_m12 *slice, si1 *chan_path, ui8 flags, si1 *password)
{
	TERN_m12			free_channel, ret_val;
	si1				tmp_str[FULL_FILE_NAME_BYTES_m12], num_str[FILE_NUMBERING_DIGITS_m12 + 1];
	si4				i, j, k, seg_idx, n_segs, mapped_segs, null_segment_cnt, thread_idx;
	SEGMENT_m12			*seg;
	UNIVERSAL_HEADER_m12		*uh;
	PROC_THREAD_INFO_m12		*proc_thread_infos;
	READ_MED_THREAD_INFO_m12	*read_MED_thread_infos;

	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
		
	// allocate channel
	free_channel = FALSE_m12;
	if (chan == NULL) {
		chan = (CHANNEL_m12 *) calloc_m12((size_t) 1, sizeof(CHANNEL_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free_channel = TRUE_m12;
	} else if (chan->flags & LH_OPEN_m12) {
		return(chan);
	}
	
	// set basic info (path, name, type, flags)
	if (G_empty_string_m12(chan_path) == FALSE_m12)
		chan->type_code = G_generate_MED_path_components_m12(chan_path, chan->path, chan->name);
	if (chan->type_code == NO_TYPE_CODE_m12 && *chan->path)
		chan->type_code = G_generate_MED_path_components_m12(chan->path, NULL, chan->name);
	if (chan->type_code != LH_TIME_SERIES_CHANNEL_m12 && chan->type_code != LH_VIDEO_CHANNEL_m12) {
		if (chan->type_code == LH_TIME_SERIES_SEGMENT_m12 || chan->type_code == LH_VIDEO_SEGMENT_m12) {  // segment passed: don't think it will be used this way, but never know
			G_extract_path_parts_m12(chan->path, chan->path, NULL, NULL);
			chan->type_code = G_generate_MED_path_components_m12(chan->path, NULL, chan->name);
		} else {
			if (free_channel == TRUE_m12)
				G_free_channel_m12(chan, TRUE_m12);
			G_error_message_m12("%s(): indeterminate channel type\n", __FUNCTION__);
			return(NULL);
		}
	}
	if (flags == LH_NO_FLAGS_m12) {
		flags = chan->flags;  // use existing channel flags, if none passed
		if (flags == LH_NO_FLAGS_m12)
			flags = globals_m12->level_header_flags;  // use global flags, if no channel flags
	}
	// set closed & inactive until successful opening
	chan->flags = (flags &= ~(LH_OPEN_m12 | LH_CHANNEL_ACTIVE_m12));
	
	// set up time & generate password data (note do this before slice is conditioned)
	if (globals_m12->password_data.processed == 0 || globals_m12->time_constants_set != TRUE_m12) {
		if (G_set_time_and_password_data_m12(password, chan->path, NULL, NULL) == FALSE_m12) {
			if (free_channel == TRUE_m12)
				G_free_channel_m12(chan, TRUE_m12);
			return(NULL);
		}
	}
	
	// process time slice (passed slice is not modified)
	if (slice == NULL) {
		if (G_all_zeros_m12((ui1 *) &chan->time_slice, (si4) sizeof(TIME_SLICE_m12)) == TRUE_m12)
			G_initialize_time_slice_m12(&chan->time_slice);  // read whole channel
	} else {  // passed slice supersedes structure slice
		chan->time_slice = *slice;
	}
	slice = &chan->time_slice;
	if (slice->conditioned == FALSE_m12)
		G_condition_time_slice_m12(slice);
			
	// get segment range
	if (slice->number_of_segments == UNKNOWN_m12) {
		if (G_get_segment_range_m12((LEVEL_HEADER_m12 *) chan, slice) == 0) {
			if (free_channel == TRUE_m12)
				G_free_channel_m12(chan, TRUE_m12);
			return(NULL);
		}
	}

	// allocate segments
	seg_idx = G_get_segment_index_m12(slice->start_segment_number);
	if (seg_idx == FALSE_m12) {
		if (free_channel == TRUE_m12)
			G_free_channel_m12(chan, TRUE_m12);
		return(NULL);
	}
	n_segs = slice->number_of_segments;
	mapped_segs = globals_m12->number_of_mapped_segments;

	if (chan->segments == NULL)
		chan->segments = (SEGMENT_m12 **) calloc_m12((size_t) mapped_segs, sizeof(SEGMENT_m12 *), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	null_segment_cnt = 0;
	if (n_segs == 1 || (flags & LH_THREAD_SEGMENT_READS_m12) == 0) {  // this is most common scenario - no need for extra thread overhead
		for (i = slice->start_segment_number, j = seg_idx; i <= slice->end_segment_number; ++i, ++j) {
			seg = chan->segments[j];
			if (seg == NULL) {
				G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, i);
				if (chan->type_code == LH_TIME_SERIES_CHANNEL_m12)
					sprintf_m12(tmp_str, "%s/%s_s%s.%s", chan->path, chan->name, num_str, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12);
				else  // LH_VIDEO_CHANNEL_m12
					sprintf_m12(tmp_str, "%s/%s_s%s.%s", chan->path, chan->name, num_str, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_str) == DIR_EXISTS_m12)  // not every segment may be present
					seg = chan->segments[j] = G_open_segment_m12(NULL, slice, tmp_str, flags, NULL);
			} else {
				seg = G_open_segment_m12(seg, slice, NULL, flags, NULL);
			}
			if (seg == NULL)
				++null_segment_cnt;
			else
				seg->parent = (void *) chan;
		}
	} else {  // thread  out multiple segments
		// set up thread infos
		proc_thread_infos = (PROC_THREAD_INFO_m12 *) calloc((size_t) n_segs, sizeof(PROC_THREAD_INFO_m12));
		read_MED_thread_infos = (READ_MED_THREAD_INFO_m12 *) calloc((size_t) n_segs, sizeof(READ_MED_THREAD_INFO_m12));
		// start read_segment threads
		
		thread_idx = 0;
		for (i = slice->start_segment_number, j = seg_idx, k = 0; i <= slice->end_segment_number; ++i, ++j, ++k) {
			seg = chan->segments[j];
			if (seg == NULL) {
				G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, i);
				if (chan->type_code == LH_TIME_SERIES_CHANNEL_m12)
					sprintf_m12(read_MED_thread_infos[k].MED_dir, "%s/%s_s%s.%s", chan->path, chan->name, num_str, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12);
				else  // LH_VIDEO_CHANNEL_m12
					sprintf_m12(read_MED_thread_infos[k].MED_dir, "%s/%s_s%s.%s", chan->path, chan->name, num_str, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12);
				if (G_file_exists_m12(read_MED_thread_infos[k].MED_dir) != DIR_EXISTS_m12) {
					// not every segment may be present
					++null_segment_cnt;
					continue;
				}
			} else {
				read_MED_thread_infos[k].MED_struct = (LEVEL_HEADER_m12 *) seg;
			}
			read_MED_thread_infos[thread_idx].slice = slice;
			read_MED_thread_infos[thread_idx].flags = flags;
			proc_thread_infos[thread_idx].thread_f = G_open_segment_thread_m12;
			proc_thread_infos[thread_idx].thread_label = "G_open_segment_thread_m12";
			proc_thread_infos[thread_idx].priority = PROC_HIGH_PRIORITY_m12;
			proc_thread_infos[thread_idx].arg = (void *) (read_MED_thread_infos + thread_idx);
			++thread_idx;
		}

		// thread out segment opens
		ret_val = PROC_distribute_jobs_m12(proc_thread_infos, n_segs, 0, TRUE_m12);  // no reserved cores, wait for completion
		
		// check results
		for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
			seg = (SEGMENT_m12 *) read_MED_thread_infos[i].MED_struct;
			if (seg == NULL)
				ret_val = FALSE_m12;
			else
				chan->segments[j] = seg;
		}
		free((void *) proc_thread_infos);
		free((void *) read_MED_thread_infos);
		if (ret_val == FALSE_m12) {
			if (free_channel == TRUE_m12)
				G_free_channel_m12(chan, TRUE_m12);
			return(NULL);
		}
	}

	// empty slice
	if (null_segment_cnt == n_segs) {
		slice->number_of_segments = EMPTY_SLICE_m12;
		if (free_channel == TRUE_m12)
			G_free_channel_m12(chan, TRUE_m12);
		return(NULL);
	}

	// update slice
	for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
		seg = chan->segments[j];
		if (seg != NULL)
			break;
	}
	slice->start_time = seg->time_slice.start_time;
	slice->start_sample_number = seg->time_slice.start_sample_number;
	slice->start_segment_number = seg->time_slice.start_segment_number;
	for (++i, ++j; i < n_segs; ++i, ++j) {
		if (chan->segments[j] != NULL)
			seg = chan->segments[j];
	}
	slice->end_time = seg->time_slice.end_time;
	slice->end_sample_number = seg->time_slice.end_sample_number;
	slice->end_segment_number = seg->time_slice.end_segment_number;
	slice->number_of_segments = TIME_SLICE_SEGMENT_COUNT_m12(slice);

	// channel records
	if (flags & LH_READ_CHANNEL_RECORDS_MASK_m12) {
		sprintf_m12(tmp_str, "%s/%s.%s", chan->path, chan->name, RECORD_INDICES_FILE_TYPE_STRING_m12);
		if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12 && chan->record_indices_fps == NULL)
			chan->record_indices_fps = G_read_file_m12(chan->record_indices_fps, tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) chan, NULL, USE_GLOBAL_BEHAVIOR_m12);
		sprintf_m12(tmp_str, "%s/%s.%s", chan->path, chan->name, RECORD_DATA_FILE_TYPE_STRING_m12);
		if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12) {
			if (flags & LH_READ_FULL_CHANNEL_RECORDS_m12) {  // read in full records data
				if (chan->record_data_fps == NULL) {
					chan->record_data_fps = G_read_file_m12(chan->record_data_fps, tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) chan, NULL, USE_GLOBAL_BEHAVIOR_m12);
				} else if (chan->record_data_fps->parameters.full_file_read != TRUE_m12) {
					FPS_free_processing_struct_m12(chan->record_data_fps, TRUE_m12);
					chan->record_data_fps = G_read_file_m12(NULL, tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) chan, NULL, USE_GLOBAL_BEHAVIOR_m12);
				}
			} else {  // just read in data universal header & leave open
				chan->record_data_fps = G_read_file_m12(chan->record_data_fps, tmp_str, 0, 0, FPS_UNIVERSAL_HEADER_ONLY_m12, (LEVEL_HEADER_m12 *) chan, NULL, USE_GLOBAL_BEHAVIOR_m12);
			}
		}
	}
	
	// ephemeral data
	if (flags & LH_GENERATE_EPHEMERAL_DATA_m12) {
		if (chan->metadata_fps != NULL)
			FPS_free_processing_struct_m12(chan->metadata_fps, TRUE_m12);
		for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
			seg = chan->segments[j];
			if (seg != NULL)
				break;
		}
		if (chan->type_code == LH_TIME_SERIES_CHANNEL_m12) {
			sprintf_m12(tmp_str, "%s/%s.%s", chan->path, chan->name, TIME_SERIES_METADATA_FILE_TYPE_STRING_m12);
			chan->metadata_fps = FPS_allocate_processing_struct_m12(NULL, tmp_str, TIME_SERIES_METADATA_FILE_TYPE_CODE_m12, METADATA_BYTES_m12, (LEVEL_HEADER_m12 *) chan, seg->metadata_fps, METADATA_BYTES_m12);
		} else if (chan->type_code == LH_VIDEO_CHANNEL_m12) {
			sprintf_m12(tmp_str, "%s/%s.%s", chan->path, chan->name, VIDEO_METADATA_FILE_TYPE_STRING_m12);
			chan->metadata_fps = FPS_allocate_processing_struct_m12(NULL, tmp_str, VIDEO_METADATA_FILE_TYPE_CODE_m12, METADATA_BYTES_m12, (LEVEL_HEADER_m12 *) chan, seg->metadata_fps, METADATA_BYTES_m12);
		}
		// merge segments
		for (++i, ++j; i < n_segs; ++i, ++j) {
			seg = chan->segments[j];
			if (seg == NULL)
				continue;
			G_merge_universal_headers_m12(chan->metadata_fps, seg->metadata_fps, NULL);
			G_merge_metadata_m12(chan->metadata_fps, seg->metadata_fps, NULL);
			if (seg->record_indices_fps != NULL && seg->record_data_fps != NULL)  // record data, not record indices universal header is merged in ephemeral data
				G_merge_universal_headers_m12(chan->metadata_fps, seg->record_data_fps, NULL);
			seg->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m12;  // clear segment flag
		}
		// merge channel records
		if (chan->record_indices_fps != NULL && chan->record_data_fps != NULL)  // record data, not record indices universal header is merged in ephemeral data
			G_merge_universal_headers_m12(chan->metadata_fps, chan->record_data_fps, NULL);
		// fix channel ephemeral universl headers (from merge functions)
		uh = chan->metadata_fps->universal_header;
		if (chan->type_code == LH_TIME_SERIES_CHANNEL_m12)
			uh->type_code = TIME_SERIES_METADATA_FILE_TYPE_CODE_m12;
		else if (chan->type_code == LH_VIDEO_CHANNEL_m12)
			uh->type_code = VIDEO_METADATA_FILE_TYPE_CODE_m12;
		uh->segment_number = UNIVERSAL_HEADER_CHANNEL_LEVEL_CODE_m12;
		uh->session_UID = globals_m12->session_UID;
		uh->channel_UID = seg->metadata_fps->universal_header->channel_UID;;
		uh->segment_UID = UID_NO_ENTRY_m12;
		chan->metadata_fps->parameters.fd = FPS_FD_EPHEMERAL_m12;
		chan->flags |= LH_UPDATE_EPHEMERAL_DATA_m12;
	}

	chan->last_access_time = G_current_uutc_m12();
	chan->flags |= (LH_OPEN_m12 | LH_CHANNEL_ACTIVE_m12);

	return(chan);
}


CHANNEL_m12	*G_open_channel_nt_m12(CHANNEL_m12 *chan, TIME_SLICE_m12 *slice, si1 *chan_path, ui8 flags, si1 *password)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (flags == LH_NO_FLAGS_m12) {
		if (chan != NULL)
			flags = chan->flags;
		if (flags == LH_NO_FLAGS_m12)
			flags = globals_m12->level_header_flags;  // use global flags, if no channel flags
	}
	chan->flags = (flags &= ~LH_THREAD_SEGMENT_READS_m12);
	
	chan = G_open_channel_m12(chan, slice,chan_path, flags, password);
	
	return(chan);
}


pthread_rval_m12	G_open_channel_thread_m12(void *ptr)
{
	PROC_THREAD_INFO_m12 		*pi;
	READ_MED_THREAD_INFO_m12 	*rmi;

#ifdef FN_DEBUG_m12
#ifndef MATLAB_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
#endif
	
	pi = (PROC_THREAD_INFO_m12 *) ptr;
	pi->status = PROC_THREAD_RUNNING_m12;  // volatile

	rmi = (READ_MED_THREAD_INFO_m12 *) (pi->arg);
	rmi->MED_struct = (LEVEL_HEADER_m12 *) G_open_channel_m12((CHANNEL_m12 *) rmi->MED_struct, rmi->slice, rmi->MED_dir, rmi->flags, rmi->password);
	
	pi->status = PROC_THREAD_FINISHED_m12;  // volatile
	
	return((pthread_rval_m12) 0);
}


SEGMENT_m12	*G_open_segment_m12(SEGMENT_m12 *seg, TIME_SLICE_m12 *slice, si1 *seg_path, ui8 flags, si1 *password)
{
	TERN_m12	free_segment;
	si1		tmp_str[FULL_FILE_NAME_BYTES_m12];
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// allocate segment
	free_segment = FALSE_m12;
	if (seg == NULL) {
		seg = (SEGMENT_m12 *) calloc_m12((size_t) 1, sizeof(SEGMENT_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		seg->en_bloc_allocation = FALSE_m12;
		free_segment = TRUE_m12;
	} else if (seg->flags & LH_OPEN_m12) {
		return(seg);
	}
	
	// set basic info (path, name, type, flags)
	if (seg_path != NULL) {
		seg->type_code = G_generate_MED_path_components_m12(seg_path, seg->path, seg->name);
	} else {
		if (G_file_exists_m12(seg->path) == DOES_NOT_EXIST_m12) {
			if (free_segment == TRUE_m12)
				G_free_segment_m12(seg, TRUE_m12);
			G_warning_message_m12("%s(): segment does not exist\n", __FUNCTION__);
			return(NULL);
		}
		seg->type_code = G_generate_MED_path_components_m12(seg->path, NULL, seg->name);
	}
	if (seg->type_code != LH_TIME_SERIES_SEGMENT_m12 && seg->type_code != LH_VIDEO_SEGMENT_m12) {
		if (free_segment == TRUE_m12)
			G_free_segment_m12(seg, TRUE_m12);
		G_error_message_m12("%s(): indeterminate segment type\n", __FUNCTION__);
		return(NULL);
	}
	if (flags == LH_NO_FLAGS_m12) {
		flags = seg->flags;  // use existing segment flags, if none passed
		if (flags == LH_NO_FLAGS_m12)
			flags = globals_m12->level_header_flags;  // use global flags, if no segment flags
	}
	seg->flags = (flags &= ~LH_OPEN_m12);

	// set up time & generate password data (note do this before slice is conditioned)
	if (globals_m12->password_data.processed == 0 || globals_m12->time_constants_set != TRUE_m12) {
		if (G_set_time_and_password_data_m12(password, seg->path, NULL, NULL) == FALSE_m12) {
			if (free_segment == TRUE_m12)
				G_free_segment_m12(seg, TRUE_m12);
			return(NULL);
		}
	}
	
	// process time slice (passed slice is not modified)
	if (slice == NULL) {
		if (G_all_zeros_m12((ui1 *) &seg->time_slice, (si4) sizeof(TIME_SLICE_m12)) == TRUE_m12)
			G_initialize_time_slice_m12(&seg->time_slice);  // read whole segment
	} else {  // passed slice supersedes structure slice
		seg->time_slice = *slice;  // passed slice is not modified
	}
	slice = &seg->time_slice;
	if (slice->conditioned == FALSE_m12)
		G_condition_time_slice_m12(slice);
		
	// metadata
	if (seg->flags & (LH_READ_SEGMENT_DATA_MASK_m12 | LH_READ_SEGMENT_METADATA_m12 | LH_GENERATE_EPHEMERAL_DATA_m12)) {
		if (seg->type_code == LH_TIME_SERIES_SEGMENT_m12)
			sprintf_m12(tmp_str, "%s/%s.%s", seg->path, seg->name, TIME_SERIES_METADATA_FILE_TYPE_STRING_m12);
		else // seg->type_code == LH_VIDEO_SEGMENT_m12
			sprintf_m12(tmp_str, "%s/%s.%s", seg->path, seg->name, VIDEO_METADATA_FILE_TYPE_STRING_m12);
		if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12)
			seg->metadata_fps = G_read_file_m12(NULL, tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) seg, NULL, USE_GLOBAL_BEHAVIOR_m12);
	}
	
	// segment data
	if (seg->flags & LH_READ_SEGMENT_DATA_MASK_m12) {

		// indices
		if (seg->type_code == LH_TIME_SERIES_SEGMENT_m12)
			sprintf_m12(tmp_str, "%s/%s.%s", seg->path, seg->name, TIME_SERIES_INDICES_FILE_TYPE_STRING_m12);
		else // seg->type_code == LH_VIDEO_SEGMENT_m12
			sprintf_m12(tmp_str, "%s/%s.%s", seg->path, seg->name, VIDEO_INDICES_FILE_TYPE_STRING_m12);
		if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12)  // note seg->video_indices_fps is the same pointer, so works for either
			seg->time_series_indices_fps = G_read_file_m12(NULL, tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) seg, NULL, USE_GLOBAL_BEHAVIOR_m12);
		
		// data (time series data only)
		if (seg->type_code == LH_TIME_SERIES_SEGMENT_m12) {
			sprintf_m12(tmp_str, "%s/%s.%s", seg->path, seg->name, TIME_SERIES_DATA_FILE_TYPE_STRING_m12);
			if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12) {
				if (seg->flags & LH_READ_FULL_SEGMENT_DATA_m12)
					seg->time_series_data_fps = G_read_file_m12(NULL, tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) seg, NULL, USE_GLOBAL_BEHAVIOR_m12);
				else
					seg->time_series_data_fps = G_read_file_m12(NULL, tmp_str, 0, 0, FPS_UNIVERSAL_HEADER_ONLY_m12, (LEVEL_HEADER_m12 *) seg, NULL, USE_GLOBAL_BEHAVIOR_m12);
			}
		}
	}

	// segment records
	if (seg->flags & LH_READ_SEGMENT_RECORDS_MASK_m12) {
		sprintf_m12(tmp_str, "%s/%s.%s", seg->path, seg->name, RECORD_INDICES_FILE_TYPE_STRING_m12);
		if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12) {
			seg->record_indices_fps = G_read_file_m12(seg->record_indices_fps, tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) seg, NULL, USE_GLOBAL_BEHAVIOR_m12);
			seg->record_indices_fps->parent = (void *) seg;
		}
		sprintf_m12(tmp_str, "%s/%s.%s", seg->path, seg->name, RECORD_DATA_FILE_TYPE_STRING_m12);
		if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12) {
			if (seg->flags & LH_READ_FULL_SEGMENT_RECORDS_m12)
				seg->record_data_fps = G_read_file_m12(seg->record_data_fps, tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) seg, NULL, USE_GLOBAL_BEHAVIOR_m12);
			else  // just read in data universal header & leave open
				seg->record_data_fps = G_read_file_m12(seg->record_data_fps, tmp_str, 0, 0, FPS_UNIVERSAL_HEADER_ONLY_m12, (LEVEL_HEADER_m12 *) seg, NULL, USE_GLOBAL_BEHAVIOR_m12);
		}
	}
	
	if (seg->flags & LH_GENERATE_EPHEMERAL_DATA_m12)
		seg->flags |= LH_UPDATE_EPHEMERAL_DATA_m12;
	seg->last_access_time = G_current_uutc_m12();
	
	seg->flags |= LH_OPEN_m12;

	return(seg);
}


pthread_rval_m12	G_open_segment_thread_m12(void *ptr)
{
	PROC_THREAD_INFO_m12 		*pi;
	READ_MED_THREAD_INFO_m12 	*rmi;

#ifdef FN_DEBUG_m12
#ifndef MATLAB_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
#endif
	
	pi = (PROC_THREAD_INFO_m12 *) ptr;
	pi->status = PROC_THREAD_RUNNING_m12;  // volatile

	rmi = (READ_MED_THREAD_INFO_m12 *) (pi->arg);
	rmi->MED_struct = (LEVEL_HEADER_m12 *) G_open_segment_m12((SEGMENT_m12 *) rmi->MED_struct, rmi->slice, rmi->MED_dir, rmi->flags, rmi->password);
	
	pi->status = PROC_THREAD_FINISHED_m12;  // volatile

	return((pthread_rval_m12) 0);
}


SESSION_m12	*G_open_session_m12(SESSION_m12 *sess, TIME_SLICE_m12 *slice, void *file_list, si4 list_len, ui8 flags, si1 *password)
{
	TERN_m12			free_session, all_channels_selected, fs_name_differs, ret_val;
	si1				*sess_dir, **chan_list, **ts_chan_list, **vid_chan_list, tmp_str[FULL_FILE_NAME_BYTES_m12], *tmp_str_ptr;
	si1				**full_ts_chan_list, **full_vid_chan_list, num_str[FILE_NUMBERING_DIGITS_m12 + 1], *regex_str;
	ui4				type_code;
	si4				i, j, k, n_chans, mapped_segs, n_segs, seg_idx, thread_idx;
	si4				fe, n_ts_chans, n_vid_chans, all_ts_chans, all_vid_chans;
	si8				curr_time;
	CHANNEL_m12			*chan;
	UNIVERSAL_HEADER_m12		*uh;
	SEGMENTED_SESS_RECS_m12		*ssr;
	PROC_THREAD_INFO_m12		*proc_thread_infos;
	READ_MED_THREAD_INFO_m12	*read_MED_thread_infos;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// if file_list is a pointer to single string, make list_len zero to indicate a one dimensional char array
	// if list_len > 0, assumed to be two dimensional array
	
	// allocate session
	free_session = FALSE_m12;
	if (sess == NULL) {
		sess = (SESSION_m12 *) calloc_m12((size_t) 1, sizeof(SESSION_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free_session = TRUE_m12;
	} else if (sess->flags & LH_OPEN_m12) {
		return(sess);
	}
	
	sess->type_code = LH_SESSION_m12;
	if (flags == LH_NO_FLAGS_m12) {
		flags = sess->flags;  // use existing session flags, if none passed
		if (flags == LH_NO_FLAGS_m12)
			flags = globals_m12->level_header_flags;  // use global flags, if no session flags
	}
	sess->flags = (flags &= ~LH_OPEN_m12);
	
	// generate channel list
	all_channels_selected = FALSE_m12;
	sess_dir = NULL;
	chan_list = NULL;
	if (list_len == 0) {  // single string
		if (STR_contains_regex_m12((si1 *) file_list) == TRUE_m12) {  // regex string passed: make 1 element channel list, NULL session directory
			chan_list = (si1 **) &file_list;
			n_chans = 1;
		} else {  // directory passed: NULL channel list
			type_code = G_MED_type_code_from_string_m12((si1 *) file_list);
			if (type_code == NO_TYPE_CODE_m12)
				type_code = G_add_level_extension_m12((si1 *) file_list);
			switch (type_code) {
				case SESSION_DIRECTORY_TYPE_CODE_m12:  // session directory passed: NULL channel list
					all_channels_selected = TRUE_m12;
					sess_dir = (si1 *) file_list;
					chan_list = NULL;
					n_chans = 0;
					break;
				case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
				case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:  // channel passed: make 1 element channel list, NULL session directory
					chan_list = (si1 **) &file_list;
					n_chans = 1;
					break;
				case TIME_SERIES_SEGMENT_DIRECTORY_TYPE_CODE_m12:  // I don't think segments will actually get passed to this function, but you never know
				case VIDEO_SEGMENT_DIRECTORY_TYPE_CODE_m12:  // segment passed: truncate to channel directory, make 1 element channel list, NULL session directory
					G_extract_path_parts_m12(tmp_str, (si1 *) file_list, NULL, NULL);
					tmp_str_ptr = tmp_str;  // copy pointer so can take address
					chan_list = &tmp_str_ptr;
					n_chans = 1;
					break;
				default:
					if (free_session == TRUE_m12)
						G_free_session_m12(sess, TRUE_m12);
					G_error_message_m12("%s(): invalid file list\n", __FUNCTION__);
					return(NULL);
			}
		}
	} else {  // channel list passed: NULL session directory
		chan_list = (si1 **) file_list;
		n_chans = list_len;
		for (i = 0; i < list_len; ++i) {
			type_code = G_MED_type_code_from_string_m12(chan_list[i]);
			if (type_code == NO_TYPE_CODE_m12)
				type_code = G_add_level_extension_m12(chan_list[i]);
		}
	}
#if defined MACOS_m12 || defined LINUX_m12
	regex_str = "[tv]icd";  // more specific (than Windows)
#endif
#ifdef WINDOWS_m12
	regex_str = "?icd";  // less specific (than MacOS or Linux)
#endif
	chan_list = G_generate_file_list_m12(chan_list, &n_chans, sess_dir, NULL, regex_str, GFL_FULL_PATH_m12);  // more specific (than Windows)
	
	if (n_chans == 0) {
		if (free_session == TRUE_m12)
			G_free_session_m12(sess, TRUE_m12);
		G_warning_message_m12("%s(): no channels found\n", __FUNCTION__);
		return(NULL);
	}

	G_extract_path_parts_m12(chan_list[0], sess->path, NULL, NULL);
	type_code = G_generate_MED_path_components_m12(sess->path, NULL, globals_m12->fs_session_name);
	sess->name = globals_m12->fs_session_name;  // only name known at this point
	if (type_code != SESSION_DIRECTORY_TYPE_CODE_m12) {
		if (free_session == TRUE_m12)
			G_free_session_m12(sess, TRUE_m12);
		G_warning_message_m12("%s(): channels must be in a MED session directory\n", __FUNCTION__);
		return(NULL);
	}
	
	// check that all files are MED channels in the same MED session directory
	// TO DO: check that they have the same session UIDs, & not require they be in the same directory
	n_ts_chans = n_vid_chans = 0;
	for (i = 0; i < n_chans; ++i) {
		G_extract_path_parts_m12(chan_list[i], tmp_str, NULL, NULL);
		if (strcmp(sess->path, tmp_str)) {
			if (free_session == TRUE_m12)
				G_free_session_m12(sess, TRUE_m12);
			G_warning_message_m12("%s(): channels must all be in the same session directory\n", __FUNCTION__);
			return(NULL);
		}
		type_code = G_MED_type_code_from_string_m12(chan_list[i]);
		switch (type_code) {
			case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
				++n_ts_chans;
				break;
			case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:
				++n_vid_chans;
				break;
			default:
				if (free_session == TRUE_m12)
					G_free_session_m12(sess, TRUE_m12);
				G_warning_message_m12("%s(): channels must be MED channel directories\n", __FUNCTION__);
				return(NULL);
		}
	}
	
	// divide channel lists
	if (flags & LH_EXCLUDE_TIME_SERIES_CHANNELS_m12) {
		n_ts_chans = 0;
		flags &= ~LH_MAP_ALL_TIME_SERIES_CHANNELS_m12;  // exclude flag supersedes map all flag
	} else if (n_ts_chans) {
		ts_chan_list = (si1 **) calloc_2D_m12((size_t) n_ts_chans, FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		if (ts_chan_list == NULL) {
			if (free_session == TRUE_m12)
				G_free_session_m12(sess, TRUE_m12);
			return(NULL);
		}
	}
	if (flags & LH_EXCLUDE_VIDEO_CHANNELS_m12) {
		n_vid_chans = 0;
		flags &= ~LH_MAP_ALL_VIDEO_CHANNELS_m12;  // exclude flag supersedes map all flag
	} else if (n_vid_chans) {
		vid_chan_list = (si1 **) calloc_2D_m12((size_t) n_vid_chans, FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		if (vid_chan_list == NULL) {
			if (free_session == TRUE_m12)
				G_free_session_m12(sess, TRUE_m12);
			return(NULL);
		}
	}
	for (i = j = k = 0; i < n_chans; ++i) {
		type_code = G_MED_type_code_from_string_m12(chan_list[i]);
		switch (type_code) {
			case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
				if (n_ts_chans)
					strcpy(ts_chan_list[j++], chan_list[i]);
				break;
			case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:
				if (n_vid_chans)
					strcpy(vid_chan_list[k++], chan_list[i]);
				break;
		}
	}
	free_m12((void *) chan_list, __FUNCTION__);
	
	// set up time series channels
	curr_time = G_current_uutc_m12();
	if ((flags & LH_MAP_ALL_TIME_SERIES_CHANNELS_m12) && (all_channels_selected == FALSE_m12)) {
		// get lists of all channels, regardless of what was passed in the list
		if (sess_dir == NULL) {
			if (n_ts_chans)
				G_extract_path_parts_m12(ts_chan_list[0], tmp_str, NULL, NULL);
			else
				G_extract_path_parts_m12(vid_chan_list[0], tmp_str, NULL, NULL);
			sess_dir = tmp_str;
		}
		full_ts_chan_list = G_generate_file_list_m12(NULL, &all_ts_chans, sess_dir, NULL, "ticd", GFL_FULL_PATH_m12);
		if (n_ts_chans) {
			sess->time_series_channels = (CHANNEL_m12 **) calloc_2D_m12((size_t) all_ts_chans, (size_t) 1, sizeof(CHANNEL_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			for (i = 0; i < all_ts_chans; ++i) {
				chan = sess->time_series_channels[i];
				chan->type_code = LH_TIME_SERIES_CHANNEL_m12;
				chan->flags = flags;
				chan->last_access_time = curr_time;
				chan->parent = (void *) sess;
				chan->en_bloc_allocation = TRUE_m12;
				G_generate_MED_path_components_m12(full_ts_chan_list[i], chan->path, chan->name);
			}
			// match passed list to full list to mark as active
			if (all_ts_chans == n_ts_chans) {
				for (i = 0; i < all_ts_chans; ++i) {
					chan = sess->time_series_channels[i];
					chan->flags |= LH_CHANNEL_ACTIVE_m12;  // need to mark active for change_reference_channel_m12()
				}
			} else {  // lists are in alphabetical order
				for (i = j = 0; i < n_ts_chans; ++i) {
					for (; strcmp(ts_chan_list[i], full_ts_chan_list[j]); ++j);
					chan = sess->time_series_channels[j];
					chan->flags |= LH_CHANNEL_ACTIVE_m12;  // need to mark active for change_reference_channel_m12()
				}
			}
			free_m12((void *) full_ts_chan_list, __FUNCTION__);
			free_m12((void *) ts_chan_list, __FUNCTION__);
			sess->number_of_time_series_channels = all_ts_chans;
		}
	} else if (n_ts_chans) {
		sess->time_series_channels = (CHANNEL_m12 **) calloc_2D_m12((size_t) n_ts_chans, (size_t) 1, sizeof(CHANNEL_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		for (i = 0; i < n_ts_chans; ++i) {
			chan = sess->time_series_channels[i];
			chan->type_code = LH_TIME_SERIES_CHANNEL_m12;
			chan->flags = flags | LH_CHANNEL_ACTIVE_m12;  // need to mark active for change_reference_channel_m12()
			chan->last_access_time = curr_time;
			chan->parent = (void *) sess;
			chan->en_bloc_allocation = TRUE_m12;
			G_generate_MED_path_components_m12(ts_chan_list[i], chan->path, chan->name);
		}
		free_m12((void *) ts_chan_list, __FUNCTION__);
		sess->number_of_time_series_channels = n_ts_chans;
	}
	
	// set up video channels
	if (sess->flags & LH_MAP_ALL_VIDEO_CHANNELS_m12 && all_channels_selected == FALSE_m12) {
		// get lists of all channels, regardless of what was passed in the list
		if (sess_dir == NULL) {
			if (n_vid_chans)
				G_extract_path_parts_m12(vid_chan_list[0], tmp_str, NULL, NULL);
			else
				G_extract_path_parts_m12(ts_chan_list[0], tmp_str, NULL, NULL);
			sess_dir = tmp_str;
		}
		full_vid_chan_list = G_generate_file_list_m12(NULL, &all_vid_chans, sess_dir, NULL, "vicd", GFL_FULL_PATH_m12);
		if (n_vid_chans) {
			sess->video_channels = (CHANNEL_m12 **) calloc_2D_m12((size_t) all_vid_chans, (size_t) 1, sizeof(CHANNEL_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			for (i = 0; i < all_vid_chans; ++i) {
				chan = sess->video_channels[i];
				chan->type_code = LH_VIDEO_CHANNEL_m12;
				chan->flags = flags;
				chan->last_access_time = curr_time;
				chan->parent = (void *) sess;
				chan->en_bloc_allocation = TRUE_m12;
				G_generate_MED_path_components_m12(full_vid_chan_list[i], chan->path, chan->name);
			}
			// match passed list to full list to mark as active
			if (all_vid_chans == n_vid_chans) {
				for (i = 0; i < all_vid_chans; ++i) {
					chan = sess->video_channels[i];
					chan->flags |= LH_CHANNEL_ACTIVE_m12;  // need to mark active for change_reference_channel_m12()
				}
			} else {  // lists are in alphbetical order
				for (i = j = 0; i < n_vid_chans; ++i) {
					for (; strcmp(vid_chan_list[i], full_vid_chan_list[j]); ++j);
					chan = sess->video_channels[j];
					chan->flags |= LH_CHANNEL_ACTIVE_m12;  // need to mark active for change_reference_channel_m12()
				}
			}
			free_m12((void *) full_vid_chan_list, __FUNCTION__);
			free_m12((void *) vid_chan_list, __FUNCTION__);
			sess->number_of_video_channels = all_vid_chans;
		}
	} else if (n_vid_chans) {
		sess->video_channels = (CHANNEL_m12 **) calloc_2D_m12((size_t) n_vid_chans, (size_t) 1, sizeof(CHANNEL_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		for (i = 0; i < n_vid_chans; ++i) {
			chan = sess->video_channels[i];
			chan->type_code = LH_VIDEO_CHANNEL_m12;
			chan->flags = flags | LH_CHANNEL_ACTIVE_m12;  // need to mark active for change_reference_channel_m12()
			chan->last_access_time = curr_time;
			chan->parent = (void *) sess;
			chan->en_bloc_allocation = TRUE_m12;
			G_generate_MED_path_components_m12(vid_chan_list[i], chan->path, chan->name);
		}
		free_m12((void *) vid_chan_list, __FUNCTION__);
		sess->number_of_video_channels = n_vid_chans;
	}
	
	// set up time & generate password data (note do this before slice is conditioned)
	if (globals_m12->password_data.processed == 0 || globals_m12->time_constants_set != TRUE_m12) {
		if (G_set_time_and_password_data_m12(password, sess->path, NULL, NULL) == FALSE_m12) {
			if (free_session == TRUE_m12)
				G_free_session_m12(sess, TRUE_m12);
			return(NULL);
		}
	}
	
	// user generated channel subsets (setting password also sets global session names)
	fs_name_differs = UNKNOWN_m12;
	if (*globals_m12->uh_session_name || *globals_m12->fs_session_name) {
		if (*globals_m12->uh_session_name && *globals_m12->fs_session_name) {
			if (strcmp(globals_m12->uh_session_name, globals_m12->fs_session_name))
				fs_name_differs = TRUE_m12;
			else
				fs_name_differs = FALSE_m12;
			sess->name = globals_m12->uh_session_name;  // default to the more generally useful version
		} else if (*globals_m12->uh_session_name) {
			fs_name_differs = FALSE_m12;
			sess->name = globals_m12->uh_session_name;  // only available version
		} else {
			fs_name_differs = FALSE_m12;
			sess->name = globals_m12->fs_session_name;  // only available version
		}
	}

	// process time slice (passed slice is not modified)
	if (slice == NULL) {
		if (G_all_zeros_m12((ui1 *) &sess->time_slice, (si4) sizeof(TIME_SLICE_m12)) == TRUE_m12)
			G_initialize_time_slice_m12(&sess->time_slice);  // read whole session
	} else {  // passed slice supersedes structure slice
		sess->time_slice = *slice;  // passed slice is not modified
	}
	slice = &sess->time_slice;
	if (slice->conditioned == FALSE_m12)
		G_condition_time_slice_m12(slice);
	
	// set reference channel (before get segment range)
	G_change_reference_channel_m12(sess, NULL, NULL, DEFAULT_CHANNEL_m12);

	// get segment range
	n_segs = slice->number_of_segments;
	if (n_segs == UNKNOWN_m12) {
		if (G_get_segment_range_m12((LEVEL_HEADER_m12 *) sess, slice) == 0) {
			if (free_session == TRUE_m12)
				G_free_session_m12(sess, TRUE_m12);
			return(NULL);
		}
	}

	n_chans = n_ts_chans + n_vid_chans;
	if (n_chans > 1) {
		// set up thread infos
		proc_thread_infos = (PROC_THREAD_INFO_m12 *) calloc((size_t) n_chans, sizeof(PROC_THREAD_INFO_m12));
		read_MED_thread_infos = (READ_MED_THREAD_INFO_m12 *) calloc((size_t) n_chans, sizeof(READ_MED_THREAD_INFO_m12));
		thread_idx = 0;
		for (i = 0; i < n_ts_chans; ++i) {
			chan = sess->time_series_channels[i];
			chan->time_slice = *slice;
			proc_thread_infos[thread_idx].thread_f = G_open_channel_thread_m12;
			proc_thread_infos[thread_idx].thread_label = "G_open_channel_thread_m12";
			proc_thread_infos[thread_idx].priority = PROC_HIGH_PRIORITY_m12;
			proc_thread_infos[thread_idx].arg = (void *) (read_MED_thread_infos + thread_idx);
			read_MED_thread_infos[thread_idx].MED_struct = (LEVEL_HEADER_m12 *) chan;
			++thread_idx;
		}
		for (i = 0; i < n_vid_chans; ++i) {
			chan = sess->video_channels[i];
			chan->time_slice = *slice;
			proc_thread_infos[thread_idx].thread_f = G_open_channel_thread_m12;
			proc_thread_infos[thread_idx].thread_label = "G_open_channel_thread_m12";
			proc_thread_infos[thread_idx].priority = PROC_HIGH_PRIORITY_m12;
			proc_thread_infos[thread_idx].arg = (void *) (read_MED_thread_infos + thread_idx);
			read_MED_thread_infos[thread_idx].MED_struct = (LEVEL_HEADER_m12 *) chan;
			++thread_idx;
		}
		
		// thread out channel opens
		ret_val = PROC_distribute_jobs_m12(proc_thread_infos, n_chans, 0, TRUE_m12);  // no reserved cores, wait for completion

		// check results
		if (ret_val == TRUE_m12) {
			for (i = 0; i < n_chans; ++i) {
				if (read_MED_thread_infos[i].MED_struct == NULL) {
					ret_val = FALSE_m12;
					break;
				}
			}
		}
		free((void *) proc_thread_infos);
		free((void *) read_MED_thread_infos);
	} else {  // one channel not worth thread overhead (fairly common scenario)
		if (n_ts_chans)  // time series channel
			chan = G_open_channel_m12(sess->time_series_channels[0], slice, NULL, flags, NULL);
		else  // video channel
			chan = G_open_channel_m12(sess->video_channels[0], slice, NULL, flags, NULL);
		ret_val = TRUE_m12;
		if (chan == NULL)
			ret_val = FALSE_m12;
	}
	if (ret_val == FALSE_m12) {
		if (free_session == TRUE_m12)
			G_free_session_m12(sess, TRUE_m12);
		G_warning_message_m12("%s(): error reading session\n", __FUNCTION__);
		return(NULL);
	}

	// update session slice
	*slice = globals_m12->reference_channel->time_slice;

	// sort channels
	G_sort_channels_by_acq_num_m12(sess);

	// session records
	if (sess->flags & LH_READ_SESSION_RECORDS_MASK_m12) {
		sprintf_m12(tmp_str, "%s/%s.%s", sess->path, sess->name, RECORD_INDICES_FILE_TYPE_STRING_m12);
		fe = G_file_exists_m12(tmp_str);
		if (fe == DOES_NOT_EXIST_m12 && fs_name_differs == TRUE_m12) {  // sess->name defaults to uh_name
			sprintf_m12(tmp_str, "%s/%s.%s", sess->path, globals_m12->fs_session_name, RECORD_INDICES_FILE_TYPE_STRING_m12);
			fe = G_file_exists_m12(tmp_str);
		}
		if (fe == FILE_EXISTS_m12)
			sess->record_indices_fps = G_read_file_m12(sess->record_indices_fps, tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) sess, NULL, USE_GLOBAL_BEHAVIOR_m12);
		sprintf_m12(tmp_str, "%s/%s.%s", sess->path, sess->name, RECORD_DATA_FILE_TYPE_STRING_m12);
		fe = G_file_exists_m12(tmp_str);
		if (fe == DOES_NOT_EXIST_m12 && fs_name_differs == TRUE_m12) {  // sess->name defaults to uh_name
			sprintf_m12(tmp_str, "%s/%s.%s", sess->path, globals_m12->fs_session_name, RECORD_DATA_FILE_TYPE_STRING_m12);
			fe = G_file_exists_m12(tmp_str);
		}
		if (fe == FILE_EXISTS_m12) {
			if (sess->flags & LH_READ_FULL_SESSION_RECORDS_m12)
				sess->record_data_fps = G_read_file_m12(sess->record_data_fps, tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) sess, NULL, USE_GLOBAL_BEHAVIOR_m12);
			else  // just read in data universal header & leave open
				sess->record_data_fps = G_read_file_m12(sess->record_data_fps, tmp_str, 0, 0, FPS_UNIVERSAL_HEADER_ONLY_m12, (LEVEL_HEADER_m12 *) sess, NULL, USE_GLOBAL_BEHAVIOR_m12);
		}
	}

	// segmented session records level
	ssr = NULL;
	if (sess->flags & LH_READ_SEGMENTED_SESS_RECS_MASK_m12) {
		sprintf_m12(tmp_str, "%s/%s.%s", sess->path, sess->name, RECORD_DIRECTORY_TYPE_STRING_m12);
		fe = G_file_exists_m12(tmp_str);
		if (fe == DOES_NOT_EXIST_m12 && fs_name_differs == TRUE_m12) {  // sess->name defaults to uh_name
			sprintf_m12(tmp_str, "%s/%s.%s", sess->path, globals_m12->fs_session_name, RECORD_DIRECTORY_TYPE_STRING_m12);
			fe = G_file_exists_m12(tmp_str);
		}
		if (fe == DIR_EXISTS_m12) {
			ssr = sess->segmented_sess_recs = (SEGMENTED_SESS_RECS_m12 *) calloc_m12((size_t) 1, sizeof(SEGMENTED_SESS_RECS_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			strcpy_m12(ssr->path, tmp_str);
			strcpy_m12(ssr->name, sess->name);
			ssr->type_code = LH_SEGMENTED_SESS_RECS_m12;
			ssr->flags = sess->flags;
			ssr->parent = (void *) sess;
			ssr->en_bloc_allocation = FALSE_m12;
			mapped_segs = globals_m12->number_of_mapped_segments;
			ssr->record_data_fps = (FILE_PROCESSING_STRUCT_m12 **) calloc_m12((size_t) mapped_segs, sizeof(FILE_PROCESSING_STRUCT_m12 *), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			ssr->record_indices_fps = (FILE_PROCESSING_STRUCT_m12 **) calloc_m12((size_t) mapped_segs, sizeof(FILE_PROCESSING_STRUCT_m12 *), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			seg_idx = G_get_segment_index_m12(slice->start_segment_number);
			for (i = slice->start_segment_number, j = seg_idx; i <= slice->end_segment_number; ++i, ++j) {
				G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, i);
				sprintf_m12(tmp_str, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, RECORD_INDICES_FILE_TYPE_STRING_m12);
				fe = G_file_exists_m12(tmp_str);
				if (fe == DOES_NOT_EXIST_m12 && fs_name_differs == TRUE_m12) {  // sess->name defaults to uh_name
					sprintf_m12(tmp_str, "%s/%s_s%s.%s", ssr->path, globals_m12->fs_session_name, num_str, RECORD_INDICES_FILE_TYPE_STRING_m12);
					fe = G_file_exists_m12(tmp_str);
				}
				if (fe == FILE_EXISTS_m12)
					ssr->record_indices_fps[j] = G_read_file_m12(ssr->record_indices_fps[j], tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) ssr, NULL, USE_GLOBAL_BEHAVIOR_m12);
				sprintf_m12(tmp_str, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, RECORD_DATA_FILE_TYPE_STRING_m12);
				fe = G_file_exists_m12(tmp_str);
				if (fe == DOES_NOT_EXIST_m12 && fs_name_differs == TRUE_m12) {  // sess->name defaults to uh_name
					sprintf_m12(tmp_str, "%s/%s_s%s.%s", ssr->path, globals_m12->fs_session_name, num_str, RECORD_DATA_FILE_TYPE_STRING_m12);
					fe = G_file_exists_m12(tmp_str);
				}
				if (fe == FILE_EXISTS_m12) {
					if (ssr->flags & LH_READ_FULL_SEGMENTED_SESS_RECS_m12)
						ssr->record_data_fps[j] = G_read_file_m12(ssr->record_data_fps[j], tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) ssr, NULL, USE_GLOBAL_BEHAVIOR_m12);
					else  // just read in data universal header & leave open
						ssr->record_data_fps[j] = G_read_file_m12(ssr->record_data_fps[j], tmp_str, 0, 0, FPS_UNIVERSAL_HEADER_ONLY_m12, (LEVEL_HEADER_m12 *) ssr, NULL, USE_GLOBAL_BEHAVIOR_m12);
				}
			}
		}
	}
	
	// ephemeral data
	if (sess->flags & LH_GENERATE_EPHEMERAL_DATA_m12) {
		if (sess->number_of_time_series_channels) {
			if (sess->time_series_metadata_fps != NULL)
				FPS_free_processing_struct_m12(sess->time_series_metadata_fps, TRUE_m12);
			sprintf_m12(tmp_str, "%s/%s_time_series.%s", sess->path, sess->name, TIME_SERIES_METADATA_FILE_TYPE_STRING_m12);
			chan = sess->time_series_channels[0];
			sess->time_series_metadata_fps = FPS_allocate_processing_struct_m12(NULL, tmp_str, TIME_SERIES_METADATA_FILE_TYPE_CODE_m12, METADATA_BYTES_m12, (LEVEL_HEADER_m12 *)  sess, chan->metadata_fps, METADATA_BYTES_m12);
			for (i = 1; i < sess->number_of_time_series_channels; ++i) {
				chan = sess->time_series_channels[i];
				if (chan->flags & LH_UPDATE_EPHEMERAL_DATA_m12) {
					G_merge_universal_headers_m12(sess->time_series_metadata_fps, chan->metadata_fps, NULL);
					G_merge_metadata_m12(sess->time_series_metadata_fps, chan->metadata_fps, NULL);
					chan->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m12;  // clear flag
				}
			}
			// merge session records
			if (sess->record_indices_fps != NULL && sess->record_data_fps != NULL)   // record data, not record indices universal header is merged in ephemeral data
				G_merge_universal_headers_m12(sess->time_series_metadata_fps, sess->record_data_fps, NULL);
			if (ssr != NULL) {
				for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
					if (ssr->record_indices_fps[j] != NULL && ssr->record_data_fps[j] != NULL)
						G_merge_universal_headers_m12(sess->time_series_metadata_fps, ssr->record_data_fps[j], NULL);
				}
			}
			// fix ephemeral universal header
			uh = sess->time_series_metadata_fps->universal_header;
			uh->type_code = TIME_SERIES_METADATA_FILE_TYPE_CODE_m12;
			uh->segment_number = UNIVERSAL_HEADER_SESSION_LEVEL_CODE_m12;
			uh->session_UID = globals_m12->session_UID;
			uh->channel_UID = uh->segment_UID = UID_NO_ENTRY_m12;
		}
		if (sess->number_of_video_channels) {
			if (sess->video_metadata_fps != NULL)
				FPS_free_processing_struct_m12(sess->video_metadata_fps, TRUE_m12);
			sprintf_m12(tmp_str, "%s/%s_video.%s", sess->path, sess->name, VIDEO_METADATA_FILE_TYPE_STRING_m12);
			chan = sess->video_channels[0];
			sess->video_metadata_fps = FPS_allocate_processing_struct_m12(NULL, tmp_str, VIDEO_METADATA_FILE_TYPE_CODE_m12, METADATA_BYTES_m12, (LEVEL_HEADER_m12 *) sess, chan->metadata_fps, METADATA_BYTES_m12);
			for (i = 1; i < sess->number_of_video_channels; ++i) {
				chan = sess->video_channels[i];
				if (chan->flags & LH_UPDATE_EPHEMERAL_DATA_m12) {
					G_merge_universal_headers_m12(sess->video_metadata_fps, chan->metadata_fps, NULL);
					G_merge_metadata_m12(sess->video_metadata_fps, chan->metadata_fps, NULL);
					chan->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m12;  // clear flag
				}
			}
			// merge session records
			if (sess->record_indices_fps != NULL && sess->record_data_fps != NULL)  // record data, not record indices universal header is merged in ephemeral data
				G_merge_universal_headers_m12(sess->video_metadata_fps, sess->record_data_fps, NULL);
			if (ssr != NULL) {
				for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
					if (ssr->record_indices_fps[j] != NULL && ssr->record_data_fps[j] != NULL)
						G_merge_universal_headers_m12(sess->video_metadata_fps, ssr->record_data_fps[j], NULL);
				}
			}
			// fix ephemeral universal header
			uh = sess->video_metadata_fps->universal_header;
			uh->type_code = VIDEO_METADATA_FILE_TYPE_CODE_m12;
			uh->segment_number = UNIVERSAL_HEADER_SESSION_LEVEL_CODE_m12;
			uh->session_UID = globals_m12->session_UID;
			uh->channel_UID = uh->segment_UID = UID_NO_ENTRY_m12;
		}
	}

	sess->last_access_time = curr_time;
	if (sess->segmented_sess_recs != NULL)
		sess->segmented_sess_recs->last_access_time = curr_time;
	sess->flags |= LH_OPEN_m12;

	return(sess);
}


SESSION_m12	*G_open_session_nt_m12(SESSION_m12 *sess, TIME_SLICE_m12 *slice, void *file_list, si4 list_len, ui8 flags, si1 *password)
{
	TERN_m12			free_session, all_channels_selected, fs_name_differs;
	si1				*sess_dir, **chan_list, **ts_chan_list, **vid_chan_list, tmp_str[FULL_FILE_NAME_BYTES_m12], *tmp_str_ptr;
	si1				**full_ts_chan_list, **full_vid_chan_list, num_str[FILE_NUMBERING_DIGITS_m12 + 1], *regex_str;
	ui4				type_code;
	si4				i, j, k, n_chans, n_ts_chans, n_vid_chans, all_ts_chans, all_vid_chans, mapped_segs, n_segs, seg_idx, fe;
	si8				curr_time;
	CHANNEL_m12			*chan;
	UNIVERSAL_HEADER_m12		*uh;
	SEGMENTED_SESS_RECS_m12		*ssr;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// if file_list is a pointer to single string, make list_len zero to indicate a one dimentional char array
	// if list_len > 0, assumed to be two dimensional array
	
	// allocate session
	free_session = FALSE_m12;
	if (sess == NULL) {
		sess = (SESSION_m12 *) calloc_m12((size_t) 1, sizeof(SESSION_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free_session = TRUE_m12;
	} else if (sess->flags & LH_OPEN_m12) {
		return(sess);
	}
	
	sess->type_code = LH_SESSION_m12;
	if (flags == LH_NO_FLAGS_m12) {
		flags = sess->flags;  // use existing session flags, if none passed
		if (flags == LH_NO_FLAGS_m12)
			flags = globals_m12->level_header_flags;  // use global flags, if no session flags
	}
	sess->flags = flags | LH_OPEN_m12;
		
	// generate channel list
	all_channels_selected = FALSE_m12;
	sess_dir = NULL;
	chan_list = NULL;
	if (list_len == 0) {  // single string
		if (STR_contains_regex_m12((si1 *) file_list) == TRUE_m12) {  // regex string passed: make 1 element channel list, NULL session directory
			chan_list = (si1 **) &file_list;
			n_chans = 1;
		} else {  // directory passed: NULL channel list
			type_code = G_MED_type_code_from_string_m12((si1 *) file_list);
			if (type_code == NO_TYPE_CODE_m12)
				type_code = G_add_level_extension_m12((si1 *) file_list);
			switch (type_code) {
				case SESSION_DIRECTORY_TYPE_CODE_m12:  // session directory passed: NULL channel list
					all_channels_selected = TRUE_m12;
					sess_dir = (si1 *) file_list;
					chan_list = NULL;
					n_chans = 0;
					break;
				case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
				case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:  // channel passed: make 1 element channel list, NULL session directory
					chan_list = (si1 **) &file_list;
					n_chans = 1;
					break;
				case TIME_SERIES_SEGMENT_DIRECTORY_TYPE_CODE_m12:  // I don't think segments will actually get passed to this function, but you never know
				case VIDEO_SEGMENT_DIRECTORY_TYPE_CODE_m12:  // segment passed: truncate to channel directory, make 1 element channel list, NULL session directory
					G_extract_path_parts_m12(tmp_str, (si1 *) file_list, NULL, NULL);
					tmp_str_ptr = tmp_str;  // copy pointer so can take address
					chan_list = &tmp_str_ptr;
					n_chans = 1;
					break;
				default:
					if (free_session == TRUE_m12)
						G_free_session_m12(sess, TRUE_m12);
					G_error_message_m12("%s(): invalid file list\n", __FUNCTION__);
					return(NULL);
			}
		}
	} else {  // channel list passed: NULL session directory
		chan_list = (si1 **) file_list;
		n_chans = list_len;
		for (i = 0; i < list_len; ++i) {
			type_code = G_MED_type_code_from_string_m12(chan_list[i]);
			if (type_code == NO_TYPE_CODE_m12)
				type_code = G_add_level_extension_m12(chan_list[i]);
		}
	}
	
#if defined MACOS_m12 || defined LINUX_m12
	regex_str = "[tv]icd";  // more specific (than Windows)
#endif
#ifdef WINDOWS_m12
	regex_str = "?icd";  // less specific (than MacOS or Linux)
#endif

	chan_list = G_generate_file_list_m12(chan_list, &n_chans, sess_dir, NULL, regex_str, GFL_FULL_PATH_m12);  // extension could be more specific ("[tv]icd") in MacOS & Linux, but not Windows

	if (n_chans == 0) {
		if (free_session == TRUE_m12)
			G_free_session_m12(sess, TRUE_m12);
		G_error_message_m12("%s(): no channels found\n", __FUNCTION__);
		return(NULL);
	}

	G_extract_path_parts_m12(chan_list[0], sess->path, NULL, NULL);
	type_code = G_generate_MED_path_components_m12(sess->path, NULL, globals_m12->fs_session_name);
	sess->name = globals_m12->fs_session_name;  // only name known at this point
	if (type_code != SESSION_DIRECTORY_TYPE_CODE_m12) {
		if (free_session == TRUE_m12)
			G_free_session_m12(sess, TRUE_m12);
		G_error_message_m12("%s(): channels must be in a MED session directory\n", __FUNCTION__);
		return(NULL);
	}
	
	// check that all files are MED channels in the same MED session directory
	// TO DO: check that they have the same session UIDs, & not require they be in the same directory
	n_ts_chans = n_vid_chans = 0;
	for (i = 0; i < n_chans; ++i) {
		G_extract_path_parts_m12(chan_list[i], tmp_str, NULL, NULL);
		if (strcmp(sess->path, tmp_str)) {
			if (free_session == TRUE_m12)
				G_free_session_m12(sess, TRUE_m12);
			G_error_message_m12("%s(): channels must all be in the same session directory\n", __FUNCTION__);
			return(NULL);
		}
		type_code = G_MED_type_code_from_string_m12(chan_list[i]);
		switch (type_code) {
			case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
				++n_ts_chans;
				break;
			case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:
				++n_vid_chans;
				break;
			default:
				if (free_session == TRUE_m12)
					G_free_session_m12(sess, TRUE_m12);
				G_error_message_m12("%s(): channels must be MED channel directories\n", __FUNCTION__);
				return(NULL);
		}
	}
	
	// divide channel lists
	if (n_ts_chans)
		ts_chan_list = (si1 **) calloc_2D_m12((size_t) n_ts_chans, FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	if (n_vid_chans)
		vid_chan_list = (si1 **) calloc_2D_m12((size_t) n_vid_chans, FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	for (i = j = k = 0; i < n_chans; ++i) {
		type_code = G_MED_type_code_from_string_m12(chan_list[i]);
		switch (type_code) {
			case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
				strcpy(ts_chan_list[j++], chan_list[i]);
				break;
			case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:
				strcpy(vid_chan_list[k++], chan_list[i]);
				break;
		}
	}
	free_m12((void *) chan_list, __FUNCTION__);

	// set up time series channels
	curr_time = G_current_uutc_m12();
	if (sess->flags & LH_MAP_ALL_TIME_SERIES_CHANNELS_m12 && all_channels_selected == FALSE_m12) {
		// get lists of all channels, regardless of what was passed in the list
		if (sess_dir == NULL) {
			if (n_ts_chans)
				G_extract_path_parts_m12(ts_chan_list[0], tmp_str, NULL, NULL);
			else
				G_extract_path_parts_m12(vid_chan_list[0], tmp_str, NULL, NULL);
			sess_dir = tmp_str;
		}
		full_ts_chan_list = G_generate_file_list_m12(NULL, &all_ts_chans, sess_dir, NULL, "ticd", GFL_FULL_PATH_m12);
		if (n_ts_chans) {
			sess->time_series_channels = (CHANNEL_m12 **) calloc_2D_m12((size_t) all_ts_chans, (size_t) 1, sizeof(CHANNEL_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			for (i = 0; i < all_ts_chans; ++i) {
				chan = sess->time_series_channels[i];
				chan->type_code = LH_TIME_SERIES_CHANNEL_m12;
				chan->flags = flags;
				chan->last_access_time = curr_time;
				chan->parent = (void *) sess;
				chan->en_bloc_allocation = TRUE_m12;
				G_generate_MED_path_components_m12(full_ts_chan_list[i], chan->path, chan->name);
			}
			// match passed list to full list to mark as active
			if (all_ts_chans == n_ts_chans) {
				for (i = 0; i < all_ts_chans; ++i) {
					chan = sess->time_series_channels[i];
					chan->flags |= LH_CHANNEL_ACTIVE_m12;
				}
			} else {  // lists are in alphabetical order
				for (i = j = 0; i < n_ts_chans; ++i) {
					for (; strcmp(ts_chan_list[i], full_ts_chan_list[j]); ++j);
					chan = sess->time_series_channels[j];
					chan->flags |= LH_CHANNEL_ACTIVE_m12;
				}
			}
			free_m12((void *) full_ts_chan_list, __FUNCTION__);
			free_m12((void *) ts_chan_list, __FUNCTION__);
			sess->number_of_time_series_channels = all_ts_chans;
		}
	} else if (n_ts_chans) {
		sess->time_series_channels = (CHANNEL_m12 **) calloc_2D_m12((size_t) n_ts_chans, (size_t) 1, sizeof(CHANNEL_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		for (i = 0; i < n_ts_chans; ++i) {
			chan = sess->time_series_channels[i];
			chan->type_code = LH_TIME_SERIES_CHANNEL_m12;
			chan->flags = flags | LH_CHANNEL_ACTIVE_m12;
			chan->parent = (void *) sess;
			chan->en_bloc_allocation = TRUE_m12;
			chan->last_access_time = curr_time;
			G_generate_MED_path_components_m12(ts_chan_list[i], chan->path, chan->name);
		}
		free_m12((void *) ts_chan_list, __FUNCTION__);
		sess->number_of_time_series_channels = n_ts_chans;
	}

	// set up video channels
	if (sess->flags & LH_MAP_ALL_VIDEO_CHANNELS_m12 && all_channels_selected == FALSE_m12) {
		// get lists of all channels, regardless of what was passed in the list
		if (sess_dir == NULL) {
			if (n_vid_chans)
				G_extract_path_parts_m12(vid_chan_list[0], tmp_str, NULL, NULL);
			else
				G_extract_path_parts_m12(ts_chan_list[0], tmp_str, NULL, NULL);
			sess_dir = tmp_str;
		}
		full_vid_chan_list = G_generate_file_list_m12(NULL, &all_vid_chans, sess_dir, NULL, "vicd", GFL_FULL_PATH_m12);
		if (n_vid_chans) {
			sess->video_channels = (CHANNEL_m12 **) calloc_2D_m12((size_t) all_vid_chans, (size_t) 1, sizeof(CHANNEL_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			for (i = 0; i < all_vid_chans; ++i) {
				chan = sess->video_channels[i];
				chan->type_code = LH_VIDEO_CHANNEL_m12;
				chan->flags = flags;
				chan->parent = (void *) sess;
				chan->en_bloc_allocation = TRUE_m12;
				chan->last_access_time = curr_time;
				G_generate_MED_path_components_m12(full_vid_chan_list[i], chan->path, chan->name);
			}
			// match passed list to full list to mark as active
			if (all_vid_chans == n_vid_chans) {
				for (i = 0; i < all_vid_chans; ++i) {
					chan = sess->video_channels[i];
					chan->flags |= LH_CHANNEL_ACTIVE_m12;
				}
			} else {  // lists are in alphbetical order
				for (i = j = 0; i < n_vid_chans; ++i) {
					for (; strcmp(vid_chan_list[i], full_vid_chan_list[j]); ++j);
					chan = sess->video_channels[j];
					chan->flags |= LH_CHANNEL_ACTIVE_m12;
				}
			}
			free_m12((void *) full_vid_chan_list, __FUNCTION__);
			free_m12((void *) vid_chan_list, __FUNCTION__);
			sess->number_of_video_channels = all_vid_chans;
		}
	} else if (n_vid_chans) {
		sess->video_channels = (CHANNEL_m12 **) calloc_2D_m12((size_t) n_vid_chans, (size_t) 1, sizeof(CHANNEL_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		for (i = 0; i < n_vid_chans; ++i) {
			chan = sess->video_channels[i];
			chan->type_code = LH_VIDEO_CHANNEL_m12;
			chan->flags = flags | LH_CHANNEL_ACTIVE_m12;
			chan->parent = (void *) sess;
			chan->en_bloc_allocation = TRUE_m12;
			chan->last_access_time = curr_time;
			G_generate_MED_path_components_m12(vid_chan_list[i], chan->path, chan->name);
		}
		free_m12((void *) vid_chan_list, __FUNCTION__);
		sess->number_of_video_channels = n_vid_chans;
	}

	// set up time & generate password data (note do this before slice is conditioned)
	if (globals_m12->password_data.processed == 0 || globals_m12->time_constants_set != TRUE_m12) {
		if (G_set_time_and_password_data_m12(password, sess->path, NULL, NULL) == FALSE_m12) {
			if (free_session == TRUE_m12)
				G_free_session_m12(sess, TRUE_m12);
			return(NULL);
		}
	}

	// user generated channel subsets (setting password also sets global session names)
	fs_name_differs = UNKNOWN_m12;
	if (*globals_m12->uh_session_name || *globals_m12->fs_session_name) {
		if (*globals_m12->uh_session_name && *globals_m12->fs_session_name) {
			if (strcmp(globals_m12->uh_session_name, globals_m12->fs_session_name))
				fs_name_differs = TRUE_m12;
			else
				fs_name_differs = FALSE_m12;
			sess->name = globals_m12->uh_session_name;  // default to the more generally useful version
		} else if (*globals_m12->uh_session_name) {
			fs_name_differs = FALSE_m12;
			sess->name = globals_m12->uh_session_name;  // only available version
		} else {
			fs_name_differs = FALSE_m12;
			sess->name = globals_m12->fs_session_name;  // only available version
		}
	}

	// process time slice (passed slice is not modified)
	if (slice == NULL) {
		if (G_all_zeros_m12((ui1 *) &sess->time_slice, (si4) sizeof(TIME_SLICE_m12)) == TRUE_m12)
			G_initialize_time_slice_m12(&sess->time_slice);  // read whole session
	} else {  // passed slice supersedes structure slice
		sess->time_slice = *slice;  // passed slice is not modified
	}
	slice = &sess->time_slice;
	if (slice->conditioned == FALSE_m12)
		G_condition_time_slice_m12(slice);
	
	// get segment range (& set global sample/frame number reference channel)
	n_segs = slice->number_of_segments;
	if (n_segs == UNKNOWN_m12) {
		if (G_get_segment_range_m12((LEVEL_HEADER_m12 *) sess, slice) == 0) {
			if (free_session == TRUE_m12)
				G_free_session_m12(sess, TRUE_m12);
			return(NULL);
		}
	}
	
	// open time series channels
	for (i = 0; i < sess->number_of_time_series_channels; ++i) {
		chan = sess->time_series_channels[i];
		if (chan->flags & LH_CHANNEL_ACTIVE_m12) {
			if (G_open_channel_nt_m12(chan, slice, NULL, (flags & ~LH_OPEN_m12), password) == NULL) {
				if (free_session == TRUE_m12) {
					G_free_session_m12(sess, TRUE_m12);
				} else if (chan != NULL) {
					if (chan->time_slice.number_of_segments == EMPTY_SLICE_m12)
						sess->time_slice.number_of_segments = EMPTY_SLICE_m12;
				}
				return(NULL);
			}
			chan->parent = (void *) sess;
		}
	}

	// open video channels
	for (i = 0; i < sess->number_of_video_channels; ++i) {
		chan = sess->video_channels[i];
		if (chan->flags & LH_CHANNEL_ACTIVE_m12) {
			if (G_open_channel_nt_m12(chan, slice, NULL, (flags & ~LH_OPEN_m12), password) == NULL) {
				if (free_session == TRUE_m12) {
					G_free_session_m12(sess, TRUE_m12);
				} else if (chan != NULL) {
					if (chan->time_slice.number_of_segments == EMPTY_SLICE_m12)
						sess->time_slice.number_of_segments = EMPTY_SLICE_m12;
				}
				return(NULL);
			}
			chan->parent = (void *) sess;
		}
	}

	// update session slice
	chan = globals_m12->reference_channel;
	if ((chan->flags & LH_CHANNEL_ACTIVE_m12) == 0)
		chan = G_get_active_channel_m12(sess, DEFAULT_CHANNEL_m12);
	slice->start_time = chan->time_slice.start_time;
	slice->end_time = chan->time_slice.end_time;
	slice->start_segment_number = chan->time_slice.start_segment_number;
	slice->end_segment_number = chan->time_slice.end_segment_number;
	slice->number_of_segments = TIME_SLICE_SEGMENT_COUNT_m12(slice);
	
	// sort channels
	G_sort_channels_by_acq_num_m12(sess);
	
	// session records
	if (sess->flags & LH_READ_SESSION_RECORDS_MASK_m12) {
		sprintf_m12(tmp_str, "%s/%s.%s", sess->path, sess->name, RECORD_INDICES_FILE_TYPE_STRING_m12);
		fe = G_file_exists_m12(tmp_str);
		if (fe == DOES_NOT_EXIST_m12 && fs_name_differs == TRUE_m12) {  // sess->name defaults to uh_name
			sprintf_m12(tmp_str, "%s/%s.%s", sess->path, globals_m12->fs_session_name, RECORD_INDICES_FILE_TYPE_STRING_m12);
			fe = G_file_exists_m12(tmp_str);
		}
		if (fe == FILE_EXISTS_m12)
			sess->record_indices_fps = G_read_file_m12(sess->record_indices_fps, tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) sess, NULL, USE_GLOBAL_BEHAVIOR_m12);
		sprintf_m12(tmp_str, "%s/%s.%s", sess->path, sess->name, RECORD_DATA_FILE_TYPE_STRING_m12);
		fe = G_file_exists_m12(tmp_str);
		if (fe == DOES_NOT_EXIST_m12 && fs_name_differs == TRUE_m12) {  // sess->name defaults to uh_name
			sprintf_m12(tmp_str, "%s/%s.%s", sess->path, globals_m12->fs_session_name, RECORD_DATA_FILE_TYPE_STRING_m12);
			fe = G_file_exists_m12(tmp_str);
		}
		if (fe == FILE_EXISTS_m12) {
			if (sess->flags & LH_READ_FULL_SESSION_RECORDS_m12)
				sess->record_data_fps = G_read_file_m12(sess->record_data_fps, tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) sess, NULL, USE_GLOBAL_BEHAVIOR_m12);
			else  // just read in data universal header & leave open
				sess->record_data_fps = G_read_file_m12(sess->record_data_fps, tmp_str, 0, 0, FPS_UNIVERSAL_HEADER_ONLY_m12, (LEVEL_HEADER_m12 *) sess, NULL, USE_GLOBAL_BEHAVIOR_m12);
		}
	}

	// segmented session records level
	ssr = NULL;
	if (sess->flags & LH_READ_SEGMENTED_SESS_RECS_MASK_m12) {
		sprintf_m12(tmp_str, "%s/%s.%s", sess->path, sess->name, RECORD_DIRECTORY_TYPE_STRING_m12);
		fe = G_file_exists_m12(tmp_str);
		if (fe == DOES_NOT_EXIST_m12 && fs_name_differs == TRUE_m12) {  // sess->name defaults to uh_name
			sprintf_m12(tmp_str, "%s/%s.%s", sess->path, globals_m12->fs_session_name, RECORD_DIRECTORY_TYPE_STRING_m12);
			fe = G_file_exists_m12(tmp_str);
		}
		if (fe == DIR_EXISTS_m12) {
			ssr = sess->segmented_sess_recs = (SEGMENTED_SESS_RECS_m12 *) calloc_m12((size_t) 1, sizeof(SEGMENTED_SESS_RECS_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			strcpy_m12(ssr->path, tmp_str);
			strcpy_m12(ssr->name, sess->name);
			ssr->type_code = LH_SEGMENTED_SESS_RECS_m12;
			ssr->flags = sess->flags;
			ssr->parent = (void *) sess;
			ssr->en_bloc_allocation = FALSE_m12;
			mapped_segs = globals_m12->number_of_mapped_segments;
			ssr->record_data_fps = (FILE_PROCESSING_STRUCT_m12 **) calloc_m12((size_t) mapped_segs, sizeof(FILE_PROCESSING_STRUCT_m12 *), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			ssr->record_indices_fps = (FILE_PROCESSING_STRUCT_m12 **) calloc_m12((size_t) mapped_segs, sizeof(FILE_PROCESSING_STRUCT_m12 *), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			seg_idx = G_get_segment_index_m12(slice->start_segment_number);
			for (i = slice->start_segment_number, j = seg_idx; i <= slice->end_segment_number; ++i, ++j) {
				G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, i);
				sprintf_m12(tmp_str, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, RECORD_INDICES_FILE_TYPE_STRING_m12);
				fe = G_file_exists_m12(tmp_str);
				if (fe == DOES_NOT_EXIST_m12 && fs_name_differs == TRUE_m12) {  // sess->name defaults to uh_name
					sprintf_m12(tmp_str, "%s/%s_s%s.%s", ssr->path, globals_m12->fs_session_name, num_str, RECORD_INDICES_FILE_TYPE_STRING_m12);
					fe = G_file_exists_m12(tmp_str);
				}
				if (fe == FILE_EXISTS_m12)
					ssr->record_indices_fps[j] = G_read_file_m12(ssr->record_indices_fps[j], tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) ssr, NULL, USE_GLOBAL_BEHAVIOR_m12);
				sprintf_m12(tmp_str, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, RECORD_DATA_FILE_TYPE_STRING_m12);
				fe = G_file_exists_m12(tmp_str);
				if (fe == DOES_NOT_EXIST_m12 && fs_name_differs == TRUE_m12) {  // sess->name defaults to uh_name
					sprintf_m12(tmp_str, "%s/%s_s%s.%s", ssr->path, globals_m12->fs_session_name, num_str, RECORD_DATA_FILE_TYPE_STRING_m12);
					fe = G_file_exists_m12(tmp_str);
				}
				if (fe == FILE_EXISTS_m12) {
					if (ssr->flags & LH_READ_FULL_SEGMENTED_SESS_RECS_m12)
						ssr->record_data_fps[j] = G_read_file_m12(ssr->record_data_fps[j], tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) ssr, NULL, USE_GLOBAL_BEHAVIOR_m12);
					else  // just read in data universal header & leave open
						ssr->record_data_fps[j] = G_read_file_m12(ssr->record_data_fps[j], tmp_str, 0, 0, FPS_UNIVERSAL_HEADER_ONLY_m12, (LEVEL_HEADER_m12 *) ssr, NULL, USE_GLOBAL_BEHAVIOR_m12);
				}
			}
		}
	}

	// ephemeral data
	if (sess->flags & LH_GENERATE_EPHEMERAL_DATA_m12) {
		if (sess->number_of_time_series_channels) {
			if (sess->time_series_metadata_fps != NULL)
				FPS_free_processing_struct_m12(sess->time_series_metadata_fps, TRUE_m12);
			sprintf_m12(tmp_str, "%s/%s_time_series.%s", sess->path, sess->name, TIME_SERIES_METADATA_FILE_TYPE_STRING_m12);
			chan = sess->time_series_channels[0];
			sess->time_series_metadata_fps = FPS_allocate_processing_struct_m12(NULL, tmp_str, TIME_SERIES_METADATA_FILE_TYPE_CODE_m12, METADATA_BYTES_m12, (LEVEL_HEADER_m12 *) sess, chan->metadata_fps, METADATA_BYTES_m12);
			for (i = 1; i < sess->number_of_time_series_channels; ++i) {
				chan = sess->time_series_channels[i];
				if (chan->flags & LH_UPDATE_EPHEMERAL_DATA_m12) {
					G_merge_universal_headers_m12(sess->time_series_metadata_fps, chan->metadata_fps, NULL);
					G_merge_metadata_m12(sess->time_series_metadata_fps, chan->metadata_fps, NULL);
					chan->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m12;  // clear flag
				}
			}
			// merge session records
			if (sess->record_indices_fps != NULL && sess->record_data_fps != NULL)    // record data, not record indices universal header is merged in ephemeral data
				G_merge_universal_headers_m12(sess->time_series_metadata_fps, sess->record_data_fps, NULL);
			if (ssr != NULL) {
				for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
					if (ssr->record_indices_fps[j] != NULL && ssr->record_data_fps[j] != NULL)
						G_merge_universal_headers_m12(sess->time_series_metadata_fps, ssr->record_data_fps[j], NULL);
				}
			}
			// fix ephemeral universal header
			uh = sess->time_series_metadata_fps->universal_header;
			uh->type_code = TIME_SERIES_METADATA_FILE_TYPE_CODE_m12;
			uh->segment_number = UNIVERSAL_HEADER_SESSION_LEVEL_CODE_m12;
			uh->session_UID = globals_m12->session_UID;
			uh->channel_UID = uh->segment_UID = UID_NO_ENTRY_m12;
		}
		if (sess->number_of_video_channels) {
			if (sess->video_metadata_fps != NULL)
				FPS_free_processing_struct_m12(sess->video_metadata_fps, TRUE_m12);
			sprintf_m12(tmp_str, "%s/%s_video.%s", sess->path, sess->name, VIDEO_METADATA_FILE_TYPE_STRING_m12);
			chan = sess->video_channels[0];
			sess->video_metadata_fps = FPS_allocate_processing_struct_m12(NULL, tmp_str, VIDEO_METADATA_FILE_TYPE_CODE_m12, METADATA_BYTES_m12, (LEVEL_HEADER_m12 *) sess, chan->metadata_fps, METADATA_BYTES_m12);
			for (i = 1; i < sess->number_of_video_channels; ++i) {
				chan = sess->video_channels[i];
				if (chan->flags & LH_UPDATE_EPHEMERAL_DATA_m12) {
					G_merge_universal_headers_m12(sess->video_metadata_fps, chan->metadata_fps, NULL);
					G_merge_metadata_m12(sess->video_metadata_fps, chan->metadata_fps, NULL);
					chan->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m12;  // clear flag
				}
			}
			// merge session records
			if (sess->record_indices_fps != NULL && sess->record_data_fps != NULL)    // record data, not record indices universal header is merged in ephemeral data
				G_merge_universal_headers_m12(sess->video_metadata_fps, sess->record_data_fps, NULL);
			if (ssr != NULL) {
				for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
					if (ssr->record_indices_fps[j] != NULL && ssr->record_data_fps[j] != NULL)
						G_merge_universal_headers_m12(sess->video_metadata_fps, ssr->record_data_fps[j], NULL);
				}
			}
			// fix ephemeral universal header
			uh = sess->video_metadata_fps->universal_header;
			uh->type_code = VIDEO_METADATA_FILE_TYPE_CODE_m12;
			uh->segment_number = UNIVERSAL_HEADER_SESSION_LEVEL_CODE_m12;
			uh->session_UID = globals_m12->session_UID;
			uh->channel_UID = uh->segment_UID = UID_NO_ENTRY_m12;
		}
	}

	sess->last_access_time = curr_time;
	if (sess->segmented_sess_recs != NULL)
		sess->segmented_sess_recs->last_access_time = curr_time;
	
	return(sess);
}


si8     G_pad_m12(ui1 *buffer, si8 content_len, ui4 alignment)
{
	si8        i, pad_bytes;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	pad_bytes = content_len % (si8) alignment;
	if (pad_bytes) {
		i = pad_bytes = (alignment - pad_bytes);
		buffer += content_len;
		while (i--)
			*buffer++ = PAD_BYTE_VALUE_m12;
	}
	
	return(content_len + pad_bytes);
}


TERN_m12	G_path_from_root_m12(si1 *path, si1 *root_path)
{
	TERN_m12	contains_formatting;
	si1		tmp_path[FULL_FILE_NAME_BYTES_m12];
	si8	len;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// assumes root_path has adequate space for new path
	
	// if root_path == NULL : return T/F on path, do not modify path
	// if root_path == path : return T/F on path, do modify path
	// if root_path != path && root_path != NULL : return T/F on path, return path from root in root_path, leaving path unmodified
	// quotes removed in returned string if present
	
	if (path == NULL) {
		if (root_path != NULL)
			*root_path = 0;
		return(FALSE_m12);
	}
	
	// remove formatting
	contains_formatting = STR_contains_formatting_m12(path, tmp_path);
	
	// remove quotes
	if (*tmp_path == '"')
		STR_strip_character_m12(tmp_path, '"');

#if defined MACOS_m12 || defined LINUX_m12
	si1	*c, *c2, base_dir[FULL_FILE_NAME_BYTES_m12];
	

	// don't modify path, just return T/F
	if (root_path == NULL) {
		if (*tmp_path == '/') {
			if (contains_formatting == TRUE_m12)
				G_warning_message_m12("%s(): path contains formatting\n", __FUNCTION__);   // only message if from root & can't modify path
			return(TRUE_m12);
		}
		return(FALSE_m12);
	}
	
	strcpy(root_path, tmp_path);

	// remove terminal '/' from passed path if present
	len = strlen(root_path);
	if (len)
		if (root_path[len - 1] == '/')
			root_path[--len] = 0;
	
	if (*root_path == '/')
		return(TRUE_m12);
	
	// get base directory
	c = root_path;
	if (*c == '~') {
		strcpy(base_dir, getenv("HOME"));
		++c;  // skip '~'
		if (*c == '/')  // skip "~/"
			++c;
	} else {
		getcwd_m12(base_dir, FULL_FILE_NAME_BYTES_m12);
	}
	
	// drop terminal '/' from base_dir, if present
	len = strlen(base_dir);
	if (base_dir[len - 1] == '/') {
		if (len > 1)  // not at root
			base_dir[--len] = 0;
	}
	
	// handle "." & ".."
	while (*c == '.') {
		if (*(c + 1) == '.') {  // backup base_dir to previous directory
			c2 = base_dir + len;
			while (*--c2 != '/');
			if (c2 == base_dir)  // at root
				*++c2 = 0;
			else
				*c2 = 0;
			len = c2 - base_dir;
			++c;
		}
		if (*(c + 1) == '/')
			c += 2;
		else
			break;  // ".filename" (invisible) form
	}

	if (*c)
		sprintf_m12(root_path, "%s/%s", base_dir, c);  // Note c may overlap root_path so use sprintf_m12()
	else
		strcpy(root_path, base_dir);
#endif
	
#ifdef WINDOWS_m12
	si1		tmp_path2[FULL_FILE_NAME_BYTES_m12];
	
	
	len = (si8) GetFullPathNameA(tmp_path, (DWORD) FULL_FILE_NAME_BYTES_m12, tmp_path2, NULL);
	if (len == 0) {  // can't resolve path
		if (root_path != path)  // if in place, leave path intact
			*root_path = 0;
		return(FALSE_m12);
	}
	
	// don't modify path, just return T/F
	if (root_path == NULL) {
		if (strncmp(tmp_path, tmp_path2, len)) {
			return(FALSE_m12);
		} else {
			if (contains_formatting == TRUE_m12)
				G_warning_message_m12("%s(): path contains formatting\n", __FUNCTION__);  // only message if from root & can't modify path
			return(TRUE_m12);
		}
	}
	
	strcpy(root_path, tmp_path2);
#endif

	return(TRUE_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	G_pop_behavior_m12(void)  //*** THIS ROUTINE IS NOT THREAD SAFE - USE JUDICIOUSLY IN THREADED APPLICATIONS ***//
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// get mutex
	PROC_pthread_mutex_lock_m12(&globals_m12->behavior_mutex);
	
	if (globals_m12->behavior_stack_entries == 0) {  // this shouldn't happen, but is possible
		globals_m12->behavior_on_fail = GLOBALS_BEHAVIOR_ON_FAIL_DEFAULT_m12;
		PROC_pthread_mutex_unlock_m12(&globals_m12->behavior_mutex);
		return;
	}
	
	globals_m12->behavior_on_fail = globals_m12->behavior_stack[--globals_m12->behavior_stack_entries];

	// release mutex
	PROC_pthread_mutex_unlock_m12(&globals_m12->behavior_mutex);

	return;
}


TERN_m12	G_process_password_data_m12(FILE_PROCESSING_STRUCT_m12 *fps, si1 *unspecified_pw)
{
	TERN_m12		pw_ok, LEVEL_1_valid;
	PASSWORD_DATA_m12	*pwd;
	ui1			hash[SHA_HASH_BYTES_m12];
	si1			unspecified_pw_bytes[PASSWORD_BYTES_m12] = {0}, putative_L1_pw_bytes[PASSWORD_BYTES_m12] = {0};
	si4			i;
	METADATA_SECTION_1_m12	*md1;
	UNIVERSAL_HEADER_m12	*uh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Returns FALSE_m12 to indicate no encryption/decryption access.
	// The password structure is set to processed, regardless of access.
	// Unencrypted data can be read without access privileges.
	
	// can't verify passwords without a universal header
	if (fps == NULL) {
		G_warning_message_m12("%s(): file processing struct is NULL\n", __FUNCTION__);
		return(FALSE_m12);
	}
	pwd = fps->parameters.password_data;
	if (pwd == NULL)
		pwd = fps->parameters.password_data = &globals_m12->password_data;
	memset((void *) pwd, 0, sizeof(PASSWORD_DATA_m12));
	pwd->processed = TRUE_m12;
	
	// NULL and "" are equivalent in this function
	if (unspecified_pw == NULL)
		unspecified_pw = "";
		
	// copy password hints from metadata to pwd if possible
	uh = fps->universal_header;
	if (uh->type_code == TIME_SERIES_METADATA_FILE_TYPE_CODE_m12 || uh->type_code == VIDEO_METADATA_FILE_TYPE_CODE_m12) {
		md1 = &fps->metadata->section_1;
		if (*md1->level_1_password_hint)
			strncpy_m12(pwd->level_1_password_hint, md1->level_1_password_hint, PASSWORD_HINT_BYTES_m12);
		if (*md1->level_2_password_hint)
			strncpy_m12(pwd->level_2_password_hint, md1->level_2_password_hint, PASSWORD_HINT_BYTES_m12);
	}

	pw_ok = FALSE_m12;
	if (*unspecified_pw) // don't warn if no password passed (could be intentional), but still show hints (below) if they exist
		pw_ok = G_check_password_m12(unspecified_pw);
	if (pw_ok == TRUE_m12) {
			
		// get terminal bytes
		G_extract_terminal_password_bytes_m12(unspecified_pw, unspecified_pw_bytes);

		// check if password protected (no need to check level 2, since for level 2 to exist, level 1 must exist)
		if (G_all_zeros_m12(uh->level_1_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m12) == TRUE_m12)
			return(TRUE_m12);
		
		// check for level 1 access
		SHA_hash_m12((ui1 *) unspecified_pw_bytes, PASSWORD_BYTES_m12, hash);  // generate SHA-256 hash of password bytes
		for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m12; ++i)  // compare with stored level 1 hash
			if (hash[i] != uh->level_1_password_validation_field[i])
				break;
		LEVEL_1_valid = FALSE_m12;
		if (i == PASSWORD_BYTES_m12) {  // Level 1 password valid (could be level 2 password also)
			pwd->access_level = LEVEL_1_ACCESS_m12;
			AES_key_expansion_m12(pwd->level_1_encryption_key, unspecified_pw_bytes);  // generate key
			if (globals_m12->verbose == TRUE_m12)
				G_message_m12("Unspecified password is valid for Level 1 access");
			LEVEL_1_valid = TRUE_m12;
		}
			
		// check if level 2 password
		for (i = 0; i < PASSWORD_BYTES_m12; ++i)  // xor with level 2 password validation field
			putative_L1_pw_bytes[i] = hash[i] ^ uh->level_2_password_validation_field[i];
			
		SHA_hash_m12((ui1 *) putative_L1_pw_bytes, PASSWORD_BYTES_m12, hash); // generate SHA-256 hash of putative level 1 password
			
		for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m12; ++i)  // compare with stored level 1 hash
			if (hash[i] != uh->level_1_password_validation_field[i])
				break;
		if (i == PASSWORD_VALIDATION_FIELD_BYTES_m12) {  // Level 2 password valid
			pwd->access_level = LEVEL_2_ACCESS_m12;
			AES_key_expansion_m12(pwd->level_1_encryption_key, putative_L1_pw_bytes);  // generate level 1 key
			AES_key_expansion_m12(pwd->level_2_encryption_key, unspecified_pw_bytes);  // generate level 2 key
			if (globals_m12->verbose == TRUE_m12)
				G_message_m12("Unspecified password is valid for Level 1 and Level 2 access\n");
			return(TRUE_m12);
		}
		if (LEVEL_1_valid == TRUE_m12)
			return(TRUE_m12);

		// invalid as level 2 password
		G_warning_message_m12("%s(): password is not valid for Level 1 or Level 2 access\n", __FUNCTION__);
	}
	// G_check_password_m12() == FALSE_m12 or unspecified password invalid
	G_show_password_hints_m12(pwd); // if hints exist

	return(FALSE_m12);
}


void	G_propogate_flags_m12(LEVEL_HEADER_m12 *level_header, ui8 new_flags)
{
	si4			n_ts_chans, n_vid_chans, n_segs;
	ui8			open_status, active_status;
	si8			i, j;
	SEGMENT_m12		*seg;
	CHANNEL_m12		*chan;
	CHANNEL_m12		**ts_chans;
	CHANNEL_m12		**vid_chans;
	SESSION_m12		*sess = NULL;
	SEGMENTED_SESS_RECS_m12	*ssr;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	switch (level_header->type_code) {
		case LH_TIME_SERIES_SEGMENT_m12:
			seg = (SEGMENT_m12 *) level_header;
			chan = NULL;
			ts_chans =  &chan;
			n_ts_chans = 1;
			vid_chans =  &chan;
			n_vid_chans = 0;
			n_segs = 1;
			break;
		case LH_VIDEO_SEGMENT_m12:
			seg = (SEGMENT_m12 *) level_header;
			chan = NULL;
			ts_chans =  &chan;
			n_ts_chans = 0;
			vid_chans =  &chan;
			n_vid_chans = 1;
			n_segs = 1;
			break;
		case LH_TIME_SERIES_CHANNEL_m12:
			chan = (CHANNEL_m12 *) level_header;
			ts_chans =  &chan;
			n_ts_chans = 1;
			n_vid_chans = 0;
			n_segs = globals_m12->number_of_mapped_segments;
			break;
		case LH_VIDEO_CHANNEL_m12:
			chan = (CHANNEL_m12 *) level_header;
			vid_chans = &chan;
			n_ts_chans = 0;
			n_vid_chans = 1;
			n_segs = globals_m12->number_of_mapped_segments;
			break;
		case LH_SESSION_m12:
			sess = (SESSION_m12 *) level_header;
			ts_chans = sess->time_series_channels;
			n_ts_chans = sess->number_of_time_series_channels;
			vid_chans = sess->video_channels;
			n_vid_chans = sess->number_of_video_channels;
			n_segs = globals_m12->number_of_mapped_segments;
			break;
		default:
			G_warning_message_m12("%s(): invalid level type\n", __FUNCTION__);
			return;
	}
	
	// condition new flags
	new_flags &= ~(LH_OPEN_m12 | LH_CHANNEL_ACTIVE_m12);
	
	// session
	if (sess != NULL) {
		open_status = sess->flags & LH_OPEN_m12;
		sess->flags = new_flags | open_status;
		// segmented session records
		ssr = sess->segmented_sess_recs;
		if (ssr != NULL) {
			open_status = ssr->flags & LH_OPEN_m12;
			ssr->flags = new_flags | open_status;
		}
	}
	
	// time series channels
	for (i = 0; i < n_ts_chans; ++i) {
		for (j = 0; j < n_segs; ++j) {
			if (ts_chans[i] != NULL)
				seg = ts_chans[i]->segments[j];
			if (seg != NULL) {
				open_status = seg->flags & LH_OPEN_m12;
				seg->flags = new_flags | open_status;
			}
		}
		if (ts_chans[i] != NULL) {
			open_status = ts_chans[i]->flags & LH_OPEN_m12;
			active_status = ts_chans[i]->flags & LH_CHANNEL_ACTIVE_m12;
			ts_chans[i]->flags = new_flags | open_status | active_status;
		}
	}
	
	// video channels
	for (i = 0; i < n_vid_chans; ++i) {
		for (j = 0; j < n_segs; ++j) {
			if (vid_chans[i] != NULL)
				seg = vid_chans[i]->segments[j];
			if (seg != NULL) {
				open_status = seg->flags & LH_OPEN_m12;
				seg->flags = new_flags | open_status;
			}
		}
		if (vid_chans[i] != NULL) {
			open_status = vid_chans[i]->flags & LH_OPEN_m12;
			active_status = vid_chans[i]->flags & LH_CHANNEL_ACTIVE_m12;
			vid_chans[i]->flags = new_flags | open_status | active_status;
		}
	}

	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	G_push_behavior_m12(ui4 behavior)  //*** THIS ROUTINE IS NOT THREAD SAFE - USE JUDICIOUSLY IN THREADED APPLICATIONS ***//
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (behavior == RESTORE_BEHAVIOR_m12) {
		G_pop_behavior_m12();
		return;
	}
	
	// get mutex
	PROC_pthread_mutex_lock_m12(&globals_m12->behavior_mutex);
	
	if (globals_m12->behavior_stack_entries == globals_m12->behavior_stack_size) {
		globals_m12->behavior_stack_size += GLOBALS_BEHAVIOR_STACK_SIZE_INCREMENT_m12;
#ifdef MATLAB_PERSISTENT_m12
		globals_m12->behavior_stack = (ui4 *) mxRealloc((void *) globals_m12->behavior_stack, (mwSize) globals_m12->behavior_stack_size * sizeof(ui4));
#else
		globals_m12->behavior_stack = (ui4 *) realloc((void *) globals_m12->behavior_stack, (size_t) globals_m12->behavior_stack_size * sizeof(ui4));
#endif
	}
	
	globals_m12->behavior_stack[globals_m12->behavior_stack_entries++] = globals_m12->behavior_on_fail;
	globals_m12->behavior_on_fail = behavior;
	
	// release mutex
	PROC_pthread_mutex_unlock_m12(&globals_m12->behavior_mutex);

	return;
}


CHANNEL_m12	*G_read_channel_m12(CHANNEL_m12 *chan, TIME_SLICE_m12 *slice, ...)  // varargs: si1 *chan_path, ui4 flags, si1 *password
{
	TERN_m12			open_channel, free_channel, ret_val;
	si1                             tmp_str[FULL_FILE_NAME_BYTES_m12], *chan_path, *password;
	si1                             num_str[FILE_NUMBERING_DIGITS_m12 + 1];
	ui8                             flags;
	si4                             i, j, k, n_segs, seg_idx, thread_idx, null_segment_cnt;
	va_list				args;
	SEGMENT_m12			*seg;
	PROC_THREAD_INFO_m12		*proc_thread_infos;
	READ_MED_THREAD_INFO_m12	*read_MED_thread_infos;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// open channel
	open_channel = free_channel = FALSE_m12;
	if (chan == NULL)
		open_channel = free_channel = TRUE_m12;
	else if (!(chan->flags & LH_OPEN_m12))
		open_channel = TRUE_m12;
	if (open_channel == TRUE_m12) {
		// get varargs
		va_start(args, slice);
		chan_path = va_arg(args, si1 *);
		flags = va_arg(args, ui8);
		password = va_arg(args, si1 *);
		va_end(args);
		// open channel
		chan = G_open_channel_m12(chan, slice, chan_path, flags, password);
		if (chan == NULL) {
			G_error_message_m12("%s(): error opening channel\n", __FUNCTION__);
			return(NULL);
		}
	}
	
	// process time slice (passed slice is not modified)
	if (slice == NULL) {
		if (G_all_zeros_m12((ui1 *) &chan->time_slice, (si4) sizeof(TIME_SLICE_m12)) == TRUE_m12)
			G_initialize_time_slice_m12(&chan->time_slice);  // read whole channel
	} else {  // passed slice supersedes structure slice
		chan->time_slice = *slice;  // passed slice is not modified
	}
	slice = &chan->time_slice;
	if (slice->conditioned == FALSE_m12)
		G_condition_time_slice_m12(slice);
		
	// get segment range
	if (slice->number_of_segments == UNKNOWN_m12) {
		n_segs = G_get_segment_range_m12((LEVEL_HEADER_m12 *) chan, slice);
		if (n_segs == 0) {
			if (free_channel == TRUE_m12)
				G_free_channel_m12(chan, TRUE_m12);
			return(NULL);
		}
	} else {
		n_segs = slice->number_of_segments;
	}
	seg_idx = G_get_segment_index_m12(slice->start_segment_number);
	if (seg_idx == FALSE_m12) {
		if (free_channel == TRUE_m12)
			G_free_channel_m12(chan, TRUE_m12);
		return(NULL);
	}

	// read segments
	null_segment_cnt = 0;
	if (n_segs == 1 || (chan->flags & LH_THREAD_SEGMENT_READS_m12) == 0) {  // most common scenario - typically no benefit with multiple channels
		for (i = slice->start_segment_number, j = seg_idx; i <= slice->end_segment_number; ++i, ++j) {
			seg = chan->segments[j];
			if (seg == NULL) {
				G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, i);
				if (chan->type_code == LH_TIME_SERIES_CHANNEL_m12)
					sprintf_m12(tmp_str, "%s/%s_s%s.%s", chan->path, chan->name, num_str, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12);
				else  // LH_VIDEO_CHANNEL_m12
					sprintf_m12(tmp_str, "%s/%s_s%s.%s", chan->path, chan->name, num_str, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_str) == DIR_EXISTS_m12)  // not every segment may be present
					seg = chan->segments[j] = G_read_segment_m12(NULL, slice, tmp_str, chan->flags, NULL);
			} else {
				seg = G_read_segment_m12(seg, slice);
			}
			if (seg == NULL)
				++null_segment_cnt;
			else
				seg->parent = (void *) chan;
		}
	} else {  // thread out multiple segments
		// set up thread infos
		proc_thread_infos = (PROC_THREAD_INFO_m12 *) calloc((size_t) n_segs, sizeof(PROC_THREAD_INFO_m12));
		read_MED_thread_infos = (READ_MED_THREAD_INFO_m12 *) calloc((size_t) n_segs, sizeof(READ_MED_THREAD_INFO_m12));
		// start read_segment threads
		
		thread_idx = 0;
		for (i = slice->start_segment_number, j = seg_idx, k = 0; i <= slice->end_segment_number; ++i, ++j, ++k) {
			seg = chan->segments[j];
			if (seg == NULL) {
				G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, i);
				if (chan->type_code == LH_TIME_SERIES_CHANNEL_m12)
					sprintf_m12(read_MED_thread_infos[k].MED_dir, "%s/%s_s%s.%s", chan->path, chan->name, num_str, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12);
				else  // LH_VIDEO_CHANNEL_m12
					sprintf_m12(read_MED_thread_infos[k].MED_dir, "%s/%s_s%s.%s", chan->path, chan->name, num_str, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12);
				if (G_file_exists_m12(read_MED_thread_infos[k].MED_dir) != DIR_EXISTS_m12) {
					// not every segment may be present
					++null_segment_cnt;
					continue;
				}
			} else {
				read_MED_thread_infos[k].MED_struct = (LEVEL_HEADER_m12 *) seg;
			}
			seg->time_slice = *slice;
			proc_thread_infos[thread_idx].thread_f = G_read_segment_thread_m12;
			proc_thread_infos[thread_idx].thread_label = "G_read_segment_thread_m12";
			proc_thread_infos[thread_idx].priority = PROC_HIGH_PRIORITY_m12;
			proc_thread_infos[thread_idx].arg = (void *) (read_MED_thread_infos + thread_idx);
			++thread_idx;
		}
		
		// thread out segment reads
		ret_val = PROC_distribute_jobs_m12(proc_thread_infos, n_segs, 0, TRUE_m12);  // no reserved cores, wait for completion
		
		// check results
		if (null_segment_cnt == n_segs)
			ret_val = FALSE_m12;
		for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
			seg = (SEGMENT_m12 *) read_MED_thread_infos[i].MED_struct;
			if (seg == NULL)
				ret_val = FALSE_m12;
			else
				chan->segments[j] = seg;
		}
		free((void *) proc_thread_infos);
		free((void *) read_MED_thread_infos);
		if (ret_val == FALSE_m12) {
			if (free_channel == TRUE_m12)
				G_free_channel_m12(chan, TRUE_m12);
			G_warning_message_m12("%s(): error reading channel\n", __FUNCTION__);
			return(NULL);
		}
	}

	// empty slice
	if (null_segment_cnt == n_segs) {
		slice->number_of_segments = EMPTY_SLICE_m12;
		if (free_channel == TRUE_m12)
			G_free_channel_m12(chan, TRUE_m12);
		return(NULL);
	}

	// update slice
	for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
		seg = chan->segments[j];
		if (seg != NULL)
			break;
	}
	slice->start_time = seg->time_slice.start_time;
	slice->start_sample_number = seg->time_slice.start_sample_number;
	slice->start_segment_number = seg->time_slice.start_segment_number;
	for (++i, ++j; i < n_segs; ++i, ++j) {
		if (chan->segments[j] != NULL)
			seg = chan->segments[j];
	}
	slice->end_time = seg->time_slice.end_time;
	slice->end_sample_number = seg->time_slice.end_sample_number;
	slice->end_segment_number = seg->time_slice.end_segment_number;
	slice->number_of_segments = TIME_SLICE_SEGMENT_COUNT_m12(slice);

	// channel records
	if (chan->flags & LH_READ_CHANNEL_RECORDS_MASK_m12)
		G_read_record_data_m12((LEVEL_HEADER_m12 *) chan, slice, 0);
	
	// update ephemeral data
	if (chan->flags & LH_GENERATE_EPHEMERAL_DATA_m12) {
		for (i = slice->start_segment_number, j = seg_idx; i <= slice->end_segment_number; ++i, ++j) {
			seg = chan->segments[j];
			if (seg == NULL)
				continue;
			if (seg->flags & LH_UPDATE_EPHEMERAL_DATA_m12) {
				G_merge_universal_headers_m12(chan->metadata_fps, seg->metadata_fps, NULL);
				G_merge_metadata_m12(chan->metadata_fps, seg->metadata_fps, NULL);
				if (seg->record_indices_fps != NULL && seg->record_data_fps != NULL)
					G_merge_universal_headers_m12(chan->metadata_fps, seg->record_data_fps, NULL);
				seg->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m12;  // clear segment flag
				chan->flags |= LH_UPDATE_EPHEMERAL_DATA_m12;  // set channel flag (for session)
			}
		}
	
		// fix session ephemeral FPS (from merge functions)
		if (chan->type_code == LH_TIME_SERIES_CHANNEL_m12)
			chan->metadata_fps->universal_header->type_code = TIME_SERIES_METADATA_FILE_TYPE_CODE_m12;
		else if (chan->type_code == LH_VIDEO_CHANNEL_m12)
			chan->metadata_fps->universal_header->type_code = VIDEO_METADATA_FILE_TYPE_CODE_m12;
		chan->metadata_fps->universal_header->segment_number = UNIVERSAL_HEADER_CHANNEL_LEVEL_CODE_m12;
		chan->metadata_fps->universal_header->segment_UID = UID_NO_ENTRY_m12;
	}

	// verbose
	if (globals_m12->verbose == TRUE_m12) {
		printf_m12("--------- Channel Universal Header ---------\n");
		G_show_universal_header_m12(chan->metadata_fps, NULL);
		printf_m12("------------ Channel Metadata --------------\n");
		G_show_metadata_m12(chan->metadata_fps, NULL, 0);
	}

	chan->last_access_time = G_current_uutc_m12();
	
	return(chan);
}


CHANNEL_m12	*G_read_channel_nt_m12(CHANNEL_m12 *chan, TIME_SLICE_m12 *slice, ...)  // varargs: si1 *chan_path, ui4 flags, si1 *password
{
	TERN_m12		open_channel;
	si1			*chan_path, *password;
	ui8			flags;
	va_list			args;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	chan_path = NULL;
	flags = LH_NO_FLAGS_m12;
	password = NULL;

	// open channel
	open_channel = FALSE_m12;
	if (chan == NULL)
		open_channel = TRUE_m12;
	else if (!(chan->flags & LH_OPEN_m12))
		open_channel = TRUE_m12;
	if (open_channel == TRUE_m12) {
		// get varargs
		va_start(args, slice);
		chan_path = va_arg(args, si1 *);
		flags = va_arg(args, ui8);
		password = va_arg(args, si1 *);
		va_end(args);
	}

	if (flags == LH_NO_FLAGS_m12) {
		if (chan != NULL)
			flags = chan->flags;
		if (flags == LH_NO_FLAGS_m12)
			flags = globals_m12->level_header_flags;  // use global flags, if no channel flags
	}
	chan->flags = (flags &= ~LH_THREAD_SEGMENT_READS_m12);

	chan = G_read_channel_m12(chan, slice, chan_path, flags, password);
	
	return(chan);
}


pthread_rval_m12	G_read_channel_thread_m12(void *ptr)
{
	PROC_THREAD_INFO_m12 		*pi;
	READ_MED_THREAD_INFO_m12 	*rmi;

#ifdef FN_DEBUG_m12
#ifndef MATLAB_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
#endif
	
	pi = (PROC_THREAD_INFO_m12 *) ptr;
	pi->status = PROC_THREAD_RUNNING_m12;  // volatile

	rmi = (READ_MED_THREAD_INFO_m12 *) (pi->arg);
	rmi->MED_struct = (LEVEL_HEADER_m12 *) G_read_channel_m12((CHANNEL_m12 *) rmi->MED_struct, rmi->slice, rmi->MED_dir, rmi->flags, rmi->password);
	
	pi->status = PROC_THREAD_FINISHED_m12;  // volatile

	return((pthread_rval_m12) 0);
}


LEVEL_HEADER_m12	*G_read_data_m12(LEVEL_HEADER_m12 *level_header, TIME_SLICE_m12 *slice, ...)  // varargs (level_header == NULL): void *file_list, si4 list_len, ui8 flags, si1 *password
{
	void				*file_list;
	si1				*password, tmp_str[FULL_FILE_NAME_BYTES_m12];
	ui4				type_code;
	si4				list_len;
	ui8				flags;
	va_list				args;
	SESSION_m12			*sess;
	CHANNEL_m12			*chan;
	SEGMENT_m12			*seg;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (level_header == NULL) {
		// get varargs
		va_start(args, slice);
		file_list = va_arg(args, void *);
		list_len = va_arg(args, si4);
		flags = va_arg(args, ui8);
		password = va_arg(args, si1 *);
		va_end(args);
		
		// get level
		if (list_len == 0) { // single string
			type_code = G_get_level_m12((si1 *) file_list, NULL);
		} else {
			G_extract_path_parts_m12((si1 *) *((si1 **) file_list), tmp_str, NULL, NULL);
			type_code = G_get_level_m12(tmp_str, NULL);
		}
		
		switch (type_code) {
			case LH_SESSION_m12:
				sess = G_open_session_m12(NULL, slice, file_list, list_len, flags, password);
				if (sess == NULL) {
					G_error_message_m12("%s(): error opening session\n", __FUNCTION__);
					return(NULL);
				}
				level_header = (LEVEL_HEADER_m12 *) sess;
				break;
			case LH_SEGMENTED_SESS_RECS_m12:
				G_error_message_m12("%s(): can not currently process segmented session records as a level\n", __FUNCTION__);
				return(NULL);
			case LH_TIME_SERIES_CHANNEL_m12:
			case LH_VIDEO_CHANNEL_m12:
				chan = G_open_channel_m12(NULL, slice, (si1 *) file_list, flags, password);
				if (chan == NULL) {
					G_error_message_m12("%s(): error opening channel\n", __FUNCTION__);
					return(NULL);
				}
				level_header = (LEVEL_HEADER_m12 *) chan;
			case LH_TIME_SERIES_SEGMENT_m12:
			case LH_VIDEO_SEGMENT_m12:
				seg = G_open_segment_m12(NULL, slice, (si1 *) file_list, flags, password);
				if (seg == NULL) {
					G_error_message_m12("%s(): error opening segment\n", __FUNCTION__);
					return(NULL);
				}
				level_header = (LEVEL_HEADER_m12 *) seg;
				break;
		}
	}

	switch (level_header->type_code) {
		case LH_SESSION_m12:
			sess = (SESSION_m12 *) level_header;
			sess = G_read_session_m12(sess, slice);
			if (sess == NULL) {
				G_error_message_m12("%s(): error reading session\n", __FUNCTION__);
				return(NULL);
			}
			break;
		case LH_SEGMENTED_SESS_RECS_m12:
			G_error_message_m12("%s(): can not currently process segmented session records as a level\n", __FUNCTION__);
			return(NULL);
		case LH_TIME_SERIES_CHANNEL_m12:
		case LH_VIDEO_CHANNEL_m12:
			chan = (CHANNEL_m12 *) level_header;
			chan = G_read_channel_m12(chan, slice);
			if (chan == NULL) {
				G_error_message_m12("%s(): error reading channel\n", __FUNCTION__);
				return(NULL);
			}
			break;
		case LH_TIME_SERIES_SEGMENT_m12:
		case LH_VIDEO_SEGMENT_m12:
			seg = (SEGMENT_m12 *) level_header;
			seg = G_read_segment_m12(seg, slice);
			if (chan == NULL) {
				G_error_message_m12("%s(): error reading segment\n", __FUNCTION__);
				return(NULL);
			}
			break;
	}

	return(level_header);
}


FILE_PROCESSING_STRUCT_m12	*G_read_file_m12(FILE_PROCESSING_STRUCT_m12 *fps, si1 *full_file_name, si8 file_offset, si8 bytes_to_read, si8 number_of_items, LEVEL_HEADER_m12 *lh, si1 *password, ui4 behavior_on_fail)
{
	TERN_m12		opened_flag, mmap_flag, close_flag, data_read_flag, allocated_flag, readable, CRC_valid;
	ui8			lh_flags;
	si8			bytes_read, required_bytes;
	UNIVERSAL_HEADER_m12	*uh;
	FILE_TIMES_m12		ft;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// if fps == NULL, it will be allocated using full file name, if not full_file name can be NULL
	
	// fps file type pointer will be set to beginning of read data section
	// bytes_to_read == bytes to read or zero, if specified in another way (e.g. number_of_items == FPS_FULL_FILE_m12 || FPS_UNIVERSAL_HEADER_ONLY_m12 or via lh_flags)
	// if bytes_to_read == 0, and it is needed, it will be calculated (passing is more efficient; in general the caller will know this value)
	// fps data_pointers will be set to beginning of bytes read in raw data (where this is in memory will depend on the memory_map & full_file_read flags)
	// 	if memory mapping is true, the data will be read to the same offset in memory as found in the file
	// 	if memory mapping is false, the data will be read to right after the universal header in memory
	// number_of_items == 0 || FPS_FULL_FILE_m12 || FPS_UNIVERSAL_HEADER_ONLY_m12
	// number_of_items is only needed for decrypting partial timeseries and record data file reads
	// if number_of_items == 0, and it is needed, it will be calculated (passing is more efficient; in general the caller will know this value)
	// if number_of_items == FPS_FULL_FILE_m12, memory mapping is FALSE, full_file_read is TRUE, and file is closed
	// if number_of_items == FPS_UNIVERSAL_HEADER_ONLY_m12, the universal header is read, and file is left open (close flag is not changed, so will close on next read if set)
	// if lh_flags != 0, they are interpreted as LEVEL_HEADER flags, and used to determined whether the should be opened with FPS_FULL_FILE_m12, FPS_UNIVERSAL_HEADER_ONLY_m12, or memory mapping
	
	if (lh == NULL)
		lh_flags = LH_NO_FLAGS_m12;
	else
		lh_flags = lh->flags;
	
	if (bytes_to_read == 0 && number_of_items == 0 && lh_flags == LH_NO_FLAGS_m12) {
		G_error_message_m12("%s(): must specify either bytes_to_read, number_of_items, or lh_flags \n", __FUNCTION__);
		G_set_error_m12(E_READ_ERR_m12, __FUNCTION__, __LINE__);
		return(NULL);
	}
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	file_offset = REMOVE_DISCONTINUITY_m12(file_offset);
	
	// allocate FPS
	allocated_flag = FALSE_m12;
	if (fps == NULL) {
		if (full_file_name == NULL) {
			G_warning_message_m12("%s(): FILE_PROCESSING_STRUCT_m12 and full_file_name are both NULL\n", __FUNCTION__);
			G_set_error_m12(E_NO_FILE_m12, __FUNCTION__, __LINE__);
			return(NULL);
		}
		close_flag = FPS_DIRECTIVES_CLOSE_FILE_DEFAULT_m12;
		mmap_flag = FPS_DIRECTIVES_MEMORY_MAP_DEFAULT_m12;
		if (lh_flags == LH_NO_FLAGS_m12)  // use global flags if none passed (these are LH_NO_FLAGS_m12 by default)
			lh_flags = globals_m12->level_header_flags;
		if (lh_flags)
			G_lh_set_directives_m12(full_file_name, lh_flags, &mmap_flag, &close_flag, &number_of_items);
		if (number_of_items == FPS_FULL_FILE_m12)
			mmap_flag = FALSE_m12;
		// allocate
		if (mmap_flag == TRUE_m12 || number_of_items == FPS_FULL_FILE_m12)
			fps = FPS_allocate_processing_struct_m12(NULL, full_file_name, NO_FILE_TYPE_CODE_m12, FPS_FULL_FILE_m12, lh, NULL, 0);
		else
			fps = FPS_allocate_processing_struct_m12(NULL, full_file_name, NO_FILE_TYPE_CODE_m12, bytes_to_read, lh, NULL, 0);
		if (fps == NULL)
			return(NULL);
		fps->directives.memory_map = mmap_flag;
		fps->directives.close_file = close_flag;
		allocated_flag = TRUE_m12;
	}
	
	// full file already read
	if (fps->parameters.full_file_read == TRUE_m12) {
		G_file_times_m12(NULL, fps->full_file_name, &ft, FALSE_m12);
		if (fps->parameters.last_access_time >= ft.modification) {  // no change since last read: common scenario for metadata files & index files
			if (file_offset < UNIVERSAL_HEADER_BYTES_m12)  // set pointers to beginning of data if none provided
				file_offset = UNIVERSAL_HEADER_BYTES_m12;
			if (number_of_items == FPS_FULL_FILE_m12) {
				file_offset = UNIVERSAL_HEADER_BYTES_m12;  // (often file_offset == 0 when number_of_items == FPS_FULL_FILE_m12)
				number_of_items = fps->universal_header->number_of_entries;
			} else if (number_of_items == 0) {
				number_of_items = G_items_for_bytes_m12(fps, &bytes_to_read);
			}
			// set pointers & number of items to values for current read
			FPS_set_pointers_m12(fps, file_offset);
			fps->number_of_items = number_of_items;
			return(fps);
		}
		fps->parameters.full_file_read = FALSE_m12;  // file changed, reset
	}

	// open file
	opened_flag = FALSE_m12;
	if (fps->parameters.fp == NULL) {
		if (!(fps->directives.open_mode & FPS_GENERIC_READ_OPEN_MODE_m12))
			fps->directives.open_mode = FPS_R_OPEN_MODE_m12;
		FPS_open_m12(fps, __FUNCTION__, behavior_on_fail);
		opened_flag = TRUE_m12;
	}

	// universal header
	uh = fps->universal_header;
	if (number_of_items == FPS_UNIVERSAL_HEADER_ONLY_m12 || number_of_items == FPS_FULL_FILE_m12 || opened_flag == TRUE_m12) {
		
		FPS_read_m12(fps, 0, UNIVERSAL_HEADER_BYTES_m12, __FUNCTION__, behavior_on_fail);
		if (uh->number_of_entries == 0) {
			if (G_correct_universal_header_m12(fps) == FALSE_m12) { // live or abnormally terminated file
				return(NULL);
			}
		}
		if (uh->session_UID != globals_m12->session_UID)  // set current session directory globals
			G_get_session_directory_m12(NULL, NULL, fps);
		if (number_of_items == FPS_UNIVERSAL_HEADER_ONLY_m12) {
			if (fps->parameters.password_data->processed == 0)	// better if done with a metadata file read (for password hints) below
				G_process_password_data_m12(fps, password);	// done here to satify rule that any read of any MED file will process password
			FPS_set_pointers_m12(fps, UNIVERSAL_HEADER_BYTES_m12);
			fps->number_of_items = 0;
			return(fps);
		} else if (number_of_items == FPS_FULL_FILE_m12) {
			file_offset = UNIVERSAL_HEADER_BYTES_m12;
			bytes_to_read = fps->parameters.flen - UNIVERSAL_HEADER_BYTES_m12;
			number_of_items = uh->number_of_entries;
			fps->parameters.full_file_read = TRUE_m12;
			fps->directives.memory_map = FALSE_m12;	// full file doesn't need memory mapping
			fps->directives.close_file = TRUE_m12;	// full file reads are closed to keep open file count down
		}
	}
	
	// get bytes_to_read (preferably this is passed)
	data_read_flag = FALSE_m12;
	if (bytes_to_read == 0) {
		bytes_to_read = G_bytes_for_items_m12(fps, &number_of_items, file_offset);
		if (uh->type_code == TIME_SERIES_DATA_FILE_TYPE_CODE_m12 || uh->type_code == RECORD_DATA_FILE_TYPE_CODE_m12) {  // variable item size types require data to be read in G_bytes_for_items_m12()
			data_read_flag = TRUE_m12;
			bytes_read = bytes_to_read;  // set bytes_to_read == bytes_read to circumvent error below
		}
	}

	// allocate memory
	if (fps->directives.memory_map == TRUE_m12 || fps->parameters.full_file_read == TRUE_m12)
		required_bytes = fps->parameters.flen;
	else
		required_bytes = bytes_to_read + UNIVERSAL_HEADER_BYTES_m12;
	if (required_bytes > fps->parameters.raw_data_bytes)
		FPS_reallocate_processing_struct_m12(fps, required_bytes);

	// set memory pointers
	FPS_set_pointers_m12(fps, file_offset);
		
	// read
	if (data_read_flag == FALSE_m12)
		bytes_read = FPS_read_m12(fps, file_offset, bytes_to_read, __FUNCTION__, behavior_on_fail);
	if (fps->directives.close_file == TRUE_m12)
		FPS_close_m12(fps);
	if (bytes_read != bytes_to_read) {
		G_error_message_m12("%s(): file read error\n", __FUNCTION__);
		if (allocated_flag == TRUE_m12)
			FPS_free_processing_struct_m12(fps, TRUE_m12);
		G_set_error_m12(E_READ_ERR_m12, __FUNCTION__, __LINE__);
		return(NULL);
	}

	// process password (better done here than above because may be reading a metadata file)
	if (fps->parameters.password_data->processed == 0)	// if metadata file, hints from section 1 will be added to password
		G_process_password_data_m12(fps, password);	// data structure, and displayed if the password is invalid
	
	// get number_of_items (preferably this is passed)
	if (number_of_items == 0)
		number_of_items = G_items_for_bytes_m12(fps, &bytes_to_read);
	fps->number_of_items = number_of_items;

	// validate CRCs
	if (globals_m12->CRC_mode & (CRC_VALIDATE_m12 | CRC_VALIDATE_ON_INPUT_m12)) {
		CRC_valid = CRC_validate_m12(fps->parameters.raw_data + UNIVERSAL_HEADER_HEADER_CRC_START_OFFSET_m12, UNIVERSAL_HEADER_BYTES_m12 - UNIVERSAL_HEADER_HEADER_CRC_START_OFFSET_m12, uh->header_CRC);
		if (CRC_valid == FALSE_m12)
			G_warning_message_m12("%s(): universal header CRC invalid for \"%s\"\n", __FUNCTION__, fps->full_file_name);
		CRC_valid = UNKNOWN_m12;
		switch (fps->universal_header->type_code) {
			case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
				CRC_valid = G_validate_time_series_data_CRCs_m12(fps);
				break;
			case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
				if (fps->parameters.full_file_read == TRUE_m12)
					CRC_valid = CRC_validate_m12(fps->data_pointers, fps->parameters.flen - UNIVERSAL_HEADER_BYTES_m12, uh->body_CRC);
				break;
			case RECORD_DATA_FILE_TYPE_CODE_m12:
				CRC_valid = G_validate_record_data_CRCs_m12(fps);
				break;
			case RECORD_INDICES_FILE_TYPE_CODE_m12:
				if (fps->parameters.full_file_read == TRUE_m12)
					CRC_valid = CRC_validate_m12(fps->data_pointers, fps->parameters.flen - UNIVERSAL_HEADER_BYTES_m12, uh->body_CRC);
				break;
			case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
			case VIDEO_METADATA_FILE_TYPE_CODE_m12:
				if (fps->parameters.full_file_read == TRUE_m12)
					CRC_valid = CRC_validate_m12(fps->data_pointers, fps->parameters.flen - UNIVERSAL_HEADER_BYTES_m12, uh->body_CRC);
				break;
		}
		if (CRC_valid == FALSE_m12)
			G_warning_message_m12("%s(): body CRC invalid for \"%s\"\n", __FUNCTION__, fps->full_file_name);
	}

	// decrypt
	switch (fps->universal_header->type_code) {
		case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
			readable = TRUE_m12;
			if (globals_m12->time_series_data_encryption_level)
				readable = G_decrypt_time_series_data_m12(fps);
			break;
		case RECORD_DATA_FILE_TYPE_CODE_m12:
			readable = G_decrypt_record_data_m12(fps);
			break;
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
			readable = G_decrypt_metadata_m12(fps);
			break;
		default:
			readable = TRUE_m12;  // file types without (possible) encryption
			break;
	}
	if (readable == FALSE_m12) {
		G_warning_message_m12("%s(): cannot decrypt file \"%s\"\n", __FUNCTION__, fps->full_file_name);
		if (allocated_flag == TRUE_m12)
			FPS_free_processing_struct_m12(fps, TRUE_m12);
		G_set_error_m12(E_READ_ERR_m12, __FUNCTION__, __LINE__);
		return(NULL);
	}
	
	return(fps);
}


si8     G_read_record_data_m12(LEVEL_HEADER_m12 *level_header, TIME_SLICE_m12 *slice, ...)  // varags: si4 seg_num
{
	si4				seg_num;
	si8				start_idx, end_idx, n_recs, bytes_to_read, offset;
	FILE_PROCESSING_STRUCT_m12	*ri_fps, *rd_fps;
	RECORD_INDEX_m12		*ri;
	SESSION_m12			*sess;
	SEGMENTED_SESS_RECS_m12		*ssr;
	CHANNEL_m12			*chan;
	SEGMENT_m12			*seg;
	va_list				args;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// seg_num only reqired for segmented session records levels
	
	switch (level_header->type_code) {
		case LH_SESSION_m12:
			sess = (SESSION_m12 *) level_header;
			ri_fps = sess->record_indices_fps;
			rd_fps = sess->record_data_fps;
			break;
		case LH_SEGMENTED_SESS_RECS_m12:
			va_start(args, slice);
			seg_num = va_arg(args, si4);
			va_end(args);
			ssr = (SEGMENTED_SESS_RECS_m12 *) level_header;
			if (ssr->flags & LH_MAP_ALL_SEGMENTS_m12)
				--seg_num;
			else
				seg_num -= slice->start_segment_number;
			ri_fps = ssr->record_indices_fps[seg_num];
			rd_fps = ssr->record_data_fps[seg_num];
			break;
		case LH_TIME_SERIES_CHANNEL_m12:
		case LH_VIDEO_CHANNEL_m12:
			chan = (CHANNEL_m12 *) level_header;
			ri_fps = chan->record_indices_fps;
			rd_fps = chan->record_data_fps;
			break;
		case LH_TIME_SERIES_SEGMENT_m12:
		case LH_VIDEO_SEGMENT_m12:
			seg = (SEGMENT_m12 *) level_header;
			ri_fps = seg->record_indices_fps;
			rd_fps = seg->record_data_fps;
			break;
	}

	start_idx = G_find_record_index_m12(ri_fps, slice->start_time, FIND_FIRST_ON_OR_AFTER_m12, 0);
	if (start_idx == NO_INDEX_m12) {  // no records "on or after" slice beginning
		if (rd_fps != NULL)
			rd_fps->number_of_items = 0;;
		return(0);
	}
	ri = ri_fps->record_indices;
	if (ri[start_idx].start_time > slice->end_time) {  // no records "on or before" slice end
		if (rd_fps != NULL)
			rd_fps->number_of_items = 0;
		return(0);
	}
	end_idx = G_find_record_index_m12(ri_fps, slice->end_time, FIND_FIRST_AFTER_m12, start_idx);
	if (end_idx == NO_INDEX_m12) // no records after slice end, but some in slice => use terminal index
		end_idx = ri_fps->universal_header->number_of_entries - 1;
	n_recs = end_idx - start_idx;
	offset = ri_fps->record_indices[start_idx].file_offset;
	bytes_to_read = ri_fps->record_indices[end_idx].file_offset - offset;
	rd_fps = G_read_file_m12(rd_fps, NULL, offset, bytes_to_read, n_recs, level_header, NULL, USE_GLOBAL_BEHAVIOR_m12);
	if (rd_fps == NULL)
		return((si8) FALSE_m12);

	return(n_recs);
}


SEGMENT_m12	*G_read_segment_m12(SEGMENT_m12 *seg, TIME_SLICE_m12 *slice, ...)  // varargs: si1 *seg_path, ui8 flags, si1 *password
{
	TERN_m12	open_segment, free_segment, inactive_ref;
	si1		*seg_path, *password;
	si4		search_mode;
	ui8		flags;
	si8		seg_abs_start_samp_num, seg_abs_end_samp_num;
	va_list		args;
	CHANNEL_m12				*chan;
	UNIVERSAL_HEADER_m12			*uh;
	TIME_SERIES_METADATA_SECTION_2_m12	*tmd2;
	VIDEO_METADATA_SECTION_2_m12		*vmd2;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// open segment
	open_segment = free_segment = FALSE_m12;
	if (seg == NULL)
		open_segment = free_segment = TRUE_m12;
	else if (!(seg->flags & LH_OPEN_m12))
		open_segment = TRUE_m12;
	if (open_segment == TRUE_m12) {
		// get varargs
		va_start(args, slice);
		seg_path = va_arg(args, si1 *);
		flags = va_arg(args, ui8);
		password = va_arg(args, si1 *);
		va_end(args);
		// open segment
		seg = G_open_segment_m12(seg, slice, seg_path, (flags & ~LH_OPEN_m12), password);
		if (seg == NULL) {
			G_warning_message_m12("%s(): error opening segment\n", __FUNCTION__);
			return(NULL);
		}
	}

	// process time slice (passed slice is not modified)
	if (slice == NULL) {
		if (G_all_zeros_m12((ui1 *) &seg->time_slice, (si4) sizeof(TIME_SLICE_m12)) == TRUE_m12)
			G_initialize_time_slice_m12(&seg->time_slice);  // read whole segment
	} else {  // passed slice supersedes structure slice
		seg->time_slice = *slice;  // passed slice is not modified
	}
	slice = &seg->time_slice;
	if (slice->conditioned == FALSE_m12)
		G_condition_time_slice_m12(slice);
	
	// check for valid limit pair (time takes priority)
	if ((search_mode = G_get_search_mode_m12(slice)) == FALSE_m12) {
		if (free_segment == TRUE_m12)
			G_free_segment_m12(seg, TRUE_m12);
		return(NULL);
	}
	uh = seg->metadata_fps->universal_header;
	if (search_mode == TIME_SEARCH_m12) {
		if (slice->start_time < uh->segment_start_time)
			slice->start_time = uh->segment_start_time;
		if (slice->end_time > uh->segment_end_time)
			slice->end_time = uh->segment_end_time;
	}
			
	// get local indices
	if (seg->type_code == LH_TIME_SERIES_SEGMENT_m12) {
		tmd2 = &seg->metadata_fps->metadata->time_series_section_2;
		seg_abs_start_samp_num = tmd2->absolute_start_sample_number;
		seg_abs_end_samp_num = seg_abs_start_samp_num + tmd2->number_of_samples - (si8) 1;
	} else {  // seg->type_code == LH_VIDEO_SEGMENT_m12
		vmd2 = &seg->metadata_fps->metadata->video_section_2;
		seg_abs_start_samp_num = vmd2->absolute_start_frame_number;
		seg_abs_end_samp_num = seg_abs_start_samp_num + (vmd2->number_of_frames - (si8) 1);
	}

	// get local indices (sample number == frame number == idx)
	if (search_mode == SAMPLE_SEARCH_m12) {
		if (slice->start_sample_number < seg_abs_start_samp_num)
			slice->start_sample_number = seg_abs_start_samp_num;
		if (slice->end_sample_number > seg_abs_end_samp_num)
			slice->end_sample_number = seg_abs_end_samp_num;
		slice->start_time = G_uutc_for_sample_number_m12((LEVEL_HEADER_m12 *) seg, slice->start_sample_number, FIND_START_m12);
		slice->end_time = G_uutc_for_sample_number_m12((LEVEL_HEADER_m12 *) seg, slice->end_sample_number, FIND_END_m12);
	} else {  // search_mode == TIME_SEARCH_m12, convert input times to local indices
		if (slice->start_time < uh->segment_start_time)
			slice->start_time = uh->segment_start_time;
		if (slice->end_time > uh->segment_end_time)
			slice->end_time = uh->segment_end_time;
		if (seg->flags & LH_READ_SEGMENT_DATA_MASK_m12) {  // may only be reading records - only need times
			slice->start_sample_number = G_sample_number_for_uutc_m12((LEVEL_HEADER_m12 *) seg, slice->start_time, FIND_CURRENT_m12);
			slice->end_sample_number = G_sample_number_for_uutc_m12((LEVEL_HEADER_m12 *) seg, slice->end_time, FIND_CURRENT_m12);
		}
	}
	slice->start_segment_number = slice->end_segment_number = seg->metadata_fps->universal_header->segment_number;
	slice->number_of_segments = 1;

	// read segment data
	inactive_ref = FALSE_m12;  // check for inactive reference
	if (seg->flags & LH_READ_SEGMENT_DATA_MASK_m12) {
		switch (seg->type_code) {
			case LH_TIME_SERIES_SEGMENT_m12:
				if (seg->parent) {
					chan = (CHANNEL_m12 *) seg->parent;
					if (chan->flags & LH_REFERENCE_INACTIVE_m12)
						inactive_ref = TRUE_m12;
				}
				if (inactive_ref == TRUE_m12)
					seg->flags &= ~LH_REFERENCE_INACTIVE_m12;  // reset segment level flag in case propogated in call
				else  // read data
					G_read_time_series_data_m12(seg, slice);
				break;
			case LH_VIDEO_SEGMENT_m12:
				// nothing for now - video segment data are native video files
				break;
		}
	}
	
	// read segment records
	if (seg->flags & LH_READ_SEGMENT_RECORDS_MASK_m12)
		if (seg->record_indices_fps != NULL && seg->record_data_fps != NULL)
			if (inactive_ref == FALSE_m12)  // don't read records either
				G_read_record_data_m12((LEVEL_HEADER_m12 *) seg, slice);

	return(seg);
}


pthread_rval_m12	G_read_segment_thread_m12(void *ptr)
{
	PROC_THREAD_INFO_m12 		*pi;
	READ_MED_THREAD_INFO_m12 	*rmi;

#ifdef FN_DEBUG_m12
#ifndef MATLAB_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
#endif
	
	pi = (PROC_THREAD_INFO_m12 *) ptr;
	pi->status = PROC_THREAD_RUNNING_m12;  // volatile
	
	rmi = (READ_MED_THREAD_INFO_m12 *) (pi->arg);
	rmi->MED_struct = (LEVEL_HEADER_m12 *) G_read_segment_m12((SEGMENT_m12 *) rmi->MED_struct, rmi->slice, rmi->MED_dir, rmi->flags, rmi->password);
	
	pi->status = PROC_THREAD_FINISHED_m12;  // volatile
	
	return((pthread_rval_m12) 0);
}


SESSION_m12	*G_read_session_m12(SESSION_m12 *sess, TIME_SLICE_m12 *slice, ...)  // varargs: void *file_list, si4 list_len, ui4 flags, si1 *password
{
	TERN_m12			open_session, free_session, calculate_channel_indices, ret_val;
	si1                             *password, num_str[FILE_NUMBERING_DIGITS_m12 + 1];
	si1				tmp_str[FULL_FILE_NAME_BYTES_m12];
	si4                             i, j, list_len, seg_idx, search_mode, thread_idx;
	si4				active_chans, active_ts_chans, active_vid_chans;
	ui8                             flags;
	sf8				ref_sf, sf_ratio;
	void				*file_list;
	va_list				args;
	UNIVERSAL_HEADER_m12		*uh;
	CHANNEL_m12			*chan;
	PROC_THREAD_INFO_m12		*proc_thread_infos;
	READ_MED_THREAD_INFO_m12	*read_MED_thread_infos;
	SEGMENTED_SESS_RECS_m12		*ssr;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// open session
	open_session = free_session = FALSE_m12;
	if (sess == NULL) {
		open_session = free_session = TRUE_m12;
	} else if (!(sess->flags & LH_OPEN_m12)) {
		G_free_session_m12(sess, FALSE_m12);
		open_session = TRUE_m12;
	}
	if (open_session == TRUE_m12) {
		// get varargs
		va_start(args, slice);
		file_list = va_arg(args, void *);
		list_len = va_arg(args, si4);
		flags = va_arg(args, ui8);
		password = va_arg(args, si1 *);
		va_end(args);
		// open session
		sess = G_open_session_m12(sess, slice, file_list, list_len, flags, password);
		if (sess == NULL) {
			G_warning_message_m12("%s(): error opening session\n", __FUNCTION__);
			return(NULL);
		}
	} else {  // process time slice (passed slice is not modified)
		if (slice == NULL) {
			if (G_all_zeros_m12((ui1 *) &sess->time_slice, (si4) sizeof(TIME_SLICE_m12)) == TRUE_m12)
				G_initialize_time_slice_m12(&sess->time_slice);  // read whole session
		} else {  // passed slice supersedes structure slice
			sess->time_slice = *slice;  // passed slice is not modified
		}
		if (sess->time_slice.conditioned == FALSE_m12)
			G_condition_time_slice_m12(slice);
	}
	slice = &sess->time_slice;
	
	// get segment range
	if (slice->number_of_segments == UNKNOWN_m12) {
		if (G_get_segment_range_m12((LEVEL_HEADER_m12 *) sess, slice) == 0) {
			if (free_session == TRUE_m12)
				G_free_session_m12(sess, TRUE_m12);
			return(NULL);
		}
	}
	seg_idx = G_check_segment_map_m12(slice, sess);
	if (seg_idx == FALSE_m12) {
		if (free_session == TRUE_m12)
			G_free_session_m12(sess, TRUE_m12);
		return(NULL);
	}
	
	// set inactive reference flags
	chan = globals_m12->reference_channel;
	if ((chan->flags & LH_CHANNEL_ACTIVE_m12) == 0) {
		if (chan->flags & LH_READ_SEGMENT_DATA_MASK_m12) {
			chan->flags |= LH_REFERENCE_INACTIVE_m12;
			chan = G_read_channel_m12(chan, slice);  // just slice read metadata & time series indices (probably already read)
			chan->flags &= ~LH_REFERENCE_INACTIVE_m12;
		}
	}
	
	// update for variable frequencies on active channel set
	G_frequencies_vary_m12(sess);

	// count active channels
	active_ts_chans = active_vid_chans = 0;
	for (i = 0; i < sess->number_of_time_series_channels; ++i)
		if (sess->time_series_channels[i]->flags & LH_CHANNEL_ACTIVE_m12)
			++active_ts_chans;
	for (i = 0; i < sess->number_of_video_channels; ++i)
		if (sess->video_channels[i]->flags & LH_CHANNEL_ACTIVE_m12)
			++active_vid_chans;
	active_chans = active_ts_chans + active_vid_chans;

	if (active_chans > 1) {
		// set up thread infos
		proc_thread_infos = (PROC_THREAD_INFO_m12 *) calloc((size_t) active_chans, sizeof(PROC_THREAD_INFO_m12));
		read_MED_thread_infos = (READ_MED_THREAD_INFO_m12 *) calloc((size_t) active_ts_chans, sizeof(READ_MED_THREAD_INFO_m12));
		search_mode = G_get_search_mode_m12(slice);
		thread_idx = 0;
		if (active_ts_chans) {
			calculate_channel_indices = FALSE_m12;
			if (globals_m12->time_series_frequencies_vary == TRUE_m12) {
				if (globals_m12->reference_channel->type_code == TIME_SERIES_CHANNEL_TYPE_m12) {
					if (search_mode == SAMPLE_SEARCH_m12) {
						calculate_channel_indices = TRUE_m12;
						ref_sf = globals_m12->reference_channel->segments[seg_idx]->metadata_fps->metadata->time_series_section_2.sampling_frequency;
					}
				}
			}
			for (i = 0; i < sess->number_of_time_series_channels; ++i) {
				chan = sess->time_series_channels[i];
				if (chan->flags & LH_CHANNEL_ACTIVE_m12) {
					if (calculate_channel_indices == TRUE_m12) {
						sf_ratio = chan->segments[seg_idx]->metadata_fps->metadata->time_series_section_2.sampling_frequency / ref_sf;
						chan->time_slice.start_sample_number = (si8) round((sf8) slice->start_sample_number * sf_ratio);
						chan->time_slice.end_sample_number = (si8) round((sf8) slice->end_sample_number * sf_ratio);
						chan->time_slice.start_time = chan->time_slice.end_time = UUTC_NO_ENTRY_m12;
					} else {
						chan->time_slice = *slice;
					}
					proc_thread_infos[thread_idx].thread_f = G_read_channel_thread_m12;
					proc_thread_infos[thread_idx].thread_label = "G_read_channel_thread_m12";
					proc_thread_infos[thread_idx].priority = PROC_HIGH_PRIORITY_m12;
					proc_thread_infos[thread_idx].arg = (void *) (read_MED_thread_infos + thread_idx);
					read_MED_thread_infos[thread_idx].MED_struct = (LEVEL_HEADER_m12 *) chan;
					++thread_idx;
				}
			}
		}
		if (active_vid_chans) {
			calculate_channel_indices = FALSE_m12;
			if (globals_m12->video_frame_rates_vary == TRUE_m12) {
				if (globals_m12->reference_channel->type_code == VIDEO_CHANNEL_TYPE_m12) {
					if (search_mode == SAMPLE_SEARCH_m12) {
						calculate_channel_indices = TRUE_m12;
						ref_sf = globals_m12->reference_channel->metadata_fps->metadata->video_section_2.frame_rate;
					}
				}
			}
			for (i = 0; i < sess->number_of_video_channels; ++i) {
				chan = sess->video_channels[i];
				if (chan->flags & LH_CHANNEL_ACTIVE_m12) {
					if (calculate_channel_indices == TRUE_m12) {
						sf_ratio = chan->metadata_fps->metadata->video_section_2.frame_rate / ref_sf;
						chan->time_slice.start_frame_number = (si8) round((sf8) slice->start_frame_number * sf_ratio);
						chan->time_slice.end_frame_number = (si8) round((sf8) slice->end_frame_number * sf_ratio);
						chan->time_slice.start_time = chan->time_slice.end_time = UUTC_NO_ENTRY_m12;
					} else {
						chan->time_slice = *slice;
					}
					proc_thread_infos[thread_idx].thread_f = G_read_channel_thread_m12;
					proc_thread_infos[thread_idx].thread_label = "G_read_channel_thread_m12";
					proc_thread_infos[thread_idx].priority = PROC_HIGH_PRIORITY_m12;
					proc_thread_infos[thread_idx].arg = (void *) (read_MED_thread_infos + thread_idx);
					read_MED_thread_infos[thread_idx].MED_struct = (LEVEL_HEADER_m12 *) chan;
					++thread_idx;
				}
			}
		}

		// thread out channel reads
		ret_val = PROC_distribute_jobs_m12(proc_thread_infos, active_chans, 0, TRUE_m12);  // no reserved cores, wait for completion

		// check results
		if (ret_val == TRUE_m12) {
			for (i = 0; i < active_chans; ++i)
				if (read_MED_thread_infos[i].MED_struct == NULL) {
					ret_val = FALSE_m12;
					break;
				}
		}
		free((void *) proc_thread_infos);
		free((void *) read_MED_thread_infos);
	} else {  // only one channel - not worth thread overhead (fairly common scenario)
		if (active_ts_chans) {
			for (i = 0; i < sess->number_of_time_series_channels; ++i) {
				chan = sess->time_series_channels[i];
				if (chan->flags & LH_CHANNEL_ACTIVE_m12)
					break;
			}
		} else {  // video channel
			for (i = 0; i < sess->number_of_video_channels; ++i) {
				chan = sess->video_channels[i];
				if (chan->flags & LH_CHANNEL_ACTIVE_m12)
					break;
			}
		}
		ret_val = TRUE_m12;
		chan = G_read_channel_m12(chan, slice);
		if (chan == NULL)
			ret_val = FALSE_m12;
	}

	if (ret_val == FALSE_m12) {
		if (free_session == TRUE_m12)
			G_free_session_m12(sess, TRUE_m12);
		G_warning_message_m12("%s(): error reading session\n", __FUNCTION__);
		return(NULL);
	}

	// update session slice
	chan = globals_m12->reference_channel;
	*slice = chan->time_slice;
	if (chan->type_code == LH_TIME_SERIES_CHANNEL_m12) {
		if (globals_m12->time_series_frequencies_vary == TRUE_m12)
			slice->start_sample_number = slice->end_sample_number = SAMPLE_NUMBER_NO_ENTRY_m12;
	} else if (chan->type_code == LH_VIDEO_CHANNEL_m12) {
		if (globals_m12->video_frame_rates_vary == TRUE_m12)
			slice->start_frame_number = slice->end_frame_number = FRAME_NUMBER_NO_ENTRY_m12;
	}

	// read session record data
	if (sess->flags & LH_READ_SESSION_RECORDS_MASK_m12)
		if (sess->record_indices_fps != NULL && sess->record_data_fps != NULL)
			G_read_record_data_m12((LEVEL_HEADER_m12 *) sess, slice, 0);
		
	// read segmented session record data
	ssr = sess->segmented_sess_recs;
	seg_idx = G_get_segment_index_m12(slice->start_segment_number);
	if (sess->flags & LH_READ_SEGMENTED_SESS_RECS_MASK_m12 && ssr != NULL) {
		for (i = slice->start_segment_number, j = seg_idx; i <= slice->end_segment_number; ++i, ++j) {
			// allocate new segment records
			if (ssr->record_indices_fps[j] == NULL && ssr->record_data_fps[j] == NULL) {
				G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, i);
				sprintf_m12(tmp_str, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, RECORD_INDICES_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12)
					ssr->record_indices_fps[j] = G_read_file_m12(ssr->record_indices_fps[j], tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) ssr, NULL, USE_GLOBAL_BEHAVIOR_m12);
				sprintf_m12(tmp_str, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, RECORD_DATA_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12)
					ssr->record_data_fps[j] = G_read_file_m12(ssr->record_data_fps[j], tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) ssr, NULL, USE_GLOBAL_BEHAVIOR_m12);
			}
			if (ssr->record_indices_fps[j] != NULL && ssr->record_data_fps[j] != NULL)
				G_read_record_data_m12((LEVEL_HEADER_m12 *) ssr, slice, i);
		}
	}
	
	// update ephemeral data  (session record ephemeral data updated on session / segment open)
	if (sess->flags & LH_GENERATE_EPHEMERAL_DATA_m12) {
		// time series ephemeral data
		for (i = 0; i < sess->number_of_time_series_channels; ++i) {
			chan = sess->time_series_channels[i];
			if (chan->flags & LH_CHANNEL_ACTIVE_m12) {
				G_merge_universal_headers_m12(sess->time_series_metadata_fps, chan->metadata_fps, NULL);
				G_merge_metadata_m12(sess->time_series_metadata_fps, chan->metadata_fps, NULL);
				chan->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m12;  // clear flag
			}
		}
		// video ephemeral data
		for (i = 0; i < sess->number_of_video_channels; ++i) {
			chan = sess->video_channels[i];
			if (chan->flags & LH_CHANNEL_ACTIVE_m12) {
				G_merge_universal_headers_m12(sess->video_metadata_fps, chan->metadata_fps, NULL);
				G_merge_metadata_m12(sess->video_metadata_fps, chan->metadata_fps, NULL);
				chan->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m12;  // clear flag
			}
		}
		// fix session ephemeral universal header (from merge functions)
		if (sess->number_of_time_series_channels) {
			uh = sess->time_series_metadata_fps->universal_header;
			uh->type_code = TIME_SERIES_METADATA_FILE_TYPE_CODE_m12;
			uh->segment_number = UNIVERSAL_HEADER_SESSION_LEVEL_CODE_m12;
			uh->session_UID = globals_m12->session_UID;
			uh->channel_UID = uh->segment_UID = UID_NO_ENTRY_m12;
		}
		if (sess->number_of_video_channels) {
			uh = sess->video_metadata_fps->universal_header;
			uh->type_code = VIDEO_METADATA_FILE_TYPE_CODE_m12;
			uh->segment_number = UNIVERSAL_HEADER_SESSION_LEVEL_CODE_m12;
			uh->session_UID = globals_m12->session_UID;
			uh->channel_UID = uh->segment_UID = UID_NO_ENTRY_m12;
		}
	}

	// verbose
	if (globals_m12->verbose == TRUE_m12) {
		if (sess->time_series_metadata_fps != NULL) {
			printf_m12("--------- Session Time Series Universal Header ---------\n");
			G_show_universal_header_m12(sess->time_series_metadata_fps, NULL);
			printf_m12("------------ Session Time Series Metadata --------------\n");
			G_show_metadata_m12(sess->time_series_metadata_fps, NULL, 0);
		}
		if (sess->video_metadata_fps != NULL) {
			printf_m12("------------ Session Video Universal Header ------------\n");
			G_show_universal_header_m12(sess->video_metadata_fps, NULL);
			printf_m12("--------------- Session Video Metadata -----------------\n");
			G_show_metadata_m12(sess->video_metadata_fps, NULL, 0);
		}
	}

	sess->last_access_time = G_current_uutc_m12();

	return(sess);
}


SESSION_m12	*G_read_session_nt_m12(SESSION_m12 *sess, TIME_SLICE_m12 *slice, ...)  // varargs: void *file_list, si4 list_len, ui8 flags, si1 *password
{
	TERN_m12			open_session, free_session, calculate_channel_indices;
	si1                             *password, num_str[FILE_NUMBERING_DIGITS_m12 + 1];
	si1				tmp_str[FULL_FILE_NAME_BYTES_m12];
	si4                             i, j, list_len, seg_idx, search_mode;
	ui8                             flags;
	sf8				ref_sf, sf_ratio;
	void				*file_list;
	va_list				args;
	CHANNEL_m12			*chan;
	UNIVERSAL_HEADER_m12		*uh;
	SEGMENTED_SESS_RECS_m12		*ssr;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// open session
	open_session = free_session = FALSE_m12;
	if (sess == NULL) {
		open_session = free_session = TRUE_m12;
	} else if (!(sess->flags & LH_OPEN_m12)) {
		G_free_session_m12(sess, FALSE_m12);
		open_session = TRUE_m12;
	}
	if (open_session == TRUE_m12) {
		// get varargs
		va_start(args, slice);
		file_list = va_arg(args, void *);
		list_len = va_arg(args, si4);
		flags = va_arg(args, ui8);
		password = va_arg(args, si1 *);
		va_end(args);
		// open session
		sess = G_open_session_nt_m12(sess, slice, file_list, list_len, flags, password);
		if (sess == NULL) {
			G_error_message_m12("%s(): error opening session\n", __FUNCTION__);
			return(NULL);
		}
	} else {  // process time slice (passed slice is not modified)
		if (slice == NULL) {
			if (G_all_zeros_m12((ui1 *) &sess->time_slice, (si4) sizeof(TIME_SLICE_m12)) == TRUE_m12)
				G_initialize_time_slice_m12(&sess->time_slice);  // read whole session
		} else {  // passed slice supersedes structure slice
			sess->time_slice = *slice;  // passed slice is not modified
		}
		if (sess->time_slice.conditioned == FALSE_m12)
			G_condition_time_slice_m12(slice);
	}
	slice = &sess->time_slice;
	
	// set global sample/frame number reference channel (before get segment range)
	if ((globals_m12->reference_channel->flags & LH_CHANNEL_ACTIVE_m12) == 0) {
		if (globals_m12->reference_channel->type_code == TIME_SERIES_CHANNEL_TYPE_m12)
			G_change_reference_channel_m12(sess, NULL, NULL, DEFAULT_TIME_SERIES_CHANNEL_m12);
		else
			G_change_reference_channel_m12(sess, NULL, NULL, DEFAULT_VIDEO_CHANNEL_m12);
	}

	// get segment range
	if (slice->number_of_segments == UNKNOWN_m12) {
		if (G_get_segment_range_m12((LEVEL_HEADER_m12 *) sess, slice) == 0) {
			if (free_session == TRUE_m12)
				G_free_session_m12(sess, TRUE_m12);
			return(NULL);
		}
	}
	seg_idx = G_get_segment_index_m12(slice->start_segment_number);
	if (seg_idx == FALSE_m12) {
		if (free_session == TRUE_m12)
			G_free_session_m12(sess, TRUE_m12);
		return(NULL);
	}

	// update for variable frequencies on active channel set
	G_frequencies_vary_m12(sess);
	search_mode = G_get_search_mode_m12(slice);

	// read time series channels
	calculate_channel_indices = FALSE_m12;
	if (globals_m12->time_series_frequencies_vary == TRUE_m12) {
		if (globals_m12->reference_channel->type_code == TIME_SERIES_CHANNEL_TYPE_m12) {
			if (search_mode == SAMPLE_SEARCH_m12) {
				calculate_channel_indices = TRUE_m12;
				ref_sf = globals_m12->reference_channel->metadata_fps->metadata->time_series_section_2.sampling_frequency;
			}
		}
	}
	for (i = 0; i < sess->number_of_time_series_channels; ++i) {
		chan = sess->time_series_channels[i];
		if (chan->flags & LH_CHANNEL_ACTIVE_m12) {
			if (calculate_channel_indices == TRUE_m12) {
				sf_ratio = chan->metadata_fps->metadata->time_series_section_2.sampling_frequency / ref_sf;
				chan->time_slice.start_sample_number = (si8) round((sf8) slice->start_sample_number * sf_ratio);
				chan->time_slice.end_sample_number = (si8) round((sf8) slice->end_sample_number * sf_ratio);
				chan->time_slice.start_time = chan->time_slice.end_time = UUTC_NO_ENTRY_m12;
			} else {
				chan->time_slice = *slice;
			}
			if (G_read_channel_nt_m12(chan, NULL) == NULL) {
				if (free_session == TRUE_m12) {
					G_free_session_m12(sess, TRUE_m12);
				} else if (chan != NULL) {
					if (chan->time_slice.number_of_segments == EMPTY_SLICE_m12)
						sess->time_slice.number_of_segments = EMPTY_SLICE_m12;
				}
				return(NULL);
			}
		}
	}

	// read video channels
	calculate_channel_indices = FALSE_m12;
	if (globals_m12->time_series_frequencies_vary == TRUE_m12) {
		if (globals_m12->reference_channel->type_code == VIDEO_CHANNEL_TYPE_m12) {
			if (search_mode == FRAME_SEARCH_m12) {
				calculate_channel_indices = TRUE_m12;
				ref_sf = globals_m12->reference_channel->metadata_fps->metadata->video_section_2.frame_rate;
			}
		}
	}
	for (i = 0; i < sess->number_of_video_channels; ++i) {
		chan = sess->video_channels[i];
		if (chan->flags & LH_CHANNEL_ACTIVE_m12) {
			if (calculate_channel_indices == TRUE_m12) {
				sf_ratio = chan->metadata_fps->metadata->video_section_2.frame_rate / ref_sf;
				chan->time_slice.start_frame_number = (si8) round((sf8) slice->start_frame_number * sf_ratio);
				chan->time_slice.end_frame_number = (si8) round((sf8) slice->end_frame_number * sf_ratio);
				chan->time_slice.start_time = chan->time_slice.end_time = UUTC_NO_ENTRY_m12;
			} else {
				chan->time_slice = *slice;
			}
			if (G_read_channel_nt_m12(chan, NULL) == NULL) {
				if (free_session == TRUE_m12) {
					G_free_session_m12(sess, TRUE_m12);
				} else if (chan != NULL) {
					if (chan->time_slice.number_of_segments == EMPTY_SLICE_m12)
						sess->time_slice.number_of_segments = EMPTY_SLICE_m12;
				}
				return(NULL);
			}
		}
	}

	// update session slice
	*slice = globals_m12->reference_channel->time_slice;
	if (globals_m12->time_series_frequencies_vary == TRUE_m12)
		slice->start_sample_number = slice->end_sample_number = SAMPLE_NUMBER_NO_ENTRY_m12;

	// read session record data
	if (sess->flags & LH_READ_SESSION_RECORDS_MASK_m12)
		if (sess->record_indices_fps != NULL && sess->record_data_fps != NULL)
			G_read_record_data_m12((LEVEL_HEADER_m12 *) sess, slice);

	// read segmented session record data
	ssr = sess->segmented_sess_recs;
	if (sess->flags & LH_READ_SEGMENTED_SESS_RECS_MASK_m12 && ssr != NULL) {
		for (i = slice->start_segment_number, j = seg_idx; i <= slice->end_segment_number; ++i, ++j) {
			// allocate new segment records
			if (ssr->record_indices_fps[j] == NULL && ssr->record_data_fps[j] == NULL) {
				G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, i);
				sprintf_m12(tmp_str, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, RECORD_INDICES_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12)
					ssr->record_indices_fps[j] = G_read_file_m12(ssr->record_indices_fps[j], tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) ssr, NULL, USE_GLOBAL_BEHAVIOR_m12);
				sprintf_m12(tmp_str, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, RECORD_DATA_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_str) == FILE_EXISTS_m12)
					ssr->record_data_fps[j] = G_read_file_m12(ssr->record_data_fps[j], tmp_str, 0, 0, 0, (LEVEL_HEADER_m12 *) ssr, NULL, USE_GLOBAL_BEHAVIOR_m12);
			}
			if (ssr->record_indices_fps[j] != NULL && ssr->record_data_fps[j] != NULL)
				G_read_record_data_m12((LEVEL_HEADER_m12 *) ssr, slice, i);
		}
	}
	
	// update ephemeral data (session record ephemeral data updated on session / segment open)
	if (sess->flags & LH_GENERATE_EPHEMERAL_DATA_m12) {
		// time series ephemeral data
		for (i = 0; i < sess->number_of_time_series_channels; ++i) {
			chan = sess->time_series_channels[i];
			if (chan->flags & LH_CHANNEL_ACTIVE_m12) {
				G_merge_universal_headers_m12(sess->time_series_metadata_fps, chan->metadata_fps, NULL);
				G_merge_metadata_m12(sess->time_series_metadata_fps, chan->metadata_fps, NULL);
				chan->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m12;  // clear flag
			}
		}
		// video ephemeral data
		for (i = 0; i < sess->number_of_video_channels; ++i) {
			chan = sess->video_channels[i];
			if (chan->flags & LH_CHANNEL_ACTIVE_m12) {
				G_merge_universal_headers_m12(sess->video_metadata_fps, chan->metadata_fps, NULL);
				G_merge_metadata_m12(sess->video_metadata_fps, chan->metadata_fps, NULL);
				chan->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m12;  // clear flag
			}
		}
		// fix session ephemeral universal header (from merge functions)
		if (sess->number_of_time_series_channels) {
			uh = sess->time_series_metadata_fps->universal_header;
			uh->type_code = TIME_SERIES_METADATA_FILE_TYPE_CODE_m12;
			uh->segment_number = UNIVERSAL_HEADER_SESSION_LEVEL_CODE_m12;
			uh->session_UID = globals_m12->session_UID;
			uh->channel_UID = uh->segment_UID = UID_NO_ENTRY_m12;
		}
		if (sess->number_of_video_channels) {
			uh = sess->video_metadata_fps->universal_header;
			uh->type_code = VIDEO_METADATA_FILE_TYPE_CODE_m12;
			uh->segment_number = UNIVERSAL_HEADER_SESSION_LEVEL_CODE_m12;
			uh->session_UID = globals_m12->session_UID;
			uh->channel_UID = uh->segment_UID = UID_NO_ENTRY_m12;
		}
	}
	
	// verbose
	if (globals_m12->verbose == TRUE_m12) {
		if (sess->time_series_metadata_fps != NULL) {
			printf_m12("--------- Session Time Series Universal Header ---------\n");
			G_show_universal_header_m12(sess->time_series_metadata_fps, NULL);
			printf_m12("------------ Session Time Series Metadata --------------\n");
			G_show_metadata_m12(sess->time_series_metadata_fps, NULL, 0);
		}
		if (sess->video_metadata_fps != NULL) {
			printf_m12("------------ Session Video Universal Header ------------\n");
			G_show_universal_header_m12(sess->video_metadata_fps, NULL);
			printf_m12("--------------- Session Video Metadata -----------------\n");
			G_show_metadata_m12(sess->video_metadata_fps, NULL, 0);
		}
	}

	sess->last_access_time = G_current_uutc_m12();

	return(sess);
}


si8     G_read_time_series_data_m12(SEGMENT_m12 *seg, TIME_SLICE_m12 *slice)
{
	TERN_m12				cps_caching, scale;
	ui4					cached_block_samples;
	si4					cached_block_cnt, *to_ptr, *from_ptr, *si4_p, to_idx, from_idx;
	si4					first_cached_block, first_cached_block_idx, last_cached_block, last_cached_block_idx;
	si8                                     i, j, terminal_ts_ind, n_samps, n_blocks, start_offset;
	si8                                     start_block, end_block, read_start_block, read_end_block, read_n_blocks, compressed_data_bytes;
	si8					local_start_idx, local_end_idx, seg_start_samp_num, n_cached_samples, cache_offset;
	sf8					scale_factor;
	CMP_CACHE_BLOCK_INFO_m12		*cached_blocks;
	FILE_PROCESSING_STRUCT_m12		*tsd_fps, *tsi_fps;
	TIME_SERIES_INDEX_m12			*tsi;
	TIME_SERIES_METADATA_SECTION_2_m12	*tmd2;
	CMP_PROCESSING_STRUCT_m12		*cps;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (seg == NULL) {
		G_error_message_m12("%s(): SEGMENT_m12 structure is NULL\n", __FUNCTION__);
		return(-1);
	}
	if ((tsd_fps = seg->time_series_data_fps) == NULL) {
		G_error_message_m12("%s(): time series data FILE_PROCESSING_STRUCT_m12 is NULL\n", __FUNCTION__);
		return(-1);
	}
	if ((tsi_fps = seg->time_series_indices_fps) == NULL) {
		G_error_message_m12("%s(): time series indices FILE_PROCESSING_STRUCT_m12 is NULL\n", __FUNCTION__);
		return(-1);
	}
	if (seg->flags & LH_NO_CPS_PTR_RESET_m12){
		G_error_message_m12("%s(): CPS pointer resets are required for this function \n", __FUNCTION__);
		return(-1);
	}
	
	// find start and end blocks (block index is for block containing sample index)
	tsi = tsi_fps->time_series_indices;
	seg_start_samp_num = seg->metadata_fps->metadata->time_series_section_2.absolute_start_sample_number;
	start_block = G_find_index_m12(seg, slice->start_sample_number, SAMPLE_SEARCH_m12);
	if (start_block < 0) {  // before first block
		start_block = 0;
		local_start_idx = 0;
	} else {
		local_start_idx = slice->start_sample_number - seg_start_samp_num;
	}
	terminal_ts_ind = tsi_fps->universal_header->number_of_entries - 1;
	end_block = G_find_index_m12(seg, slice->end_sample_number, SAMPLE_SEARCH_m12);
	if (end_block == terminal_ts_ind) {  // after last block (points to terminal index)
		local_end_idx = tsi[end_block].start_sample_number - 1;  // terminal index start_sample_number (== total samples in segment)
		end_block = terminal_ts_ind - 1;  // index of last true block
	} else {
		local_end_idx = slice->end_sample_number - seg_start_samp_num;
	}
	n_blocks = (end_block - start_block) + 1;

	// allocate cps
	n_samps = tsi[end_block + 1].start_sample_number - tsi[start_block].start_sample_number;
	start_offset = REMOVE_DISCONTINUITY_m12(tsi[start_block].file_offset);
	tmd2 = &seg->metadata_fps->metadata->time_series_section_2;
	cached_block_cnt = 0;
	read_start_block = start_block;
	read_end_block = end_block;
	if (tsd_fps->parameters.cps == NULL) {
		compressed_data_bytes = REMOVE_DISCONTINUITY_m12(tsi[end_block + 1].file_offset) - start_offset;
		cps = CMP_allocate_processing_struct_m12(tsd_fps, CMP_DECOMPRESSION_MODE_m12, n_samps, compressed_data_bytes, tmd2->maximum_block_keysample_bytes, tmd2->maximum_block_samples, NULL, NULL);
		if ((cps_caching = cps->directives.cps_caching) == TRUE_m12) {
			cached_blocks = cps->parameters.cached_blocks = (CMP_CACHE_BLOCK_INFO_m12 *) calloc_m12((size_t) n_blocks, sizeof(CMP_CACHE_BLOCK_INFO_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			cps->parameters.cached_block_list_len = n_blocks;
		}
	} else {
		cps = tsd_fps->parameters.cps;
		cps_caching = cps->directives.cps_caching;
		if (cps_caching == TRUE_m12) {
			if (cps->parameters.cached_block_list_len < n_blocks) {
				cps->parameters.cached_blocks = (CMP_CACHE_BLOCK_INFO_m12 *) realloc_m12((void *) cps->parameters.cached_blocks, (size_t) n_blocks * sizeof(CMP_CACHE_BLOCK_INFO_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
				cps->parameters.cached_block_list_len = n_blocks;
			}
			cached_blocks = cps->parameters.cached_blocks;
			cached_block_cnt = cps->parameters.cached_block_cnt;
			if (cached_block_cnt) {
				// reallocate cache manually so CMP_reallocate_processing_struct_m12() does not free
				if (n_samps > cps->parameters.allocated_decompressed_samples) {
					cps->decompressed_data = cps->parameters.cache = (si4 *) realloc_m12((void *) cps->parameters.cache, n_samps * sizeof(si4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
					cps->parameters.allocated_decompressed_samples = n_samps;
				}
				first_cached_block = cached_blocks[0].block_number;
				last_cached_block = cached_blocks[cached_block_cnt - 1].block_number;
				if (first_cached_block <= end_block && last_cached_block >= start_block) {
					last_cached_block_idx = end_block - first_cached_block;
					if (last_cached_block_idx >= cached_block_cnt)
						last_cached_block_idx = cached_block_cnt - 1;
					last_cached_block = cached_blocks[last_cached_block_idx].block_number;
					first_cached_block_idx = start_block - first_cached_block;
					if (first_cached_block_idx < 0)
						first_cached_block_idx = 0;
					first_cached_block = cached_blocks[first_cached_block_idx].block_number;
					cached_block_cnt = (last_cached_block - first_cached_block) + 1;
					// full request is cached (don't update cache until there's at least one uncached block)
					if (first_cached_block <= start_block && last_cached_block >= end_block) {  // full request is cached
						cache_offset = cached_blocks[first_cached_block_idx].cache_offset + (local_start_idx - tsi[start_block].start_sample_number);
						cps->decompressed_ptr = cps->decompressed_data = cps->parameters.cache + cache_offset;
						n_samps = (local_end_idx - local_start_idx) + 1;
						return(n_samps);
					}
					// shift samples
					to_ptr = cps->parameters.cache + (tsi[first_cached_block].start_sample_number - tsi[start_block].start_sample_number);
					from_ptr = cps->parameters.cache + cached_blocks[first_cached_block_idx].cache_offset;
					n_cached_samples = (cached_blocks[last_cached_block_idx].cache_offset + (si8) cached_blocks[last_cached_block_idx].block_samples) - cached_blocks[first_cached_block_idx].cache_offset;
					if (to_ptr > from_ptr) {  // right shift (move backwards)
						to_ptr += n_cached_samples;
						from_ptr += n_cached_samples;
						for (i = n_cached_samples; i--;)
							*--to_ptr = *--from_ptr;
					} else if (to_ptr < from_ptr) {  // left shift (move forwards)
						for (i = n_cached_samples; i--;)
							*to_ptr++ = *from_ptr++;
					}  // else don't move anything
					// shift cached block infos
					to_idx = first_cached_block - start_block;
					from_idx = first_cached_block_idx;
					first_cached_block_idx = to_idx;
					last_cached_block_idx = (first_cached_block_idx + cached_block_cnt) - 1;
					if (to_idx > from_idx) {  // right shift (move backwards)
						to_idx += cached_block_cnt;
						from_idx += cached_block_cnt;
						for (i = 0; i < cached_block_cnt; ++i)
							cached_blocks[--to_idx] = cached_blocks[--from_idx];
					} else if (to_idx < from_idx) {  // left shift (move forwards)
						for (i = 0; i < cached_block_cnt; ++i)
							cached_blocks[to_idx++] = cached_blocks[from_idx++];
					}  // else don't move anything
					// set uncached blocks to zero samples (used as flag to cache)
					for (i = 0; i < first_cached_block_idx; ++i)
						cached_blocks[i].block_samples = 0;
					for (i = last_cached_block_idx + 1; i < n_blocks; ++i)
						cached_blocks[i].block_samples = 0;
					// full request is cached (cache updated here)
				} else {
					cached_block_cnt = 0;  // none of requested blocks in requested range
				}
			}
		}
		// limit read, if possible (if cached blocks are in middle, they are read - but this should be uncommon)
		if (cached_block_cnt) {
			if (first_cached_block == start_block) {
				read_start_block = last_cached_block + 1;
				for (i = 0; i <= last_cached_block_idx; ++i)
					cached_blocks[i].data_read = FALSE_m12;
				for (; i < n_blocks; ++i)
					cached_blocks[i].data_read = TRUE_m12;
			} else if (last_cached_block == end_block) {
				read_end_block = first_cached_block - 1;
				for (i = 0; i < first_cached_block_idx; ++i)
					cached_blocks[i].data_read = TRUE_m12;
				for (; i < n_blocks; ++i)
					cached_blocks[i].data_read = FALSE_m12;
			} else {
				for (i = 0; i < n_blocks; ++i)
					cached_blocks[i].data_read = FALSE_m12;
			}
			start_offset = REMOVE_DISCONTINUITY_m12(tsi[read_start_block].file_offset);
			compressed_data_bytes = REMOVE_DISCONTINUITY_m12(tsi[read_end_block + 1].file_offset) - start_offset;
		} else {
			start_offset = REMOVE_DISCONTINUITY_m12(tsi[start_block].file_offset);
			compressed_data_bytes = REMOVE_DISCONTINUITY_m12(tsi[end_block + 1].file_offset) - start_offset;
		}
		CMP_update_CPS_pointers_m12(tsd_fps, CMP_RESET_DECOMPRESSED_PTR_m12 | CMP_RESET_BLOCK_HEADER_PTR_m12);
		cps = CMP_reallocate_processing_struct_m12(tsd_fps, CMP_DECOMPRESSION_MODE_m12, n_samps, tmd2->maximum_block_samples);
	}

	// read in compressed data
	read_n_blocks = (read_end_block - read_start_block) + 1;
	G_read_file_m12(tsd_fps, NULL, start_offset, compressed_data_bytes, read_n_blocks, (LEVEL_HEADER_m12 *) seg, NULL, USE_GLOBAL_BEHAVIOR_m12);

	// set limit on first block
	cps->parameters.block_start_index = local_start_idx - tsi[start_block].start_sample_number;
	
	scale = FALSE_m12;
	if (cps->directives.convert_to_native_units == TRUE_m12) {
		scale_factor = tmd2->amplitude_units_conversion_factor;
		if (scale_factor != 1.0 && scale_factor != TIME_SERIES_METADATA_AMPLITUDE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m12)
			scale = TRUE_m12;
	}
		
	// loop over blocks
	cache_offset = 0;
	cps->decompressed_ptr = cps->parameters.cache;
	for (i = 0, j = start_block; i < n_blocks; ++i, ++j) {
		if (cached_block_cnt) {
			if ((cached_block_samples = cached_blocks[i].block_samples)) {
				cps->decompressed_ptr += cached_block_samples;
				if (cached_blocks[i].data_read == TRUE_m12)  // data read because in middle, but block is still cached
					CMP_update_CPS_pointers_m12(tsd_fps, CMP_UPDATE_BLOCK_HEADER_PTR_m12);
				cached_blocks[i].cache_offset = cache_offset;
				cache_offset += cached_block_samples;
				continue;
			}
		}
		// set limit on last block
		if (j == end_block)
			cps->parameters.block_end_index = local_end_idx - tsi[j].start_sample_number;
		CMP_decode_m12(tsd_fps);

		if (cps_caching == TRUE_m12) {
			cached_blocks[i].cache_offset = cache_offset;
			cached_blocks[i].block_samples = cps->block_header->number_of_samples;
			cache_offset += cached_blocks[i].block_samples;
			cached_blocks[i].block_number = j;
		}
		if (scale == TRUE_m12) {  // scale to native units
			i = cps->block_header->number_of_samples;
			si4_p = cps->decompressed_ptr;
			while (i--) {
				*si4_p = CMP_round_si4_m12((sf8) *si4_p * scale_factor);
				++si4_p;
			}
		}
		CMP_update_CPS_pointers_m12(tsd_fps, CMP_UPDATE_BLOCK_HEADER_PTR_m12 | CMP_UPDATE_DECOMPRESSED_PTR_m12);
	}
	
	if (cps_caching == TRUE_m12)
		cps->parameters.cached_block_cnt = n_blocks;  // all blocks now cached
		
	n_samps = (local_end_idx - local_start_idx) + 1;  // trim (it did contain total samps in blocks)
	
	return(n_samps);
}


TERN_m12    G_recover_passwords_m12(si1 *L3_password, UNIVERSAL_HEADER_m12 *universal_header)
{
	TERN_m12	level_1_valid;
	ui1     	hash[SHA_HASH_BYTES_m12], L3_hash[SHA_HASH_BYTES_m12];
	si1     	L3_password_bytes[PASSWORD_BYTES_m12], hex_str[HEX_STRING_BYTES_m12(PASSWORD_BYTES_m12)];
	si1     	saved_L1_password_bytes[PASSWORD_BYTES_m12], putative_L1_password_bytes[PASSWORD_BYTES_m12], putative_L2_password_bytes[PASSWORD_BYTES_m12];
	si4     	i;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (G_check_password_m12(L3_password) == FALSE_m12)
		return(FALSE_m12);
	
	// get terminal bytes
	G_extract_terminal_password_bytes_m12(L3_password, L3_password_bytes);
	
	// get level 3 password hash
	SHA_hash_m12((ui1 *) L3_password_bytes, PASSWORD_BYTES_m12, L3_hash);  // generate SHA-256 hash of level 3 password bytes
	
	// check for level 1 access
	for (i = 0; i < PASSWORD_BYTES_m12; ++i)  // xor with level 3 password validation field
		putative_L1_password_bytes[i] = L3_hash[i] ^ universal_header->level_3_password_validation_field[i];
	
	SHA_hash_m12((ui1 *) putative_L1_password_bytes, PASSWORD_BYTES_m12, hash); // generate SHA-256 hash of putative level 1 password
	
	for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m12; ++i)  // compare with stored level 1 hash
		if (hash[i] != universal_header->level_1_password_validation_field[i])
			break;
	level_1_valid = FALSE_m12;
	if (i == PASSWORD_VALIDATION_FIELD_BYTES_m12) {  // Level 1 password recovered
		memcpy(saved_L1_password_bytes, putative_L1_password_bytes, PASSWORD_BYTES_m12);
		level_1_valid = TRUE_m12;
	}
	
	// check for level 2 password (may be same password for both levels)
	memcpy(putative_L2_password_bytes, putative_L1_password_bytes, PASSWORD_BYTES_m12);
	for (i = 0; i < PASSWORD_BYTES_m12; ++i)  // xor with level 2 password validation field
		putative_L1_password_bytes[i] = hash[i] ^ universal_header->level_2_password_validation_field[i];
	
	SHA_hash_m12((ui1 *) putative_L1_password_bytes, PASSWORD_BYTES_m12, hash); // generate SHA-256 hash of putative level 1 password
	
	for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m12; ++i)  // compare with stored level 1 hash
		if (hash[i] != universal_header->level_1_password_validation_field[i])
			break;
	
	// Level 2 password valid
	if (i == PASSWORD_VALIDATION_FIELD_BYTES_m12) {
		STR_generate_hex_string_m12((ui1 *) putative_L1_password_bytes, PASSWORD_BYTES_m12, hex_str);
		G_message_m12("Level 1 password (bytes): '%s' (%s)\n", putative_L1_password_bytes, hex_str);
		STR_generate_hex_string_m12((ui1 *) putative_L2_password_bytes, PASSWORD_BYTES_m12, hex_str);
		G_message_m12("Level 2 password (bytes): '%s' (%s)\n", putative_L2_password_bytes, hex_str);
	} else if (level_1_valid == TRUE_m12) {
		STR_generate_hex_string_m12((ui1 *) saved_L1_password_bytes, PASSWORD_BYTES_m12, hex_str);
		G_message_m12("Level 1 password (bytes): '%s' (%s)\n", saved_L1_password_bytes, hex_str);
		G_message_m12("No Level 2 password\n");
	} else {
		G_warning_message_m12("%s(): the level 3 password is not valid for recovery\n", __FUNCTION__, __LINE__);
		return(FALSE_m12);
	}
	
	return(TRUE_m12);
}

#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
TERN_m12	G_remove_path_m12(si1 *path)
{
	si1	command[FULL_FILE_NAME_BYTES_m12 + 8];
	si4	fe, ret_val;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	fe = G_file_exists_m12(path);
	
	if (fe == FILE_EXISTS_m12) {
		
		#if defined MACOS_m12 || defined LINUX_m12
		sprintf_m12(command, "rm -f \"%s\"", path);
		#endif
		#ifdef WINDOWS_m12
		sprintf_m12(command, "del \"%s\"", path);
		#endif
		ret_val = system_m12(command, TRUE_m12, __FUNCTION__, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12);
		if (ret_val) {
			G_warning_message_m12("%s(): could not remove file \"%s\"\n", __FUNCTION__, path);
			return(FALSE_m12);
		}
		
		return(TRUE_m12);
	} else if (fe == DIR_EXISTS_m12) {
		#if defined MACOS_m12 || defined LINUX_m12
		sprintf_m12(command, "rm -Rf \"\"%s", path);
		#endif
		#ifdef WINDOWS_m12
		sprintf_m12(command, "rmdir \\/s \\/q \"%s\"", path);
		#endif
		ret_val = system_m12(command, TRUE_m12, __FUNCTION__, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12);
		if (ret_val) {
			G_warning_message_m12("%s(): could not remove directory \"%s\"\n", __FUNCTION__, path);
			return(FALSE_m12);
		}

		return(TRUE_m12);
	}
	
	return(TRUE_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	G_remove_recording_time_offset_m12(si8 *time)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (*time != UUTC_NO_ENTRY_m12)
		*time += globals_m12->recording_time_offset;
	
	return;
}


void    G_reset_metadata_for_update_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	TIME_SERIES_METADATA_SECTION_2_m12	*tmd2;
	VIDEO_METADATA_SECTION_2_m12		*vmd2;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// section 2 fields
	switch (fps->universal_header->type_code) {
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
			tmd2 = &fps->metadata->time_series_section_2;
			tmd2->number_of_samples = 0;
			tmd2->number_of_blocks = 0;
			tmd2->maximum_block_bytes = 0;
			tmd2->maximum_block_samples = 0;
			tmd2->maximum_block_keysample_bytes = 0;
			tmd2->maximum_block_duration = 0;
			tmd2->number_of_discontinuities = 0;
			tmd2->maximum_contiguous_blocks = 0;
			tmd2->maximum_contiguous_block_bytes = 0;
			tmd2->maximum_contiguous_samples = 0;
			break;
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
			vmd2 = &fps->metadata->video_section_2;
			vmd2->number_of_frames = 0;
			vmd2->number_of_clips = 0;
			vmd2->maximum_clip_bytes = 0;
			vmd2->maximum_clip_frames = 0;
			vmd2->number_of_video_files = 0;
			vmd2->maximum_clip_duration = 0.0;
			vmd2->number_of_discontinuities = 0;
			vmd2->maximum_contiguous_clips = 0;
			vmd2->maximum_contiguous_clip_bytes = 0;
			vmd2->maximum_contiguous_frames = 0;
			break;
		default:
			G_error_message_m12("%s(): Unrecognized metadata type in file \"%s\"\n", __FUNCTION__, fps->full_file_name);
			break;
	}
	
	return;
}


si8     G_sample_number_for_uutc_m12(LEVEL_HEADER_m12 *level_header, si8 target_uutc, ui4 mode, ...)  // varargs: si8 ref_sample_number, si8 ref_uutc, sf8 sampling_frequency
{
	si1			tmp_str[FULL_FILE_NAME_BYTES_m12], num_str[FILE_NUMBERING_DIGITS_m12 + 1];
	si4			seg_num, seg_idx;
	si8                     n_inds, i, absolute_numbering_offset;
	si8			ref_sample_number, ref_uutc, test_time;
	sf8                     tmp_sf8, sampling_frequency, rounded_samp_num, samp_num_eps;
	ui4			mask;
	va_list			args;
	TIME_SERIES_INDEX_m12	*tsi;
	SEGMENT_m12		*seg;
	CHANNEL_m12		*chan;
	SESSION_m12		*sess;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// G_sample_number_for_uutc_m12(NULL, si8 target_uutc, ui4 mode, si8 ref_index, si8 ref_uutc, sf8 sampling_frequency);
	// returns sample number extrapolated from ref_index (relative / absolute is determined by magnitude of reference values)
	
	// G_sample_number_for_uutc_m12(seg, target_uutc, mode);
	// returns sample number extrapolated from closest time series index in reference frame specified by mode
	
	// mode FIND_ABSOLUTE_m12 (default): session (or reference) relative sample numbering
	// mode FIND_RELATIVE_m12: segment relative sample numbering
	// mode FIND_CURRENT_m12 (default): sample period within which the target_uutc falls
	// mode FIND_CLOSEST_m12: sample number closest to the target_uutc
	// mode FIND_NEXT_m12: sample number following the sample period within which the target_uutc falls ( == FIND_CURRENT_m12 + 1)
	// mode FIND_PREVIOUS_m12: sample number preceding the sample period within which the target_uutc falls ( == FIND_CURRENT_m12 - 1)

	if (level_header == NULL) {  // reference points passed
		va_start(args, mode);
		ref_sample_number = va_arg(args, si8);
		ref_uutc = va_arg(args, si8);
		sampling_frequency = va_arg(args, sf8);
		va_end(args);
		absolute_numbering_offset = 0;
		tsi = NULL;
	} else {  // level header passed
		switch (level_header->type_code) {
			case LH_TIME_SERIES_SEGMENT_m12:
				seg = (SEGMENT_m12 *) level_header;
				break;
			case LH_TIME_SERIES_CHANNEL_m12:
			case LH_SESSION_m12:
				seg_num = G_segment_for_uutc_m12(level_header, target_uutc);
				seg_idx = G_get_segment_index_m12(seg_num);
				if (seg_idx == FALSE_m12)
					return(SAMPLE_NUMBER_NO_ENTRY_m12);
				if (level_header->type_code == LH_TIME_SERIES_CHANNEL_m12) {
					chan = (CHANNEL_m12 *) level_header;
				} else {  // SESSION_m12
					chan = globals_m12->reference_channel;
					if (chan->type_code != LH_TIME_SERIES_CHANNEL_m12) {
						sess = (SESSION_m12 *) level_header;
						chan = sess->time_series_channels[0];
					}
				}
				seg = chan->segments[seg_idx];
				break;
			case LH_VIDEO_CHANNEL_m12:
			case LH_VIDEO_SEGMENT_m12:
				return(G_frame_number_for_uutc_m12(level_header, target_uutc, mode));
			default:
				G_warning_message_m12("%s(): invalid level type\n", __FUNCTION__);
				return(SAMPLE_NUMBER_NO_ENTRY_m12);
		}
		
		if (seg == NULL) {  // channel or session
			G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, seg_num);
			sprintf_m12(tmp_str, "%s/%s_s%s.%s", chan->path, chan->name, num_str, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12);
			seg = chan->segments[seg_idx] = G_open_segment_m12(NULL, NULL, tmp_str, chan->flags, NULL);
		} else if (!(seg->flags & LH_OPEN_m12)) {  // closed segment
			G_open_segment_m12(seg, NULL, NULL, seg->flags, NULL);
		}
		if (seg == NULL) {
			G_warning_message_m12("%s(): can't open segment\n", __FUNCTION__);
			return(SAMPLE_NUMBER_NO_ENTRY_m12);
		}

		tsi = seg->time_series_indices_fps->time_series_indices;
		if (tsi == NULL) {
			G_warning_message_m12("%s(): time series indices are NULL => returning SAMPLE_NUMBER_NO_ENTRY_m12\n", __FUNCTION__);
			return(SAMPLE_NUMBER_NO_ENTRY_m12);
		}
		n_inds = seg->time_series_indices_fps->universal_header->number_of_entries - 1;  // account for terminal index here - cleaner code below
		if (mode & FIND_RELATIVE_m12)
			absolute_numbering_offset = 0;
		else  // FIND_ABSOLUTE_m12 (default)
			absolute_numbering_offset = seg->metadata_fps->metadata->time_series_section_2.absolute_start_sample_number;
		
		// condition target
		if (target_uutc < 0)  // relative time
			target_uutc = globals_m12->session_start_time - target_uutc;
		test_time = target_uutc - globals_m12->recording_time_offset;
		if (test_time > 0 && target_uutc != END_OF_TIME_m12)  // END_OF_TIME_m12 is not offset
			target_uutc = test_time;

		// get index
		i = G_find_index_m12(seg, target_uutc, TIME_SEARCH_m12);
		if (i == -1)  // target time earlier than segment start => return segment start sample
			return(absolute_numbering_offset);

		ref_sample_number = (tsi += i)->start_sample_number;
		if (i == n_inds)  // target time later than segment end => return segment end sample number
			return((ref_sample_number - 1) + absolute_numbering_offset);
		ref_uutc = tsi->start_time;

		sampling_frequency = seg->metadata_fps->metadata->time_series_section_2.sampling_frequency;
	}
	
	// round up if very close to next sample
	tmp_sf8 = ((sf8) (target_uutc - ref_uutc) / (sf8) 1e6) * sampling_frequency;
	rounded_samp_num = (sf8) ((si8) (tmp_sf8 + (sf8) 0.5));
	samp_num_eps = rounded_samp_num - tmp_sf8;
	if (samp_num_eps > (sf8) 0.0)
		if (samp_num_eps < SAMPLE_NUMBER_EPS_m12)
			tmp_sf8 = rounded_samp_num;
	
	mask = (ui4) (FIND_CLOSEST_m12 | FIND_NEXT_m12 | FIND_CURRENT_m12 | FIND_PREVIOUS_m12);
	switch (mode & mask) {
		case FIND_CLOSEST_m12:
			tmp_sf8 += (sf8) 0.5;
			break;
		case FIND_NEXT_m12:
			tmp_sf8 += (sf8) 1.0;
			break;
		case FIND_PREVIOUS_m12:
			if (tmp_sf8 >= (sf8) 1.0)
				tmp_sf8 -= (sf8) 1.0;
			break;
		case FIND_CURRENT_m12:
		default:
			break;
	}

	return(ref_sample_number + (si8) tmp_sf8 + absolute_numbering_offset);
}


si4	G_search_Sgmt_records_m12(Sgmt_RECORD_m12 *Sgmt_records, TIME_SLICE_m12 *slice, ui4 search_mode)
{
	si1				seg_name[SEGMENT_BASE_FILE_NAME_BYTES_m12], md_file[FULL_FILE_NAME_BYTES_m12], num_str[FILE_NUMBERING_DIGITS_m12 + 1];
	si4				i, idx, low_idx, high_idx;
	si8				target;
	CHANNEL_m12			*chan;
	FILE_PROCESSING_STRUCT_m12	*md_fps;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Note: this may seem like overkill, that a simple forward linear search would suffice,
	// but in theory there can be a large number of non-uniformly spaced segments.
	
	if (search_mode == TIME_SEARCH_m12) {
		// start segment
		target = slice->start_time;
		low_idx = 0;
		high_idx = globals_m12->number_of_session_segments - 1;
		if (target > Sgmt_records[high_idx].end_time) {
			slice->start_segment_number = SEGMENT_NUMBER_NO_ENTRY_m12;
			G_warning_message_m12("%s(): requested start time is after session end\n", __FUNCTION__);
			idx = 0;
		} else {
			if (target < Sgmt_records[0].start_time) {
				idx = 0;
			} else {
				do {  // binary search
					idx = (low_idx + high_idx) >> 1;
					if (Sgmt_records[idx].start_time > target)
						high_idx = idx;
					else
						low_idx = idx;
				} while ((high_idx - low_idx) > 1);
				if (target > Sgmt_records[low_idx].end_time)
				    idx = high_idx;
				else if (target < Sgmt_records[high_idx].start_time)
				    idx = low_idx;
			}
			slice->start_segment_number = idx + 1;
		}
		
		// end segment
		target = slice->end_time;
		low_idx = idx;
		high_idx = globals_m12->number_of_session_segments - 1;
		if (target < Sgmt_records[low_idx].start_time) {
			slice->end_segment_number = SEGMENT_NUMBER_NO_ENTRY_m12;
			G_warning_message_m12("%s(): requested end time precedes requested start time\n", __FUNCTION__);
		} else {
			if (target >= Sgmt_records[high_idx].end_time) {
				idx = high_idx;
			} else {
				do {  // binary search
					idx = (low_idx + high_idx) >> 1;
					if (Sgmt_records[idx].start_time > target)
						high_idx = idx;
					else
						low_idx = idx;
				} while ((high_idx - low_idx) > 1);
				if (target > Sgmt_records[low_idx].end_time)
				    idx = high_idx;
				else if (target < Sgmt_records[high_idx].start_time)
				    idx = low_idx;
			}
			slice->end_segment_number = idx + 1;
		}
	}
	else {  // search_mode == SAMPLE_SEARCH_m12
		
		// sample search required, but no sample data in Sgmt_records => fill it in (e.g from session records in variable frequency session)
		if (Sgmt_records[0].start_sample_number == SAMPLE_NUMBER_NO_ENTRY_m12) {
			chan = globals_m12->reference_channel;
			for (i = 0; i < globals_m12->number_of_session_segments; ++i) {
				G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, Sgmt_records[i].segment_number);
				sprintf_m12(seg_name, "%s_s%s", chan->name, num_str);
				sprintf_m12(md_file, "%s/%s.%s/%s.%s", chan->path, seg_name, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12, seg_name, TIME_SERIES_METADATA_FILE_TYPE_STRING_m12);
				md_fps = G_read_file_m12(NULL, md_file, 0, 0, FPS_FULL_FILE_m12, NULL, NULL, USE_GLOBAL_BEHAVIOR_m12);
				if (md_fps == NULL)
					continue;
				Sgmt_records[i].end_sample_number = Sgmt_records[i].start_sample_number = md_fps->metadata->time_series_section_2.absolute_start_sample_number;
				Sgmt_records[i].end_sample_number += (md_fps->metadata->time_series_section_2.number_of_samples - 1);
				FPS_free_processing_struct_m12(md_fps, TRUE_m12);
			}
		}

		// start segment
		target = slice->start_sample_number;
		low_idx = 0;
		high_idx = globals_m12->number_of_session_segments - 1;
		if (target > Sgmt_records[high_idx].end_sample_number) {
			slice->start_segment_number = SEGMENT_NUMBER_NO_ENTRY_m12;
			G_warning_message_m12("%s(): requested start sample is after session end\n", __FUNCTION__);
			idx = 0;
		} else {
			if (target < Sgmt_records[0].start_sample_number) {
				idx = 0;
			} else {
				do {  // binary search
					idx = (low_idx + high_idx) >> 1;
					if (Sgmt_records[idx].start_sample_number > target)
						high_idx = idx;
					else
						low_idx = idx;
				} while ((high_idx - low_idx) > 1);
				if (target > Sgmt_records[low_idx].end_sample_number)
				    idx = high_idx;
				else if (target < Sgmt_records[high_idx].start_sample_number)
				    idx = low_idx;
			}
			slice->start_segment_number = idx + 1;
		}
		
		// end segment
		target = slice->end_sample_number;
		low_idx = idx;
		high_idx = globals_m12->number_of_session_segments - 1;
		if (target < Sgmt_records[low_idx].start_sample_number) {
			slice->end_segment_number = SEGMENT_NUMBER_NO_ENTRY_m12;
			G_warning_message_m12("%s(): requested end sample precedes requested start sample\n", __FUNCTION__);
		} else {
			if (target >= Sgmt_records[high_idx].end_sample_number) {
				idx = high_idx;
			} else {
				do {  // binary search
					idx = (low_idx + high_idx) >> 1;
					if (Sgmt_records[idx].start_sample_number > target)
						high_idx = idx;
					else
						low_idx = idx;
				} while ((high_idx - low_idx) > 1);
				if (target > Sgmt_records[low_idx].end_sample_number)
				    idx = high_idx;
				else if (target < Sgmt_records[high_idx].start_sample_number)
				    idx = low_idx;
			}
			slice->end_segment_number = idx + 1;
		}
	}

	// return number of segments
	if (slice->start_segment_number == SEGMENT_NUMBER_NO_ENTRY_m12 || slice->end_segment_number == SEGMENT_NUMBER_NO_ENTRY_m12)
		return(0);
	else
		return(TIME_SLICE_SEGMENT_COUNT_m12(slice));
}

		
si4	G_segment_for_frame_number_m12(LEVEL_HEADER_m12 *level_header, si8 target_frame)
{
	TERN_m12		get_Sgmt_recs;
	si4			idx, low_idx, high_idx;
	CHANNEL_m12		*chan;
	SESSION_m12		*sess;
	Sgmt_RECORD_m12		*Sgmt_records;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	switch (level_header->type_code) {
		case LH_TIME_SERIES_CHANNEL_m12:
			return(G_segment_for_sample_number_m12(level_header, target_frame));
			break;
		case LH_VIDEO_CHANNEL_m12:
			chan = (CHANNEL_m12 *) level_header;
			Sgmt_records = chan->Sgmt_records;
			if (Sgmt_records == NULL && chan->parent != NULL)
				Sgmt_records = ((SESSION_m12 *) chan->parent)->Sgmt_records;
			else
				Sgmt_records = G_build_Sgmt_records_array_m12(chan->record_indices_fps, chan->record_data_fps, chan);
			break;
		case LH_SESSION_m12:
			sess = (SESSION_m12 *) level_header;
			Sgmt_records = sess->Sgmt_records;
			get_Sgmt_recs = FALSE_m12;
			if (Sgmt_records == NULL)
				get_Sgmt_recs = TRUE_m12;
			else if (Sgmt_records[0].start_frame_number == FRAME_NUMBER_NO_ENTRY_m12)
				get_Sgmt_recs = TRUE_m12;
			if (get_Sgmt_recs == TRUE_m12) {
				chan = globals_m12->reference_channel;
				if (chan->type_code != LH_VIDEO_CHANNEL_m12)
					chan = sess->video_channels[0];
				if (chan->Sgmt_records != NULL)
					Sgmt_records = chan->Sgmt_records;
				else
					Sgmt_records = chan->Sgmt_records = G_build_Sgmt_records_array_m12(chan->record_indices_fps, chan->record_data_fps, chan);
			}
			break;
		default:
			G_warning_message_m12("%s(): invalid level type\n", __FUNCTION__);
			return(SEGMENT_NUMBER_NO_ENTRY_m12);
	}

	// Note: this may seem like overkill, that a simple forward linear search would suffice,
	// but in theory there can be a large number of non-uniformly spaced segments
	low_idx = 0;
	high_idx = globals_m12->number_of_session_segments - 1;
	if (target_frame <= Sgmt_records[0].start_frame_number)
		return(1);  // return first segment if requested frame number <= session start
	if (target_frame >= Sgmt_records[high_idx].end_frame_number)
		return(high_idx + 1);  // return last segment if requested frame number <= session start
		
	do {  // binary search
		idx = (low_idx + high_idx) >> 1;
		if (Sgmt_records[idx].start_frame_number > target_frame)
			high_idx = idx;
		else
			low_idx = idx;
	} while ((high_idx - low_idx) > 1);
	
	if (target_frame > Sgmt_records[low_idx].end_frame_number)
	    idx = high_idx;
	else if (target_frame < Sgmt_records[high_idx].start_frame_number)
	    idx = low_idx;

	return(idx + 1);
}


si4	G_segment_for_sample_number_m12(LEVEL_HEADER_m12 *level_header, si8 target_sample)
{
	TERN_m12		get_Sgmt_recs;
	si4			idx, low_idx, high_idx;
	CHANNEL_m12		*chan;
	SESSION_m12		*sess;
	Sgmt_RECORD_m12		*Sgmt_records;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Note: this may seem like overkill, that a simple forward linear search would suffice,
	// but in theory there can be a large number of non-uniformly spaced segments.
	
	switch (level_header->type_code) {
		case LH_VIDEO_CHANNEL_m12:
			return(G_segment_for_frame_number_m12(level_header, target_sample));
			break;
		case LH_TIME_SERIES_CHANNEL_m12:
			chan = (CHANNEL_m12 *) level_header;
			Sgmt_records = chan->Sgmt_records;
			if (Sgmt_records == NULL && chan->parent != NULL)
				Sgmt_records = ((SESSION_m12 *) chan->parent)->Sgmt_records;
			else
				Sgmt_records = G_build_Sgmt_records_array_m12(chan->record_indices_fps, chan->record_data_fps, chan);
			break;
		case LH_SESSION_m12:
			sess = (SESSION_m12 *) level_header;
			Sgmt_records = sess->Sgmt_records;
			get_Sgmt_recs = FALSE_m12;
			if (Sgmt_records == NULL)
				get_Sgmt_recs = TRUE_m12;
			else if (Sgmt_records[0].start_sample_number == SAMPLE_NUMBER_NO_ENTRY_m12)
				get_Sgmt_recs = TRUE_m12;
			if (get_Sgmt_recs == TRUE_m12) {
				chan = globals_m12->reference_channel;
				if (chan->type_code != LH_TIME_SERIES_CHANNEL_m12)
					chan = sess->time_series_channels[0];
				if (chan->Sgmt_records != NULL)
					Sgmt_records = chan->Sgmt_records;
				else
					Sgmt_records = chan->Sgmt_records = G_build_Sgmt_records_array_m12(chan->record_indices_fps, chan->record_data_fps, chan);
			}
			break;
		default:
			G_warning_message_m12("%s(): invalid level type\n", __FUNCTION__);
			return(SEGMENT_NUMBER_NO_ENTRY_m12);
	}
	
	low_idx = 0;
	high_idx = globals_m12->number_of_session_segments - 1;
	if (target_sample <= Sgmt_records[0].start_sample_number)
		return(1);  // return first segment if requested sample number <= session start
	if (target_sample >= Sgmt_records[high_idx].end_sample_number)
		return(high_idx + 1);  // return last segment if requested sample number >= session end
		
	do {  // binary search
		idx = (low_idx + high_idx) >> 1;
		if (Sgmt_records[idx].start_sample_number > target_sample)
			high_idx = idx;
		else
			low_idx = idx;
	} while ((high_idx - low_idx) > 1);
	
	if (target_sample > Sgmt_records[low_idx].end_sample_number)
	    idx = high_idx;
	else if (target_sample < Sgmt_records[high_idx].start_sample_number)
	    idx = low_idx;

	return(idx + 1);
}

		
si4	G_segment_for_uutc_m12(LEVEL_HEADER_m12 *level_header, si8 target_time)
{
	si4			idx, low_idx, high_idx;
	CHANNEL_m12		*chan;
	SESSION_m12		*sess;
	Sgmt_RECORD_m12		*Sgmt_records;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Note: this may seem like overkill, that a simple forward linear search would suffice,
	// but in theory there can be a large number of non-uniformly spaced segments.
	
	switch (level_header->type_code) {
		case LH_VIDEO_CHANNEL_m12:
		case LH_TIME_SERIES_CHANNEL_m12:
			chan = (CHANNEL_m12 *) level_header;
			Sgmt_records = chan->Sgmt_records;
			if (Sgmt_records == NULL && chan->parent != NULL)
				Sgmt_records = ((SESSION_m12 *) chan->parent)->Sgmt_records;
			else
				Sgmt_records = chan->Sgmt_records = G_build_Sgmt_records_array_m12(chan->record_indices_fps, chan->record_data_fps, chan);
			break;
		case LH_SESSION_m12:
			sess = (SESSION_m12 *) level_header;
			Sgmt_records = sess->Sgmt_records;
			if (Sgmt_records == NULL) {
				if (globals_m12->reference_channel->Sgmt_records == NULL)
					Sgmt_records = sess->Sgmt_records = G_build_Sgmt_records_array_m12(sess->record_indices_fps, sess->record_data_fps, NULL);
				else
					Sgmt_records = globals_m12->reference_channel->Sgmt_records;
			}
			break;
		default:
			G_warning_message_m12("%s(): invalid level type\n", __FUNCTION__);
			return(SEGMENT_NUMBER_NO_ENTRY_m12);
	}
	
	low_idx = 0;
	high_idx = globals_m12->number_of_session_segments - 1;
	if (target_time <= Sgmt_records[0].start_time)
		return(1);  // return first segment if requested time <= session start
	if (target_time >= Sgmt_records[high_idx].end_time)
		return(high_idx + 1);   // return last segment if requested time >= session end
		
	do {  // binary search
		idx = (low_idx + high_idx) >> 1;
		if (Sgmt_records[idx].start_time > target_time)
			high_idx = idx;
		else
			low_idx = idx;
	} while ((high_idx - low_idx) > 1);
	
	if (target_time > Sgmt_records[low_idx].end_time)
	    idx = high_idx;
	else if (target_time < Sgmt_records[high_idx].start_time)
	    idx = low_idx;

	return(idx + 1);
}


void    G_sendgrid_email_m12(si1 *sendgrid_key, si1 *to_email, si1 *cc_email, si1 *to_name, si1 *subject, si1 *content, si1 *from_email, si1 *from_name, si1 *reply_to_email, si1 *reply_to_name)
{
	TERN_m12	include_cc;
	si1     	command[2048], escaped_content[2048];
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (sendgrid_key == NULL) {
		G_warning_message_m12("%s(): key is NULL => returning\n");
		return;
	}
	if (*sendgrid_key == 0) {
		G_warning_message_m12("%s(): key is empty => returning\n");
		return;
	}
	if (to_email == NULL) {
		G_warning_message_m12("%s(): to_email is NULL => returning\n");
		return;
	}
	if (*to_email == 0) {
		G_warning_message_m12("%s(): to_email is empty => returning\n");
		return;
	}
	include_cc = TRUE_m12;
	if (cc_email == NULL)
		include_cc = FALSE_m12;
	else if (*cc_email == 0)
		include_cc = FALSE_m12;
	if (to_name == NULL)
		to_name = "";
	if (subject == NULL)
		subject = "";
	if (content == NULL)
		content = "";
	if (*content)
		STR_re_escape_m12(content, escaped_content);
	else
		content = " ";  // sendgrid requires at least one character
	if (from_email == NULL)
		from_email = "";
	if (from_name == NULL)
		from_name = "";
	if (reply_to_email == NULL)
		reply_to_email = "";
	if (reply_to_name == NULL)
		reply_to_name = "";


#if defined MACOS_m12 || defined LINUX_m12
	if (include_cc == TRUE_m12)
		sprintf(command, "/usr/bin/curl --connect-timeout 5.0 --request POST --url https://api.sendgrid.com/v3/mail/send --header 'authorization: Bearer %s' --header 'content-type: application/json' --data '{\"personalizations\":[{\"to\": [{\"email\": \"%s\", \"name\": \"%s\"}], \"cc\": [{\"email\": \"%s\"}], \"subject\": \"%s\"}], \"content\": [{\"type\": \"text/plain\", \"value\": \"%s\"}], \"from\": {\"email\": \"%s\", \"name\": \"%s\"}, \"reply_to\": {\"email\": \"%s\", \"name\": \"%s\"}}' > %s 2>&1", sendgrid_key, to_email, to_name, cc_email, subject, escaped_content, from_email, from_name, reply_to_email, reply_to_name, NULL_DEVICE_m12);
	else
		sprintf(command, "/usr/bin/curl --connect-timeout 5.0 --request POST --url https://api.sendgrid.com/v3/mail/send --header 'authorization: Bearer %s' --header 'content-type: application/json' --data '{\"personalizations\":[{\"to\": [{\"email\": \"%s\", \"name\": \"%s\"}], \"subject\": \"%s\"}], \"content\": [{\"type\": \"text/plain\", \"value\": \"%s\"}], \"from\": {\"email\": \"%s\", \"name\": \"%s\"}, \"reply_to\": {\"email\": \"%s\", \"name\": \"%s\"}}' > %s 2>&1", sendgrid_key, to_email, to_name, subject, escaped_content, from_email, from_name, reply_to_email, reply_to_name, NULL_DEVICE_m12);
	system(command);
#endif
	
#ifdef WINDOWS_m12
	if (include_cc == TRUE_m12)
		sprintf(command, "curl.exe --connect-timeout 5.0 --request POST --url https://api.sendgrid.com/v3/mail/send --header \"authorization: Bearer %s\" --header \"content-type: application/json\" --data \"{\\\"personalizations\\\":[{\\\"to\\\": [{\\\"email\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\"}], \\\"cc\\\": [{\\\"email\\\": \\\"%s\\\"}], \\\"subject\\\": \\\"%s\\\"}], \\\"content\\\": [{\\\"type\\\": \\\"text/plain\\\", \\\"value\\\": \\\"%s\\\"}], \\\"from\\\": {\\\"email\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\"}, \\\"reply_to\\\": {\\\"email\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\"}}\" > %s 2>&1", sendgrid_key, to_email, to_name, cc_email, subject, escaped_content, from_email, from_name, reply_to_email, reply_to_name, NULL_DEVICE_m12);
	else
		sprintf(command, "curl.exe --connect-timeout 5.0 --request POST --url https://api.sendgrid.com/v3/mail/send --header \"authorization: Bearer %s\" --header \"content-type: application/json\" --data \"{\\\"personalizations\\\":[{\\\"to\\\": [{\\\"email\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\"}], \\\"subject\\\": \\\"%s\\\"}], \\\"content\\\": [{\\\"type\\\": \\\"text/plain\\\", \\\"value\\\": \\\"%s\\\"}], \\\"from\\\": {\\\"email\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\"}, \\\"reply_to\\\": {\\\"email\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\"}}\" > %s 2>&1", sendgrid_key, to_email, to_name, subject, escaped_content, from_email, from_name, reply_to_email, reply_to_name, NULL_DEVICE_m12);
	WN_system_m12(command);
#endif

	return;
}


void	G_set_error_m12(const si4 err_code, const si1 *function, const si4 line)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (globals_m12->err_code == E_NO_ERR_m12) {
		globals_m12->err_code = err_code;
		globals_m12->err_func = function;
		globals_m12->err_line = line;
	}
	
	return;
}


TERN_m12    G_set_global_time_constants_m12(TIMEZONE_INFO_m12 *timezone_info, si8 session_start_time, TERN_m12 prompt)
{
	si4                     n_potential_timezones, potential_timezone_entries[TZ_TABLE_ENTRIES_m12];
	si4                     i, j, response_num, items;
	TIMEZONE_INFO_m12	*tz_table;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (global_tables_m12->timezone_table == NULL)
		G_initialize_timezone_tables_m12();
	
	// reset
	globals_m12->time_constants_set = FALSE_m12;
	
	// capitalize & check aliases
	G_condition_timezone_info_m12(timezone_info);  // modified if alias found
	
	// start search
	n_potential_timezones = TZ_TABLE_ENTRIES_m12;
	tz_table = global_tables_m12->timezone_table;
	for (i = 0; i < n_potential_timezones; ++i)
		potential_timezone_entries[i] = i;
	
	// match country
	j = 0;
	if (*timezone_info->country) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp(timezone_info->country, tz_table[potential_timezone_entries[i]].country) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m12;
		n_potential_timezones = j;
	}
	
	// match country_acronym_2_letter
	j = 0;
	if (*timezone_info->country_acronym_2_letter) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp(timezone_info->country_acronym_2_letter, tz_table[potential_timezone_entries[i]].country_acronym_2_letter) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m12;
		n_potential_timezones = j;
	}
	
	// match country_acronym_3_letter
	j = 0;
	if (*timezone_info->country_acronym_3_letter) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp(timezone_info->country_acronym_3_letter, tz_table[potential_timezone_entries[i]].country_acronym_3_letter) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m12;
		n_potential_timezones = j;
	}
	
	// match standard_timezone_acronym
	j = 0;
	if (*timezone_info->standard_timezone_acronym) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp(timezone_info->standard_timezone_acronym, tz_table[potential_timezone_entries[i]].standard_timezone_acronym) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m12;
		n_potential_timezones = j;
	}

	// match standard_timezone
	j = 0;
	if (*timezone_info->standard_timezone) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp(timezone_info->standard_timezone, tz_table[potential_timezone_entries[i]].standard_timezone) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m12;
		n_potential_timezones = j;
	}

	// match daylight_timezone_acronym
	j = 0;
	if (*timezone_info->daylight_timezone_acronym) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp(timezone_info->daylight_timezone_acronym, tz_table[potential_timezone_entries[i]].daylight_timezone_acronym) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m12;
		n_potential_timezones = j;
	}

	// match daylight_timezone
	j = 0;
	if (*timezone_info->daylight_timezone) {
		for (i = 0; i < n_potential_timezones; ++i) 
			if (strcmp(timezone_info->daylight_timezone, tz_table[potential_timezone_entries[i]].daylight_timezone) == 0) 
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m12;
		n_potential_timezones = j;
	}

	// match standard_UTC_offset
	j = 0;
	if (timezone_info->standard_UTC_offset) {  // zero is a valid offset, but also could be zero from calloc() - can't use it to exclude
		for (i = 0; i < n_potential_timezones; ++i)
			if (timezone_info->standard_UTC_offset == tz_table[potential_timezone_entries[i]].standard_UTC_offset)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m12;
		n_potential_timezones = j;
	}

	// match territory
	j = 0;
	if (*timezone_info->territory) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp(timezone_info->territory, tz_table[potential_timezone_entries[i]].territory) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m12;
		n_potential_timezones = j;
	}
	
	// match territory_acronym
	j = 0;
	if (*timezone_info->territory_acronym) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp(timezone_info->territory_acronym, tz_table[potential_timezone_entries[i]].territory_acronym) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m12;
		n_potential_timezones = j;
	}

	// still multiple: doesn't matter if UTC offset, daylight change info, & timezone names all match
	for (i = 1; i < n_potential_timezones; ++i) {
		if (tz_table[potential_timezone_entries[i]].standard_UTC_offset != tz_table[potential_timezone_entries[0]].standard_UTC_offset)
			break;
		if (tz_table[potential_timezone_entries[i]].daylight_time_start_code != tz_table[potential_timezone_entries[0]].daylight_time_start_code)
			break;
		if (tz_table[potential_timezone_entries[i]].daylight_time_end_code != tz_table[potential_timezone_entries[0]].daylight_time_end_code)
			break;
		if (strcmp(tz_table[potential_timezone_entries[i]].standard_timezone, tz_table[potential_timezone_entries[0]].standard_timezone))
			break;
	}
	if (i == n_potential_timezones)
		goto SET_GTC_TIMEZONE_MATCH_m12;

	// still multiple: ask user
	if (prompt == TRUE_m12) {
		fprintf_m12(stderr, "\nMultiple potential timezone entries:\n\n");
		for (i = 0; i < n_potential_timezones; ++i) {
			fprintf_m12(stderr, "%d)\n", i + 1);
			G_show_timezone_info_m12(&tz_table[potential_timezone_entries[i]], FALSE_m12);
			fputc_m12('\n', stderr);
		}
		fprintf_m12(stderr, "Select one (by number): ");
		items = scanf("%d", &response_num);
		if (items != 1 || response_num < 1 || response_num > n_potential_timezones) {
			G_error_message_m12("Invalid choice\n");
			exit_m12(-1);
		}
		potential_timezone_entries[0] = potential_timezone_entries[--response_num];
	} else {
		return(FALSE_m12);
	}
	
SET_GTC_TIMEZONE_MATCH_m12:
	*timezone_info = tz_table[potential_timezone_entries[0]];
	globals_m12->standard_UTC_offset = timezone_info->standard_UTC_offset;
	strncpy_m12(globals_m12->standard_timezone_acronym, timezone_info->standard_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m12);
	strncpy_m12(globals_m12->standard_timezone_string, timezone_info->standard_timezone, TIMEZONE_STRING_BYTES_m12);
	STR_to_title_m12(globals_m12->standard_timezone_string);  // beautify
	if (timezone_info->daylight_time_start_code) {
		if (timezone_info->daylight_time_start_code == DTCC_VALUE_NO_ENTRY_m12) {
			globals_m12->observe_DST = UNKNOWN_m12;
		} else {
			globals_m12->observe_DST = TRUE_m12;
			strncpy_m12(globals_m12->daylight_timezone_acronym, timezone_info->daylight_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m12);
			strncpy_m12(globals_m12->daylight_timezone_string, timezone_info->daylight_timezone, TIMEZONE_STRING_BYTES_m12);
			STR_to_title_m12(globals_m12->daylight_timezone_string);  // beautify
			globals_m12->daylight_time_start_code.value = timezone_info->daylight_time_start_code;
			globals_m12->daylight_time_end_code.value = timezone_info->daylight_time_end_code;
		}
	} else {
		globals_m12->observe_DST = FALSE_m12;
	}
	globals_m12->time_constants_set = TRUE_m12;

	if (session_start_time)  // pass CURRENT_TIME_m12 for session starting now; pass zero if just need to get timezone_info for a locale
		G_generate_recording_time_offset_m12(session_start_time);

	return(TRUE_m12);
}


void	G_set_globals_pointer_m12(GLOBALS_m12 *new_globals)
{
	si4		i;
	pid_t_m12	_id;
	
	
	// NOTE if this is temporary, caller should save previous glopbals & call this again to restore
	
	// lock list
	PROC_pthread_mutex_lock_m12(&globals_list_mutex_m12);

	// return parent (or only) globals
	// most common usage, so check first
	if (globals_list_len_m12 == 1) {
		globals_list_m12[0] = new_globals;
		PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12); // unlock list
		return;
	}
	
	// no globals exist
	if (globals_list_len_m12 == 0) {
		globals_list_len_m12 = 1;
#ifdef MATLAB_PERSISTENT_m12
		globals_list_m12 = (GLOBALS_m12 **) mxCalloc((mwSize) globals_list_len_m12, sizeof(GLOBALS_m12 *));
#else
		globals_list_m12 = (GLOBALS_m12 **) calloc((size_t) globals_list_len_m12, sizeof(GLOBALS_m12 *));
#endif
		globals_list_m12[0] = new_globals;
		PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12); // unlock list
		return;
	}
	
	// return thread local globals
	_id = PROC_gettid_m12();
	
	for (i = 0; i < globals_list_len_m12; ++i) {
		if (globals_list_m12[i]->_id == _id) {
			globals_list_m12[i] = new_globals;
			PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12); // unlock list
			return;
		}
	}

	// return process globals
	_id = PROC_getpid_m12();

	for (i = 0; i < globals_list_len_m12; ++i) {
		if (globals_list_m12[i]->_id == _id) {
			globals_list_m12[i] = new_globals;
			PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12); // unlock list
			return;
		}
	}

	// unlock list
	PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12);
	
	return;
}


TERN_m12	G_set_time_and_password_data_m12(si1 *unspecified_password, si1 *MED_directory, si1 *metadata_section_2_encryption_level, si1 *metadata_section_3_encryption_level)
{
	si1                             metadata_file[FULL_FILE_NAME_BYTES_m12];
	FILE_PROCESSING_STRUCT_m12	*metadata_fps;
	METADATA_SECTION_1_m12		*md1;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// find a MED metadata file
	if (G_find_metadata_file_m12(MED_directory, metadata_file) == NULL) {
		G_error_message_m12("%s(): \"%s\" does not contain any metadata files\n", __FUNCTION__, MED_directory);
		return(FALSE_m12);
	}

	// G_read_file_m12() will process password and set current session directory globals
	// G_decrypt_metadata_m12() will set global time constants, from section 3
	globals_m12->password_data.processed = 0;  // not ternary FALSE_m12 (so when structure is zeroed it is marked as not processed)
	metadata_fps = G_read_file_m12(NULL, metadata_file, 0, 0, FPS_FULL_FILE_m12, NULL, unspecified_password, RETURN_ON_FAIL_m12);
	if (metadata_fps == NULL)
		return(FALSE_m12);
	globals_m12->session_start_time = metadata_fps->universal_header->session_start_time;

	// return metadata encryption level info
	md1 = &metadata_fps->metadata->section_1;
	if (metadata_section_2_encryption_level != NULL)
		*metadata_section_2_encryption_level = md1->section_2_encryption_level;
	if (metadata_section_3_encryption_level != NULL)
		*metadata_section_3_encryption_level = md1->section_3_encryption_level;

	// clean up
	FPS_free_processing_struct_m12(metadata_fps, TRUE_m12);

	return(TRUE_m12);
}


void	G_show_behavior_m12(void)
{
	si1	behavior_string[256];
	si4	i, j, bse;
	
	
	// get mutex
	PROC_pthread_mutex_lock_m12(&globals_m12->behavior_mutex);

	printf_m12("\nCurrent Global Behavior:\n------------------------\n");
	G_behavior_string_m12(globals_m12->behavior_on_fail, behavior_string);
	printf_m12("%s\n\n", behavior_string);
	
	bse = (si4) globals_m12->behavior_stack_entries;
	if (bse) {
		printf_m12("Current Behavior Stack:\n-----------------------\n");
		for (i = 0, j = bse - 1; i < bse; ++i, --j) {
			G_behavior_string_m12(globals_m12->behavior_stack[j], behavior_string);
			printf_m12("%d)\t%s\n", i, behavior_string);
		}
		printf_m12("\n");
	}
	
	// release mutex
	PROC_pthread_mutex_unlock_m12(&globals_m12->behavior_mutex);

	return;
}


void    G_show_daylight_change_code_m12(DAYLIGHT_TIME_CHANGE_CODE_m12 *code, si1 *prefix)
{
	static si1	*relative_days[7] = { "", "First", "Second", "Third", "Fourth", "Fifth", "Last"};
	static si1	*weekdays[8] = { "", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
	static si1	*months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
	static si1	*mday_num_sufs[32] = { 	"", "st", "nd", "rd", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", \
						"th", "th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th", "th", "st" };
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (prefix == NULL)
		prefix = "";
	printf_m12("%sStructure Content:\n", prefix);
	printf_m12("%sCode Type (DST end / DST Not Observed / DST start) ==  (-1 / 0 / +1): %hhd\n", prefix, code->code_type);
	printf_m12("%sDay of Week (No Entry / [Sunday : Saturday]) ==  (0 / [1 : 7]): %hhd\n", prefix, code->day_of_week);
	printf_m12("%sRelative Weekday of Month (No Entry / [First : Fifth] / Last) ==  (0 / [1 : 5] / 6): %hhd\n", prefix, code->relative_weekday_of_month);
	printf_m12("%sDay of Month (No Entry / [1 : 31]) ==  (0 / [1 : 31]): %hhd\n", prefix, code->day_of_month);
	printf_m12("%sMonth (No Entry / [January : December]) ==  (-1 / [0 : 11]): %hhd\n", prefix, code->month);
	printf_m12("%sHours of Day [-128 : +127] hours relative to 00:00 (midnight): %hhd\n", prefix, code->hours_of_day);
	printf_m12("%sReference Time (Local / UTC) ==  (0 / 1): %hhd\n", prefix, code->reference_time);
	printf_m12("%sShift Minutes [-120 : +120] minutes: %hhd\n", prefix, code->shift_minutes);
	printf_m12("%sValue: 0x%lX\n\n", prefix, code->value);

	// human readable
	printf_m12("%sTranslated Content: ", prefix);
	switch (code->value) {
		case DTCC_VALUE_NO_ENTRY_m12:
			printf_m12("daylight saving change information not entered\n\n");
			return;
		case DTCC_VALUE_NOT_OBSERVED_m12:
			printf_m12("daylight saving not observed\n\n");
			return;
	}
	switch (code->code_type) {
		case -1:
			printf_m12("daylight saving END\n");
			break;
		case 1:
			printf_m12("daylight saving START\n");
			break;
	}

	printf_m12("%s", prefix);
	if (code->relative_weekday_of_month) {
		printf_m12("%s ", relative_days[(si4) code->relative_weekday_of_month]);
		printf_m12("%s ", weekdays[(si4) (code->day_of_week + 1)]);
		printf_m12("in %s ", months[(si4) code->month]);
	} else if (code->day_of_month) {
		printf_m12("%s ", months[(si4) code->month]);
		printf_m12("%hhd%s ", code->day_of_month, mday_num_sufs[(si4) code->day_of_month]);
	}

	printf_m12("at %hhd:00 ", code->hours_of_day);
	switch (code->reference_time) {
		case 0:
			printf_m12("local ");
			break;
		case 1:
			printf_m12("UTC ");
			break;
	}
	if (code->shift_minutes < 0)
		printf_m12(" (shift back by %hhd minutes)\n\n", -(code->shift_minutes));
	else
		printf_m12(" (shift forward by %hhd minutes)\n\n", code->shift_minutes);

	return;
}


void	G_show_file_times_m12(FILE_TIMES_m12 *ft)
{
	si1	time_str[TIME_STRING_BYTES_m12];
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	printf_m12("Creation Time: ");
	if (ft->creation == UUTC_NO_ENTRY_m12) {
		printf_m12("no entry\n");
	} else {
		STR_time_string_m12(ft->creation, time_str, TRUE_m12, FALSE_m12, FALSE_m12);
		printf_m12("%ld (oUTC), %s\n", ft->creation, time_str);
	}
	
	printf_m12("Access Time: ");
	if (ft->access == UUTC_NO_ENTRY_m12) {
		printf_m12("no entry\n");
	} else {
		STR_time_string_m12(ft->access, time_str, TRUE_m12, FALSE_m12, FALSE_m12);
		printf_m12("%ld (oUTC), %s\n", ft->access, time_str);
	}

	printf_m12("Modification Time: ");
	if (ft->creation == UUTC_NO_ENTRY_m12) {
		printf_m12("no entry\n");
	} else {
		STR_time_string_m12(ft->modification, time_str, TRUE_m12, FALSE_m12, FALSE_m12);
		printf_m12("%ld (oUTC), %s\n", ft->modification, time_str);
	}

	return;
}


void    G_show_globals_m12(void)
{
	si1     	hex_str[HEX_STRING_BYTES_m12(sizeof(si8))];
	si4		i;
	GLOBALS_m12	*globals;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	globals = globals_m12;
	printf_m12("\nMED Globals\n-----------\n");
	if (globals->_id == 0)
		printf_m12("_id: no entry\n");
	else
		printf_m12("_id: 0x%016lx\n", globals->_id);

	printf_m12("\nRecord Filters\n--------------\n");
	if (globals->record_filters == NULL) {
		printf_m12("no entry\n");
	} else if (globals->record_filters[0] == NO_TYPE_CODE_m12) {
		printf_m12("no entry\n");
	} else {
		printf_m12("0x%08x\n", globals->record_filters[0]);
		for (i = 1; globals->record_filters[i] != NO_TYPE_CODE_m12; ++i)
			printf_m12(", 0x%08x", globals->record_filters[i]);
		printf_m12("\n");
	}

	printf_m12("\nCurrent Session\n---------------\n");
	if (globals->session_UID == 0)
		printf_m12("Session UID: no_entry\n", globals->session_UID);
	else
		printf_m12("Session UID: 0x%016lx\n", globals->session_UID);
	if (*globals->session_directory == 0)
		printf_m12("Session Directory: no entry\n", globals->session_directory);
	else
		printf_m12("Session Directory: %s\n", globals->session_directory);  // path including file system session directory name
	printf_m12("Session Start Time: ");
	if (globals->session_start_time == UUTC_NO_ENTRY_m12)
		printf_m12("no entry\n");
	else if (globals->session_start_time == BEGINNING_OF_TIME_m12)
		printf_m12("beginning of time\n");
	else if (globals->session_start_time == END_OF_TIME_m12)
		printf_m12("end of time\n");
	else
		printf_m12("%ld\n", globals->session_start_time);
	printf_m12("Session End Time: ");
	if (globals->session_end_time == UUTC_NO_ENTRY_m12)
		printf_m12("no entry\n");
	else if (globals->session_end_time == BEGINNING_OF_TIME_m12)
		printf_m12("beginning of time\n");
	else if (globals->session_end_time == END_OF_TIME_m12)
		printf_m12("end of time\n");
	else
		printf_m12("%ld\n", globals->session_end_time);
	if (globals->session_name == NULL)
		printf_m12("Session Name: NULL\n");
	else
		printf_m12("Session Name: %s\n", globals->session_name);
	printf_m12("\tuh_session_name: %s\n", globals->uh_session_name);  // from session universal headers
	printf_m12("\tfs_session_name: %s\n", globals->fs_session_name);  // from file system (different if user created channel subset with different name)
	printf_m12("Number of Session Samples \\/ Frames: ");
	if (globals->number_of_session_samples == SAMPLE_NUMBER_NO_ENTRY_m12)
		printf_m12("no entry\n");
	else
		printf_m12("%ld\n", globals->number_of_session_samples);
	printf_m12("Number of Session Segments: ");
	if (globals->number_of_session_segments == SEGMENT_NUMBER_NO_ENTRY_m12)
		printf_m12("no entry\n");
	else
		printf_m12("%d\n", globals->number_of_session_segments);
	printf_m12("Number of Mapped Segments: ");
	if (globals->number_of_mapped_segments == SEGMENT_NUMBER_NO_ENTRY_m12)
		printf_m12("no entry\n");
	else
		printf_m12("%d\n", globals->number_of_mapped_segments);
	printf_m12("Reference Channel Name: ");
	if (*globals->reference_channel_name == 0)
		printf_m12("no entry\n");
	else
		printf_m12("%s\n", globals->reference_channel_name);
	printf_m12("Reference Channel: ");
	if (globals->reference_channel == NULL)
		printf_m12("not set\n");
	else
		printf_m12("set\n");

	printf_m12("\nActive Channels\n---------------\n");
	printf_m12("Time Series Frequencies Vary: ");
	if (globals->time_series_frequencies_vary == UNKNOWN_m12)
		printf_m12("unknown\n");
	else if (globals->time_series_frequencies_vary == TRUE_m12)
		printf_m12("true\n");
	else if (globals->time_series_frequencies_vary == FALSE_m12)
		printf_m12("false\n");
	else
		printf_m12("%hhd\n", globals->time_series_frequencies_vary);
	if (globals->minimum_time_series_frequency == FREQUENCY_NO_ENTRY_m12)
		printf_m12("Minimum Time Series Frequency: no entry\n");
	else
		printf_m12("Minimum Time Series Frequency: %lf\n", globals->minimum_time_series_frequency);
	if (globals->maximum_time_series_frequency == FREQUENCY_NO_ENTRY_m12)
		printf_m12("Maximum Time Series Frequency: no entry\n");
	else
		printf_m12("Maximum Time Series Frequency: %lf\n", globals->maximum_time_series_frequency);
	if (globals->minimum_time_series_frequency_channel == NULL)
		printf_m12("Minimum Time Series Frequency Channel: no entry\n");
	else
		printf_m12("Minimum Time Series Frequency Channel Name: %s\n", globals->minimum_time_series_frequency_channel->name);
	if (globals->maximum_time_series_frequency_channel == NULL)
		printf_m12("Maximum Time Series Frequency Channel: no entry\n");
	else
		printf_m12("Maximum Time Series Frequency Channel Name: %s\n", globals->maximum_time_series_frequency_channel->name);
	printf_m12("Video Frame Rates Vary: ");
	if (globals->video_frame_rates_vary == UNKNOWN_m12)
		printf_m12("unknown\n");
	else if (globals->video_frame_rates_vary == TRUE_m12)
		printf_m12("true\n");
	else if (globals->video_frame_rates_vary == FALSE_m12)
		printf_m12("false\n");
	else
		printf_m12("%hhd\n", globals->video_frame_rates_vary);
	if (globals->minimum_video_frame_rate == FREQUENCY_NO_ENTRY_m12)
		printf_m12("Minimum Video Frame Rate: no entry\n");
	else
		printf_m12("Minimum Video Frame Rate: %lf\n", globals->minimum_video_frame_rate);
	if (globals_m12->maximum_video_frame_rate == FREQUENCY_NO_ENTRY_m12)
		printf_m12("Maximum Video Frame Rate: no entry\n");
	else
		printf_m12("Minimum Video Frame Rate: %lf\n", globals->maximum_video_frame_rate);
	if (globals->minimum_video_frame_rate_channel == NULL)
		printf_m12("Minimum Video Frame Rate Channel: no entry\n");
	else
		printf_m12("Minimum Video Frame Rate Channel Name: %s\n", globals->minimum_video_frame_rate_channel->name);
	if (globals->maximum_video_frame_rate_channel == NULL)
		printf_m12("Maximum Video Frame Rate Channel: no entry\n");
	else
		printf_m12("Maximum Video Frame Rate Channel Name: %s\n", globals->maximum_video_frame_rate_channel->name);

	printf_m12("\nTime Constants\n--------------\n");
	printf_m12("time_constants_set: %hhd\n", globals->time_constants_set);
	printf_m12("RTO_known: %hhd\n", globals->RTO_known);
	printf_m12("observe_DST: %hhd\n", globals->observe_DST);
	printf_m12("recording_time_offset: %ld\n", globals->recording_time_offset);
	printf_m12("standard_UTC_offset: %d\n", globals->standard_UTC_offset);
	printf_m12("standard_timezone_acronym: %s\n", globals->standard_timezone_acronym);
	printf_m12("standard_timezone_string: %s\n", globals->standard_timezone_string);
	printf_m12("daylight_timezone_acronym: %s\n", globals->daylight_timezone_acronym);
	printf_m12("daylight_timezone_string: %s\n", globals->daylight_timezone_string);
	STR_generate_hex_string_m12((ui1 *) &globals->daylight_time_start_code.value, 8, hex_str);
	printf_m12("daylight_time_start_code: %s\n", hex_str);
	STR_generate_hex_string_m12((ui1 *) &globals->daylight_time_end_code.value, 8, hex_str);
	printf_m12("daylight_time_end_code: %s\n", hex_str);
	
	printf_m12("\nAlignment Fields\n----------------\n");
	printf_m12("universal_header_aligned: %hhd\n", globals->universal_header_aligned);
	printf_m12("metadata_section_1_aligned: %hhd\n", globals->metadata_section_1_aligned);
	printf_m12("time_series_metadata_section_2_aligned: %hhd\n", globals->time_series_metadata_section_2_aligned);
	printf_m12("video_metadata_section_2_aligned: %hhd\n", globals->video_metadata_section_2_aligned);
	printf_m12("metadata_section_3_aligned: %hhd\n", globals->metadata_section_3_aligned);
	printf_m12("all_metadata_structures_aligned: %hhd\n", globals->all_metadata_structures_aligned);
	printf_m12("time_series_indices_aligned: %hhd\n", globals->time_series_indices_aligned);
	printf_m12("video_indices_aligned: %hhd\n", globals->video_indices_aligned);
	printf_m12("CMP_block_header_aligned: %hhd\n", globals->CMP_block_header_aligned);
	printf_m12("record_header_aligned: %hhd\n", globals->record_header_aligned);
	printf_m12("record_indices_aligned: %hhd\n", globals->record_indices_aligned);
	printf_m12("all_record_structures_aligned: %hhd\n", globals->all_record_structures_aligned);
	printf_m12("all_structures_aligned: %hhd\n", globals->all_structures_aligned);
	
	printf_m12("\nError\n-------------\n");
	printf_m12("err_code: %d\n", globals->err_code);
	if (globals->err_code) {
		printf_m12("err_func: %s\n", globals->err_func);
		printf_m12("err_line: %s\n", globals->err_line);
	}

	printf_m12("\nMiscellaneous\n-------------\n");
	printf_m12("file_creation_umask: %u\n", globals->file_creation_umask);
	printf_m12("time_series_data_encryption_level: %hhd\n", globals->time_series_data_encryption_level);
	printf_m12("CRC_mode: %u\n", globals->CRC_mode);
	printf_m12("verbose: %hhd\n", globals->verbose);
	printf_m12("behavior_on_fail: %u\n", globals->behavior_on_fail);
	printf_m12("level_header_flags: %lu\n", globals->level_header_flags);
	printf_m12("mmap_block_bytes: ");
	if (globals->mmap_block_bytes == GLOBALS_MMAP_BLOCK_BYTES_NO_ENTRY_m12)
		printf_m12("no entry\n");
	else
		printf_m12("%d\n", globals->mmap_block_bytes);
	
	printf_m12("\n");
	
	return;
}


void	G_show_level_header_flags_m12(ui8 flags)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	printf_m12("\nLevel Header Flags:\n------------------\n");
	if (flags == LH_NO_FLAGS_m12) {
		printf_m12("no level header flags set\n");
		return;
	}
	if (flags & LH_OPEN_m12)
		printf_m12("LH_OPEN_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_OPEN_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_GENERATE_EPHEMERAL_DATA_m12)
		printf_m12("LH_GENERATE_EPHEMERAL_DATA_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_GENERATE_EPHEMERAL_DATA_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_UPDATE_EPHEMERAL_DATA_m12)
		printf_m12("LH_UPDATE_EPHEMERAL_DATA_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_UPDATE_EPHEMERAL_DATA_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_MAP_ALL_TIME_SERIES_CHANNELS_m12)
		printf_m12("LH_MAP_ALL_TIME_SERIES_CHANNELS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_MAP_ALL_TIME_SERIES_CHANNELS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_MAP_ALL_VIDEO_CHANNELS_m12)
		printf_m12("LH_MAP_ALL_VIDEO_CHANNELS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_MAP_ALL_VIDEO_CHANNELS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_READ_SLICE_SESSION_RECORDS_m12)
		printf_m12("LH_READ_SLICE_SESSION_RECORDS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_READ_SLICE_SESSION_RECORDS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_READ_FULL_SESSION_RECORDS_m12)
		printf_m12("LH_READ_FULL_SESSION_RECORDS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_READ_FULL_SESSION_RECORDS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_MEM_MAP_SESSION_RECORDS_m12)
		printf_m12("LH_MEM_MAP_SESSION_RECORDS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_MEM_MAP_SESSION_RECORDS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_READ_SLICE_SEGMENTED_SESS_RECS_m12)
		printf_m12("LH_READ_SLICE_SEGMENTED_SESS_RECS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_READ_SLICE_SEGMENTED_SESS_RECS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_READ_FULL_SEGMENTED_SESS_RECS_m12)
		printf_m12("LH_READ_FULL_SEGMENTED_SESS_RECS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_READ_FULL_SEGMENTED_SESS_RECS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_MEM_MAP_SEGMENTED_SESS_RECS_m12)
		printf_m12("LH_MEM_MAP_SEGMENTED_SESS_RECS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_MEM_MAP_SEGMENTED_SESS_RECS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_CHANNEL_ACTIVE_m12)
		printf_m12("LH_CHANNEL_ACTIVE_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_CHANNEL_ACTIVE_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_MAP_ALL_SEGMENTS_m12)
		printf_m12("LH_MAP_ALL_SEGMENTS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_MAP_ALL_SEGMENTS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_THREAD_SEGMENT_READS_m12)
		printf_m12("LH_THREAD_SEGMENT_READS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_THREAD_SEGMENT_READS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_READ_SLICE_CHANNEL_RECORDS_m12)
		printf_m12("LH_READ_SLICE_CHANNEL_RECORDS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_READ_SLICE_CHANNEL_RECORDS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_READ_FULL_CHANNEL_RECORDS_m12)
		printf_m12("LH_READ_FULL_CHANNEL_RECORDS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_READ_FULL_CHANNEL_RECORDS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_MEM_MAP_CHANNEL_RECORDS_m12)
		printf_m12("LH_MEM_MAP_CHANNEL_RECORDS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_MEM_MAP_CHANNEL_RECORDS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_READ_SLICE_SEGMENT_DATA_m12)
		printf_m12("LH_READ_SLICE_SEGMENT_DATA_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_READ_SLICE_SEGMENT_DATA_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_READ_FULL_SEGMENT_DATA_m12)
		printf_m12("LH_READ_FULL_SEGMENT_DATA_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_READ_FULL_SEGMENT_DATA_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_MEM_MAP_SEGMENT_DATA_m12)
		printf_m12("LH_MEM_MAP_SEGMENT_DATA_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_MEM_MAP_SEGMENT_DATA_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_READ_SEGMENT_METADATA_m12)
		printf_m12("LH_READ_SEGMENT_METADATA_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_READ_SEGMENT_METADATA_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_READ_SLICE_SEGMENT_RECORDS_m12)
		printf_m12("LH_READ_SLICE_SEGMENT_RECORDS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_READ_SLICE_SEGMENT_RECORDS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_READ_FULL_SEGMENT_RECORDS_m12)
		printf_m12("LH_READ_FULL_SEGMENT_RECORDS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_READ_FULL_SEGMENT_RECORDS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_MEM_MAP_SEGMENT_RECORDS_m12)
		printf_m12("LH_MEM_MAP_SEGMENT_RECORDS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_MEM_MAP_SEGMENT_RECORDS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_NO_CPS_PTR_RESET_m12)
		printf_m12("LH_NO_CPS_PTR_RESET_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_NO_CPS_PTR_RESET_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & LH_NO_CPS_CACHING_m12)
		printf_m12("LH_NO_CPS_CACHING_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("LH_NO_CPS_CACHING_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	printf_m12("\n");
	
	return;
}


void    G_show_location_info_m12(LOCATION_INFO_m12 *li)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	G_show_timezone_info_m12(&li->timezone_info, TRUE_m12);
	printf_m12("Locality: %s\n", li->locality);
	printf_m12("Postal Code: %s\n", li->postal_code);
	printf_m12("Timezone Description: %s\n", li->timezone_description);
	printf_m12("Latitude: %lf\n", li->latitude);
	printf_m12("Longitude: %lf\n", li->longitude);
	printf_m12("WAN_IPv4 Address: %s\n", li->WAN_IPv4_address);
	
	return;
}


void	G_show_metadata_m12(FILE_PROCESSING_STRUCT_m12 *fps, METADATA_m12 *md, ui4 type_code)
{
	si1                                     hex_str[HEX_STRING_BYTES_m12(8)];
	METADATA_SECTION_1_m12			*md1;
	TIME_SERIES_METADATA_SECTION_2_m12	*tmd2, *gmd2;
	VIDEO_METADATA_SECTION_2_m12		*vmd2;
	METADATA_SECTION_3_m12			*md3;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// if passing metadata pointer, also pass type code
	
	// assign
	if (fps != NULL) {
		md = (METADATA_m12 *) fps->data_pointers;
		type_code = fps->universal_header->type_code;
	}
	
	if (md != NULL) {
		md1 = &md->section_1;
		if (type_code == TIME_SERIES_METADATA_FILE_TYPE_CODE_m12) {
			tmd2 = &md->time_series_section_2;
			vmd2 = NULL;
		} else {  // type_code == VIDEO_METADATA_FILE_TYPE_CODE_m12
			vmd2 = &md->video_section_2;
			tmd2 = NULL;
		}
		md3 = &md->section_3;
	} else {
		G_error_message_m12("%s(): invalid input\n", __FUNCTION__);
		return;
	}
	
	// show
	printf_m12("------------------- Metadata - START -------------------\n");
	printf_m12("------------------ Section 1 - START -------------------\n");
	if (*md1->level_1_password_hint)
		UTF8_printf_m12("Level 1 Password Hint: %s\n", md1->level_1_password_hint);
	if (*md1->level_2_password_hint)
		UTF8_printf_m12("Level 2 Password Hint: %s\n", md1->level_2_password_hint);
	printf_m12("Section 2 Encryption Level: %d ", md1->section_2_encryption_level);
	if (md1->section_2_encryption_level == NO_ENCRYPTION_m12)
		printf_m12("(none)\n");
	else if (md1->section_2_encryption_level == LEVEL_1_ENCRYPTION_m12)
		printf_m12("(level 1, currently encrypted)\n");
	else if (md1->section_2_encryption_level == LEVEL_2_ENCRYPTION_m12)
		printf_m12("(level 2, currently encrypted)\n");
	else if (md1->section_2_encryption_level == -LEVEL_1_ENCRYPTION_m12)
		printf_m12("(level 1, currently decrypted)\n");
	else if (md1->section_2_encryption_level == -LEVEL_2_ENCRYPTION_m12)
		printf_m12("(level 2, currently decrypted)\n");
	else
		printf_m12("(unrecognized code)\n");
	printf_m12("Section 3 Encryption Level: %d ", md1->section_3_encryption_level);
	if (md1->section_3_encryption_level == NO_ENCRYPTION_m12)
		printf_m12("(none)\n");
	else if (md1->section_3_encryption_level == LEVEL_1_ENCRYPTION_m12)
		printf_m12("(level 1, currently encrypted)\n");
	else if (md1->section_3_encryption_level == LEVEL_2_ENCRYPTION_m12)
		printf_m12("(level 2, currently encrypted)\n");
	else if (md1->section_3_encryption_level == -LEVEL_1_ENCRYPTION_m12)
		printf_m12("(level 1, currently decrypted)\n");
	else if (md1->section_3_encryption_level == -LEVEL_2_ENCRYPTION_m12)
		printf_m12("(level 2, currently decrypted)\n");
	else
		printf_m12("(unrecognized code)\n");
	printf_m12("Time Series Data Encryption Level: %d ", md1->time_series_data_encryption_level);
	if (md1->time_series_data_encryption_level == NO_ENCRYPTION_m12)
		printf_m12("(none)\n");
	else if (md1->time_series_data_encryption_level == LEVEL_1_ENCRYPTION_m12)
		printf_m12("(level 1, currently encrypted)\n");
	else if (md1->time_series_data_encryption_level == LEVEL_2_ENCRYPTION_m12)
		printf_m12("(level 2, currently encrypted)\n");
	else if (md1->time_series_data_encryption_level == -LEVEL_1_ENCRYPTION_m12)
		printf_m12("(level 1, currently decrypted)\n");
	else if (md1->time_series_data_encryption_level == -LEVEL_2_ENCRYPTION_m12)
		printf_m12("(level 2, currently decrypted)\n");
	else
		printf_m12("(unrecognized code)\n");
	printf_m12("------------------- Section 1 - END --------------------\n");
	printf_m12("------------------ Section 2 - START -------------------\n");
	
	// decrypt if needed
	if (md1->section_2_encryption_level > NO_ENCRYPTION_m12 || md1->section_3_encryption_level > NO_ENCRYPTION_m12)
		if (fps != NULL)
			G_decrypt_metadata_m12(fps);
	
	if (md1->section_2_encryption_level <= NO_ENCRYPTION_m12) {
		
		// type-independent fields
		gmd2 = tmd2;
		if (*gmd2->session_description)
			UTF8_printf_m12("Session Description: %s\n", gmd2->session_description);
		else
			printf_m12("Session Description: no entry\n");
		if (*gmd2->channel_description)
			UTF8_printf_m12("Channel Description: %s\n", gmd2->channel_description);
		else
			printf_m12("Channel Description: no entry\n");
		if (*gmd2->segment_description)
			UTF8_printf_m12("Segment Description: %s\n", gmd2->segment_description);
		else
			printf_m12("Segment Description: no entry\n");
		if (*gmd2->equipment_description)
			UTF8_printf_m12("Equipment Description: %s\n", gmd2->equipment_description);
		else
			printf_m12("Equipment Description: no entry\n");
		if (gmd2->acquisition_channel_number == METADATA_ACQUISITION_CHANNEL_NUMBER_NO_ENTRY_m12)
			printf_m12("Acquisition Channel Number: no entry\n");
		else
			printf_m12("Acquisition Channel Number: %d\n", gmd2->acquisition_channel_number);
		
		// type-specific fields
		if (tmd2 != NULL) {
			if (*tmd2->reference_description)
				UTF8_printf_m12("Reference Description: %s\n", tmd2->reference_description);
			else
				printf_m12("Reference Description: no entry\n");
			if (tmd2->sampling_frequency == TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12)
				printf_m12("Sampling Frequency: no entry\n");
			else if (tmd2->sampling_frequency == TIME_SERIES_METADATA_FREQUENCY_VARIABLE_m12)
				printf_m12("Sampling Frequency: variable\n");
			else
				printf_m12("Sampling Frequency: %lf\n", tmd2->sampling_frequency);
			if (tmd2->low_frequency_filter_setting == TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12)
				printf_m12("Low Frequency Filter Setting: no entry\n");
			else if (tmd2->low_frequency_filter_setting == TIME_SERIES_METADATA_FREQUENCY_VARIABLE_m12)
				printf_m12("Low Frequency Filter Setting: variable\n");
			else
				printf_m12("Low Frequency Filter Setting (Hz): %lf\n", tmd2->low_frequency_filter_setting);
			if (tmd2->high_frequency_filter_setting == TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12)
				printf_m12("High Frequency Filter Setting: no entry\n");
			else if (tmd2->high_frequency_filter_setting == TIME_SERIES_METADATA_FREQUENCY_VARIABLE_m12)
				printf_m12("High Frequency Filter Setting: variable\n");
			else
				printf_m12("High Frequency Filter Setting (Hz): %lf\n", tmd2->high_frequency_filter_setting);
			if (tmd2->notch_filter_frequency_setting == TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12)
				printf_m12("Notch Filter Frequency Setting: no entry\n");
			else if (tmd2->notch_filter_frequency_setting == TIME_SERIES_METADATA_FREQUENCY_VARIABLE_m12)
				printf_m12("Notch Filter Frequency Setting: variable\n");
			else
				printf_m12("Notch Filter Frequency Setting (Hz): %lf\n", tmd2->notch_filter_frequency_setting);
			if (tmd2->AC_line_frequency == TIME_SERIES_METADATA_FREQUENCY_NO_ENTRY_m12)
				printf_m12("AC Line Frequency: no entry\n");
			else
				printf_m12("AC Line Frequency (Hz): %lf\n", tmd2->AC_line_frequency);
			if (tmd2->amplitude_units_conversion_factor == TIME_SERIES_METADATA_AMPLITUDE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m12)
				printf_m12("Amplitiude Units Conversion Factor: no entry\n");
			else
				printf_m12("Amplitude Units Conversion Factor: %lf\n", tmd2->amplitude_units_conversion_factor);
			if (*tmd2->amplitude_units_description)
				UTF8_printf_m12("Amplitude Units Description: %s\n", tmd2->amplitude_units_description);
			else
				printf_m12("Amplitude Units Description: no entry\n");
			if (tmd2->time_base_units_conversion_factor == TIME_SERIES_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m12)
				printf_m12("Time Base Units Conversion Factor: no entry\n");
			else
				printf_m12("Time Base Units Conversion Factor: %lf\n", tmd2->time_base_units_conversion_factor);
			if (*tmd2->time_base_units_description)
				UTF8_printf_m12("Time Base Units Description: %s\n", tmd2->time_base_units_description);
			else
				printf_m12("Time Base Units Description: no entry\n");
			if (tmd2->absolute_start_sample_number == TIME_SERIES_METADATA_ABSOLUTE_START_SAMPLE_NUMBER_NO_ENTRY_m12)
				printf_m12("Absolute Start Sample Number: no entry\n");
			else
				printf_m12("Absolute Start Sample Number: %ld\n", tmd2->absolute_start_sample_number);
			if (tmd2->number_of_samples == TIME_SERIES_METADATA_NUMBER_OF_SAMPLES_NO_ENTRY_m12)
				printf_m12("Number of Samples: no entry\n");
			else
				printf_m12("Number of Samples: %ld\n", tmd2->number_of_samples);
			if (tmd2->number_of_blocks == TIME_SERIES_METADATA_NUMBER_OF_BLOCKS_NO_ENTRY_m12)
				printf_m12("Number of Blocks: no entry\n");
			else
				printf_m12("Number of Blocks: %ld\n", tmd2->number_of_blocks);
			if (tmd2->maximum_block_bytes == TIME_SERIES_METADATA_MAXIMUM_BLOCK_BYTES_NO_ENTRY_m12)
				printf_m12("Maximum Block Bytes: no entry\n");
			else
				printf_m12("Maximum Block Bytes: %ld\n", tmd2->maximum_block_bytes);
			if (tmd2->maximum_block_samples == TIME_SERIES_METADATA_MAXIMUM_BLOCK_SAMPLES_NO_ENTRY_m12)
				printf_m12("Maximum Block Samples: no entry\n");
			else
				printf_m12("Maximum Block Samples: %u\n", tmd2->maximum_block_samples);
			if (tmd2->maximum_block_keysample_bytes == TIME_SERIES_METADATA_MAXIMUM_BLOCK_KEYSAMPLE_BYTES_NO_ENTRY_m12)
				printf_m12("Maximum Block Difference Bytes: no entry\n");
			else
				printf_m12("Maximum Block Keysample Bytes: %u\n", tmd2->maximum_block_keysample_bytes);
			if (tmd2->maximum_block_duration == TIME_SERIES_METADATA_MAXIMUM_BLOCK_DURATION_NO_ENTRY_m12)
				printf_m12("Maximum Block Duration: no entry\n");
			else
				UTF8_printf_m12("Maximum Block Duration: %lf %s\n", tmd2->maximum_block_duration, tmd2->time_base_units_description);
			if (tmd2->number_of_discontinuities == TIME_SERIES_METADATA_NUMBER_OF_DISCONTINUITIES_NO_ENTRY_m12)
				printf_m12("Number of Discontinuities: no entry\n");
			else
				printf_m12("Number of Discontinuities: %ld\n", tmd2->number_of_discontinuities);
			if (tmd2->maximum_contiguous_blocks == TIME_SERIES_METADATA_MAXIMUM_CONTIGUOUS_BLOCKS_NO_ENTRY_m12)
				printf_m12("Maximum Contiguous Blocks: no entry\n");
			else
				printf_m12("Maximum Contiguous Blocks: %ld\n", tmd2->maximum_contiguous_blocks);
			if (tmd2->maximum_contiguous_block_bytes == TIME_SERIES_METADATA_MAXIMUM_CONTIGUOUS_BLOCK_BYTES_NO_ENTRY_m12)
				printf_m12("Maximum Contiguous Block Bytes: no entry\n");
			else
				printf_m12("Maximum Contiguous Block Bytes: %ld\n", tmd2->maximum_contiguous_block_bytes);
			if (tmd2->maximum_contiguous_samples == TIME_SERIES_METADATA_MAXIMUM_CONTIGUOUS_SAMPLES_NO_ENTRY_m12)
				printf_m12("Maximum Contiguous Samples: no entry\n");
			else
				printf_m12("Maximum Contiguous Samples: %ld\n", tmd2->maximum_contiguous_samples);
		} else if (vmd2 != NULL) {
			if (vmd2->time_base_units_conversion_factor == VIDEO_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m12)
				printf_m12("Time Base Units Conversion Factor: no entry\n");
			else
				printf_m12("Time Base Units Conversion Factor: %lf\n", vmd2->time_base_units_conversion_factor);
			if (*vmd2->time_base_units_description)
				UTF8_printf_m12("Time Base Units Description: %s\n", vmd2->time_base_units_description);
			else
				printf_m12("Time Base Units Description: no entry\n");
			if (vmd2->absolute_start_frame_number == VIDEO_METADATA_ABSOLUTE_START_FRAME_NUMBER_NO_ENTRY_m12)
				printf_m12("Absolute Start Frame Number: no entry\n");
			else
				printf_m12("Absolute Start Frame Number: %ld\n", vmd2->absolute_start_frame_number);
			if (vmd2->number_of_frames == VIDEO_METADATA_NUMBER_OF_FRAMES_NO_ENTRY_m12)
				printf_m12("Number of Frames: no entry\n");
			else
				printf_m12("Number of Frames: %ld\n", vmd2->number_of_frames);
			if (vmd2->frame_rate == VIDEO_METADATA_FRAME_RATE_NO_ENTRY_m12)
				printf_m12("Frame Rate: no entry\n");
			else if (vmd2->frame_rate == VIDEO_METADATA_FRAME_RATE_VARIABLE_m12)
				printf_m12("Frame Rate: variable\n");
			else
				printf_m12("Frame Rate: %lf (frames per second)\n", vmd2->frame_rate);
			if (vmd2->number_of_clips == VIDEO_METADATA_NUMBER_OF_CLIPS_NO_ENTRY_m12)
				printf_m12("Number of Clips: no entry\n");
			else
				printf_m12("Number of Clips: %ld (~= number of video indices)\n", vmd2->number_of_clips);
			if (vmd2->maximum_clip_bytes == VIDEO_METADATA_MAXIMUM_CLIP_BYTES_NO_ENTRY_m12)
				printf_m12("Maximum Clip Bytes: no entry\n");
			else
				printf_m12("Maximum Clip Bytes: %ld\n", vmd2->maximum_clip_bytes);
			if (vmd2->maximum_clip_frames == VIDEO_METADATA_MAXIMUM_CLIP_FRAMES_NO_ENTRY_m12)
				printf_m12("Maximum Clip Frames: no entry\n");
			else
				printf_m12("Maximum Clip Frames: %ld\n", vmd2->maximum_clip_frames);
			if (vmd2->number_of_video_files == VIDEO_METADATA_NUMBER_OF_VIDEO_FILES_NO_ENTRY_m12)
				printf_m12("Number of Video Files: no entry\n");
			else
				printf_m12("Number of Video Files: %d\n", vmd2->number_of_video_files);
			if (vmd2->maximum_clip_duration == VIDEO_METADATA_MAXIMUM_CLIP_DURATION_NO_ENTRY_m12)
				printf_m12("Maximum Clip Duration: no entry\n");
			else
				UTF8_printf_m12("Maximum Clip Duration: %lf %s\n", vmd2->maximum_clip_duration, vmd2->time_base_units_description);
			if (vmd2->number_of_discontinuities == VIDEO_METADATA_NUMBER_OF_DISCONTINUITIES_NO_ENTRY_m12)
				printf_m12("Number of Discontinuities: no entry\n");
			else
				printf_m12("Number of Discontinuities: %ld\n", vmd2->number_of_discontinuities);
			if (vmd2->maximum_contiguous_clips == VIDEO_METADATA_MAXIMUM_CONTIGUOUS_CLIPS_NO_ENTRY_m12)
				printf_m12("Maximum Contiguous Clips: no entry\n");
			else
				printf_m12("Maximum Contiguous Clips: %ld\n", vmd2->maximum_contiguous_clips);
			if (vmd2->maximum_contiguous_clip_bytes == VIDEO_METADATA_MAXIMUM_CONTIGUOUS_CLIP_BYTES_NO_ENTRY_m12)
				printf_m12("Maximum Contiguous Clip Bytes: no entry\n");
			else
				printf_m12("Maximum Contiguous Clip Bytes: %ld\n", vmd2->maximum_contiguous_clip_bytes);
			if (vmd2->maximum_contiguous_frames == VIDEO_METADATA_MAXIMUM_CONTIGUOUS_FRAMES_NO_ENTRY_m12)
				printf_m12("Maximum Contiguous Frames: no entry\n");
			else
				printf_m12("Maximum Contiguous Frames: %ld\n", vmd2->maximum_contiguous_frames);
			if (vmd2->horizontal_pixels == VIDEO_METADATA_HORIZONTAL_PIXELS_NO_ENTRY_m12)
				printf_m12("Horizontal Pixels: no entry\n");
			else
				printf_m12("Horizontal Pixels: %u\n", vmd2->horizontal_pixels);
			if (vmd2->vertical_pixels == VIDEO_METADATA_VERTICAL_PIXELS_NO_ENTRY_m12)
				printf_m12("Vertical Pixels: no entry\n");
			else
				printf_m12("Vertical Pixels: %u\n", vmd2->vertical_pixels);
			if (*vmd2->video_format)
				UTF8_printf_m12("Video Format: %s\n", vmd2->video_format);
			else
				printf_m12("Video Format: no entry\n");
		} else {
			printf_m12("(unrecognized metadata section 2 type)\n");
		}
	} else {
		printf_m12("No access to section 2\n");
	}
	printf_m12("------------------- Section 2 - END --------------------\n");
	printf_m12("------------------ Section 3 - START -------------------\n");
	if (md1->section_3_encryption_level <= NO_ENCRYPTION_m12) {
		if (md3->recording_time_offset == UUTC_NO_ENTRY_m12)
			printf_m12("Recording Time Offset: no entry\n");
		else
			printf_m12("Recording Time Offset: %ld\n", md3->recording_time_offset);
		if (md3->daylight_time_start_code.value == DTCC_VALUE_NO_ENTRY_m12) {
			printf_m12("Daylight Time Start Code: no entry\n");
		} else {
			STR_generate_hex_string_m12((ui1 *) &md3->daylight_time_start_code.value, 8, hex_str);
			printf_m12("Daylight Time Start Code: %s\n", hex_str);
		}
		if (md3->daylight_time_end_code.value == DTCC_VALUE_NO_ENTRY_m12) {
			printf_m12("Daylight Time End Code: no entry\n");
		} else {
			STR_generate_hex_string_m12((ui1 *) &md3->daylight_time_end_code.value, 8, hex_str);
			printf_m12("Daylight Time End Code: %s\n", hex_str);
		}
		if (*md3->standard_timezone_acronym)
			printf_m12("Standard Timezone Acronym: %s\n", md3->standard_timezone_acronym);
		else
			printf_m12("Standard Timezone Acronym: no entry\n");
		if (*md3->standard_timezone_string)
			printf_m12("Standard Timezone String: %s\n", md3->standard_timezone_string);
		else
			printf_m12("Standard Timezone String: no entry\n");
		if (*md3->daylight_timezone_acronym)
			printf_m12("Daylight Timezone Acronym: %s\n", md3->daylight_timezone_acronym);
		else
			printf_m12("Daylight Timezone Acronym: no entry\n");
		if (*md3->daylight_timezone_string)
			printf_m12("Daylight Timezone String: %s\n", md3->daylight_timezone_string);
		else
			printf_m12("Daylight Timezone String: no entry\n");
		if (*md3->subject_name_1)
			UTF8_printf_m12("Subject Name 1: %s\n", md3->subject_name_1);
		else
			printf_m12("Subject Name 1: no entry\n");
		if (*md3->subject_name_2)
			UTF8_printf_m12("Subject Name 2: %s\n", md3->subject_name_2);
		else
			printf_m12("Subject Name 2: no entry\n");
		if (*md3->subject_name_3)
			UTF8_printf_m12("Subject Name 3: %s\n", md3->subject_name_3);
		else
			printf_m12("Subject Name 3: no entry\n");
		if (*md3->subject_ID)
			UTF8_printf_m12("Subject ID: %s\n", md3->subject_ID);
		else
			printf_m12("Subject ID: no entry\n");
		if (*md3->recording_country)
			UTF8_printf_m12("Recording Country: %s\n", md3->recording_country);
		else
			printf_m12("Recording Country: no entry\n");
		if (*md3->recording_territory)
			UTF8_printf_m12("Recording Territory: %s\n", md3->recording_territory);
		else
			printf_m12("Recording Territory: no entry\n");
		if (*md3->recording_locality)
			UTF8_printf_m12("Recording Locality: %s\n", md3->recording_locality);
		else
			printf_m12("Recording Locality: no entry\n");
		if (*md3->recording_institution)
			UTF8_printf_m12("Recording Institution: %s\n", md3->recording_institution);
		else
			printf_m12("Recording Institution: no entry\n");
		if (*md3->geotag_format)
			UTF8_printf_m12("GeoTag Format: %s\n", md3->geotag_format);
		else
			printf_m12("GeoTag Format: no entry\n");
		if (*md3->geotag_data)
			UTF8_printf_m12("GeoTag Data: %s\n", md3->geotag_data);
		else
			printf_m12("GeoTag Data: no entry\n");
		if (md3->standard_UTC_offset == STANDARD_UTC_OFFSET_NO_ENTRY_m12)
			printf_m12("Standard UTC Offset: no entry\n");
		else
			printf_m12("Standard UTC Offset: %d\n", md3->standard_UTC_offset);
	} else {
		printf_m12("No access to section 3\n");
	}
	printf_m12("------------------- Section 3 - END --------------------\n");
	printf_m12("-------------------- Metadata - END --------------------\n\n");
	
	return;
}


void	G_show_password_data_m12(PASSWORD_DATA_m12 *pwd)
{
	si1	hex_str[HEX_STRING_BYTES_m12(ENCRYPTION_KEY_BYTES_m12)];
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// use G_message_m12() because show_password_data_m12() is used in normal (no programming) functions => so allow output to be suppressed easily
	if (pwd == NULL) {
		G_message_m12("\n-------------- Global Password Data - START --------------\n");
		pwd = &globals_m12->password_data;
	}
	else {
		G_message_m12("\n------------------ Password Data - START -----------------\n");
	}
	if (pwd->access_level >= LEVEL_1_ACCESS_m12) {
		STR_generate_hex_string_m12(pwd->level_1_encryption_key, ENCRYPTION_KEY_BYTES_m12, hex_str);
		G_message_m12("Level 1 Encryption Key: %s\n", hex_str);
	}
	if (pwd->access_level == LEVEL_2_ACCESS_m12) {
		STR_generate_hex_string_m12(pwd->level_2_encryption_key, ENCRYPTION_KEY_BYTES_m12, hex_str);
		G_message_m12("Level 2 Encryption Key: %s\n", hex_str);
	}
	G_show_password_hints_m12(pwd);
	G_message_m12("Access Level: %hhu\n", pwd->access_level);
	G_message_m12("Processed: %hhd\n", pwd->processed);
	G_message_m12("------------------- Password Data - END ------------------\n\n");
	
	return;
}


void	G_show_password_hints_m12(PASSWORD_DATA_m12 *pwd)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// use G_message_m12() because show_password_data_m12() is used in normal (not programming) functions => so allow output to be suppressed easily
	
	if (pwd == NULL)
		pwd = &globals_m12->password_data;
	if (*pwd->level_1_password_hint)
		G_message_m12("Level 1 Password Hint: %s\n", pwd->level_1_password_hint);
	if (*pwd->level_2_password_hint)
		G_message_m12("Level 2 Password Hint: %s\n", pwd->level_2_password_hint);
	
	return;
}


void	G_show_records_m12(FILE_PROCESSING_STRUCT_m12 *record_data_fps, si4 *record_filters)
{
	ui1			*ui1_p;
	si8			i, n_recs, r_cnt;
	RECORD_HEADER_m12	*rh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// record_filters is a signed, "NULL terminated" array version of MED record type codes to include or exclude when reading records.
	// The terminal entry is NO_TYPE_CODE_m12 (== zero). NULL or no filter codes includes all records (== no filters).
	// filter modes: match positive: include
	//		 match negative: exclude
	//		 no match:
	//			all filters positive: exclude
	//			else: include
	// Note: as type codes are composed of ascii bytes values (< 0x80), it is always possible to make them negative without promotion.
	//
	// Example usage: si4	my_rec_filters[] = { REC_Sgmt_TYPE_CODE_m12, REC_Note_TYPE_CODE_m12, NO_TYPE_CODE_m12 };
	//
	// If the passed record_filters is NULL, the global record_filters will be used.
	// If the global record_filters are NULL, all records will be accepted.
	// If record_filters is a "zero-length" array (i.e. record_filters = { NO_TYPE_CODE_m12 }), all records will be accepted.
	// record_filters
	
	
	if (record_filters == NULL)
		record_filters = globals_m12->record_filters;	// if these too are NULL, no filters applied
	else if (*record_filters == NO_TYPE_CODE_m12)		// Note: if G_read_record_data_m12() with these filters was used to get records, filtering is already done
		record_filters = NULL;				// show all types, even if global filters are not NULL
	
	// show records
	n_recs = record_data_fps->number_of_items;
	ui1_p = (void *) record_data_fps->record_data;
	for (i = r_cnt = 0; i < n_recs; ++i) {
		rh = (RECORD_HEADER_m12 *) ui1_p;
		if (G_include_record_m12(rh->type_code, record_filters) == TRUE_m12)
			REC_show_record_m12(record_data_fps, rh, ++r_cnt);
		ui1_p += rh->total_record_bytes;
	}
	
	return;
}


void	G_show_Sgmt_records_array_m12(LEVEL_HEADER_m12 *level_header, Sgmt_RECORD_m12 *Sgmt)
{
	si1	                time_str[TIME_STRING_BYTES_m12], hex_str[HEX_STRING_BYTES_m12(8)];
	si4			n_segs;
	si8			i;
	CHANNEL_m12		*chan;
	SESSION_m12		*sess;
	
	
	if (level_header != NULL) {
		switch (level_header->type_code) {
			case LH_TIME_SERIES_CHANNEL_m12:
			case LH_VIDEO_CHANNEL_m12:
				chan = (CHANNEL_m12 *) level_header;
				Sgmt = chan->Sgmt_records;
				break;
			case LH_SESSION_m12:
				sess = (SESSION_m12 *) level_header;
				Sgmt = sess->Sgmt_records;
				break;
			default:
				G_warning_message_m12("%s(): invalid level type\n", __FUNCTION__);
				return;
		}
	} else if (Sgmt == NULL) {
		G_warning_message_m12("%s(): both arguments are NULL\n", __FUNCTION__);
		return;
	}
	
	if (Sgmt == NULL) {
		G_warning_message_m12("%s(): NULL Sgmt records array\n", __FUNCTION__);
		return;
	}
	
	n_segs = globals_m12->number_of_session_segments;
	if (n_segs == 0) {
		G_warning_message_m12("%s(): empty Sgmt records array\n", __FUNCTION__);
		return;
	}
	
	for (i = 0; i < n_segs; ++i, ++Sgmt) {
		printf_m12("%sRecord number: %ld%s\n", TC_RED_m12, i + 1, TC_RESET_m12);
		if (Sgmt->start_time == RECORD_HEADER_START_TIME_NO_ENTRY_m12)
			printf_m12("Record Start Time: no entry\n");
		else {
			STR_time_string_m12(Sgmt->start_time, time_str, TRUE_m12, FALSE_m12, FALSE_m12);
			printf_m12("Record Start Time: %ld (oUTC), %s\n", Sgmt->start_time, time_str);
		}
		STR_time_string_m12(Sgmt->end_time, time_str, TRUE_m12, FALSE_m12, FALSE_m12);
		printf_m12("End Time: %ld (oUTC), %s\n", Sgmt->end_time, time_str);
		if (Sgmt->start_sample_number == REC_Sgmt_v10_START_SAMPLE_NUMBER_NO_ENTRY_m12)
			printf_m12("Start Sample Number: no entry\n");
		else
			printf_m12("Start Sample Number: %ld\n", Sgmt->start_sample_number);
		if (Sgmt->end_sample_number == REC_Sgmt_v10_END_SAMPLE_NUMBER_NO_ENTRY_m12)
			printf_m12("End Sample Number: no entry\n");
		else
			printf_m12("End Sample Number: %ld\n", Sgmt->end_sample_number);
		STR_generate_hex_string_m12((ui1*)&Sgmt->segment_UID, 8, hex_str);
		printf_m12("Segment UID: %s\n", hex_str);
		if (Sgmt->segment_number == REC_Sgmt_v10_SEGMENT_NUMBER_NO_ENTRY_m12)
			printf_m12("Segment Number: no entry\n");
		else
			printf_m12("Segment Number: %d\n", Sgmt->segment_number);

		if (Sgmt->acquisition_channel_number == REC_Sgmt_v10_ACQUISITION_CHANNEL_NUMBER_ALL_CHANNELS_m12)
			printf_m12("Acquisition Channel Number: all channels\n");
		else if (Sgmt->acquisition_channel_number == REC_Sgmt_v10_ACQUISITION_CHANNEL_NUMBER_NO_ENTRY_m12)
			printf_m12("Acquisition Channel Number: no entry\n");
		else
			printf_m12("Acquisition Channel Number: %d\n", Sgmt->acquisition_channel_number);

		if (Sgmt->sampling_frequency == REC_Sgmt_v10_SAMPLING_FREQUENCY_NO_ENTRY_m12)
			printf_m12("Sampling Frequency: no entry\n");
		else if (Sgmt->sampling_frequency == REC_Sgmt_v10_SAMPLING_FREQUENCY_VARIABLE_m12)
			printf_m12("Sampling Frequency: variable\n");
		else
			printf_m12("Sampling Frequency: %lf\n\n", Sgmt->sampling_frequency);
	}

	return;
}


void    G_show_time_slice_m12(TIME_SLICE_m12 *slice)
{	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	printf_m12("Conditioned: ");
	if (slice->conditioned == TRUE_m12)
		printf_m12("true\n");
	else if (slice->conditioned == FALSE_m12)
		printf_m12("false\n");
	else if (slice->conditioned == UNKNOWN_m12)
		printf_m12("unknown\n");
	else
		printf_m12("invalid value (%hhd)\n", slice->conditioned);
	
	if (slice->number_of_segments == UNKNOWN_m12)
		printf_m12("Number of Segments: unknown\n");
	else if (slice->number_of_segments == EMPTY_SLICE_m12)
		printf_m12("Number of Segments: empty slice (segments missing)\n");
	else
		printf_m12("Number of Segments: %d\n", slice->number_of_segments);

	printf_m12("Start Time: ");
	if (slice->start_time == UUTC_NO_ENTRY_m12)
		printf_m12("no entry\n");
	else if (slice->start_time == BEGINNING_OF_TIME_m12)
		printf_m12("beginning of time\n");
	else if (slice->start_time == END_OF_TIME_m12)
		printf_m12("end of time\n");
	else
		printf_m12("%ld\n", slice->start_time);
	
	printf_m12("End Time: ");
	if (slice->end_time == UUTC_NO_ENTRY_m12)
		printf_m12("no entry\n");
	else if (slice->end_time == BEGINNING_OF_TIME_m12)
		printf_m12("beginning of time\n");
	else if (slice->end_time == END_OF_TIME_m12)
		printf_m12("end of time\n");
	else
		printf_m12("%ld\n", slice->end_time);
	
	printf_m12("Start Sample/Frame Number: ");
	if (slice->start_sample_number == SAMPLE_NUMBER_NO_ENTRY_m12)
		printf_m12("no entry\n");
	else if (slice->start_sample_number == END_OF_SAMPLE_NUMBERS_m12)
		printf_m12("end of samples/frames\n");
	else
		printf_m12("%ld\n", slice->start_sample_number);
	
	printf_m12("End Sample/Frame Number: ");
	if (slice->end_sample_number == SAMPLE_NUMBER_NO_ENTRY_m12)
		printf_m12("no entry\n");
	else if (slice->end_sample_number == END_OF_SAMPLE_NUMBERS_m12)
		printf_m12("end of samples/frames\n");
	else
		printf_m12("%ld\n", slice->end_sample_number);
	
	printf_m12("Start Segment Number: ");
	if (slice->start_segment_number == SEGMENT_NUMBER_NO_ENTRY_m12)
		printf_m12("no entry\n");
	else
		printf_m12("%d\n", slice->start_segment_number);
	
	printf_m12("End Segment Number: ");
	if (slice->end_segment_number == SEGMENT_NUMBER_NO_ENTRY_m12)
		printf_m12("no entry\n");
	else
		printf_m12("%d\n", slice->end_segment_number);
		
	printf_m12("\n");
	
	return;
}


void    G_show_timezone_info_m12(TIMEZONE_INFO_m12 *timezone_entry, TERN_m12 show_DST_detail)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	printf_m12("Country: %s\n", timezone_entry->country);
	printf_m12("Country Acronym (2 letter): %s\n", timezone_entry->country_acronym_2_letter);
	printf_m12("Country Acronym (3 letter): %s\n", timezone_entry->country_acronym_3_letter);
	if (*timezone_entry->territory)
		printf_m12("Territory: %s\n", timezone_entry->territory);
	if (*timezone_entry->territory_acronym)
		printf_m12("Territory Acronym: %s\n", timezone_entry->territory_acronym);
	printf_m12("Standard Timezone: %s\n", timezone_entry->standard_timezone);
	printf_m12("Standard Timezone Acronym: %s\n", timezone_entry->standard_timezone_acronym);
	printf_m12("Standard UTC Offset (secs): %d\n", timezone_entry->standard_UTC_offset);
	
	if (timezone_entry->daylight_time_start_code) {
		printf_m12("Daylight Timezone: %s\n", timezone_entry->daylight_timezone);
		printf_m12("Daylight Timezone Acronym: %s\n", timezone_entry->daylight_timezone_acronym);
		if (timezone_entry->daylight_time_start_code == DTCC_VALUE_NO_ENTRY_m12) {
			printf_m12("Daylight Time data is not available\n");
		} else if (show_DST_detail == TRUE_m12) {
			printf_m12("Daylight Time Start Code: 0x%lX\n", timezone_entry->daylight_time_start_code);
			G_show_daylight_change_code_m12((DAYLIGHT_TIME_CHANGE_CODE_m12 *) &timezone_entry->daylight_time_start_code, "\t");
			printf_m12("Daylight Time End Code: 0x%lX\n", timezone_entry->daylight_time_end_code);
			G_show_daylight_change_code_m12((DAYLIGHT_TIME_CHANGE_CODE_m12 *) &timezone_entry->daylight_time_end_code, "\t");
		}
	} else {
		printf_m12("Daylight Time is not observed\n");
	}
	return;
}


void	G_show_universal_header_m12(FILE_PROCESSING_STRUCT_m12 *fps, UNIVERSAL_HEADER_m12 *uh)
{
	TERN_m12        ephemeral_flag;
	si1             hex_str[HEX_STRING_BYTES_m12(PASSWORD_VALIDATION_FIELD_BYTES_m12)], time_str[TIME_STRING_BYTES_m12];
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// assign
	if (fps != NULL) {
		uh = fps->universal_header;
		if (fps->parameters.fd == FPS_FD_EPHEMERAL_m12)
			ephemeral_flag = TRUE_m12;
		else
			ephemeral_flag = FALSE_m12;
	} else {
		if (uh == NULL) {
			G_error_message_m12("%s(): invalid input\n", __FUNCTION__);
			return;
		}
		ephemeral_flag = UNKNOWN_m12;
	}
	
	printf_m12("---------------- Universal Header - START ----------------\n");
	if (uh->header_CRC == CRC_NO_ENTRY_m12)
		printf_m12("Header CRC: no entry\n");
	else {
		STR_generate_hex_string_m12((ui1 *)&uh->header_CRC, CRC_BYTES_m12, hex_str);
		printf_m12("Header CRC: %s\n", hex_str);
	}
	if (uh->body_CRC == CRC_NO_ENTRY_m12)
		printf_m12("Body CRC: no entry\n");
	else {
		STR_generate_hex_string_m12((ui1 *)&uh->body_CRC, CRC_BYTES_m12, hex_str);
		printf_m12("Body CRC: %s\n", hex_str);
	}
	if (uh->segment_end_time == UUTC_NO_ENTRY_m12)
		printf_m12("Segment End Time: no entry\n");
	else {
		STR_time_string_m12(uh->segment_end_time, time_str, TRUE_m12, FALSE_m12, FALSE_m12);
		printf_m12("Segment End Time: %ld (oUTC), %s\n", uh->segment_end_time, time_str);
	}
	if (uh->number_of_entries == UNIVERSAL_HEADER_NUMBER_OF_ENTRIES_NO_ENTRY_m12)
		printf_m12("Number of Entries: no entry\n");
	else {
		printf_m12("Number of Entries: %ld  ", uh->number_of_entries);
		switch (uh->type_code) {
			case RECORD_DATA_FILE_TYPE_CODE_m12:
				printf_m12("(number of records in the file)\n");
				break;
			case RECORD_INDICES_FILE_TYPE_CODE_m12:
				printf_m12("(number of record indices in the file)\n");
				break;
			case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
			case VIDEO_METADATA_FILE_TYPE_CODE_m12:
				if (ephemeral_flag == TRUE_m12)
					printf_m12("(maximum number of records in records files at this level and below)\n");
				else if (ephemeral_flag == FALSE_m12)
					printf_m12("(one metadata entry per metadata file)\n");
				else // UNKNOWN
					printf_m12("(one metadata entry, or maximum number of records in a records file at this level and below)\n");
				break;
			case VIDEO_INDICES_FILE_TYPE_CODE_m12:
				printf_m12("(number of video indices in the file)\n");
				break;
			case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
				printf_m12("(number of CMP blocks in the file)\n");
				break;
			case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
				printf_m12("(number of time series indices in the file)\n");
				break;
			default:
				printf_m12("\n");
				break;
		}
	}
	if (uh->maximum_entry_size == UNIVERSAL_HEADER_MAXIMUM_ENTRY_SIZE_NO_ENTRY_m12)
		printf_m12("Maximum Entry Size: no entry\n");
	else {
		printf_m12("Maximum Entry Size: %u  ", uh->maximum_entry_size);
		switch (uh->type_code) {
			case RECORD_DATA_FILE_TYPE_CODE_m12:
				printf_m12("(number of bytes in the largest record in the file)\n");
				break;
			case RECORD_INDICES_FILE_TYPE_CODE_m12:
				printf_m12("(number of bytes in a record index)\n");
				break;
			case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
			case VIDEO_METADATA_FILE_TYPE_CODE_m12:
				if (ephemeral_flag == TRUE_m12)
					printf_m12("(maximum number of bytes in a record at this level and below)\n");
				else if (ephemeral_flag == FALSE_m12)
					printf_m12("(number of bytes in a metadata structure)\n");
				else // UNKNOWN
					printf_m12("(metadata bytes, or maximum number of bytes in a record at this level and below)\n");
				break;
			case VIDEO_INDICES_FILE_TYPE_CODE_m12:
				printf_m12("(number of bytes in a video index)\n");
				break;
			case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
				printf_m12("(number of bytes in the largest CMP block in the file)\n");
				break;
			case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
				printf_m12("(number of bytes in a time series index)\n");
				break;
			default:
				printf_m12("\n");
				break;
				
		}
	}
	if (uh->segment_number == UNIVERSAL_HEADER_SEGMENT_NUMBER_NO_ENTRY_m12)
		printf_m12("Segment Number: no entry\n");
	else if (uh->segment_number == UNIVERSAL_HEADER_CHANNEL_LEVEL_CODE_m12)
		printf_m12("Segment Number: channel level\n");
	else if (uh->segment_number == UNIVERSAL_HEADER_SESSION_LEVEL_CODE_m12)
		printf_m12("Segment Number: session level\n");
	else
		printf_m12("Segment Number: %d\n", uh->segment_number);
	if (*uh->type_string)
		printf_m12("File Type String: %s\n", uh->type_string);
	else
		printf_m12("File Type String: no entry\n");
	if (uh->MED_version_major == UNIVERSAL_HEADER_MED_VERSION_MAJOR_NO_ENTRY_m12 || uh->MED_version_minor == UNIVERSAL_HEADER_MED_VERSION_MINOR_NO_ENTRY_m12) {
		if (uh->MED_version_major == UNIVERSAL_HEADER_MED_VERSION_MAJOR_NO_ENTRY_m12)
			printf_m12("MED Version Major: no entry\n");
		else
			printf_m12("MED Version Major: %u\n", uh->MED_version_major);
		if (uh->MED_version_minor == UNIVERSAL_HEADER_MED_VERSION_MINOR_NO_ENTRY_m12)
			printf_m12("MED Version Minor: no entry\n");
		else
			printf_m12("MED Version Minor: %u\n", uh->MED_version_minor);
	}
	else
		printf_m12("MED Version: %u.%u\n", uh->MED_version_major, uh->MED_version_minor);
	if (uh->byte_order_code == UNIVERSAL_HEADER_BYTE_ORDER_CODE_NO_ENTRY_m12)
		printf_m12("Byte Order Code: no entry ");
	else {
		printf_m12("Byte Order Code: %u ", uh->byte_order_code);
		if (uh->byte_order_code == LITTLE_ENDIAN_m12)
			printf_m12("(little endian)\n");
		else if (uh->byte_order_code == BIG_ENDIAN_m12)
			printf_m12("(big endian)\n");
		else
			printf_m12("(unrecognized code)\n");
	}
	if (uh->session_start_time == UUTC_NO_ENTRY_m12)
		printf_m12("Session Start Time: no entry\n");
	else {
		STR_time_string_m12(uh->session_start_time, time_str, TRUE_m12, FALSE_m12, FALSE_m12);
		printf_m12("Session Start Time: %ld (oUTC), %s\n", uh->session_start_time, time_str);
	}
	if (uh->segment_start_time == UUTC_NO_ENTRY_m12)
		printf_m12("Segment Start Time: no entry\n");
	else {
		STR_time_string_m12(uh->segment_start_time, time_str, TRUE_m12, FALSE_m12, FALSE_m12);
		printf_m12("Segment Start Time: %ld (oUTC), %s\n", uh->segment_start_time, time_str);
	}
	if (*uh->session_name)
		UTF8_printf_m12("Session Name: %s\n", uh->session_name);
	else
		printf_m12("Session Name: no entry\n");
	if (*uh->channel_name)
		UTF8_printf_m12("Channel Name: %s\n", uh->channel_name);
	else
		printf_m12("Channel Name: no entry\n");
	if (*uh->anonymized_subject_ID)
		UTF8_printf_m12("Anonymized Subject ID: %s\n", uh->anonymized_subject_ID);
	else
		printf_m12("Anonymized Subject ID: no entry\n");
	if (uh->session_UID == UID_NO_ENTRY_m12)
		printf_m12("Session UID: no entry\n");
	else {
		STR_generate_hex_string_m12((ui1 *)&uh->session_UID, UID_BYTES_m12, hex_str);
		printf_m12("Session UID: %s\n", hex_str);
	}
	if (uh->channel_UID == UID_NO_ENTRY_m12)
		printf_m12("Channel UID: no entry\n");
	else {
		STR_generate_hex_string_m12((ui1 *)&uh->channel_UID, UID_BYTES_m12, hex_str);
		printf_m12("Channel UID: %s\n", hex_str);
	}
	if (uh->segment_UID == UID_NO_ENTRY_m12)
		printf_m12("Segment UID: no entry\n");
	else {
		STR_generate_hex_string_m12((ui1 *)&uh->segment_UID, UID_BYTES_m12, hex_str);
		printf_m12("Segment UID: %s\n", hex_str);
	}
	if (uh->file_UID == UID_NO_ENTRY_m12)
		printf_m12("File UID: no entry\n");
	else {
		STR_generate_hex_string_m12((ui1 *)&uh->file_UID, UID_BYTES_m12, hex_str);
		printf_m12("File UID: %s\n", hex_str);
	}
	if (uh->provenance_UID == UID_NO_ENTRY_m12)
		printf_m12("Provenance UID: no entry\n");
	else {
		STR_generate_hex_string_m12((ui1 *)&uh->provenance_UID, UID_BYTES_m12, hex_str);
		printf_m12("Provenance UID: %s  ", hex_str);
		if (uh->provenance_UID == uh->file_UID)
			printf_m12("(original data)\n");
		else
			printf_m12("(derived data)\n");
	}
	if (G_all_zeros_m12(uh->level_1_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m12) == TRUE_m12)
		printf_m12("Level 1 Password Validation_Field: no entry\n");
	else {
		STR_generate_hex_string_m12(uh->level_1_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m12, hex_str);
		printf_m12("Level 1 Password Validation_Field: %s\n", hex_str);
	}
	if (G_all_zeros_m12(uh->level_2_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m12) == TRUE_m12)
		printf_m12("Level 2 Password Validation_Field: no entry\n");
	else {
		STR_generate_hex_string_m12(uh->level_2_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m12, hex_str);
		printf_m12("Level 2 Password Validation_Field: %s\n", hex_str);
	}
	if (G_all_zeros_m12(uh->level_3_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m12) == TRUE_m12)
		printf_m12("Level 3 Password Validation_Field: no entry\n");
	else {
		STR_generate_hex_string_m12(uh->level_3_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m12, hex_str);
		printf_m12("Level 3 Password Validation_Field: %s\n", hex_str);
	}
	printf_m12("---------------- Universal Header - END ----------------\n\n");
	
	return;
}


TERN_m12	G_sort_channels_by_acq_num_m12(SESSION_m12 *sess)
{
	TERN_m12			read_metadata;
	si1				seg_dir[FULL_FILE_NAME_BYTES_m12], md_file[FULL_FILE_NAME_BYTES_m12], num_str[FILE_NUMBERING_DIGITS_m12 + 1];
	si4				i, n_chans, seg_idx;
	CHANNEL_m12			*chan;
	SEGMENT_m12			*seg;
	FILE_PROCESSING_STRUCT_m12	*md_fps;
	ACQ_NUM_SORT_m12		*acq_idxs;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// Currently function only sort time series channels
	// Returns TRUE if sorted, FALSE if duplicate numbers exist, or other error condition

	n_chans = sess->number_of_time_series_channels;
	if (n_chans == 0) {
		G_warning_message_m12("%s(): no time series channels allocated\n", __FUNCTION__);
		return(FALSE_m12);
	}
	
	// build ACQ_NUM_SORT_m12 array
	acq_idxs = (ACQ_NUM_SORT_m12 *) malloc(n_chans * sizeof(ACQ_NUM_SORT_m12));
	seg_idx = G_get_segment_index_m12(FIRST_OPEN_SEGMENT_m12);
	*num_str = 0;
	for (i = 0; i < n_chans; ++i) {
		chan = sess->time_series_channels[i];
		read_metadata = FALSE_m12;
		if (chan->segments == NULL) {
			read_metadata = TRUE_m12;
		} else {
			seg = chan->segments[seg_idx];
			if (seg == NULL)
				read_metadata = TRUE_m12;
			else if (seg->metadata_fps == NULL)
				read_metadata = TRUE_m12;
		}
		if (read_metadata == TRUE_m12) {
			if (*num_str == 0)
				G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, seg_idx + 1);
			sprintf_m12(seg_dir, "%s/%s_s%s.%s", chan->path, chan->name, num_str, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12);
			sprintf_m12(md_file, "%s/%s_s%s.%s", seg_dir, chan->name, num_str, TIME_SERIES_METADATA_FILE_TYPE_STRING_m12);
			if (G_file_exists_m12(md_file) == FILE_EXISTS_m12) {
				md_fps = G_read_file_m12(NULL, md_file, 0, 0, FPS_FULL_FILE_m12, NULL, NULL, USE_GLOBAL_BEHAVIOR_m12);
				if (md_fps == NULL) {
					G_warning_message_m12("%s(): error reading metadata file \"%s\"\n", __FUNCTION__, md_file);
					free((void *) acq_idxs);
					return(FALSE_m12);
				}
			} else {
				G_warning_message_m12("%s(): metadata file \"%s\" is missing\n", __FUNCTION__, md_file);
				free((void *) acq_idxs);
				return(FALSE_m12);
			}
			acq_idxs[i].acq_num = md_fps->metadata->time_series_section_2.acquisition_channel_number;
			FPS_free_processing_struct_m12(md_fps, TRUE_m12);
		} else {
			seg = chan->segments[seg_idx];
			acq_idxs[i].acq_num = seg->metadata_fps->metadata->time_series_section_2.acquisition_channel_number;
		}
		acq_idxs[i].chan = chan;
	}

	// sort it
	qsort((void *) acq_idxs, (size_t) n_chans, sizeof(ACQ_NUM_SORT_m12), G_compare_acq_nums_m12);
	
	// check for duplicates
	for (i = 1; i < n_chans; ++i)
		if (acq_idxs[i].acq_num == acq_idxs[i - 1].acq_num)
			break;
	if (i < n_chans) {
		G_warning_message_m12("%s(): duplicate acquisition channel numbers => not sorting\n", __FUNCTION__);
		free((void *) acq_idxs);
		return(FALSE_m12);
	}

	// move channel pointers
	for (i = 0; i < n_chans; ++i)
		sess->time_series_channels[i] = acq_idxs[i].chan;
	free((void *) acq_idxs);

	return(TRUE_m12);
}


void	G_sort_records_m12(LEVEL_HEADER_m12 *level_header, si4 segment_number)
{
	ui1				*tmp_rec_data;
	si1				ri_path[FULL_FILE_NAME_BYTES_m12], rd_path[FULL_FILE_NAME_BYTES_m12], num_str[FILE_NUMBERING_DIGITS_m12 + 1];
	si4				seg_idx;
	si8				i, n_recs, file_start_time;
	SEGMENT_m12			*seg;
	CHANNEL_m12			*chan;
	SESSION_m12			*sess;
	SEGMENTED_SESS_RECS_m12		*ssr;
	FILE_PROCESSING_STRUCT_m12	*ri_fps, *rd_fps;
	RECORD_INDEX_m12		*ri;
	RECORD_HEADER_m12		*rh;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// for efficient searching of records during reading, MED requires records to be in temporal order
	// this function exists because in some converted file formats, records of different types are in different files, & it is not convenient to sort them during the conversion
	// call this function after records are completely written to disk, including terminal indices (if files are open they will be closed & reopened)
	// call for each potentially affected MED level
	// sorted records will overwrite the unsorted records
	// records with start times of UUTC_NO_ENTRY_m12 (information not associated with a specific time) will be assigned the segment start time if segmented, or the session start time
	// the segment_number argument is only required for segmented session records, otherwise ignored
	// this process is not terribly efficient, but should only need to be done once
	
	switch (level_header->type_code) {
		case LH_VIDEO_SEGMENT_m12:
		case LH_TIME_SERIES_SEGMENT_m12:
			seg = (SEGMENT_m12 *) level_header;
			sprintf_m12(ri_path, "%s/%s.%s", seg->path, seg->name, RECORD_INDICES_FILE_TYPE_STRING_m12);
			sprintf_m12(rd_path, "%s/%s.%s", seg->path, seg->name, RECORD_DATA_FILE_TYPE_STRING_m12);
			FPS_close_m12(seg->record_indices_fps);
			FPS_close_m12(seg->record_data_fps);
			break;
		case LH_TIME_SERIES_CHANNEL_m12:
		case LH_VIDEO_CHANNEL_m12:
			chan = (CHANNEL_m12 *) level_header;
			sprintf_m12(ri_path, "%s/%s.%s", chan->path, chan->name, RECORD_INDICES_FILE_TYPE_STRING_m12);
			sprintf_m12(rd_path, "%s/%s.%s", chan->path, chan->name, RECORD_DATA_FILE_TYPE_STRING_m12);
			FPS_close_m12(chan->record_indices_fps);
			FPS_close_m12(chan->record_data_fps);
			break;
		case LH_SESSION_m12:
			sess = (SESSION_m12 *) level_header;
			sprintf_m12(ri_path, "%s/%s.%s", sess->path, sess->name, RECORD_INDICES_FILE_TYPE_STRING_m12);
			sprintf_m12(rd_path, "%s/%s.%s", sess->path, sess->name, RECORD_DATA_FILE_TYPE_STRING_m12);
			FPS_close_m12(sess->record_indices_fps);
			FPS_close_m12(sess->record_data_fps);
			break;
		case LH_SEGMENTED_SESS_RECS_m12:
			ssr = (SEGMENTED_SESS_RECS_m12 *) level_header;
			G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, segment_number);
			sprintf_m12(ri_path, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, RECORD_INDICES_FILE_TYPE_STRING_m12);
			sprintf_m12(rd_path, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, RECORD_DATA_FILE_TYPE_STRING_m12);
			if (globals_m12->number_of_mapped_segments == 1) {  // most commonly just allocate one ssr & overwrite with new segments, but not required to do it that way
				seg_idx = 0;
			} else {
				G_push_behavior_m12(SUPPRESS_OUTPUT_m12);
				seg_idx = G_get_segment_index_m12(segment_number);
				G_pop_behavior_m12();
				if (seg_idx == FALSE_m12)
					return;
			}
			FPS_close_m12(ssr->record_indices_fps[seg_idx]);
			FPS_close_m12(ssr->record_data_fps[seg_idx]);
			break;
		default:
			G_warning_message_m12("%s(): invalid level type\n", __FUNCTION__);
			return;
	}
	if (G_file_exists_m12(ri_path) != FILE_EXISTS_m12)
		return;
	if (G_file_exists_m12(rd_path) != FILE_EXISTS_m12)
		return;

	// read data (full file read will automatically close files)
	ri_fps = G_read_file_m12(NULL, ri_path, 0, 0, FPS_FULL_FILE_m12, NULL, NULL, USE_GLOBAL_BEHAVIOR_m12);
	rd_fps = G_read_file_m12(NULL, rd_path, 0, 0, FPS_FULL_FILE_m12, NULL, NULL, USE_GLOBAL_BEHAVIOR_m12);
	
	// fix any no-entry start times
	n_recs = rd_fps->number_of_items;
	ri = ri_fps->record_indices;
	file_start_time = ri_fps->universal_header->file_start_time;
	for (i = n_recs; i--; ++ri) {
		if (ri->start_time == UUTC_NO_ENTRY_m12) {
			rh = (RECORD_HEADER_m12 *) (rd_fps->parameters.raw_data + ri->file_offset);
			ri->start_time = rh->start_time = file_start_time;
		}
	}
	
	// sort indices (leave file offsets intact)
	qsort((void *) ri_fps->record_indices, (size_t) n_recs, sizeof(RECORD_INDEX_m12), G_compare_record_index_times);  // leave terminal index where it is
	
	// copy record data before writing
	tmp_rec_data = (ui1 *) malloc((size_t) rd_fps->parameters.raw_data_bytes);
	memcpy((void *) tmp_rec_data, (void *) rd_fps->parameters.raw_data, (size_t) rd_fps->parameters.raw_data_bytes);
		
	// reopen files for writing
	ri_fps->directives.close_file = FALSE_m12;
	G_write_file_m12(ri_fps, 0, UNIVERSAL_HEADER_BYTES_m12, FPS_UNIVERSAL_HEADER_ONLY_m12, NULL, USE_GLOBAL_BEHAVIOR_m12);
	rd_fps->directives.close_file = FALSE_m12;
	G_write_file_m12(rd_fps, 0, UNIVERSAL_HEADER_BYTES_m12, FPS_UNIVERSAL_HEADER_ONLY_m12, NULL, USE_GLOBAL_BEHAVIOR_m12);

	// write out sorted records
	ri = ri_fps->record_indices;
	for (i = n_recs; i--; ++ri) {
		rh = (RECORD_HEADER_m12 *) (tmp_rec_data + ri->file_offset);
		ri->file_offset = rd_fps->parameters.flen;
		G_write_file_m12(ri_fps, FPS_APPEND_m12, INDEX_BYTES_m12, 1, (void *) ri, USE_GLOBAL_BEHAVIOR_m12);
		G_write_file_m12(rd_fps, FPS_APPEND_m12, rh->total_record_bytes, 1, (void *) rh, USE_GLOBAL_BEHAVIOR_m12);
	}
	
	// write terminal index
	G_write_file_m12(ri_fps, FPS_APPEND_m12, INDEX_BYTES_m12, 1, (void *) ri, USE_GLOBAL_BEHAVIOR_m12);

	// clean up
	FPS_free_processing_struct_m12(ri_fps, TRUE_m12);
	FPS_free_processing_struct_m12(rd_fps, TRUE_m12);
	free((void *) tmp_rec_data);
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
TERN_m12 G_ternary_entry_m12(si1 *entry)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (G_empty_string_m12(entry) == TRUE_m12) {
		G_warning_message_m12("%s(): empty string => returning UNKNOWN\n", __FUNCTION__);
		return(UNKNOWN_m12);
	}
	    	    
	switch (*entry) {
		case 't':  // "true" case
		case 'T':  // "True / TRUE" case
		case 'y':  // "yes" case
		case 'Y':  // "Yes / YES" case
		case '1':  // ternary case
			return(TRUE_m12);
			break;
		case 'f':  // "false" case
		case 'F':  // "False / FALSE" case
		case 'n':  // "no" case
		case 'N':  // "No / NO" case
			return(FALSE_m12);
			break;
		case '-':  // possibly ternary case
			if (*(entry + 1) == '1')
				return(FALSE_m12);
			break;
		case 'u':  // "unknown" case
		case 'U':  // "Unknown / UNKNOWN" case
		case '0':  // ternary case
			return(UNKNOWN_m12);
			break;
	}
	    	    
	G_warning_message_m12("%s(): unrecognized pattern => returning UNKNOWN\n", __FUNCTION__);
	    
	return(UNKNOWN_m12);
}


void    G_textbelt_text_m12(si1 *phone_number, si1 *content, si1 *textbelt_key)
{
	si1     command[1024];
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (phone_number == NULL) {
		G_warning_message_m12("%s(): phone number is NULL => returning\n");
		return;
	}
	if (*phone_number == 0) {
		G_warning_message_m12("%s(): phone number is empty => returning\n");
		return;
	}
	if (content == NULL) {
		G_warning_message_m12("%s(): content is NULL => returning\n");
		return;
	}
	if (*content == 0) {
		G_warning_message_m12("%s(): content is empty => returning\n");
		return;
	}
	if (textbelt_key == NULL) {
		G_warning_message_m12("%s(): key is NULL => returning\n");
		return;
	}
	if (*textbelt_key == 0) {
		G_warning_message_m12("%s(): key is empty => returning\n");
		return;
	}

#if defined MACOS_m12 || defined LINUX_m12
	sprintf(command, "/usr/bin/curl --connect-timeout 5.0 -X POST https://textbelt.com/text --data-urlencode phone='%s' --data-urlencode message='%s' -d key=%s > %s 2>&1", phone_number, content, textbelt_key, NULL_DEVICE_m12);
	system(command);
#endif
#ifdef WINDOWS_m12
	sprintf(command, "curl.exe --connect-timeout 5.0 -X POST https://textbelt.com/text --data-urlencode phone=\"%s\" --data-urlencode message=\"%s\" -d key=%s > %s 2>&1", phone_number, content, textbelt_key, NULL_DEVICE_m12);
	WN_system_m12(command);
#endif

	return;
}


si1	*G_unique_temp_file_m12(si1 *temp_file)
{
	ui8	rand_val;
	
	// use instead of globals_m12->temp_file for anything that could be threaded
	
	// if NULL is passed, caller is responsible for freeing
	if (temp_file == NULL)
		temp_file = (si1 *) malloc_m12((size_t) FULL_FILE_NAME_BYTES_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
#if defined MACOS_m12 || defined LINUX_m12
	rand_val = (ui8) random();
	rand_val <<= 32;
	rand_val |= (ui8) random();
#endif
#ifdef WINDOWS_m12
	rand_val = (ui8) rand();
	rand_val <<= 16;
	rand_val |= (ui8) rand();
	rand_val <<= 16;
	rand_val |= (ui8) rand();
	rand_val <<= 16;
	rand_val |= (ui8) rand();
#endif

	sprintf_m12(temp_file, "%s/junk_%016lx", globals_m12->temp_dir, rand_val);
	
	return(temp_file);
}


void	G_update_maximum_entry_size_m12(FILE_PROCESSING_STRUCT_m12 *fps, si8 number_of_items, si8 bytes_to_write, si8 file_offset)
{
	ui4				entry_size;
	si8				i;
	RECORD_HEADER_m12		*rh;
	CMP_BLOCK_FIXED_HEADER_m12	*bh;
	UNIVERSAL_HEADER_m12		*uh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
		
	uh = fps->universal_header;
	switch (uh->type_code) {
		case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
		case VIDEO_INDICES_FILE_TYPE_CODE_m12:
		case RECORD_INDICES_FILE_TYPE_CODE_m12:
			uh->maximum_entry_size = INDEX_BYTES_m12;
			return;
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
			uh->maximum_entry_size = METADATA_BYTES_m12;
			return;
	}
	
	if (number_of_items == 1) {
		if (uh->maximum_entry_size < bytes_to_write)
			uh->maximum_entry_size = bytes_to_write;
		return;
	}
	
	FPS_set_pointers_m12(fps, file_offset);
	switch (uh->type_code) {
		case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
			bh = fps->parameters.cps->block_header;
			for (i = 0; i < number_of_items; ++i) {
				entry_size = (si8) bh->total_block_bytes;
				if (uh->maximum_entry_size < entry_size)
					uh->maximum_entry_size = entry_size;
				bh = (CMP_BLOCK_FIXED_HEADER_m12 *) ((ui1 *) bh + entry_size);
			}
			break;
		case RECORD_DATA_FILE_TYPE_CODE_m12:
			rh = (RECORD_HEADER_m12 *) fps->record_data;
			for (i = 0; i < number_of_items; ++i) {
				entry_size = (si8) rh->total_record_bytes;
				if (uh->maximum_entry_size < entry_size)
					uh->maximum_entry_size = entry_size;
				rh = (RECORD_HEADER_m12 *) ((ui1 *) rh + entry_size);
			}
			break;
	}
		
	return;
}


si8     G_uutc_for_frame_number_m12(LEVEL_HEADER_m12 *level_header, si8 target_frame_number, ui4 mode, ...)  // varargs: si8 ref_frame_number, si8 ref_uutc, sf8 frame_rate
{
	si1			tmp_str[FULL_FILE_NAME_BYTES_m12], num_str[FILE_NUMBERING_DIGITS_m12 + 1];
	si4			seg_num, seg_idx;
	si8                     absolute_numbering_offset, ref_frame_number;
	si8			ref_uutc, i, n_inds, tmp_si8;
	sf8                     tmp_sf8, frame_rate;
	ui4			mask;
	va_list			args;
	SEGMENT_m12		*seg;
	CHANNEL_m12		*chan;
	SESSION_m12		*sess;
	VIDEO_INDEX_m12		*vi;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// G_uutc_for_frame_number_m12(NULL, si8 target_frame_number, ui4 mode, si8 ref_frame_number, si8 ref_uutc, sf8 frame_rate)
	// returns uutc extrapolated from ref_uutc
	// NOTE: target_frame_number must be session-relative (global indexing)
	
	// G_uutc_for_frame_number_m12(seg, target_uutc, mode)
	// returns uutc extrapolated from closest video index in frame specified by mode (this is typically more accurate, & takes discontinuities into account)
	
	// frame time is defined as the period from frame onset until the next frame
	// mode FIND_START_m12 (default): first uutc >= start of target frame period
	// mode FIND_END_m12: last uutc < start of next frame period
	// mode FIND_CENTER_m12: uutc closest to the center of the frame period
	
	if (level_header == NULL) {  // reference points passed
		va_start(args, mode);
		ref_frame_number = va_arg(args, si8);
		ref_uutc = va_arg(args, si8);
		frame_rate = va_arg(args, sf8);
		va_end(args);
		vi = NULL;
	} else {  // level header passed
		switch (level_header->type_code) {
			case LH_VIDEO_SEGMENT_m12:
				seg = (SEGMENT_m12 *) level_header;
				break;
			case LH_VIDEO_CHANNEL_m12:
			case LH_SESSION_m12:
				seg_num = G_segment_for_frame_number_m12(level_header, target_frame_number);
				seg_idx = G_get_segment_index_m12(seg_num);
				if (seg_idx == FALSE_m12)
					return(UUTC_NO_ENTRY_m12);
				if (level_header->type_code == LH_VIDEO_CHANNEL_m12) {
					chan = (CHANNEL_m12 *) level_header;
				} else {
					chan = globals_m12->reference_channel;
					if (chan->type_code != LH_VIDEO_CHANNEL_m12) {
						sess = (SESSION_m12 *) level_header;
						chan = sess->video_channels[0];
					}
				}
				seg = chan->segments[seg_idx];
				break;
			case LH_TIME_SERIES_CHANNEL_m12:
			case LH_TIME_SERIES_SEGMENT_m12:
				return(G_uutc_for_sample_number_m12(level_header, target_frame_number, mode));
			default:
				G_error_message_m12("%s(): invalid level type\n", __FUNCTION__);
				return(UUTC_NO_ENTRY_m12);
		}
		// open segment
		if (seg == NULL) {
			G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, seg_num);
			sprintf_m12(tmp_str, "%s/%s_s%s.%s", chan->path, chan->name, num_str, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12);
			seg = chan->segments[seg_idx] = G_open_segment_m12(NULL, NULL, tmp_str, chan->flags, NULL);
		} else if (!(seg->flags & LH_OPEN_m12)) {
			G_open_segment_m12(seg, NULL, NULL, seg->flags, NULL);
		}
		if (seg == NULL) {
			G_warning_message_m12("%s(): can't open segment\n", __FUNCTION__);
			return(UUTC_NO_ENTRY_m12);
		}

		vi = seg->video_indices_fps->video_indices;
		if (vi == NULL) {
			G_warning_message_m12("%s(): video indices are NULL => returning UUTC_NO_ENTRY_m12\n", __FUNCTION__);
			return(UUTC_NO_ENTRY_m12);
		}
		n_inds = seg->video_indices_fps->universal_header->number_of_entries - 1;  // account for terminal index here - cleaner code below
		
		i = G_find_index_m12(seg, target_frame_number, SAMPLE_SEARCH_m12);
		if (i == -1)  // target frame earlier than segment start => return segment start time
			return(vi->start_time);
		vi += i;
		if (i == n_inds)  // target frame later than segment end => return segment end uutc
			return(vi->start_time - 1);
		
		// make target_frame_number relative
		absolute_numbering_offset = seg->metadata_fps->metadata->video_section_2.absolute_start_frame_number;
		target_frame_number -= absolute_numbering_offset;

		ref_uutc = vi->start_time;
		ref_frame_number = vi->start_frame_number;
		frame_rate = seg->metadata_fps->metadata->video_section_2.frame_rate;
	}
	
	tmp_sf8 = (sf8) (target_frame_number - ref_frame_number) * (sf8) 1e6;
	mask = (ui4) (FIND_END_m12 | FIND_CENTER_m12 | FIND_START_m12);
	switch (mode & mask) {
		case FIND_END_m12:
			tmp_sf8 = (tmp_sf8 + (sf8) 1e6) / frame_rate;
			tmp_si8 = (si8) tmp_sf8;
			if (tmp_sf8 == (sf8) tmp_si8)
				--tmp_si8;
			break;
		case FIND_CENTER_m12:
			tmp_si8 = (si8) (((tmp_sf8 + (sf8) 5e5) / frame_rate) + (sf8) 0.5);
			break;
		case FIND_START_m12:
		default:
			tmp_sf8 = tmp_sf8 / frame_rate;
			tmp_si8 = (si8) tmp_sf8;
			if (tmp_sf8 != (sf8) tmp_si8)
				++tmp_si8;
			break;
	}
	
	return(ref_uutc + tmp_si8);
}


si8     G_uutc_for_sample_number_m12(LEVEL_HEADER_m12 *level_header, si8 target_sample_number, ui4 mode, ...)  // varargs: si8 ref_sample_number, si8 ref_uutc, sf8 sampling_frequency
{
	si1			tmp_str[FULL_FILE_NAME_BYTES_m12], num_str[FILE_NUMBERING_DIGITS_m12 + 1];
	si4			seg_num, seg_idx;
	si8                     absolute_numbering_offset, ref_sample_number;
	si8			ref_uutc, n_inds, i, tmp_si8;
	sf8                     tmp_sf8, sampling_frequency;
	ui4			mask;
	va_list			args;
	SEGMENT_m12		*seg;
	CHANNEL_m12		*chan;
	SESSION_m12		*sess;
	TIME_SERIES_INDEX_m12	*tsi;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// G_uutc_for_sample_number_m12(NULL, si8 target_sample_number, ui4 mode, si8 ref_sample_number, si8 ref_uutc, sf8 sampling_frequency)
	// returns uutc extrapolated from ref_uutc
	// NOTE: target_sample_number must be session-relative (global indexing)

	// G_uutc_for_sample_number_m12(seg, target_uutc, mode)
	// returns uutc extrapolated from closest time series index in frame specified by mode (this is typically more accurate, & takes discontinuities into account)
	
	// sample time is defined as the period from sample onset until the next sample
	// mode FIND_START_m12 (default): first uutc >= start of target sample period
	// mode FIND_END_m12: last uutc < start of next sample period
	// mode FIND_CENTER_m12: uutc closest to the center of the sample period
	
	if (level_header == NULL) {  // reference points passed
		va_start(args, mode);
		ref_sample_number = va_arg(args, si8);
		ref_uutc = va_arg(args, si8);
		sampling_frequency = va_arg(args, sf8);
		va_end(args);
		tsi = NULL;
	} else {  // level header passed
		switch (level_header->type_code) {
			case LH_TIME_SERIES_SEGMENT_m12:
				seg = (SEGMENT_m12 *) level_header;
				break;
			case LH_TIME_SERIES_CHANNEL_m12:
			case LH_SESSION_m12:
				seg_num = G_segment_for_sample_number_m12(level_header, target_sample_number);
				seg_idx = G_get_segment_index_m12(seg_num);
				if (seg_idx == FALSE_m12)
					return(UUTC_NO_ENTRY_m12);
				if (level_header->type_code == LH_TIME_SERIES_CHANNEL_m12) {
					chan = (CHANNEL_m12 *) level_header;
				} else {
					chan = globals_m12->reference_channel;
					if (chan->type_code != LH_TIME_SERIES_CHANNEL_m12) {
						sess = (SESSION_m12 *) level_header;
						chan = sess->time_series_channels[0];
					}
				}
				seg = chan->segments[seg_idx];
				break;
			case LH_VIDEO_CHANNEL_m12:
			case LH_VIDEO_SEGMENT_m12:
				return(G_uutc_for_frame_number_m12(level_header, target_sample_number, mode));
			default:
				G_warning_message_m12("%s(): invalid level type\n", __FUNCTION__);
				return(UUTC_NO_ENTRY_m12);
		}
		// open segment
		if (seg == NULL) {
			G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, seg_num);
			sprintf_m12(tmp_str, "%s/%s_s%s.%s", chan->path, chan->name, num_str, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12);
			seg = chan->segments[seg_idx] = G_open_segment_m12(NULL, NULL, tmp_str, chan->flags, NULL);
		} else if (!(seg->flags & LH_OPEN_m12)) {
			G_open_segment_m12(seg, NULL, NULL, seg->flags, NULL);
		}
		if (seg == NULL) {
			G_warning_message_m12("%s(): can't open segment\n", __FUNCTION__);
			return(UUTC_NO_ENTRY_m12);
		}

		tsi = seg->time_series_indices_fps->time_series_indices;
		if (tsi == NULL) {
			G_warning_message_m12("%s(): time series indices are NULL => returning UUTC_NO_ENTRY_m12\n", __FUNCTION__);
			return(UUTC_NO_ENTRY_m12);
		}
		n_inds = seg->time_series_indices_fps->universal_header->number_of_entries - 1;  // account for terminal index here - cleaner code below
		
		i = G_find_index_m12(seg, target_sample_number, SAMPLE_SEARCH_m12);
		if (i == -1)  // target sample earlier than segment start => return segment start time
			return(tsi->start_time);
		tsi += i;
		if (i == n_inds)  // target sample later than segment end => return segment end uutc
			return(tsi->start_time - 1);
		
		// make target_sample_number relative
		absolute_numbering_offset = seg->metadata_fps->metadata->time_series_section_2.absolute_start_sample_number;
		target_sample_number -= absolute_numbering_offset;

		ref_uutc = tsi->start_time;
		ref_sample_number = tsi->start_sample_number;
		sampling_frequency = seg->metadata_fps->metadata->time_series_section_2.sampling_frequency;
	}
	
	tmp_sf8 = (sf8) (target_sample_number - ref_sample_number) * (sf8) 1e6;
	mask = (ui4) (FIND_END_m12 | FIND_CENTER_m12 | FIND_START_m12);
	switch (mode & mask) {
		case FIND_END_m12:
			tmp_sf8 = (tmp_sf8 + (sf8) 1e6) / sampling_frequency;
			tmp_si8 = (si8) tmp_sf8;
			if (tmp_sf8 == (sf8) tmp_si8)
				--tmp_si8;
			break;
		case FIND_CENTER_m12:
			tmp_si8 = (si8) (((tmp_sf8 + (sf8) 5e5) / sampling_frequency) + (sf8) 0.5);
			break;
		case FIND_START_m12:
		default:
			tmp_sf8 = tmp_sf8 / sampling_frequency;
			tmp_si8 = (si8) tmp_sf8;
			if (tmp_sf8 != (sf8) tmp_si8)
				++tmp_si8;
			break;
	}
		
	return(ref_uutc + tmp_si8);
}


TERN_m12        G_validate_record_data_CRCs_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	TERN_m12        	valid;
	si8             	i;
	RECORD_HEADER_m12	*rh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	valid = TRUE_m12;
	rh = (RECORD_HEADER_m12	*) fps->record_data;
	for (i = fps->number_of_items; i--;) {
		
		valid = CRC_validate_m12((ui1 *) rh + RECORD_HEADER_CRC_START_OFFSET_m12, rh->total_record_bytes - RECORD_HEADER_CRC_START_OFFSET_m12, rh->record_CRC);
		if (valid == FALSE_m12)
			return(valid);
		
		rh = (RECORD_HEADER_m12 *) ((ui1 *) rh + rh->total_record_bytes);
	}
	
	return(valid);
}


TERN_m12        G_validate_time_series_data_CRCs_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	TERN_m12        		valid;
	si8             		i;
	CMP_BLOCK_FIXED_HEADER_m12	*bh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	valid = TRUE_m12;
	bh = fps->parameters.cps->block_header;
	for (i = fps->number_of_items; i--;) {
		valid = CRC_validate_m12((ui1 *) bh + CMP_BLOCK_CRC_START_OFFSET_m12, bh->total_block_bytes - CMP_BLOCK_CRC_START_OFFSET_m12, bh->block_CRC);
		if (valid == FALSE_m12)
			return(valid);
		bh = (CMP_BLOCK_FIXED_HEADER_m12 *) ((ui1 *) bh + bh->total_block_bytes);
	}
	
	return(valid);
}


void    G_warning_message_m12(si1 *fmt, ...)
{
	va_list		args;
	

	// GREEN suppressible text to stderr
	if (!(globals_m12->behavior_on_fail & SUPPRESS_WARNING_OUTPUT_m12)) {
#ifndef MATLAB_m12
		fprintf(stderr, TC_GREEN_m12);
#endif
		va_start(args, fmt);
		UTF8_vfprintf_m12(stderr, fmt, args);
		va_end(args);
#ifndef MATLAB_m12
		fprintf(stderr, TC_RESET_m12);
		fflush(stderr);
#endif
	}
	
	return;
}


si8	G_write_file_m12(FILE_PROCESSING_STRUCT_m12 *fps, si8 file_offset, si8 bytes_to_write, si8 number_of_items, void *external_data, ui4 behavior_on_fail)
{
	TERN_m12			update_maximum_entry_size;
	si8                             bytes_written;
	void				*saved_data_pointers, *encrypted_data, *unencrypted_data;
	UNIVERSAL_HEADER_m12		*uh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;

	// if number_of_items == FPS_FULL_FILE_m12, full file is written, universal header CRC is updated, and file is closed. Note: number_of_entries must be filled in in universal header.
	// if number_of_items == FPS_UNIVERSAL_HEADER_ONLY_m12, the universal header is written, and file is left open (header CRC is not updated unless directive is set)
	// if number_of_items == FPS_CLOSE_m12: update universal header & close file => only universal header written
	// if file_offset == FPS_APPEND_m12, the file iss appended
	
	// clobber file if exists and is closed, create if non-existent
	if (fps->parameters.fp == NULL) {
		if (!(fps->directives.open_mode & FPS_GENERIC_WRITE_OPEN_MODE_m12))
			fps->directives.open_mode = FPS_W_OPEN_MODE_m12;
		FPS_open_m12(fps, __FUNCTION__, behavior_on_fail);
	}
	
	if (number_of_items == FPS_CLOSE_m12) {
		fps->directives.update_universal_header = TRUE_m12;
		FPS_write_m12(fps, 0, UNIVERSAL_HEADER_BYTES_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		FPS_close_m12(fps);
		return(0);  // nothing new written
	}
	
	if (external_data != NULL) {
		saved_data_pointers = fps->data_pointers;
		fps->data_pointers = external_data;
	}
		
	uh = fps->universal_header;
	update_maximum_entry_size = TRUE_m12;
	if (number_of_items == FPS_UNIVERSAL_HEADER_ONLY_m12) {
		bytes_written = FPS_write_m12(fps, 0, UNIVERSAL_HEADER_BYTES_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		fps->number_of_items = 0;
		return(bytes_written);
	}
	
	if (number_of_items == FPS_FULL_FILE_m12) {
		number_of_items = uh->number_of_entries;
		file_offset = UNIVERSAL_HEADER_BYTES_m12;
		fps->directives.close_file = TRUE_m12;  // update universal header automatically set with close_file directive
	}
	
	if (number_of_items == 0) {
		if (bytes_to_write == 0) {
			G_error_message_m12("%s(): must specify either bytes to write or number of items\n");
			return((si8) FALSE_m12);
		}
		number_of_items = G_items_for_bytes_m12(fps, &bytes_to_write);
		update_maximum_entry_size = FALSE_m12;
	}
	fps->number_of_items = number_of_items;
	
	if (bytes_to_write == 0) {
		bytes_to_write = G_bytes_for_items_m12(fps, &number_of_items, 0);
		update_maximum_entry_size = FALSE_m12;
	}
	
	if (update_maximum_entry_size == TRUE_m12)
		G_update_maximum_entry_size_m12(fps, number_of_items, bytes_to_write, file_offset);
	
	if (file_offset == FPS_APPEND_m12 || file_offset == fps->parameters.flen)
		uh->number_of_entries += number_of_items;
	
	// leave decrypted directive
	encrypted_data = NULL;
	if (fps->directives.leave_decrypted == TRUE_m12) {
		switch (uh->type_code) {
			case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
			case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
			case VIDEO_METADATA_FILE_TYPE_CODE_m12:
			case RECORD_DATA_FILE_TYPE_CODE_m12:  // this mechanism assumes copying is faster than decrypting, but it might not be.
				encrypted_data = malloc_m12(bytes_to_write, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
				memcpy(encrypted_data, fps->data_pointers, bytes_to_write);  // encrypted below
				unencrypted_data = fps->data_pointers;
				fps->data_pointers = encrypted_data;
				break;
		}
	}
	
	// encrypt
	switch (uh->type_code) {
		case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
			G_encrypt_time_series_data_m12(fps);
			break;
		case RECORD_DATA_FILE_TYPE_CODE_m12:
			G_encrypt_record_data_m12(fps);
			break;
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
			G_encrypt_metadata_m12(fps);
			break;
	}
	
	// Calculate CRCs
	// IMPORTANT: if the file is written non-sequentially (not FPS_APPEND_m12 or FPS_FULL_FILE_m12), the CRCs will be invalid
	if (globals_m12->CRC_mode & (CRC_CALCULATE_m12 | CRC_CALCULATE_ON_OUTPUT_m12)) {
		switch (uh->type_code) {
			case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
				G_calculate_time_series_data_CRCs_m12(fps);
				break;
			case RECORD_DATA_FILE_TYPE_CODE_m12:
				G_calculate_record_data_CRCs_m12(fps);
				break;
			case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
			case VIDEO_INDICES_FILE_TYPE_CODE_m12:
			case RECORD_INDICES_FILE_TYPE_CODE_m12:
				G_calculate_indices_CRCs_m12(fps);
				break;
			case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
			case VIDEO_METADATA_FILE_TYPE_CODE_m12:
				G_calculate_metadata_CRC_m12(fps);
				break;
		}
	}
	
	// always update universal header on close
	if (fps->directives.close_file == TRUE_m12)
		fps->directives.update_universal_header = TRUE_m12;
	
	// write
	bytes_written = FPS_write_m12(fps, file_offset, bytes_to_write, __FUNCTION__, behavior_on_fail);
	
	// close
	if (fps->directives.close_file == TRUE_m12)
		FPS_close_m12(fps);
	
	// leave decrypted directive
	if (encrypted_data != NULL) {
		free_m12(encrypted_data, __FUNCTION__);
		fps->data_pointers = unencrypted_data;
	}

	// restore data pointers if writing from external memory
	if (external_data != NULL)
		fps->data_pointers = saved_data_pointers;
		
	return(bytes_written);
}



//**********************************//
// MARK: ENCRYPTION FUNCTIONS  (AES)
//**********************************//

// ATTRIBUTION
//
// Advanced Encryption Standard implementation in C.
// By Niyaz PK
// E-mail: niyazlife@gmail.com
// Downloaded from Website: www.hoozi.com
//
// "This is the source code for encryption using the latest AES algorithm.
// The AES algorithm is also called Rijndael algorithm. The AES algorithm is
// recommended for non-classified use by the National Institute of Standards
// and Technology (NIST), USA."
//
// For the complete description of the algorithm, see:
// http://www.csrc.nist.gov/publications/fips/fips197/fips-197.pdf
//
// THE CODE IN THIS FILE IS SET FOR AES 128-BIT ENCRYPTION / DECRYPTION ONLY
//
// Minor modifications have been made for compatibility with the MED Library.

// This function adds the round key to state.
// The round key is added to the state by an XOR function.
void	AES_add_round_key_m12(si4 round, ui1 state[][4], ui1 *round_key)
{
	si4	i, j;
	
	
	for (i = 0; i < 4; i++)
		for (j = 0; j < 4; j++)
			state[j][i] ^= round_key[(round * AES_NB_m12 * 4) + (i * AES_NB_m12) + j];
	
	return;
}


// Cipher is the main encryption function
void	AES_cipher_m12(ui1 *in, ui1 *out, ui1 state[][4], ui1 *round_key)
{
	si4	i, j, round = 0;
	
	
	// Copy the input PlainText to state array.
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			state[j][i] = in[i * 4 + j];
		}
	}
	
	// Add the First round key to the state before starting the rounds.
	AES_add_round_key_m12(0, state, round_key);
	
	// There will be AES_NR rounds.
	// The first AES_NR - 1 rounds are identical.
	// These AES_NR - 1 rounds are executed in the loop below.
	for (round = 1; round < AES_NR_m12; round++) {
		AES_sub_bytes_m12(state);
		AES_shift_rows_m12(state);
		AES_mix_columns_m12(state);
		AES_add_round_key_m12(round, state, round_key);
	}
	
	// The last round is given below.
	// The MixColumns function is not here in the last round.
	AES_sub_bytes_m12(state);
	AES_shift_rows_m12(state);
	AES_add_round_key_m12(AES_NR_m12, state, round_key);
	
	// The encryption process is over.
	// Copy the state array to output array.
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			out[i * 4 + j] = state[j][i];
		}
	}
	
	return;
}


// "data" is buffer to be decrypted
// "len" is bytes to be decrypted
// if decrypting multiple times with the same encryption key, pass in expanded key
// decryption is done in place
void	AES_decrypt_m12(ui1 *data, si8 len, si1 *password, ui1 *expanded_key)
{
	ui1	*ui1_p;
	si1	key[AES_KEY_BYTES_m12] = {0};
	si8	i, encryption_blocks, n_leftovers;
	ui1	state[4][4]; // the array that holds the intermediate results during encryption
	ui1	round_key[AES_EXPANDED_KEY_BYTES_m12]; // The array that stores the round keys
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (global_tables_m12->AES_sbox_table == NULL)  // all tables initialized together
		AES_initialize_tables_m12();
	
	if (expanded_key == NULL) {
		if (password != NULL) {
			if (*password) {
				// password becomes the key (16 bytes, zero-padded if shorter, truncated if longer)
				strncpy_m12(key, password, 16);
				
				// The KeyExpansion routine must be called before encryption.
				AES_key_expansion_m12(round_key, key);
				expanded_key = round_key;
			}
		}
	}
	if (expanded_key == NULL) {
		G_warning_message_m12("%s(): No password or expanded key\n", __FUNCTION__);
		return;
	}

	// AES decryption
	encryption_blocks = len >> 4;
	ui1_p = data;
	for (i = encryption_blocks; i--;) {
		AES_inv_cipher_m12(ui1_p, ui1_p, state, expanded_key);
		ui1_p += ENCRYPTION_BLOCK_BYTES_m12;
	}

	// non-AES addition invoked only if not multiple of 16
	n_leftovers = len - (encryption_blocks << 4);
	if (n_leftovers)
		AES_leftover_decrypt_m12(n_leftovers, ui1_p);
	
	return;
}


// "data" is buffer to be encrypted
// "len" is bytes to be encrypted
// if encrypting multiple times with the same encryption key, pass in expanded key
// encryption is done in place
void	AES_encrypt_m12(ui1 *data, si8 len, si1 *password, ui1 *expanded_key)
{
	ui1	*ui1_p;
	si1	key[AES_KEY_BYTES_m12] = {0};
	si8	i, encryption_blocks, n_leftovers;
	ui1	state[4][4]; // the array that holds the intermediate results during encryption
	ui1	round_key[AES_EXPANDED_KEY_BYTES_m12]; // The array that stores the round keys
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (global_tables_m12->AES_sbox_table == NULL)  // all tables initialized together
		AES_initialize_tables_m12();
	
	if (expanded_key == NULL) {
		if (password != NULL) {
			if (*password) {
				// password becomes the key (16 bytes, zero-padded if shorter, truncated if longer)
				strncpy_m12(key, password, 16);
				
				// The KeyExpansion routine must be called before encryption.
				AES_key_expansion_m12(round_key, key);
				expanded_key = round_key;
			}
		}
	}
	if (expanded_key == NULL) {
		G_warning_message_m12("%s(): No password or expanded key\n", __FUNCTION__);
		return;
	}

	// AES encryption
	encryption_blocks = len >> 4;
	ui1_p = data;
	for (i = encryption_blocks; i--;) {
		AES_cipher_m12(ui1_p, ui1_p, state, expanded_key);
		ui1_p += ENCRYPTION_BLOCK_BYTES_m12;
	}

	// non-AES addition invoked only if not multiple of 16
	n_leftovers = len - (encryption_blocks << 4);
	if (n_leftovers)
		AES_leftover_encrypt_m12(n_leftovers, ui1_p);

	return;
}


// This function produces AES_NB * (AES_NR + 1) round keys. The round keys are used in each round to encrypt the states.
// NOTE: make sure any terminal unused bytes in key array (password) are zeroed
void	AES_key_expansion_m12(ui1 *expanded_key, si1 *key)
{
	si4	i, j, *rcon_table;
	ui1	temp[4], k;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// The round constant word array, Rcon[i], contains the values given by
	// x to the power (i - 1) being powers of x (x is denoted as {02}) in the field GF(28)
	// Note that i starts at 1, not 0).

	if (global_tables_m12->AES_rcon_table == NULL)
		AES_initialize_tables_m12();
	rcon_table = global_tables_m12->AES_rcon_table;
	
	// The first round key is the key itself.
	for (i = j = 0; i < AES_NK_m12; i++, j += 4) {
		expanded_key[j] = key[j];
		expanded_key[j + 1] = key[j + 1];
		expanded_key[j + 2] = key[j + 2];
		expanded_key[j + 3] = key[j + 3];
	}
	
	// All other round keys are found from the previous round keys.
	while (i < (AES_NB_m12 * (AES_NR_m12 + 1))) {
		
		for (j = 0; j < 4; j++)
			temp[j] = expanded_key[(i - 1) * 4 + j];
		
		if (i % AES_NK_m12 == 0) {
			// This rotates the 4 bytes in a word to the left once.
			// [a0,a1,a2,a3] becomes [a1,a2,a3,a0]
			k = temp[0];
			temp[0] = temp[1];
			temp[1] = temp[2];
			temp[2] = temp[3];
			temp[3] = k;
			
			// This takes a four-byte input word and applies the S-box
			// to each of the four bytes to produce an output word.
			temp[0] = (ui1)AES_get_sbox_value_m12(temp[0]);
			temp[1] = (ui1)AES_get_sbox_value_m12(temp[1]);
			temp[2] = (ui1)AES_get_sbox_value_m12(temp[2]);
			temp[3] = (ui1)AES_get_sbox_value_m12(temp[3]);
			
			temp[0] = temp[0] ^ (ui1) rcon_table[i / AES_NK_m12];
		}
		else if (AES_NK_m12 > 6 && i % AES_NK_m12 == 4) {
			// This takes a four-byte input word and applies the S-box
			// to each of the four bytes to produce an output word.
			temp[0] = (ui1)AES_get_sbox_value_m12(temp[0]);
			temp[1] = (ui1)AES_get_sbox_value_m12(temp[1]);
			temp[2] = (ui1)AES_get_sbox_value_m12(temp[2]);
			temp[3] = (ui1)AES_get_sbox_value_m12(temp[3]);
		}
		
		expanded_key[i * 4] = expanded_key[(i - AES_NK_m12) * 4] ^ temp[0];
		expanded_key[i * 4 + 1] = expanded_key[(i - AES_NK_m12) * 4 + 1] ^ temp[1];
		expanded_key[i * 4 + 2] = expanded_key[(i - AES_NK_m12) * 4 + 2] ^ temp[2];
		expanded_key[i * 4 + 3] = expanded_key[(i - AES_NK_m12) * 4 + 3] ^ temp[3];
		
		i++;
	}
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	AES_get_sbox_invert_m12(si4 num)
{
	if (global_tables_m12->AES_rsbox_table == NULL)
		AES_initialize_tables_m12();
	
	return(global_tables_m12->AES_rsbox_table[num]);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	AES_get_sbox_value_m12(si4 num)
{
	if (global_tables_m12->AES_sbox_table == NULL)
		AES_initialize_tables_m12();
	
	return(global_tables_m12->AES_sbox_table[num]);
}


TERN_m12	AES_initialize_tables_m12(void)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (global_tables_m12->AES_rcon_table != NULL)
		return(TRUE_m12);

	PROC_pthread_mutex_lock_m12(&global_tables_m12->AES_mutex);
	if (global_tables_m12->AES_rcon_table != NULL) {  // may have been done by another thread while waiting
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->AES_mutex);
		return(TRUE_m12);
	}

	// rcon table
	if (global_tables_m12->AES_rcon_table == NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		global_tables_m12->AES_rcon_table = (si4 *) mxCalloc((mwSize) AES_RCON_ENTRIES_m12, (mwSize) sizeof(si4));
	#else
		global_tables_m12->AES_rcon_table = (si4 *) calloc((size_t) AES_RCON_ENTRIES_m12, sizeof(si4));
	#endif
		{
			si4 temp[AES_RCON_ENTRIES_m12] = AES_RCON_m12;
			memcpy(global_tables_m12->AES_rcon_table, temp, AES_RCON_ENTRIES_m12 * sizeof(si4));
		}
	}
	
	// rsbox table
	if (global_tables_m12->AES_rsbox_table == NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		global_tables_m12->AES_rsbox_table = (si4 *) mxCalloc((mwSize) AES_RSBOX_ENTRIES_m12, (mwSize) sizeof(si4));
	#else
		global_tables_m12->AES_rsbox_table = (si4 *) calloc((size_t) AES_RSBOX_ENTRIES_m12, sizeof(si4));
	#endif
		{
			si4 temp[AES_RSBOX_ENTRIES_m12] = AES_RSBOX_m12;
			memcpy(global_tables_m12->AES_rsbox_table, temp, AES_RSBOX_ENTRIES_m12 * sizeof(si4));
		}
	}

	// sbox table
	if (global_tables_m12->AES_sbox_table == NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		global_tables_m12->AES_sbox_table = (si4 *) mxCalloc((mwSize) AES_SBOX_ENTRIES_m12, (mwSize) sizeof(si4));
	#else
		global_tables_m12->AES_sbox_table = (si4 *) calloc((size_t) AES_SBOX_ENTRIES_m12, sizeof(si4));
	#endif
		{
			si4 temp[AES_SBOX_ENTRIES_m12] = AES_SBOX_m12;
			memcpy(global_tables_m12->AES_sbox_table, temp, AES_SBOX_ENTRIES_m12 * sizeof(si4));
		}
	}

	PROC_pthread_mutex_unlock_m12(&global_tables_m12->AES_mutex);

	return(TRUE_m12);
}


// Inv Cipher is the main decryption function
void	AES_inv_cipher_m12(ui1 *in, ui1 *out, ui1 state[][4], ui1 *round_key)
{
	si4	i, j, round = 0;
	
	// Copy the input encrypted text to state array.
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			state[j][i] = in[i * 4 + j];
		}
	}
	
	// Add the First round key to the state before starting the rounds.
	AES_add_round_key_m12(AES_NR_m12, state, round_key);
	
	// There will be AES_NR rounds.
	// The first AES_NR - 1 rounds are identical.
	// These AES_NR - 1 rounds are executed in the loop below.
	for (round = AES_NR_m12 - 1; round > 0; round--) {
		AES_inv_shift_rows_m12(state);
		AES_inv_sub_bytes_m12(state);
		AES_add_round_key_m12(round, state, round_key);
		AES_inv_mix_columns_m12(state);
	}
	
	// The last round is given below.
	// The MixColumns function is not here in the last round.
	AES_inv_shift_rows_m12(state);
	AES_inv_sub_bytes_m12(state);
	AES_add_round_key_m12(0, state, round_key);
	
	// The decryption process is over.
	// Copy the state array to output array.
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			out[i * 4 + j] = state[j][i];
		}
	}
	
	return;
}


// The method used to multiply may be difficult to understand.
// Please use the references to gain more information.
void	AES_inv_mix_columns_m12(ui1 state[][4])
{
	si4	i;
	ui1	a, b, c, d;
	

	for (i = 0; i < 4; i++) {
		a = state[0][i];
		b = state[1][i];
		c = state[2][i];
		d = state[3][i];
		state[0][i] = AES_MULTIPLY_m12(a, 0x0e) ^ AES_MULTIPLY_m12(b, 0x0b) ^ AES_MULTIPLY_m12(c, 0x0d) ^ AES_MULTIPLY_m12(d, 0x09);
		state[1][i] = AES_MULTIPLY_m12(a, 0x09) ^ AES_MULTIPLY_m12(b, 0x0e) ^ AES_MULTIPLY_m12(c, 0x0b) ^ AES_MULTIPLY_m12(d, 0x0d);
		state[2][i] = AES_MULTIPLY_m12(a, 0x0d) ^ AES_MULTIPLY_m12(b, 0x09) ^ AES_MULTIPLY_m12(c, 0x0e) ^ AES_MULTIPLY_m12(d, 0x0b);
		state[3][i] = AES_MULTIPLY_m12(a, 0x0b) ^ AES_MULTIPLY_m12(b, 0x0d) ^ AES_MULTIPLY_m12(c, 0x09) ^ AES_MULTIPLY_m12(d, 0x0e);
	}
	
	return;
}


void	AES_inv_shift_rows_m12(ui1 state[][4])
{
	ui1	temp;
	
	
	// Rotate first row 1 columns to right
	temp = state[1][3];
	state[1][3] = state[1][2];
	state[1][2] = state[1][1];
	state[1][1] = state[1][0];
	state[1][0] = temp;
	
	// Rotate second row 2 columns to right
	temp = state[2][0];
	state[2][0] = state[2][2];
	state[2][2] = temp;
	
	temp = state[2][1];
	state[2][1] = state[2][3];
	state[2][3] = temp;
	
	// Rotate third row 3 columns to right
	temp = state[3][0];
	state[3][0] = state[3][1];
	state[3][1] = state[3][2];
	state[3][2] = state[3][3];
	state[3][3] = temp;
	
	return;
}


void	AES_inv_sub_bytes_m12(ui1 state[][4])
{
	si4	i, j;
	
	
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			state[i][j] = (ui1) AES_get_sbox_invert_m12(state[i][j]);
		}
	}
	
	return;
}


void	AES_leftover_decrypt_m12(si4 n_leftovers, ui1 *data)
{
	ui1	*ui1_p1, *ui1_p2;
	
	
	ui1_p1 = data;
	if (n_leftovers--) {
		ui1_p2 = ui1_p1 + n_leftovers;
		ui1_p1 = ui1_p2 - 1;
		for (; n_leftovers--; --ui1_p2)
			*ui1_p2 = *ui1_p2 ^ *ui1_p1--;
		*ui1_p1 = ~*ui1_p1;
	}

	return;
}


void	AES_leftover_encrypt_m12(si4 n_leftovers, ui1 *data)
{
	ui1	*ui1_p1, *ui1_p2;
	
	
	ui1_p1 = data;
	if (n_leftovers) {
		*ui1_p1 = ~*ui1_p1;
		ui1_p2 = ui1_p1 + 1;
		for (; --n_leftovers; ++ui1_p2)
			*ui1_p2 = *ui1_p2 ^ *ui1_p1++;
	}

	return;
}


// Mix Columns function mixes the columns of the state matrix
// The method used may look complicated, but it is easy if you know the underlying theory.
// Refer the documents specified above.
void	AES_mix_columns_m12(ui1 state[][4])
{
	si4	i;
	ui1	Tmp, Tm, t;
	
	
	for (i = 0; i < 4; i++) {
		t = state[0][i];
		Tmp = state[0][i] ^ state[1][i] ^ state[2][i] ^ state[3][i];
		Tm = state[0][i] ^ state[1][i];
		Tm = AES_XTIME_m12(Tm);
		state[0][i] ^= Tm ^ Tmp;
		Tm = state[1][i] ^ state[2][i];
		Tm = AES_XTIME_m12(Tm);
		state[1][i] ^= Tm ^ Tmp;
		Tm = state[2][i] ^ state[3][i];
		Tm = AES_XTIME_m12(Tm);
		state[2][i] ^= Tm ^ Tmp;
		Tm = state[3][i] ^ t;
		Tm = AES_XTIME_m12(Tm);
		state[3][i] ^= Tm ^ Tmp;
	}
	
	return;
}


// The Shift Rows function shifts the rows in the state to the left.
// Each row is shifted with different offset.
// Offset = Row number. So the first row is not shifted.
void	AES_shift_rows_m12(ui1 state[][4])
{
	ui1	temp;
	
	
	// Rotate first row 1 columns to left
	temp = state[1][0];
	state[1][0] = state[1][1];
	state[1][1] = state[1][2];
	state[1][2] = state[1][3];
	state[1][3] = temp;
	
	// Rotate second row 2 columns to left
	temp = state[2][0];
	state[2][0] = state[2][2];
	state[2][2] = temp;
	
	temp = state[2][1];
	state[2][1] = state[2][3];
	state[2][3] = temp;
	
	// Rotate third row 3 columns to left
	temp = state[3][0];
	state[3][0] = state[3][3];
	state[3][3] = state[3][2];
	state[3][2] = state[3][1];
	state[3][1] = temp;
	
	return;
}


// The Sub Bytes function substitutes the values in the
// state matrix with values in an S-box.
void	AES_sub_bytes_m12(ui1 state[][4])
{
	si4	i, j;
	
	
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			state[i][j] = (ui1) AES_get_sbox_value_m12(state[i][j]);
		}
	}
	
	return;
}



//*******************************************//
// MARK: ALIGNMENT CHECKING FUNCTIONS  (ALCK)
//*******************************************//


TERN_m12        ALCK_all_m12(void)
{
	TERN_m12        return_value;
	ui1		*bytes;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// see if already checked
	if (globals_m12->all_structures_aligned != UNKNOWN_m12)
		return(globals_m12->all_structures_aligned);
	
	return_value = TRUE_m12;
	bytes = (ui1 *) malloc(METADATA_FILE_BYTES_m12);  // METADATA is largest file structure
	
	// check all structures
	if ((ALCK_universal_header_m12(bytes)) == FALSE_m12)
		return_value = FALSE_m12;
	if ((ALCK_metadata_m12(bytes)) == FALSE_m12)
		return_value = FALSE_m12;
	if ((ALCK_time_series_indices_m12(bytes)) == FALSE_m12)
		return_value = FALSE_m12;
	if ((ALCK_video_indices_m12(bytes)) == FALSE_m12)
		return_value = FALSE_m12;
	if ((ALCK_record_indices_m12(bytes)) == FALSE_m12)
		return_value = FALSE_m12;
	if ((ALCK_record_header_m12(bytes)) == FALSE_m12)
		return_value = FALSE_m12;
	if ((REC_check_structure_alignments_m12(bytes)) == FALSE_m12)
		return_value = FALSE_m12;
	if ((CMP_check_block_header_alignment_m12(bytes)) == FALSE_m12)
		return_value = FALSE_m12;

	free((void *) bytes);
	
	if (return_value == TRUE_m12) {
		globals_m12->all_structures_aligned = TRUE_m12;
		if (globals_m12->verbose == TRUE_m12)
			G_message_m12("All MED Library structures are aligned\n");
	} else {
		G_error_message_m12("%s(): unaligned MED structures\n", __FUNCTION__);
	}
	
	return(return_value);
}


TERN_m12        ALCK_metadata_m12(ui1 *bytes)
{
	TERN_m12	return_value, free_flag = FALSE_m12;
	METADATA_m12	*md;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// see if already checked
	if (globals_m12->all_metadata_structures_aligned != UNKNOWN_m12)
		return(globals_m12->all_metadata_structures_aligned);
	
	return_value = TRUE_m12;
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(METADATA_FILE_BYTES_m12);
		free_flag = TRUE_m12;
	}
	
	// check overall size
	if (sizeof(METADATA_m12) != METADATA_BYTES_m12)
		return_value = FALSE_m12;

	// check substructure offsets
	md = (METADATA_m12 *) bytes;
	if (&md->section_1 != (METADATA_SECTION_1_m12 *) bytes)
		return_value = FALSE_m12;
	if (&md->time_series_section_2 != (TIME_SERIES_METADATA_SECTION_2_m12 *) (bytes + METADATA_SECTION_1_BYTES_m12))
		return_value = FALSE_m12;
	if (&md->video_section_2 != (VIDEO_METADATA_SECTION_2_m12 *) (bytes + METADATA_SECTION_1_BYTES_m12))
		return_value = FALSE_m12;
	if (&md->section_3 != (METADATA_SECTION_3_m12 *) (bytes + METADATA_SECTION_1_BYTES_m12 + METADATA_SECTION_2_BYTES_m12))
		return_value = FALSE_m12;

	// check substructure contents
	if (ALCK_metadata_section_1_m12(bytes) == FALSE_m12)
		return_value = FALSE_m12;
	if (ALCK_time_series_metadata_section_2_m12(bytes) == FALSE_m12)
		return_value = FALSE_m12;
	if (ALCK_video_metadata_section_2_m12(bytes) == FALSE_m12)
		return_value = FALSE_m12;
	if (ALCK_metadata_section_3_m12(bytes) == FALSE_m12)
			return_value = FALSE_m12;
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (return_value == TRUE_m12)
		globals_m12->all_metadata_structures_aligned = TRUE_m12;

	return(return_value);
}


TERN_m12	ALCK_metadata_section_1_m12(ui1 *bytes)
{
	METADATA_SECTION_1_m12	*md1;
	TERN_m12		free_flag = FALSE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// see if already checked
	if (globals_m12->metadata_section_1_aligned == UNKNOWN_m12)
		globals_m12->metadata_section_1_aligned = FALSE_m12;
	else
		return(globals_m12->metadata_section_1_aligned);
	
	// check overall size
	if (sizeof(METADATA_SECTION_1_m12) != METADATA_SECTION_1_BYTES_m12)
		goto METADATA_SECTION_1_NOT_ALIGNED_m12;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(METADATA_FILE_BYTES_m12);
		free_flag = TRUE_m12;
	}
	md1 = (METADATA_SECTION_1_m12 *) (bytes + UNIVERSAL_HEADER_BYTES_m12);
	if (md1->level_1_password_hint != (si1 *) (bytes + METADATA_LEVEL_1_PASSWORD_HINT_OFFSET_m12))
		goto METADATA_SECTION_1_NOT_ALIGNED_m12;
	if (md1->level_2_password_hint != (si1 *) (bytes + METADATA_LEVEL_2_PASSWORD_HINT_OFFSET_m12))
		goto METADATA_SECTION_1_NOT_ALIGNED_m12;
	if (&md1->section_2_encryption_level != (si1 *) (bytes + METADATA_SECTION_2_ENCRYPTION_LEVEL_OFFSET_m12))
		goto METADATA_SECTION_1_NOT_ALIGNED_m12;
	if (&md1->section_3_encryption_level != (si1 *) (bytes + METADATA_SECTION_3_ENCRYPTION_LEVEL_OFFSET_m12))
		goto METADATA_SECTION_1_NOT_ALIGNED_m12;
	if (&md1->time_series_data_encryption_level != (si1 *) (bytes + METADATA_TIME_SERIES_DATA_ENCRYPTION_LEVEL_OFFSET_m12))
		goto METADATA_SECTION_1_NOT_ALIGNED_m12;
	if (md1->protected_region != (ui1 *) (bytes + METADATA_SECTION_1_PROTECTED_REGION_OFFSET_m12))
		goto METADATA_SECTION_1_NOT_ALIGNED_m12;
	if (md1->discretionary_region != (ui1 *) (bytes + METADATA_SECTION_1_DISCRETIONARY_REGION_OFFSET_m12))
		goto METADATA_SECTION_1_NOT_ALIGNED_m12;
	
	// aligned
	globals_m12->metadata_section_1_aligned = TRUE_m12;
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("METADATA_SECTION_1_m12 structure is aligned\n");
	
	return(TRUE_m12);
	
	// not aligned
METADATA_SECTION_1_NOT_ALIGNED_m12:
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_error_message_m12("%s(): METADATA_SECTION_1_m12 structure is NOT aligned\n", __FUNCTION__);
	
	return(FALSE_m12);
}


TERN_m12	ALCK_metadata_section_3_m12(ui1 *bytes)
{
	METADATA_SECTION_3_m12	*md3;
	TERN_m12		free_flag = FALSE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// see if already checked
	if (globals_m12->metadata_section_3_aligned == UNKNOWN_m12)
		globals_m12->metadata_section_3_aligned = FALSE_m12;
	else
		return(globals_m12->metadata_section_3_aligned);
	
	// check overall size
	if (sizeof(METADATA_SECTION_3_m12) != METADATA_SECTION_3_BYTES_m12)
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(METADATA_FILE_BYTES_m12);
		free_flag = TRUE_m12;
	}
	md3 = (METADATA_SECTION_3_m12 *) (bytes + METADATA_SECTION_3_OFFSET_m12);
	if (&md3->recording_time_offset != (si8 *) (bytes + METADATA_RECORDING_TIME_OFFSET_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (&md3->daylight_time_start_code != (DAYLIGHT_TIME_CHANGE_CODE_m12 *) (bytes + METADATA_DAYLIGHT_TIME_START_CODE_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (&md3->daylight_time_end_code != (DAYLIGHT_TIME_CHANGE_CODE_m12 *) (bytes + METADATA_DAYLIGHT_TIME_END_CODE_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->standard_timezone_acronym != (si1 *) (bytes + METADATA_STANDARD_TIMEZONE_ACRONYM_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->standard_timezone_string != (si1 *) (bytes + METADATA_STANDARD_TIMEZONE_STRING_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->daylight_timezone_acronym != (si1 *) (bytes + METADATA_DAYLIGHT_TIMEZONE_ACRONYM_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->daylight_timezone_string != (si1 *) (bytes + METADATA_DAYLIGHT_TIMEZONE_STRING_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->subject_name_1 != (si1 *) (bytes + METADATA_SUBJECT_NAME_1_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->subject_name_2 != (si1 *) (bytes + METADATA_SUBJECT_NAME_2_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->subject_name_3 != (si1 *) (bytes + METADATA_SUBJECT_NAME_3_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->subject_ID != (si1 *) (bytes + METADATA_SUBJECT_ID_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->recording_country != (si1 *) (bytes + METADATA_RECORDING_COUNTRY_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->recording_territory != (si1 *) (bytes + METADATA_RECORDING_TERRITORY_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->recording_locality != (si1 *) (bytes + METADATA_RECORDING_LOCALITY_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->recording_institution != (si1 *) (bytes + METADATA_RECORDING_INSTITUTION_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->geotag_format != (si1 *) (bytes + METADATA_GEOTAG_FORMAT_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->geotag_data != (si1 *) (bytes + METADATA_GEOTAG_DATA_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (&md3->standard_UTC_offset != (si4 *) (bytes + METADATA_STANDARD_UTC_OFFSET_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->protected_region != (ui1 *) (bytes + METADATA_SECTION_3_PROTECTED_REGION_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	if (md3->discretionary_region != (ui1 *) (bytes + METADATA_SECTION_3_DISCRETIONARY_REGION_OFFSET_m12))
		goto METADATA_SECTION_3_NOT_ALIGNED_m12;
	
	// aligned
	globals_m12->metadata_section_3_aligned = TRUE_m12;
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("METADATA_SECTION_3_m12 structure is aligned\n");
	
	return(TRUE_m12);
	
	// not aligned
METADATA_SECTION_3_NOT_ALIGNED_m12:
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_error_message_m12("%s(): METADATA_SECTION_3_m12 structure is NOT aligned\n", __FUNCTION__);
	
	return(FALSE_m12);
}


TERN_m12	ALCK_record_header_m12(ui1 *bytes)
{
	RECORD_HEADER_m12	*rh;
	TERN_m12                free_flag = FALSE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// see if already checked
	if (globals_m12->record_header_aligned == UNKNOWN_m12)
		globals_m12->record_header_aligned = FALSE_m12;
	else
		return(globals_m12->record_header_aligned);
	
	// check overall size
	if (sizeof(RECORD_HEADER_m12) != RECORD_HEADER_BYTES_m12)
		goto RECORD_HEADER_NOT_ALIGNED_m12;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(RECORD_HEADER_BYTES_m12);
		free_flag = TRUE_m12;
	}
	rh = (RECORD_HEADER_m12 *) bytes;
	if (&rh->record_CRC != (ui4 *) (bytes + RECORD_HEADER_RECORD_CRC_OFFSET_m12))
		goto RECORD_HEADER_NOT_ALIGNED_m12;
	if (&rh->total_record_bytes != (ui4 *) (bytes + RECORD_HEADER_TOTAL_RECORD_BYTES_OFFSET_m12))
		goto RECORD_HEADER_NOT_ALIGNED_m12;
	if (&rh->start_time != (si8 *) (bytes + RECORD_HEADER_START_TIME_OFFSET_m12))
		goto RECORD_HEADER_NOT_ALIGNED_m12;
	if (rh->type_string != (si1 *) (bytes + RECORD_HEADER_TYPE_STRING_OFFSET_m12))
		goto RECORD_HEADER_NOT_ALIGNED_m12;
	if (&rh->type_code != (ui4 *) (bytes + RECORD_HEADER_TYPE_CODE_OFFSET_m12))
		goto RECORD_HEADER_NOT_ALIGNED_m12;
	if (&rh->type_string_terminal_zero != (si1 *) (bytes + RECORD_HEADER_TYPE_STRING_TERMINAL_ZERO_OFFSET_m12))
		goto RECORD_HEADER_NOT_ALIGNED_m12;
	if (&rh->version_major != (ui1 *) (bytes + RECORD_HEADER_VERSION_MAJOR_OFFSET_m12))
		goto RECORD_HEADER_NOT_ALIGNED_m12;
	if (&rh->version_minor != (ui1 *) (bytes + RECORD_HEADER_VERSION_MINOR_OFFSET_m12))
		goto RECORD_HEADER_NOT_ALIGNED_m12;
	if (&rh->encryption_level != (si1 *) (bytes + RECORD_HEADER_ENCRYPTION_LEVEL_OFFSET_m12))
		goto RECORD_HEADER_NOT_ALIGNED_m12;
	
	// aligned
	globals_m12->record_header_aligned = TRUE_m12;
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("RECORD_HEADER_m12 structure is aligned\n");
	
	return(TRUE_m12);
	
	// not aligned
RECORD_HEADER_NOT_ALIGNED_m12:
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_error_message_m12("%s(): RECORD_HEADER_m12 structure is NOT aligned\n", __FUNCTION__);
	
	return(FALSE_m12);
}


TERN_m12	ALCK_record_indices_m12(ui1 *bytes)
{
	RECORD_INDEX_m12	*ri;
	TERN_m12		free_flag = FALSE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// see if already checked
	if (globals_m12->record_indices_aligned == UNKNOWN_m12)
		globals_m12->record_indices_aligned = FALSE_m12;
	else
		return(globals_m12->record_indices_aligned);
	
	// check overall size
	if (sizeof(RECORD_INDEX_m12) != RECORD_INDEX_BYTES_m12)
		goto RECORD_INDICES_NOT_ALIGNED_m12;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(RECORD_INDEX_BYTES_m12);
		free_flag = TRUE_m12;
	}
	ri = (RECORD_INDEX_m12 *) bytes;
	if (&ri->file_offset != (si8 *) (bytes + RECORD_INDEX_FILE_OFFSET_OFFSET_m12))
		goto RECORD_INDICES_NOT_ALIGNED_m12;
	if (&ri->start_time != (si8 *) (bytes + RECORD_INDEX_START_TIME_OFFSET_m12))
		goto RECORD_INDICES_NOT_ALIGNED_m12;
	if (ri->type_string != (si1 *) (bytes + RECORD_INDEX_TYPE_STRING_OFFSET_m12))
		goto RECORD_INDICES_NOT_ALIGNED_m12;
	if (&ri->type_code != (ui4 *) (bytes + RECORD_INDEX_TYPE_CODE_OFFSET_m12))
		goto RECORD_INDICES_NOT_ALIGNED_m12;
	if (&ri->type_string_terminal_zero != (si1 *) (bytes + RECORD_INDEX_TYPE_STRING_TERMINAL_ZERO_OFFSET_m12))
		goto RECORD_INDICES_NOT_ALIGNED_m12;
	if (&ri->version_major != (ui1 *) (bytes + RECORD_INDEX_VERSION_MAJOR_OFFSET_m12))
		goto RECORD_INDICES_NOT_ALIGNED_m12;
	if (&ri->version_minor != (ui1 *) (bytes + RECORD_INDEX_VERSION_MINOR_OFFSET_m12))
		goto RECORD_INDICES_NOT_ALIGNED_m12;
	if (&ri->encryption_level != (si1 *) (bytes + RECORD_INDEX_ENCRYPTION_LEVEL_OFFSET_m12))
		goto RECORD_INDICES_NOT_ALIGNED_m12;
	
	// aligned
	globals_m12->record_indices_aligned = TRUE_m12;
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		printf_m12("RECORD_INDEX_m12 structure is aligned\n");
	
	return(TRUE_m12);
	
	// not aligned
RECORD_INDICES_NOT_ALIGNED_m12:
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_error_message_m12("%s(): RECORD_INDEX_m12 structure is NOT aligned\n", __FUNCTION__);
	
	return(FALSE_m12);
}


TERN_m12	ALCK_time_series_indices_m12(ui1 *bytes)
{
	TIME_SERIES_INDEX_m12	*tsi;
	TERN_m12		free_flag = FALSE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// see if already checked
	if (globals_m12->time_series_indices_aligned == UNKNOWN_m12)
		globals_m12->time_series_indices_aligned = FALSE_m12;
	else
		return(globals_m12->time_series_indices_aligned);
	
	// check overall size
	if (sizeof(TIME_SERIES_INDEX_m12) != TIME_SERIES_INDEX_BYTES_m12)
		goto TIME_SERIES_INDICES_NOT_ALIGNED_m12;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(TIME_SERIES_INDEX_BYTES_m12);
		free_flag = TRUE_m12;
	}
	tsi = (TIME_SERIES_INDEX_m12 *) bytes;
	if (&tsi->file_offset != (si8 *) (bytes + TIME_SERIES_INDEX_FILE_OFFSET_OFFSET_m12))
		goto TIME_SERIES_INDICES_NOT_ALIGNED_m12;
	if (&tsi->start_time != (si8 *) (bytes + TIME_SERIES_INDEX_START_TIME_OFFSET_m12))
		goto TIME_SERIES_INDICES_NOT_ALIGNED_m12;
	if (&tsi->start_sample_number != (si8 *) (bytes + TIME_SERIES_INDEX_START_SAMPLE_NUMBER_OFFSET_m12))
		goto TIME_SERIES_INDICES_NOT_ALIGNED_m12;
	
	// aligned
	globals_m12->time_series_indices_aligned = TRUE_m12;
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("TIME_SERIES_INDEX_m12 structure is aligned\n");
	
	return(TRUE_m12);
	
	// not aligned
TIME_SERIES_INDICES_NOT_ALIGNED_m12:
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_error_message_m12("%s(): TIME_SERIES_INDEX_m12 structure is NOT aligned\n", __FUNCTION__);
	
	return(FALSE_m12);
}


TERN_m12	ALCK_time_series_metadata_section_2_m12(ui1 *bytes)
{
	TIME_SERIES_METADATA_SECTION_2_m12	*md2;
	TERN_m12				free_flag = FALSE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// see if already checked
	if (globals_m12->time_series_metadata_section_2_aligned == UNKNOWN_m12)
		globals_m12->time_series_metadata_section_2_aligned = FALSE_m12;
	else
		return(globals_m12->time_series_metadata_section_2_aligned);
	
	// check overall size
	if (sizeof(TIME_SERIES_METADATA_SECTION_2_m12) != METADATA_SECTION_2_BYTES_m12)
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(METADATA_FILE_BYTES_m12);
		free_flag = TRUE_m12;
	}
	md2 = (TIME_SERIES_METADATA_SECTION_2_m12 *) (bytes + METADATA_SECTION_2_OFFSET_m12);
	// channel type independent fields
	if (md2->session_description != (si1 *) (bytes + METADATA_SESSION_DESCRIPTION_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (md2->channel_description != (si1 *) (bytes + METADATA_CHANNEL_DESCRIPTION_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (md2->segment_description != (si1 *) (bytes + METADATA_SEGMENT_DESCRIPTION_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (md2->equipment_description != (si1 *) (bytes + METADATA_EQUIPMENT_DESCRIPTION_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->acquisition_channel_number != (si4 *) (bytes + METADATA_ACQUISITION_CHANNEL_NUMBER_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	// channel type specific fields
	if (md2->reference_description != (si1 *) (bytes + TIME_SERIES_METADATA_REFERENCE_DESCRIPTION_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->sampling_frequency != (sf8 *) (bytes + TIME_SERIES_METADATA_SAMPLING_FREQUENCY_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->low_frequency_filter_setting != (sf8 *) (bytes + TIME_SERIES_METADATA_LOW_FREQUENCY_FILTER_SETTING_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->high_frequency_filter_setting != (sf8 *) (bytes + TIME_SERIES_METADATA_HIGH_FREQUENCY_FILTER_SETTING_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->notch_filter_frequency_setting != (sf8 *) (bytes + TIME_SERIES_METADATA_NOTCH_FILTER_FREQUENCY_SETTING_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->AC_line_frequency != (sf8 *) (bytes + TIME_SERIES_METADATA_AC_LINE_FREQUENCY_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->amplitude_units_conversion_factor != (sf8 *) (bytes + TIME_SERIES_METADATA_AMPLITUDE_UNITS_CONVERSION_FACTOR_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (md2->amplitude_units_description != (si1 *) (bytes + TIME_SERIES_METADATA_AMPLITUDE_UNITS_DESCRIPTION_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->time_base_units_conversion_factor != (sf8 *) (bytes + TIME_SERIES_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (md2->time_base_units_description != (si1 *) (bytes + TIME_SERIES_METADATA_TIME_BASE_UNITS_DESCRIPTION_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->absolute_start_sample_number != (si8 *) (bytes + TIME_SERIES_METADATA_ABSOLUTE_START_SAMPLE_NUMBER_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->number_of_samples != (si8 *) (bytes + TIME_SERIES_METADATA_NUMBER_OF_SAMPLES_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->number_of_blocks != (si8 *) (bytes + TIME_SERIES_METADATA_NUMBER_OF_BLOCKS_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->maximum_block_bytes != (si8 *) (bytes + TIME_SERIES_METADATA_MAXIMUM_BLOCK_BYTES_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->maximum_block_samples != (ui4 *) (bytes + TIME_SERIES_METADATA_MAXIMUM_BLOCK_SAMPLES_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->maximum_block_keysample_bytes != (ui4 *) (bytes + TIME_SERIES_METADATA_MAXIMUM_BLOCK_KEYSAMPLE_BYTES_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->maximum_block_duration != (sf8 *) (bytes + TIME_SERIES_METADATA_MAXIMUM_BLOCK_DURATION_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->number_of_discontinuities != (si8 *) (bytes + TIME_SERIES_METADATA_NUMBER_OF_DISCONTINUITIES_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->maximum_contiguous_blocks != (si8 *) (bytes + TIME_SERIES_METADATA_MAXIMUM_CONTIGUOUS_BLOCKS_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->maximum_contiguous_block_bytes != (si8 *) (bytes + TIME_SERIES_METADATA_MAXIMUM_CONTIGUOUS_BLOCK_BYTES_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&md2->maximum_contiguous_samples != (si8 *) (bytes + TIME_SERIES_METADATA_MAXIMUM_CONTIGUOUS_SAMPLES_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (md2->protected_region != (ui1 *) (bytes + TIME_SERIES_METADATA_SECTION_2_PROTECTED_REGION_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (md2->discretionary_region != (ui1 *) (bytes + TIME_SERIES_METADATA_SECTION_2_DISCRETIONARY_REGION_OFFSET_m12))
		goto TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12;
	
	// aligned
	globals_m12->time_series_metadata_section_2_aligned = TRUE_m12;
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("TIME_SERIES_METADATA_SECTION_2_m12 structure is aligned\n");
	
	return(TRUE_m12);
	
	// not aligned
TIME_SERIES_METADATA_SECTION_2_NOT_ALIGNED_m12:
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_error_message_m12("%s(): TIME_SERIES_METADATA_SECTION_2_m12 structure is NOT aligned\n", __FUNCTION__);
	
	return(FALSE_m12);
}


TERN_m12	ALCK_universal_header_m12(ui1 *bytes)
{
	UNIVERSAL_HEADER_m12	*uh;
	TERN_m12		free_flag = FALSE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// see if already checked
	if (globals_m12->universal_header_aligned == UNKNOWN_m12)
		globals_m12->universal_header_aligned = FALSE_m12;
	else
		return(globals_m12->universal_header_aligned);
	
	// check overall size
	if (sizeof(UNIVERSAL_HEADER_m12) != UNIVERSAL_HEADER_BYTES_m12)
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(UNIVERSAL_HEADER_BYTES_m12);
		free_flag = TRUE_m12;
	}
	uh = (UNIVERSAL_HEADER_m12 *) bytes;
	if (&uh->header_CRC != (ui4 *) (bytes + UNIVERSAL_HEADER_HEADER_CRC_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->body_CRC != (ui4 *) (bytes + UNIVERSAL_HEADER_BODY_CRC_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->segment_end_time != (si8 *) (bytes + UNIVERSAL_HEADER_FILE_END_TIME_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->number_of_entries != (si8 *) (bytes + UNIVERSAL_HEADER_NUMBER_OF_ENTRIES_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->maximum_entry_size != (ui4 *) (bytes + UNIVERSAL_HEADER_MAXIMUM_ENTRY_SIZE_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->segment_number != (si4 *) (bytes + UNIVERSAL_HEADER_SEGMENT_NUMBER_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (uh->type_string != (si1 *) (bytes + UNIVERSAL_HEADER_TYPE_STRING_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->type_code != (ui4 *) (bytes + UNIVERSAL_HEADER_TYPE_CODE_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->type_string_terminal_zero != (si1 *) (bytes + UNIVERSAL_HEADER_TYPE_STRING_TERMINAL_ZERO_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->MED_version_major != (ui1 *) (bytes + UNIVERSAL_HEADER_MED_VERSION_MAJOR_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->MED_version_minor != (ui1 *) (bytes + UNIVERSAL_HEADER_MED_VERSION_MINOR_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->byte_order_code != (ui1 *) (bytes + UNIVERSAL_HEADER_BYTE_ORDER_CODE_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->session_start_time != (si8 *) (bytes + UNIVERSAL_HEADER_SESSION_START_TIME_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->segment_start_time != (si8 *) (bytes + UNIVERSAL_HEADER_FILE_START_TIME_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (uh->session_name != (si1 *) (bytes + UNIVERSAL_HEADER_SESSION_NAME_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (uh->channel_name != (si1 *)  (bytes + UNIVERSAL_HEADER_CHANNEL_NAME_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (uh->anonymized_subject_ID != (si1 *) (bytes + UNIVERSAL_HEADER_ANONYMIZED_SUBJECT_ID_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->session_UID != (ui8 *) (bytes + UNIVERSAL_HEADER_SESSION_UID_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->channel_UID != (ui8 *) (bytes + UNIVERSAL_HEADER_CHANNEL_UID_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->segment_UID != (ui8 *) (bytes + UNIVERSAL_HEADER_SEGMENT_UID_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->file_UID != (ui8 *) (bytes + UNIVERSAL_HEADER_FILE_UID_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (&uh->provenance_UID != (ui8 *) (bytes + UNIVERSAL_HEADER_PROVENANCE_UID_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (uh->level_1_password_validation_field != (ui1 *) (bytes + UNIVERSAL_HEADER_LEVEL_1_PASSWORD_VALIDATION_FIELD_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (uh->level_2_password_validation_field != (ui1 *) (bytes + UNIVERSAL_HEADER_LEVEL_2_PASSWORD_VALIDATION_FIELD_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (uh->level_3_password_validation_field != (ui1 *) (bytes + UNIVERSAL_HEADER_LEVEL_3_PASSWORD_VALIDATION_FIELD_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (uh->protected_region != (ui1 *) (bytes + UNIVERSAL_HEADER_PROTECTED_REGION_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	if (uh->discretionary_region != (ui1 *) (bytes + UNIVERSAL_HEADER_DISCRETIONARY_REGION_OFFSET_m12))
		goto UNIVERSAL_HEADER_NOT_ALIGNED_m12;
	
	// aligned
	globals_m12->universal_header_aligned = TRUE_m12;
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("UNIVERSAL_HEADER_m12 structure is aligned\n");
	
	return(TRUE_m12);
	
	// not aligned
UNIVERSAL_HEADER_NOT_ALIGNED_m12:
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_error_message_m12("%s(): UNIVERSAL_HEADER_m12 structure is NOT aligned\n", __FUNCTION__);
	
	return(FALSE_m12);
}


TERN_m12	ALCK_video_indices_m12(ui1 *bytes)
{
	VIDEO_INDEX_m12		*vi;
	TERN_m12		free_flag = FALSE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// see if already checked
	if (globals_m12->video_indices_aligned == UNKNOWN_m12)
		globals_m12->video_indices_aligned = FALSE_m12;
	else
		return(globals_m12->video_indices_aligned);
	
	// check overall size
	if (sizeof(VIDEO_INDEX_m12) != VIDEO_INDEX_BYTES_m12)
		goto VIDEO_INDICES_NOT_ALIGNED_m12;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(VIDEO_INDEX_BYTES_m12);
		free_flag = TRUE_m12;
	}
	vi = (VIDEO_INDEX_m12 *) bytes;
	if (&vi->file_offset != (si8 *) (bytes + VIDEO_INDEX_FILE_OFFSET_OFFSET_m12))
		goto VIDEO_INDICES_NOT_ALIGNED_m12;
	if (&vi->start_time != (si8 *) (bytes + VIDEO_INDEX_START_TIME_OFFSET_m12))
		goto VIDEO_INDICES_NOT_ALIGNED_m12;
	if (&vi->start_frame_number != (ui4 *) (bytes + VIDEO_INDEX_START_FRAME_OFFSET_m12))
		goto VIDEO_INDICES_NOT_ALIGNED_m12;
	if (&vi->video_file_number != (ui4 *) (bytes + VIDEO_INDEX_VIDEO_FILE_NUMBER_OFFSET_m12))
		goto VIDEO_INDICES_NOT_ALIGNED_m12;
	
	// aligned
	globals_m12->video_indices_aligned = TRUE_m12;
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("VIDEO_INDEX_m12 structure is aligned\n");
	
	return(TRUE_m12);
	
	// not aligned
VIDEO_INDICES_NOT_ALIGNED_m12:
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_error_message_m12("%s(): VIDEO_INDEX_m12 structure is NOT aligned\n", __FUNCTION__);
	
	return(FALSE_m12);
}


TERN_m12	ALCK_video_metadata_section_2_m12(ui1 *bytes)
{
	VIDEO_METADATA_SECTION_2_m12	*vmd2;
	TERN_m12			free_flag = FALSE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// see if already checked
	if (globals_m12->video_metadata_section_2_aligned == UNKNOWN_m12)
		globals_m12->video_metadata_section_2_aligned = FALSE_m12;
	else
		return(globals_m12->video_metadata_section_2_aligned);
	
	// check overall size
	if (sizeof(VIDEO_METADATA_SECTION_2_m12) != METADATA_SECTION_2_BYTES_m12)
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(METADATA_FILE_BYTES_m12);
		free_flag = TRUE_m12;
	}
	vmd2 = (VIDEO_METADATA_SECTION_2_m12 *) (bytes + METADATA_SECTION_2_OFFSET_m12);
	// channel type independent fields
	if (vmd2->session_description != (si1 *) (bytes + METADATA_SESSION_DESCRIPTION_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (vmd2->channel_description != (si1 *) (bytes + METADATA_CHANNEL_DESCRIPTION_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (vmd2->equipment_description != (si1 *) (bytes + METADATA_EQUIPMENT_DESCRIPTION_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->acquisition_channel_number != (si4 *) (bytes + METADATA_ACQUISITION_CHANNEL_NUMBER_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	// channel type specific fields
	if (&vmd2->time_base_units_conversion_factor != (sf8 *) (bytes + VIDEO_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (vmd2->time_base_units_description != (si1 *) (bytes + VIDEO_METADATA_TIME_BASE_UNITS_DESCRIPTION_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->absolute_start_frame_number != (si8 *) (bytes + VIDEO_METADATA_ABSOLUTE_START_FRAME_NUMBER_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->number_of_frames != (si8 *) (bytes + VIDEO_METADATA_NUMBER_OF_FRAMES_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->frame_rate != (sf8 *) (bytes + VIDEO_METADATA_FRAME_RATE_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->number_of_clips != (si8 *) (bytes + VIDEO_METADATA_NUMBER_OF_CLIPS_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->maximum_clip_bytes != (si8 *) (bytes + VIDEO_METADATA_MAXIMUM_CLIP_BYTES_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->maximum_clip_frames != (ui4 *) (bytes + VIDEO_METADATA_MAXIMUM_CLIP_FRAMES_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->number_of_video_files != (si4 *) (bytes + VIDEO_METADATA_NUMBER_OF_VIDEO_FILES_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->maximum_clip_duration != (sf8 *) (bytes + VIDEO_METADATA_MAXIMUM_CLIP_DURATION_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->number_of_discontinuities != (si8 *) (bytes + VIDEO_METADATA_NUMBER_OF_DISCONTINUITIES_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->maximum_contiguous_clips != (si8 *) (bytes + VIDEO_METADATA_MAXIMUM_CONTIGUOUS_CLIPS_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->maximum_contiguous_clip_bytes != (si8 *) (bytes + VIDEO_METADATA_MAXIMUM_CONTIGUOUS_CLIP_BYTES_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->maximum_contiguous_frames != (si8 *) (bytes + VIDEO_METADATA_MAXIMUM_CONTIGUOUS_FRAMES_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->horizontal_pixels != (ui4 *) (bytes + VIDEO_METADATA_HORIZONTAL_PIXELS_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (&vmd2->vertical_pixels != (ui4 *) (bytes + VIDEO_METADATA_VERTICAL_PIXELS_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (vmd2->video_format != (si1 *) (bytes + VIDEO_METADATA_VIDEO_FORMAT_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (vmd2->protected_region != (ui1 *) (bytes + VIDEO_METADATA_SECTION_2_PROTECTED_REGION_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	if (vmd2->discretionary_region != (ui1 *) (bytes + VIDEO_METADATA_SECTION_2_DISCRETIONARY_REGION_OFFSET_m12))
		goto VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12;
	
	// aligned
	globals_m12->video_metadata_section_2_aligned = TRUE_m12;
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("VIDEO_METADATA_SECTION_2_m12 structure is aligned\n");
	
	return(TRUE_m12);
	
	// not aligned
VIDEO_METADATA_SECTION_2_NOT_ALIGNED_m12:
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_error_message_m12("%s(): VIDEO_METADATA_SECTION_2_m12 structure is NOT aligned\n", __FUNCTION__);
	
	return(FALSE_m12);
}



//******************************************//
// MARK: ALLOCATION TRACKING FUNCTIONS  (AT)
//******************************************//


void	AT_add_entry_m12(void *address, size_t requested_bytes, const si1 *function)
{
	ui8		actual_bytes;
	si8		prev_node_count;
	AT_NODE		*atn;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifndef AT_DEBUG_m12
	G_warning_message_m12("The allocation tracking (AT) system was not initialized: compile with AT_DEBUG_m12.\n%s() called from %s()\n", __FUNCTION__, function);
	return;
#endif
	
	if (address == NULL) {
		G_warning_message_m12("%s(): attempting to add NULL object, called from function %s()\n", __FUNCTION__, function);
		return;
	}
	
	// get mutex
	AT_mutex_on();
		
	// expand list if needed
	if (globals_m12->AT_used_node_count == globals_m12->AT_node_count) {
		prev_node_count = globals_m12->AT_node_count;
		globals_m12->AT_node_count += GLOBALS_AT_LIST_SIZE_INCREMENT_m12;
#ifdef MATLAB_PERSISTENT_m12
		globals_m12->AT_nodes = (AT_NODE *) mxRealloc((void *) globals_m12->AT_nodes, (mwSize) (globals_m12->AT_node_count * sizeof(AT_NODE)));
#else
		globals_m12->AT_nodes = (AT_NODE *) realloc((void *) globals_m12->AT_nodes, globals_m12->AT_node_count * sizeof(AT_NODE));
#endif
		if (globals_m12->AT_nodes == NULL) {
			AT_mutex_off();
			G_error_message_m12("%s(): error expanding AT list => exiting\n", __FUNCTION__);
			exit_m12(-1);
		}
		// zero new memory
		memset((void *) (globals_m12->AT_nodes + prev_node_count), 0, (size_t) GLOBALS_AT_LIST_SIZE_INCREMENT_m12 * sizeof(AT_NODE));
		atn = globals_m12->AT_nodes + prev_node_count;
	} else {
		atn = globals_m12->AT_nodes + globals_m12->AT_used_node_count;
	}
	
	// get true allocated bytes
#ifdef MACOS_m12
	actual_bytes = (ui8) malloc_size(address);
#endif
#ifdef LINUX_m12
	actual_bytes = (ui8) malloc_usable_size(address);
#endif
#ifdef WINDOWS_m12
	actual_bytes = (ui8) _msize(address);
#endif
			
	// fill in
	atn->address = address;
	atn->requested_bytes = requested_bytes;
	atn->actual_bytes = actual_bytes;
	atn->alloc_function = function;
	
	// update
	++globals_m12->AT_used_node_count;

	// return mutex
	AT_mutex_off();
	
	return;
}


ui8	AT_alloc_size_m12(void *address)
{
	si8		i;
	ui8		requested_bytes;
	AT_NODE		*atn;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifndef AT_DEBUG_m12
	G_warning_message_m12("%s(): the allocation tracking (AT) system was not initialized: compile with AT_DEBUG_m12.\n", __FUNCTION__);
	return(0);
#endif

	if (address == NULL) {
		G_warning_message_m12("%s(): attempting find a NULL object\n", __FUNCTION__);
		return(0);
	}
	
	AT_mutex_on();

	atn = globals_m12->AT_nodes;
	for (i = globals_m12->AT_node_count; i--; ++atn) {
		if (atn->address == address) {
			requested_bytes = atn->requested_bytes;
			AT_mutex_off();
			return(requested_bytes);
		}
	}
	
	G_message_m12("%s(): no entry for address %lu\n", __FUNCTION__, (ui8) address);
	AT_mutex_off();

	return(0);
}


void	AT_free_all_m12(void)
{
	si8		i, alloced_entries;
	AT_NODE		*atn;
	
#ifdef FN_DEBUG_m12
	#ifdef MATLAB_m12
	mexPrintf("%s()\n", __FUNCTION__);
	#else
	printf("%s()\n", __FUNCTION__);
	#endif
#endif
	
#ifndef AT_DEBUG_m12
	G_warning_message_m12("%s(): the allocation tracking (AT) system was not initialized: compile with AT_DEBUG_m12.\n", __FUNCTION__);
	return;
#endif

	AT_mutex_on();

	alloced_entries = 0;
	atn = globals_m12->AT_nodes;
	for (i = globals_m12->AT_node_count; i--; ++atn) {
		if (atn->address == NULL)
			continue;
		if (atn->free_function == NULL)
			++alloced_entries;
	}

	if (alloced_entries) {
		#ifdef MATLAB_m12
		if (alloced_entries > 1)
			mexPrintf("\n%s(): freeing %ld entries:\n", __FUNCTION__, alloced_entries);
		else
			mexPrintf("\n%s(): freeing one entry:\n", __FUNCTION__);
		#else
		if (alloced_entries > 1)
			printf_m12("\n%s(): freeing %ld entries:\n", __FUNCTION__, alloced_entries);
		else
			printf_m12("\n%s(): freeing one entry:\n", __FUNCTION__);
		#endif

		atn = globals_m12->AT_nodes;
		for (i = globals_m12->AT_node_count; i--; ++atn) {
			if (atn->address == NULL)
				continue;
			if (atn->free_function == NULL) {
				AT_mutex_off();  // release mutex for AT_show_entry_m12()
				AT_show_entry_m12(atn->address);
				AT_mutex_on();  // reclaim mutex
				#ifdef MATLAB_PERSISTENT_m12
				mxFree(atn->address);
				#else
				free(atn->address);
				#endif
			}
		}
	}

	AT_mutex_off();

	return;
}


TERN_m12	AT_freeable_m12(void *address)
{
	si8		i;
	AT_NODE		*atn;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifndef AT_DEBUG_m12
	G_warning_message_m12("%s(): the allocation tracking (AT) system was not initialized: compile with AT_DEBUG_m12.\n", __FUNCTION__);
	return(UNKNOWN_m12);
#endif

	// silent function - just to tell whether an address is in the AT list
	
	if (address == NULL)
		return(FALSE_m12);
	
	// get mutex
	AT_mutex_on();
	
	// look for match entry
	atn = globals_m12->AT_nodes;
	for (i = globals_m12->AT_node_count; i--; ++atn)
		if (atn->address == address)
			break;

	// no entry
	if (i < 0) {
		AT_mutex_off();
		return(FALSE_m12);
	}

	// already freed
	if (atn->free_function != NULL) {
		AT_mutex_off();
		return(FALSE_m12);
	}

	// return mutex
	AT_mutex_off();
	
	return(TRUE_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	AT_mutex_off(void)
{
	PROC_pthread_mutex_unlock_m12(&globals_m12->AT_mutex);

	return;
}



#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	AT_mutex_on(void)
{
	PROC_pthread_mutex_lock_m12(&globals_m12->AT_mutex);

	return;
}


TERN_m12	AT_remove_entry_m12(void *address, const si1 *function)
{
	si8		i;
	AT_NODE		*atn, *freed_atn;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifndef AT_DEBUG_m12
	G_warning_message_m12("The allocation tracking (AT) system was not initialized: compile with AT_DEBUG_m12.\n%s() called from %s()\n", __FUNCTION__, function);
	return(FALSE_m12);
#endif

	// Note this function does not free the accociated memory, just marks it as freed in the AT list
	
	if (address == NULL) {
		G_warning_message_m12("%s(): attempting to free NULL object, called from function %s()\n", __FUNCTION__, function);
		return(FALSE_m12);
	}

	// get mutex
	AT_mutex_on();
	
	// look for match entry
	atn = globals_m12->AT_nodes;
	freed_atn = NULL;
	for (i = globals_m12->AT_node_count; i--; ++atn) {
		if (atn->address == address) {
			if (atn->free_function != NULL)  // keep looking at rest of entries: same address may have been allocated subsequently
				freed_atn = atn;
			else
				break;
		}
	}

	// no entry
	if (i < 0) {
		AT_mutex_off();
		if (freed_atn != NULL) {
			G_warning_message_m12("%s(): address was already freed, called from function %s():", __FUNCTION__, function);
			AT_show_entry_m12(address);  // show where previously freed
		} else {
			G_warning_message_m12("%s(): address is not allocated, called from function %s()\n", __FUNCTION__, function);
			AT_show_entry_m12(address);  // show where previously freed
		}
		return(FALSE_m12);
	}

	// mark as freed
	atn->free_function = function;

	// return mutex
	AT_mutex_off();
	
	return(TRUE_m12);
}


void	AT_show_entries_m12(ui4	entry_type)
{
	si8		i;
	AT_NODE		*atn;
	si8		alloced_entries = 0;
	si8		freed_entries = 0;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifndef AT_DEBUG_m12
	G_warning_message_m12("%s(): the allocation tracking (AT) system was not initialized: compile with AT_DEBUG_m12\n", __FUNCTION__);
	return;
#endif
	AT_mutex_on();
	
	atn = globals_m12->AT_nodes;
	for (i = globals_m12->AT_node_count; i--; ++atn) {
		if (atn->address == NULL)
			continue;
		if (atn->free_function == NULL) {
			if (entry_type & AT_CURRENTLY_ALLOCATED_m12) {
				G_message_m12("\naddress: %lu\n", (ui8) atn->address);
				G_message_m12("requested bytes: %lu\n", atn->requested_bytes);
				G_message_m12("actual bytes: %lu\n", atn->actual_bytes);
				G_message_m12("allocated by: %s()\n", atn->alloc_function);
			}
			++alloced_entries;
		} else {
			if (entry_type & AT_PREVIOUSLY_FREED_m12) {
				G_message_m12("\naddress: %lu\n", (ui8) atn->address);
				G_message_m12("requested bytes: %lu\n", atn->requested_bytes);
				G_message_m12("actual bytes: %lu\n", atn->actual_bytes);
				G_message_m12("allocated by: %s()\n", atn->alloc_function);
				G_message_m12("freed by: %s()\n", atn->free_function);
			}
			++freed_entries;
		}
	}

	G_message_m12("\ncurrently allocated AT entries: %lu\n", alloced_entries);
	G_message_m12("previously freed AT entries: %lu\n", freed_entries);

	AT_mutex_off();

	return;
}


void	AT_show_entry_m12(void *address)
{
	si8		i;
	AT_NODE		*atn;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

#ifndef AT_DEBUG_m12
	G_warning_message_m12("%s(): the allocation tracking (AT) system was not initialized: compile with AT_DEBUG_m12.\n", __FUNCTION__);
	return;
#endif

	if (address == NULL) {
		#ifdef AT_DEBUG_m12
		G_warning_message_m12("%s(): attempting to show a NULL object\n", __FUNCTION__);
		#endif
		return;
	}
	
	AT_mutex_on();

	atn = globals_m12->AT_nodes;
	for (i = globals_m12->AT_node_count; i--; ++atn) {
		if (atn->address == address) {
			G_message_m12("\naddress: %lu\n", (ui8) atn->address);
			G_message_m12("requested bytes: %lu\n", atn->requested_bytes);
			G_message_m12("actual bytes: %lu\n", atn->actual_bytes);
			G_message_m12("allocated by: %s()\n", atn->alloc_function);
			if (atn->free_function != NULL)
				G_message_m12("freed by: %s()\n", atn->free_function);
			AT_mutex_off();
			return;
		}
	}
	G_message_m12("%s(): no entry for address %lu\n", __FUNCTION__, (ui8) address);
	
	AT_mutex_off();

	return;
}


TERN_m12	AT_update_entry_m12(void *orig_address, void *new_address, size_t requested_bytes, const si1 *function)
{
	si8		i;
	AT_NODE		*atn;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifndef AT_DEBUG_m12
	G_warning_message_m12("The allocation tracking (AT) system was not initialized: compile with AT_DEBUG_m12.\n%s() called from %s()\n", __FUNCTION__, function);
	return(FALSE_m12);
#endif

	if (orig_address == NULL) {
		if (new_address != NULL) {
			AT_add_entry_m12(new_address, requested_bytes, function);
			return(TRUE_m12);
		}
	}
	if (new_address == NULL) {
		G_warning_message_m12("%s(): attempting to reassign to NULL object, called from function %s()\n", __FUNCTION__, function);
		return(FALSE_m12);
	}
	
	// get mutex
	AT_mutex_on();

	// look for match entry
	atn = globals_m12->AT_nodes;
	for (i = globals_m12->AT_node_count; i--; ++atn)
		if (atn->address == orig_address)
			break;
	
	// no entry
	if (i < 0) {
		AT_mutex_off();
		G_warning_message_m12("%s(): address %lu is not in the list, called from function %s()\n", __FUNCTION__, (ui8) orig_address, function);
		return(FALSE_m12);
	}
	
	if (atn->free_function != NULL) {
		G_warning_message_m12("%s(): original address was already freed, called from function %s():", __FUNCTION__, function);
		AT_show_entry_m12(orig_address);
		G_warning_message_m12("=> replacing with new data\n");
		atn->free_function = NULL;
	}

	// update
	atn->address = new_address;
#ifdef MACOS_m12
	atn->actual_bytes = (ui8) malloc_size(new_address);
#endif
#ifdef LINUX_m12
	atn->actual_bytes = (ui8) malloc_usable_size(new_address);
#endif
#ifdef WINDOWS_m12
	atn->actual_bytes = (ui8) _msize(new_address);
#endif
	atn->requested_bytes = requested_bytes;
	atn->alloc_function = function;

	// return mutex
	AT_mutex_off();

	return(TRUE_m12);
}



//*************************************************//
// MARK: COMPRESSION & COMPUTATION FUNCTIONS  (CMP)
//*************************************************//

#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
CMP_BUFFERS_m12    *CMP_allocate_buffers_m12(CMP_BUFFERS_m12 *buffers, si8 n_buffers, si8 n_elements, si8 element_size, TERN_m12 zero_data, TERN_m12 lock_memory)
{
	TERN_m12	free_structure;
	ui1		*array_base;
	ui8		pointer_bytes, array_bytes, total_requested_bytes, mod;
	si8		i;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// all buffers are 8-byte aligned
	// also use this function to re-allocate (data not preserved)
	// cast buffer pointers to desired type (as long as element_size <= allocated type size)
	// e.g.  sf8_array = (sf8 *) buffer[0]; si4_array = (si4 *) buffer[1];
	
	free_structure = FALSE_m12;
	if (buffers == NULL) {
		buffers = (CMP_BUFFERS_m12 *) calloc_m12((size_t) 1, sizeof(CMP_BUFFERS_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		if (buffers == NULL)
			return(NULL);
		free_structure = TRUE_m12;
	} else if (buffers->n_buffers >= n_buffers && buffers->n_elements >= n_elements && buffers->element_size >= element_size) {
		return(buffers);
	}
	
	// buffer pointers
	pointer_bytes = (ui8) (n_buffers * sizeof(void *));
	if ((mod = (pointer_bytes & (ui8) 7)))
		pointer_bytes += ((ui8) 8 - mod);
	
	// array bytes (pass sizeof(x) for element size so any pad bytes of structures are included)
	array_bytes = (ui8) (n_elements * element_size);
	if ((mod = (array_bytes & (ui8) 7)))
		array_bytes += ((ui8) 8 - mod);
	
	// allocate
	total_requested_bytes = pointer_bytes + (n_buffers * array_bytes);
	if (total_requested_bytes > buffers->total_allocated_bytes) {
		if (buffers->buffer != NULL) {
			if (buffers->locked == TRUE_m12)
				buffers->locked = munlock_m12((void *) buffers->buffer, (size_t) buffers->total_allocated_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			free_m12((void *) buffers->buffer, __FUNCTION__);  // usually faster to free & alloc than realloc because of potential memory move
		}
		if (zero_data == TRUE_m12)
			buffers->buffer = (void **) calloc_m12((size_t) total_requested_bytes, sizeof(ui1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		else
			buffers->buffer = (void **) malloc_m12((size_t) total_requested_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		if (buffers->buffer == NULL) {
			if (free_structure == TRUE_m12)
				free_m12((void *) buffers, __FUNCTION__);
			return(NULL);
		}
		buffers->total_allocated_bytes = total_requested_bytes;
	} else if (zero_data == TRUE_m12) {
		memset((void *) buffers->buffer, 0, (size_t) total_requested_bytes);
	}
	buffers->n_buffers = n_buffers;
	buffers->n_elements = n_elements;
	buffers->element_size = element_size;
	
	// assign pointers
	array_base = (ui1 *) buffers->buffer + pointer_bytes;
	for (i = 0; i < n_buffers; ++i) {
		buffers->buffer[i] = (void *) array_base;
		array_base += array_bytes;
	}
	
	// lock
	buffers->locked = FALSE_m12;
	if (lock_memory == TRUE_m12)
		buffers->locked = mlock_m12((void *) buffers->buffer, (size_t) buffers->total_allocated_bytes, FALSE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	return(buffers);
}


CMP_PROCESSING_STRUCT_m12	*CMP_allocate_processing_struct_m12(FILE_PROCESSING_STRUCT_m12 *fps, ui4 mode, si8 data_samples, si8 compressed_data_bytes, si8 keysample_bytes, ui4 block_samples, CMP_DIRECTIVES_m12 *directives, CMP_PARAMETERS_m12 *parameters)
{
	TERN_m12	need_compressed_data = FALSE_m12;
	TERN_m12	need_decompressed_data = FALSE_m12;
	TERN_m12	need_original_data = FALSE_m12;
	TERN_m12	need_keysample_buffer = FALSE_m12;
	TERN_m12	need_detrended_buffer = FALSE_m12;
	TERN_m12	need_derivative_buffer = FALSE_m12;
	TERN_m12	need_scrap_buffer = FALSE_m12;
	TERN_m12	need_scaled_amplitude_buffer = FALSE_m12;
	TERN_m12	need_scaled_frequency_buffer = FALSE_m12;
	TERN_m12	need_VDS_buffers = FALSE_m12;
	si8		pad_samples;
	CMP_PROCESSING_STRUCT_m12	*cps;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// pass CMP_SELF_MANAGED_MEMORY_m12 for data_samples to prevent automatic re-allocation

	if (fps->universal_header->type_code != TIME_SERIES_DATA_FILE_TYPE_CODE_m12) {
		G_error_message_m12("%s(): FPS must be time series data\n", __FUNCTION__);
		return(NULL);
	}
	
	if (fps->parameters.cps == NULL)
		fps->parameters.cps = (CMP_PROCESSING_STRUCT_m12 *) calloc_m12((size_t) 1, sizeof(CMP_PROCESSING_STRUCT_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	cps = fps->parameters.cps;
	PROC_pthread_mutex_init_m12(&cps->parameters.mutex,  NULL);
	
	// set up directives
	if (directives != NULL)
		cps->directives = *directives;
	else // set defaults
		CMP_initialize_directives_m12(&cps->directives, (ui1) mode);
	if (fps->parent != NULL) {  // set level header directives
		if (((LEVEL_HEADER_m12 *) fps->parent)->flags & LH_NO_CPS_PTR_RESET_m12)
			cps->directives.cps_pointer_reset = FALSE_m12;  // default is TRUE_m12
		if (((LEVEL_HEADER_m12 *) fps->parent)->flags & LH_NO_CPS_CACHING_m12)
			cps->directives.cps_caching = FALSE_m12;  // default is TRUE_m12
	}
	
	// set up parameters
	if (parameters != NULL)
		cps->parameters = *parameters;
	else  // set defaults
		CMP_initialize_parameters_m12(&cps->parameters);
		
	if (mode == CMP_COMPRESSION_MODE_NO_ENTRY_m12) {
		G_warning_message_m12("%s(): No compression mode specified\n", __FUNCTION__);
		return(cps);
	}
	
	// allocate RED/PRED buffers
	if (cps->directives.algorithm == CMP_RED1_COMPRESSION_m12 || cps->directives.algorithm == CMP_RED2_COMPRESSION_m12) {  // VDS uses RED & PRED, but allocated for PRED
		if (cps->directives.mode == CMP_COMPRESSION_MODE_m12) {
			cps->parameters.count = calloc_m12(CMP_RED_MAX_STATS_BINS_m12, sizeof(ui4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			cps->parameters.sorted_count = calloc_m12(CMP_RED_MAX_STATS_BINS_m12, sizeof(CMP_STATISTICS_BIN_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			cps->parameters.symbol_map = calloc_m12(CMP_RED_MAX_STATS_BINS_m12, sizeof(ui1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			need_derivative_buffer = TRUE_m12;
		} else {
			cps->parameters.count = NULL;
			cps->parameters.sorted_count = NULL;
			cps->parameters.symbol_map = NULL;
		}
		cps->parameters.cumulative_count = calloc_m12(CMP_RED_MAX_STATS_BINS_m12 + 1, sizeof(ui8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		cps->parameters.minimum_range = calloc_m12(CMP_RED_MAX_STATS_BINS_m12, sizeof(ui8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	} else if (cps->directives.algorithm == CMP_PRED1_COMPRESSION_m12 || cps->directives.algorithm == CMP_PRED2_COMPRESSION_m12 || cps->directives.algorithm == CMP_VDS_COMPRESSION_m12) {  // VDS uses RED & PRED, but buffers allocated for PRED
		if (cps->directives.mode == CMP_COMPRESSION_MODE_m12) {
			cps->parameters.count = (void *) calloc_2D_m12((size_t) CMP_PRED_CATS_m12, CMP_RED_MAX_STATS_BINS_m12, sizeof(ui4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			cps->parameters.sorted_count = (void *) calloc_2D_m12((size_t) CMP_PRED_CATS_m12, CMP_RED_MAX_STATS_BINS_m12, sizeof(CMP_STATISTICS_BIN_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			cps->parameters.symbol_map = (void *) calloc_2D_m12((size_t) CMP_PRED_CATS_m12, CMP_RED_MAX_STATS_BINS_m12, sizeof(ui1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			need_derivative_buffer = TRUE_m12;
		} else {
			cps->parameters.count = NULL;
			cps->parameters.sorted_count = NULL;
			cps->parameters.symbol_map = NULL;
		}
		cps->parameters.cumulative_count = (void *) calloc_2D_m12((size_t) CMP_PRED_CATS_m12, CMP_RED_MAX_STATS_BINS_m12 + 1, sizeof(ui8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		cps->parameters.minimum_range = (void *) calloc_2D_m12((size_t) CMP_PRED_CATS_m12, CMP_RED_MAX_STATS_BINS_m12, sizeof(ui8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	} else {
		cps->parameters.count = NULL;
		cps->parameters.sorted_count = NULL;
		cps->parameters.symbol_map = NULL;
		cps->parameters.cumulative_count = NULL;
		cps->parameters.minimum_range = NULL;
	}
	
	// VDS
	if (cps->directives.algorithm == CMP_VDS_COMPRESSION_m12)
		need_VDS_buffers = TRUE_m12;
	
	// decompression
	if (cps->directives.mode == CMP_DECOMPRESSION_MODE_m12) {
		need_compressed_data = TRUE_m12;
		need_decompressed_data = TRUE_m12;
		need_keysample_buffer = TRUE_m12;
	} else {  // compression
		need_compressed_data = TRUE_m12;
		need_original_data = TRUE_m12;
		need_keysample_buffer = TRUE_m12;
		
		if (cps->directives.detrend_data == TRUE_m12)
			need_detrended_buffer = TRUE_m12;
		if (cps->directives.find_derivative_level == TRUE_m12)
			need_scrap_buffer = TRUE_m12;
		if (cps->directives.set_amplitude_scale == TRUE_m12 || cps->directives.find_amplitude_scale == TRUE_m12)
			need_scaled_amplitude_buffer = TRUE_m12;
		if (cps->directives.set_frequency_scale == TRUE_m12 || cps->directives.find_frequency_scale == TRUE_m12)
			need_scaled_frequency_buffer = TRUE_m12;
		if (cps->directives.find_amplitude_scale == TRUE_m12 || cps->directives.find_frequency_scale == TRUE_m12)
			need_decompressed_data = TRUE_m12;
	}
	
	// original_data - caller specified array size
	if (need_original_data == TRUE_m12 && data_samples > 0)
		cps->input_buffer = cps->original_ptr = cps->original_data = (si4 *) calloc_m12((size_t) data_samples, sizeof(si4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	else
		cps->input_buffer = cps->original_ptr = cps->original_data = NULL;
	
	// allocated_block_samples applies to any array whose size depends only on number of block samples
	cps->parameters.allocated_block_samples = block_samples;
	
	// compressed_data - caller specified array size
	if (need_compressed_data == TRUE_m12) {
		if (fps->parameters.raw_data_bytes < (compressed_data_bytes + UNIVERSAL_HEADER_BYTES_m12)) {
			FPS_reallocate_processing_struct_m12(fps, compressed_data_bytes + UNIVERSAL_HEADER_BYTES_m12);
		} else {
			cps->parameters.allocated_compressed_bytes = fps->parameters.raw_data_bytes - UNIVERSAL_HEADER_BYTES_m12;
			cps->block_header = (CMP_BLOCK_FIXED_HEADER_m12 *) fps->data_pointers;
		}
	} else {
		cps->parameters.allocated_compressed_bytes = 0;
	}
	
	// keysample_buffer - caller specified or maximum bytes required for specified block size
	if (keysample_bytes == 0)
		keysample_bytes = CMP_MAX_KEYSAMPLE_BYTES_m12(block_samples);
	if (need_keysample_buffer == TRUE_m12) {
		cps->parameters.keysample_buffer = (si1 *) calloc_m12((size_t) keysample_bytes, sizeof(ui1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		cps->parameters.allocated_keysample_bytes = keysample_bytes;
	} else {
		cps->parameters.keysample_buffer = NULL;
		cps->parameters.allocated_keysample_bytes = 0;
	}

	// decompressed_data - caller specified array size
	if (need_decompressed_data == TRUE_m12) {
		if (cps->directives.mode == CMP_DECOMPRESSION_MODE_m12) {
			if (data_samples > 0)
				cps->parameters.cache = cps->decompressed_data = cps->decompressed_ptr = (si4 *) calloc_m12((size_t) data_samples, sizeof(si4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			else
				cps->parameters.cache = cps->decompressed_data = cps->decompressed_ptr = NULL;
			cps->parameters.allocated_decompressed_samples = data_samples;
		} else { // cps->directives.mode == CMP_COMPRESSION_MODE_m12  (decompressed_ptr used to calculate mean residual ratio for each block)
			cps->parameters.cache = cps->decompressed_data = cps->decompressed_ptr = (si4 *) calloc_m12((size_t) block_samples, sizeof(si4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			cps->parameters.allocated_decompressed_samples = block_samples;
		}
	} else {
		cps->parameters.cache = cps->decompressed_data = cps->decompressed_ptr = NULL;
		cps->parameters.allocated_decompressed_samples = 0;
	}
	
	// detrended_buffer - maximum bytes required for caller specified block size
	if (need_detrended_buffer == TRUE_m12)
		cps->parameters.detrended_buffer = (si4 *) calloc_m12((size_t) block_samples, sizeof(si4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	else
		cps->parameters.detrended_buffer = NULL;
	
	// derivative_buffer - maximum bytes required for caller specified block size
	if (need_derivative_buffer == TRUE_m12) {
		cps->parameters.derivative_buffer = (si4 *) malloc_m12((size_t) (block_samples << 2), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	} else {
		cps->parameters.derivative_buffer = NULL;
	}
	
	// scrap_buffers: here maximum bytes required for caller specified block size (other routines may expand)
	if (need_scrap_buffer == TRUE_m12) {
		cps->parameters.scrap_buffers = CMP_allocate_buffers_m12(NULL, 1, block_samples, sizeof(si4), FALSE_m12, FALSE_m12);
	} else {
		cps->parameters.scrap_buffers = NULL;
	}

	// scaled_amplitude_buffer - maximum bytes required for caller specified block size
	if (need_scaled_amplitude_buffer == TRUE_m12)
		cps->parameters.scaled_amplitude_buffer = (si4 *) calloc_m12((size_t) block_samples, sizeof(si4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	else
		cps->parameters.scaled_amplitude_buffer = NULL;
	
	// scaled_frequency_buffer - maximum bytes required for caller specified block size
	if (need_scaled_frequency_buffer == TRUE_m12)
		cps->parameters.scaled_frequency_buffer = (si4 *) calloc_m12((size_t) block_samples, sizeof(si4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	else
		cps->parameters.scaled_frequency_buffer = NULL;
	
	// VDS buffers - maximum bytes required for caller specified block size
	if (need_VDS_buffers == TRUE_m12) {
		if (mode == CMP_COMPRESSION_MODE_m12)
			pad_samples = CMP_VDS_LOWPASS_ORDER_m12 * 6;
		else
			pad_samples = CMP_MAK_PAD_SAMPLES_m12;
		cps->parameters.VDS_input_buffers = CMP_allocate_buffers_m12(NULL, CMP_VDS_INPUT_BUFFERS_m12, (si8) block_samples + pad_samples, sizeof(sf8), FALSE_m12, FALSE_m12);
		cps->parameters.VDS_output_buffers = CMP_allocate_buffers_m12(NULL, CMP_VDS_OUTPUT_BUFFERS_m12, (si8) block_samples, sizeof(sf8), FALSE_m12, FALSE_m12);
	} else {
		cps->parameters.VDS_input_buffers = cps->parameters.VDS_output_buffers = NULL;
	}

	return(cps);
}


void	CMP_binterpolate_sf8_m12(sf8 *in_data, si8 in_len, sf8 *out_data, si8 out_len, ui4 center_mode, TERN_m12 extrema, sf8 *minima, sf8 *maxima)
{
	si8		i, j, max_bin_width;
	si8		i_bin_width, i_bin_start, i_bin_end;
	sf8		*in_val, *bin_start_p, f_bin_width, f_bin_end, bin_min, bin_max, bin_sum, *quantile_buf, us_ratio;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (in_len <= 1) {
		if (in_len == 0)
			return;
		for (i = 0; i < out_len; ++i)
			out_data[i] = in_data[0];
		if (extrema == TRUE_m12)
			minima[i] = maxima[i] = in_data[0];
		return;
	}
	if (in_len == out_len) {
		memcpy(out_data, in_data, in_len << 3);
		if (extrema == TRUE_m12) {
			memcpy(minima, in_data, in_len << 3);
			memcpy(maxima, in_data, in_len << 3);
		}
		return;
	}
	
	switch (center_mode) {
		case	CMP_CENT_MODE_NONE_m12:
			if (extrema == FALSE_m12)  // no binterpolation requested: interpolate
				return;
		case	CMP_CENT_MODE_MIDPOINT_m12:
		case	CMP_CENT_MODE_MEAN_m12:
		case	CMP_CENT_MODE_MEDIAN_m12:
			break;
		case	CMP_CENT_MODE_FASTEST_m12:
			if (extrema == TRUE_m12)
				center_mode = CMP_CENT_MODE_MIDPOINT_m12;
			else
				center_mode = CMP_CENT_MODE_MEAN_m12;
			break;
		default:
			G_warning_message_m12("%s(): invalid center mode\n", __FUNCTION__);
			return;
	}
	
	// upsample
	if (in_len <= out_len) {
		if (center_mode == CMP_CENT_MODE_NONE_m12)
			out_data = (sf8 *) malloc((size_t) (out_len << 3));
		if (in_len == out_len) {
			memcpy((void *) out_data, (void *) in_data, (size_t) (out_len << 3));
		} else {
			us_ratio = (sf8) out_len / (sf8) in_len;
			if (us_ratio >= CMP_SPLINE_UPSAMPLE_SF_RATIO_m12)  // not an option at this point
				CMP_spline_interp_sf8_m12(in_data, in_len, out_data, out_len, NULL);
			else
				CMP_lin_interp_sf8_m12(in_data, in_len, out_data, out_len);
		}
		if (extrema == TRUE_m12) {
			memcpy((void *) minima, (void *) out_data, (size_t) (out_len << 3));
			memcpy((void *) maxima, (void *) out_data, (size_t) (out_len << 3));
		}
		if (center_mode == CMP_CENT_MODE_NONE_m12)
			free((void *) out_data);
		
		return;
	}

	// downsample
	--out_len;
	f_bin_width = (sf8) in_len / (sf8) out_len;
	f_bin_end = f_bin_width / (sf8) 2.0;
	i_bin_end = (si8) (f_bin_end + 0.5);
	in_val = in_data;
	if (center_mode == CMP_CENT_MODE_MEDIAN_m12) {
		max_bin_width = (si8) ceil(f_bin_width);
		quantile_buf = (sf8 *) malloc((size_t) (max_bin_width << 3));
	}
	
	// initial half-bin (no central tendency measure - could skew)
	if (center_mode != CMP_CENT_MODE_NONE_m12)
		out_data[0] = in_data[0];
	if (extrema == TRUE_m12) {
		bin_min = bin_max = *in_val++;
		for (j = i_bin_end; --j; ++in_val) {
			if (*in_val < bin_min)
				bin_min = *in_val;
			else if (*in_val > bin_max)
				bin_max = *in_val;
		}
		minima[0] = bin_min;
		maxima[0] = bin_max;
	} else {
		in_val += i_bin_end;
	}
	
	// central bins
	// Note: every combination is done to avoid unnessary computation where possible
	if (extrema == TRUE_m12) {
		switch (center_mode) {
			case CMP_CENT_MODE_NONE_m12:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					bin_min = bin_max = *in_val++;
					for (j = i_bin_width; --j; ++in_val) {
						if (*in_val < bin_min)
							bin_min = *in_val;
						else if (*in_val > bin_max)
							bin_max = *in_val;
					}
					minima[i] = bin_min;
					maxima[i] = bin_max;
				}
				break;
			case CMP_CENT_MODE_MIDPOINT_m12:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					bin_min = bin_max = *in_val++;
					for (j = i_bin_width; --j; ++in_val) {
						if (*in_val < bin_min)
							bin_min = *in_val;
						else if (*in_val > bin_max)
							bin_max = *in_val;
					}
					minima[i] = bin_min;
					maxima[i] = bin_max;
					out_data[i] = (bin_min + bin_max) / (sf8) 2.0;
				}
				break;
			case	CMP_CENT_MODE_MEAN_m12:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					bin_sum = bin_min = bin_max = *in_val++;
					for (j = i_bin_width; --j; ++in_val) {
						bin_sum += *in_val;
						if (*in_val < bin_min)
							bin_min = *in_val;
						else if (*in_val > bin_max)
							bin_max = *in_val;
					}
					minima[i] = bin_min;
					maxima[i] = bin_max;
					out_data[i] = bin_sum / (sf8) i_bin_width;
				}
				break;
			case	CMP_CENT_MODE_MEDIAN_m12:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					bin_start_p = in_val;
					bin_sum = bin_min = bin_max = *in_val++;
					for (j = i_bin_width; --j; ++in_val) {
						bin_sum += *in_val;
						if (*in_val < bin_min)
							bin_min = *in_val;
						else if (*in_val > bin_max)
							bin_max = *in_val;
					}
					minima[i] = bin_min;
					maxima[i] = bin_max;
					out_data[i] = CMP_quantval_m12(bin_start_p, i_bin_width, (sf8) 0.5, TRUE_m12, quantile_buf);
				}
				break;
		}
	} else {  // extrema == FALSE_m12
		switch (center_mode) {
			case CMP_CENT_MODE_MIDPOINT_m12:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					bin_min = bin_max = *in_val++;
					for (j = i_bin_width; --j; ++in_val) {
						if (*in_val < bin_min)
							bin_min = *in_val;
						else if (*in_val > bin_max)
							bin_max = *in_val;
					}
					out_data[i] = (bin_min + bin_max) / (sf8) 2.0;
				}
				break;
			case	CMP_CENT_MODE_MEAN_m12:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					bin_sum = *in_val++;
					for (j = i_bin_width; --j; ++in_val)
						bin_sum += *in_val;
					out_data[i] = bin_sum / (sf8) i_bin_width;
				}
				break;
			case	CMP_CENT_MODE_MEDIAN_m12:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					out_data[i] = CMP_quantval_m12(in_val, i_bin_width, (sf8) 0.5, TRUE_m12, quantile_buf);
					in_val += i_bin_width;
				}
				break;
		}
	}
		
	// terminal half-bin (no central tendency measure - could skew)
	if (center_mode != CMP_CENT_MODE_NONE_m12)
		out_data[out_len] = in_data[in_len - 1];
	if (extrema == TRUE_m12) {
		i_bin_start = i_bin_end;
		i_bin_end = in_len;
		i_bin_width = i_bin_end - i_bin_start;
		bin_min = bin_max = *in_val++;
		for (j = i_bin_width; --j; ++in_val) {
			if (*in_val < bin_min)
				bin_min = *in_val;
			else if (*in_val > bin_max)
				bin_max = *in_val;
		}
		minima[out_len] = bin_min;
		maxima[out_len] = bin_max;
	}
	
	if (center_mode == CMP_CENT_MODE_MEDIAN_m12)
		free((void *) quantile_buf);


	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	CMP_byte_to_hex_m12(ui1 byte, si1 *hex)
{
	ui1	hi_val, lo_val;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	hi_val = byte >> 4;
	if (hi_val > 9)
		hi_val += ((ui1) 'a' - 10);
	else
		hi_val += (ui1) '0';
	*hex++ = (si1) hi_val;
	
	lo_val = byte & 0x0F;
	if (lo_val > 9)
		lo_val += ((ui1) 'a' - 10);
	else
		lo_val += (ui1) '0';
	*hex = (si1) lo_val;

	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
sf8      CMP_calculate_mean_residual_ratio_m12(si4 *original_data, si4 *lossy_data, ui4 n_samps)
{
	sf8        sum, mrr, diff, r;
	si8        i;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	sum = (sf8) 0.0;
	for (i = n_samps; i--;) {
		if (*original_data) {
			diff = (sf8) (*original_data - *lossy_data++);
			r = diff / (sf8) *original_data++;
			sum += ABS_m12(r);
		} else {
			--n_samps;
			++original_data;
			++lossy_data;
		}
	}
	
	if (sum == (sf8) 0.0)
		mrr = (sf8) 0.0;
	else
		mrr = sum / (sf8) n_samps;
	
	return(mrr);
}


void    CMP_calculate_statistics_m12(REC_Stat_v10_m12 *stats, si4 *input_buffer, si8 len, CMP_NODE_m12 *nodes)
{
	CMP_NODE_m12		*np, head, tail;
	TERN_m12		free_nodes;
	si4			*x;
	sf8            		sum_x, n, dm, t, sdm2, sdm3, sdm4, m1, m2, m3, m4;
	sf8             	true_median;
	si8             	i, n_nodes, mid_idx, max_cnt, running_cnt;
	ui1             	median_found;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// allocate
	if (nodes == NULL) {
		nodes = (CMP_NODE_m12 *) calloc_m12((size_t)len, sizeof(CMP_NODE_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free_nodes = TRUE_m12;
	}
	else {
		free_nodes = FALSE_m12;
	}
	
	// sort
	x = input_buffer;
	n_nodes = CMP_ts_sort_m12(x, len, nodes, &head, &tail, FALSE_m12);
	
	// min, max, mean, median, & mode
	sum_x = (sf8) 0.0;
	running_cnt = max_cnt = 0;
	mid_idx = len >> 1;
	median_found = 0;
	for (i = n_nodes, np = head.next; i--; np = np->next) {
		sum_x += (sf8) np->val * (sf8) np->count;
		if (np->count > max_cnt) {
			max_cnt = np->count;
			stats->mode = np->val;
		}
		if (median_found == 0) {
			running_cnt += np->count;
			if (running_cnt >= mid_idx) {
				if (running_cnt == mid_idx) {
					true_median = (sf8) np->val + (sf8) np->next->val;
					stats->median = CMP_round_si4_m12(true_median);
				} else {
					stats->median = np->val;
				}
				median_found = 1;
			}
		}
	}
	n = (sf8) len;
	stats->minimum = head.next->val;
	stats->maximum = tail.prev->val;
	m1 = sum_x / n;
	stats->mean = CMP_round_si4_m12((sf8) m1);
	
	// variance
	sdm2 = sdm3 = sdm4 = (sf8) 0.0;
	for (i = n_nodes, np = head.next; i--; np = np->next) {
		dm = (sf8) np->val - m1;
		sdm2 += (t = dm * dm * (sf8) np->count);
		sdm3 += (t *= dm);
		sdm4 += (t *= dm);
	}
	stats->variance = (sf4) (m2 = sdm2 / n);
	m3 = sdm3 / n;
	m4 = sdm4 / n;
	
	// skewness
	t = m3 / sqrt(m2 * m2 * m2);
	if (isnan(t))
		t = (sf8) 0.0;  // possible NaN here: set to zero
	else if (len > 2) // correct bias
		t *= sqrt((n - (sf8) 1.0) / n) * (n / (n - (sf8) 2.0));
	stats->skewness = (sf4) t;
	
	// kurtosis
	t = m4 / (m2 * m2);
	if (len > 3) { // correct bias
		t = ((n + (sf8) 1.0) * t) - ((sf8) 3.0 * (n - (sf8) 1.0));
		t *= (n - (sf8) 1.0) / ((n - (sf8) 2.0) * (n - (sf8) 3.0));
		t += 3;
	}
	stats->kurtosis = (sf4) t;
	
	// clean up
	if (free_nodes == TRUE_m12)
		free_m12((void *) nodes, __FUNCTION__);
	
	return;
}


TERN_m12        CMP_check_block_header_alignment_m12(ui1 *bytes)
{
	CMP_BLOCK_FIXED_HEADER_m12	*cbh;
	TERN_m12			free_flag = FALSE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// see if already checked
	if (globals_m12->CMP_block_header_aligned == UNKNOWN_m12)
		globals_m12->CMP_block_header_aligned = FALSE_m12;
	else
		return(globals_m12->CMP_block_header_aligned);
	
	// check overall size
	if (sizeof(CMP_BLOCK_FIXED_HEADER_m12) != CMP_BLOCK_FIXED_HEADER_BYTES_m12)
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(CMP_BLOCK_FIXED_HEADER_BYTES_m12);
		free_flag = TRUE_m12;
	}
	cbh = (CMP_BLOCK_FIXED_HEADER_m12 *)bytes;
	if (&cbh->block_start_UID != (ui8 *) (bytes + CMP_BLOCK_START_UID_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->block_CRC != (ui4 *) (bytes + CMP_BLOCK_CRC_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->block_flags != (ui4 *) (bytes + CMP_BLOCK_BLOCK_FLAGS_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->start_time != (si8 *) (bytes + CMP_BLOCK_START_TIME_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->acquisition_channel_number != (si4 *) (bytes + CMP_BLOCK_ACQUISITION_CHANNEL_NUMBER_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->total_block_bytes != (ui4 *) (bytes + CMP_BLOCK_TOTAL_BLOCK_BYTES_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->number_of_samples != (ui4 *) (bytes + CMP_BLOCK_NUMBER_OF_SAMPLES_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->number_of_records != (ui2 *) (bytes + CMP_BLOCK_NUMBER_OF_RECORDS_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->record_region_bytes != (ui2 *) (bytes + CMP_BLOCK_RECORD_REGION_BYTES_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->parameter_flags != (ui4 *) (bytes + CMP_BLOCK_PARAMETER_FLAGS_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->parameter_region_bytes != (ui2 *) (bytes + CMP_BLOCK_PARAMETER_REGION_BYTES_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->protected_region_bytes != (ui2 *) (bytes + CMP_BLOCK_PROTECTED_REGION_BYTES_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->discretionary_region_bytes != (ui2 *) (bytes + CMP_BLOCK_DISCRETIONARY_REGION_BYTES_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->model_region_bytes != (ui2 *) (bytes + CMP_BLOCK_MODEL_REGION_BYTES_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	if (&cbh->total_header_bytes != (ui4 *) (bytes + CMP_BLOCK_TOTAL_HEADER_BYTES_OFFSET_m12))
		goto CMP_BLOCK_HEADER_NOT_ALIGNED_m12;
	
	// aligned
	globals_m12->CMP_block_header_aligned = TRUE_m12;
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("CMP_BLOCK_FIXED_HEADER_m12 structure is aligned\n", __FUNCTION__);
	
	return(TRUE_m12);
	
	// not aligned
CMP_BLOCK_HEADER_NOT_ALIGNED_m12:
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_error_message_m12("%s(): CMP_BLOCK_FIXED_HEADER_m12 structure is NOT aligned\n", __FUNCTION__);
	
	return(FALSE_m12);
}


TERN_m12     CMP_check_CPS_allocation_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	TERN_m12	ret_val = TRUE_m12;
	si1		need_compressed_data = FALSE_m12;
	si1		need_decompressed_data = FALSE_m12;
	si1		need_original_data = FALSE_m12;
	si1		need_detrended_buffer = FALSE_m12;
	si1		need_derivative_buffer = FALSE_m12;
	si1		need_scaled_amplitude_buffer = FALSE_m12;
	si1		need_scaled_frequency_buffer = FALSE_m12;
	si1		need_keysample_buffer = FALSE_m12;
	si1		need_VDS_buffers = FALSE_m12;
	CMP_PROCESSING_STRUCT_m12	*cps;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (fps->universal_header->type_code != TIME_SERIES_DATA_FILE_TYPE_CODE_m12) {
		G_error_message_m12("%s(): FPS must be time series data\n", __FUNCTION__);
		return(FALSE_m12);
	}
	
	cps = fps->parameters.cps;
	if (cps == NULL) {
		G_warning_message_m12("%s(): cps is not allocated\n", __FUNCTION__);
		return(FALSE_m12);
	}
	
	if (cps->directives.algorithm == CMP_VDS_COMPRESSION_m12)
		need_VDS_buffers = TRUE_m12;

	// decompression
	if (cps->directives.mode == CMP_DECOMPRESSION_MODE_m12) {
		need_compressed_data = TRUE_m12;
		need_decompressed_data = TRUE_m12;
		need_keysample_buffer = TRUE_m12;
	}
	
	// compression
	else {
		need_compressed_data = TRUE_m12;
		need_original_data = TRUE_m12;
		need_keysample_buffer = TRUE_m12;
		
		if (cps->directives.detrend_data == TRUE_m12)
			need_detrended_buffer = TRUE_m12;
		if (cps->directives.set_derivative_level == TRUE_m12 || cps->directives.find_derivative_level == TRUE_m12)
			need_derivative_buffer = TRUE_m12;
		if (cps->directives.set_amplitude_scale == TRUE_m12 || cps->directives.find_amplitude_scale == TRUE_m12)
			need_scaled_amplitude_buffer = TRUE_m12;
		if (cps->directives.set_frequency_scale == TRUE_m12 || cps->directives.find_frequency_scale == TRUE_m12)
			need_scaled_frequency_buffer = TRUE_m12;
		if (cps->directives.find_amplitude_scale == TRUE_m12 || cps->directives.find_frequency_scale == TRUE_m12)
			need_decompressed_data = TRUE_m12;
	}
	
	// check compressed_data
	if (need_compressed_data == TRUE_m12 && fps->time_series_data == NULL) {
		G_error_message_m12("%s(): \"compressed_data\" is not allocated in the FILE_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m12;
	}
	
	// check keysample_buffer
	if (need_keysample_buffer == TRUE_m12 && cps->parameters.keysample_buffer == NULL) {
		G_error_message_m12("%s(): \"keysample_buffer\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m12;
	}
	
	// check original_data
	if (need_original_data == TRUE_m12 && cps->original_data == NULL) {
		G_error_message_m12("%s(): \"original_data\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m12;
	}
	if (need_original_data == FALSE_m12 && cps->original_data != NULL) {
		G_warning_message_m12("%s(): \"original_data\" is needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		free_m12((void *) cps->original_data, __FUNCTION__);
		cps->original_ptr = cps->original_data = NULL;
		ret_val = FALSE_m12;
	}
	
	// check decompressed_data
	if (need_decompressed_data == TRUE_m12 && cps->decompressed_data == NULL) {
		G_error_message_m12("%s(): \"decompressed_data\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m12;
	}
	if (need_decompressed_data == FALSE_m12 && cps->decompressed_data != NULL) {
		G_warning_message_m12("%s(): \"decompressed_data\" is needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		free_m12((void *) cps->decompressed_data, __FUNCTION__);
		cps->decompressed_ptr = cps->decompressed_data = NULL;
		ret_val = FALSE_m12;
	}
	
	// check detrended_buffer
	if (need_detrended_buffer == TRUE_m12 && cps->parameters.detrended_buffer == NULL) {
		G_error_message_m12("%s(): \"detrended_buffer\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m12;
	}
	if (need_detrended_buffer == FALSE_m12 && cps->parameters.detrended_buffer != NULL) {
		G_warning_message_m12("%s(): \"detrended_buffer\" is needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		free_m12((void *) cps->parameters.detrended_buffer, __FUNCTION__);
		cps->parameters.detrended_buffer = NULL;
		ret_val = FALSE_m12;
	}
	
	// check derivative_buffer
	if (need_derivative_buffer == TRUE_m12 && cps->parameters.derivative_buffer == NULL) {
		G_error_message_m12("%s(): \"derivative_buffer\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m12;
	}
	if (need_derivative_buffer == FALSE_m12 && cps->parameters.derivative_buffer != NULL) {
		G_warning_message_m12("%s(): \"derivative_buffer\" is needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		free_m12((void *) cps->parameters.derivative_buffer, __FUNCTION__);
		cps->parameters.derivative_buffer = NULL;
		ret_val = FALSE_m12;
	}
	
	// check scaled_amplitude_buffer
	if (need_scaled_amplitude_buffer == TRUE_m12 && cps->parameters.scaled_amplitude_buffer == NULL) {
		G_error_message_m12("%s(): \"scaled_amplitude_buffer\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m12;
	}
	if (need_scaled_amplitude_buffer == FALSE_m12 && cps->parameters.scaled_amplitude_buffer != NULL) {
		G_warning_message_m12("%s(): \"scaled_amplitude_buffer\" is needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		free_m12((void *) cps->parameters.scaled_amplitude_buffer, __FUNCTION__);
		cps->parameters.scaled_amplitude_buffer = NULL;
		ret_val = FALSE_m12;
	}
	
	// check scaled_frequency_buffer
	if (need_scaled_frequency_buffer == TRUE_m12 && cps->parameters.scaled_frequency_buffer == NULL) {
		G_error_message_m12("%s(): \"scaled_frequency_buffer\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m12;
	}
	if (need_scaled_frequency_buffer == FALSE_m12 && cps->parameters.scaled_frequency_buffer != NULL) {
		G_warning_message_m12("%s(): \"scaled_frequency_buffer\" is needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		free_m12((void *) cps->parameters.scaled_frequency_buffer, __FUNCTION__);
		cps->parameters.scaled_frequency_buffer = NULL;
		ret_val = FALSE_m12;
	}
	
	// check VDS buffers
	if (need_VDS_buffers == TRUE_m12 && (cps->parameters.VDS_input_buffers == NULL || cps->parameters.VDS_output_buffers == NULL)) {
		G_error_message_m12("%s(): \"VDS_buffers\" are not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m12;
	}
	if (need_VDS_buffers == FALSE_m12 && (cps->parameters.VDS_input_buffers != NULL || cps->parameters.VDS_output_buffers != NULL)) {
		G_warning_message_m12("%s(): \"VDS_buffers\" are needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		CMP_free_buffers_m12(cps->parameters.VDS_input_buffers, TRUE_m12);
		cps->parameters.VDS_input_buffers = NULL;
		CMP_free_buffers_m12(cps->parameters.VDS_output_buffers, TRUE_m12);
		cps->parameters.VDS_output_buffers = NULL;
		ret_val = FALSE_m12;
	}
	return(ret_val);
}


TERN_m12        CMP_G_check_record_header_alignment_m12(ui1 *bytes)
{
	CMP_RECORD_HEADER_m12	*crh;
	TERN_m12		free_flag = FALSE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// see if already checked
	if (globals_m12->CMP_record_header_aligned == UNKNOWN_m12)
		globals_m12->CMP_record_header_aligned = FALSE_m12;
	else
		return(globals_m12->CMP_record_header_aligned);
	
	// check overall size
	if (sizeof(CMP_RECORD_HEADER_m12) != CMP_RECORD_HEADER_BYTES_m12)
		goto CMP_RECORD_HEADER_NOT_ALIGNED_m12;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(CMP_RECORD_HEADER_BYTES_m12);
		free_flag = TRUE_m12;
	}
	crh = (CMP_RECORD_HEADER_m12 *)bytes;
	if (&crh->type_code != (ui4 *) (bytes + CMP_RECORD_HEADER_TYPE_CODE_OFFSET_m12))
		goto CMP_RECORD_HEADER_NOT_ALIGNED_m12;
	if (&crh->version_major != (ui1 *) (bytes + CMP_RECORD_HEADER_VERSION_MAJOR_OFFSET_m12))
		goto CMP_RECORD_HEADER_NOT_ALIGNED_m12;
	if (&crh->version_minor != (ui1 *) (bytes + CMP_RECORD_HEADER_VERSION_MINOR_OFFSET_m12))
		goto CMP_RECORD_HEADER_NOT_ALIGNED_m12;
	if (&crh->total_bytes != (ui2 *) (bytes + CMP_RECORD_HEADER_TOTAL_BYTES_OFFSET_m12))
		goto CMP_RECORD_HEADER_NOT_ALIGNED_m12;
	
	// aligned
	globals_m12->CMP_record_header_aligned = TRUE_m12;
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("CMP_RECORD_HEADER_m12 structure is aligned\n");
	
	return(TRUE_m12);
	
	// not aligned
CMP_RECORD_HEADER_NOT_ALIGNED_m12:
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_error_message_m12("%s(): CMP_RECORD_HEADER_m12 structure is NOT aligned\n", __FUNCTION__);
	
	return(FALSE_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     CMP_compare_sf8_m12(const void *a, const void * b)
{
	if (*((sf8 *) a) > *((sf8 *) b))
		return(1);
	else if (*((sf8 *) a) < *((sf8 *) b))
		return(-1);
	return(0);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     CMP_compare_si4_m12(const void *a, const void * b)
{
	if (*((si4 *) a) > *((si4 *) b))
		return(1);
	else if (*((si4 *) a) < *((si4 *) b))
		return(-1);
	return(0);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     CMP_compare_si8_m12(const void *a, const void * b)
{
	if (*((si8 *) a) > *((si8 *) b))
		return(1);
	else if (*((si8 *) a) < *((si8 *) b))
		return(-1);
	return(0);
}


si4	CMP_count_bins_m12(CMP_PROCESSING_STRUCT_m12 *cps, si4 *deriv_p, ui1 n_derivs)
{
	ui1	*ui1_p, overflow_bytes, ks_flag;
	ui4	n_samps, n_deriv_samps, *count;
	si4	low_d, high_d, n_bins, diff;
	si8	i, j;
	

	// generate count & build keysample array
	if (cps->parameters.minimum_difference_value > 0) {  // positive derivatives
		low_d = 1; high_d = 255;
		ks_flag = CMP_POS_DERIV_KEYSAMPLE_FLAG_m12;  // == 0 (non-overflow range: 1 to 255)
	} else {
		low_d = -127; high_d = 127;
		ks_flag = CMP_UI1_KEYSAMPLE_FLAG_m12;  // == -128 (non-overflow range: -127 to +127)
	}
	
	count = (ui4 *) cps->parameters.count;
	memset((void *) count, 0, CMP_RED_MAX_STATS_BINS_m12 * sizeof(ui4));
	overflow_bytes = CMP_get_overflow_bytes_m12(cps, CMP_COMPRESSION_MODE_m12, CMP_RED_COMPRESSION_m12);
	deriv_p += + n_derivs;
	n_samps = cps->block_header->number_of_samples;
	n_deriv_samps = n_samps - n_derivs;
	
	for (i = n_deriv_samps; i--;) {
		diff = *deriv_p++;
		if (diff < low_d || diff > high_d) {
			ui1_p = (ui1 *) &diff;
			++count[ks_flag];
			j = overflow_bytes; do {
				++count[*ui1_p++];
			} while (--j);
		} else {
			++count[(ui1) diff];
		}
	}

	n_bins = 0;
	for (i = 0; i < 256; ++i)
		if (count[i])
			++n_bins;
	
	return(n_bins);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	CMP_cps_mutex_off_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	PROC_pthread_mutex_unlock_m12(&cps->parameters.mutex);
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	CMP_cps_mutex_on_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	PROC_pthread_mutex_lock_m12(&cps->parameters.mutex);

	return;
}


void    CMP_decode_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	ui4				offset;
	si4				*si4_p;
	sf4				*sf4_p;
	sf8				intercept, gradient, amplitude_scale, frequency_scale;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	CMP_PROCESSING_STRUCT_m12	*cps;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (fps->universal_header->type_code != TIME_SERIES_DATA_FILE_TYPE_CODE_m12) {
		G_error_message_m12("%s(): FPS must be time series data\n", __FUNCTION__);
		return;
	}
	
	cps = fps->parameters.cps;
	block_header = cps->block_header;
	if (cps->parameters.allocated_block_samples < block_header->number_of_samples) {
		if (CMP_reallocate_processing_struct_m12(fps, CMP_DECOMPRESSION_MODE_m12, (si8) block_header->number_of_samples, block_header->number_of_samples) == NULL) {
			G_error_message_m12("%s(): reallocation error\n", __FUNCTION__);
			return;
		}
		block_header = cps->block_header;
	}
	
	// decrypt (probably done in G_read_file_m12(), but if not, do here)
	if (block_header->block_flags & CMP_BF_ENCRYPTION_MASK_m12)
		CMP_decrypt_m12(fps);
	
	// discontinuity
	if (block_header->block_flags & CMP_BF_DISCONTINUITY_MASK_m12)
		cps->parameters.discontinuity = TRUE_m12;
	else
		cps->parameters.discontinuity = FALSE_m12;
	
	// get variable region
	CMP_get_variable_region_m12(cps);
	
	// decompress
	switch (block_header->block_flags & CMP_BF_ALGORITHMS_MASK_m12) {
		case CMP_BF_RED1_ENCODING_MASK_m12:
			cps->directives.algorithm = CMP_RED1_COMPRESSION_m12;
			CMP_RED1_decode_m12(cps);
			break;
		case CMP_BF_PRED1_ENCODING_MASK_m12:
			cps->directives.algorithm = CMP_PRED1_COMPRESSION_m12;
			CMP_PRED1_decode_m12(cps);
			break;
		case CMP_BF_MBE_ENCODING_MASK_m12:
			cps->directives.algorithm = CMP_MBE_COMPRESSION_m12;
			CMP_MBE_decode_m12(cps);
			break;
		case CMP_BF_VDS_ENCODING_MASK_m12:
			cps->directives.algorithm = CMP_VDS_COMPRESSION_m12;
			CMP_VDS_decode_m12(cps);
			break;
		case CMP_BF_RED2_ENCODING_MASK_m12:
			cps->directives.algorithm = CMP_RED2_COMPRESSION_m12;
			CMP_RED2_decode_m12(cps);
			break;
		case CMP_BF_PRED2_ENCODING_MASK_m12:
			cps->directives.algorithm = CMP_PRED2_COMPRESSION_m12;
			CMP_PRED2_decode_m12(cps);
			break;
		default:
			G_error_message_m12("%s(): unrecognized compression algorithm (%u)\n", __FUNCTION__, block_header->block_flags & CMP_BF_ALGORITHMS_MASK_m12);
			return;
	}

	if (cps->directives.algorithm != CMP_VDS_COMPRESSION_m12) {
		// unscale frequency-scaled decompressed_data if scaled (in place)
		// no blockwise frequency scaling in VDS encoded data
		if (block_header->parameter_flags & CMP_PF_FREQUENCY_SCALE_MASK_m12) {
			sf4_p = (sf4 *) cps->block_parameters;
			offset = cps->parameters.block_parameter_map[CMP_PF_FREQUENCY_SCALE_IDX_m12];
			frequency_scale = (sf8) *(sf4_p + offset);
			CMP_unscale_frequency_si4_m12(cps->decompressed_ptr, cps->decompressed_ptr, (si8) block_header->number_of_samples, frequency_scale);
		}
		
		// unscale amplitude-scaled decompressed_data if scaled (in place)
		// VDS_decode_m12() does amplitude scaling itself
		if (block_header->parameter_flags & CMP_PF_AMPLITUDE_SCALE_MASK_m12) {
			sf4_p = (sf4 *) cps->block_parameters;
			offset = cps->parameters.block_parameter_map[CMP_PF_AMPLITUDE_SCALE_IDX_m12];
			amplitude_scale = (sf8) *(sf4_p + offset);
			CMP_unscale_amplitude_si4_m12(cps->decompressed_ptr, cps->decompressed_ptr, (si8) block_header->number_of_samples, amplitude_scale);
		}
		
		// add trend to decompressed_data if detrended (in place)
		// VDS_decode_m12() does retrending itself
		if (CMP_IS_DETRENDED_m12(block_header)) {
			sf4_p = (sf4 *) cps->block_parameters;
			offset = cps->parameters.block_parameter_map[CMP_PF_GRADIENT_IDX_m12];
			gradient = (sf8) *(sf4_p + offset);
			si4_p = (si4 *) cps->block_parameters;
			offset = cps->parameters.block_parameter_map[CMP_PF_INTERCEPT_IDX_m12];
			intercept = (sf8) *(si4_p + offset);
			CMP_retrend_si4_m12(cps->decompressed_ptr, cps->decompressed_ptr, block_header->number_of_samples, gradient, intercept);
		}
	}
	
	// restrict returned samples
	cps->parameters.block_end_index = 0xFFFFFFFF;  // reset
	if (cps->parameters.block_start_index) {
		if (cps->directives.algorithm != CMP_VDS_COMPRESSION_m12 || cps->directives.cps_caching == TRUE_m12)
			cps->decompressed_data = cps->parameters.cache + cps->parameters.block_start_index;
		cps->parameters.block_start_index = 0;  // reset
	}

	return;
}


TERN_m12	CMP_decrypt_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	ui1				*key;
	si8				encryption_bytes, encryptable_bytes;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	PASSWORD_DATA_m12		*pwd;
	CMP_PROCESSING_STRUCT_m12	*cps;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (fps->universal_header->type_code != TIME_SERIES_DATA_FILE_TYPE_CODE_m12) {
		G_error_message_m12("%s(): FPS must be time series data\n", __FUNCTION__);
		return(FALSE_m12);
	}
	cps = fps->parameters.cps;
	block_header = cps->block_header;

	// check if block is encrypted (already checked in CMP_decode() - just check here in case function being used independently)
	if (!(block_header->block_flags & CMP_BF_ENCRYPTION_MASK_m12))
		return(TRUE_m12);

	// get decryption key
	pwd = fps->parameters.password_data;
	if (block_header->block_flags & CMP_BF_LEVEL_1_ENCRYPTION_MASK_m12) {
		if (block_header->block_flags & CMP_BF_LEVEL_2_ENCRYPTION_MASK_m12) {
			G_error_message_m12("%s(): Cannot decrypt data: flags indicate both level 1 & level 2 encryption\n", __FUNCTION__);
			return(FALSE_m12);
		}
		if (pwd->access_level >= LEVEL_1_ENCRYPTION_m12) {
			key = pwd->level_1_encryption_key;
		} else {
			G_error_message_m12("%s(): Cannot decrypt data: insufficient access\n", __FUNCTION__);
			return(FALSE_m12);
		}
	} else {  // level 2 bit is set
		if (pwd->access_level == LEVEL_2_ENCRYPTION_m12) {
			key = pwd->level_2_encryption_key;
		} else {
			G_error_message_m12("%s(): Cannot decrypt data: insufficient access\n", __FUNCTION__);
			return(FALSE_m12);
		}
	}
	
	// calculate encryption bytes
	encryptable_bytes = block_header->total_block_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m12;
	if (block_header->block_flags | CMP_BF_MBE_ENCODING_MASK_m12) {
		encryption_bytes = encryptable_bytes;
	} else {
		encryption_bytes = (block_header->total_header_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m12) + ENCRYPTION_BLOCK_BYTES_m12;
		if (encryption_bytes > encryptable_bytes)
			encryption_bytes = encryptable_bytes;
	}
	
	// decrypt
	AES_decrypt_m12((ui1 *) block_header + CMP_BLOCK_ENCRYPTION_START_OFFSET_m12, encryption_bytes, NULL, key);
	
	// set block flags to decrypted
	block_header->block_flags &= ~CMP_BF_ENCRYPTION_MASK_m12;
	
	return(TRUE_m12);
}


void    CMP_detrend_m12(si4 *input_buffer, si4 *output_buffer, si8 len, CMP_PROCESSING_STRUCT_m12 *cps)
{
	si4	*si4_p1, *si4_p2;
	sf4	sf4_m;
	si4	si4_b;
	sf8	m, b, mx_plus_b;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// detrend from input_buffer to output_buffer
	// slope and intercept values entered into block_header
	// if input_buffer == output_buffer detrending will be done in place
	// if cps != NULL store coefficients in block parameters
	
	CMP_lad_reg_si4_m12(input_buffer, len, &m, &b);
	
	// store m & b in block parameter region
	// NOTE: block parameter region must be setup first
	if (cps != NULL) {
		// demote precision
		sf4_m = (sf4) m;
		si4_b = CMP_round_si4_m12(b);  // this is an integer because sf4 can only precisely encode offsets up to 24 bits, but MED guarantees 32-bit lossless detrending
		// store the values
		*((sf4 *) cps->block_parameters + cps->parameters.block_parameter_map[CMP_PF_GRADIENT_IDX_m12]) = sf4_m;
		*((si4 *) cps->block_parameters + cps->parameters.block_parameter_map[CMP_PF_INTERCEPT_IDX_m12]) = si4_b;
		// promote back to sf8, maintaining demoted precision
		m = (sf8) sf4_m;
		b = (sf8) si4_b;
	}

	// subtract trend from input_buffer to output_buffer
	mx_plus_b = b;
	si4_p1 = input_buffer;
	si4_p2 = output_buffer;
	while (len--)
		*si4_p2++ = CMP_round_si4_m12((sf8) *si4_p1++ - (mx_plus_b += m));

	return;
}

					   
void    CMP_detrend_sf8_m12(sf8 *input_buffer, sf8 *output_buffer, si8 len)
{
	sf8	*sf8_p1, *sf8_p2, m, b, mx_plus_b;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// detrend from input_buffer to output_buffer
	// slope and intercept values entered into block_header
	// if input_buffer == output_buffer detrending will be done in place
	// if cps != NULL store coefficients in block parameters
	
	CMP_lad_reg_sf8_m12(input_buffer, len, &m, &b);
	
	// subtract trend from input_buffer to output_buffer
	mx_plus_b = b;
	sf8_p1 = input_buffer;
	sf8_p2 = output_buffer;
	while (len--)
		*sf8_p2++ = *sf8_p1++ - (mx_plus_b += m);

	return;
}


ui1	CMP_differentiate_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	ui1				deriv_level, set_deriv_level;
	ui4				n_samps, n_diffs;
	si4				*input_buffer, *deriv_buffer, samp_min, samp_max, diff_min, diff_max;
	si4				diff, *si4_p1, *si4_p2, *si4_p3, n_bins, last_bins;
	si8				i, si8_diff, pos_inf_si4, neg_inf_si4;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Returns 0-255
	
	// from input buffer to derivative buffer
	block_header = cps->block_header;
	n_samps = block_header->number_of_samples;
	if (n_samps <= 1) {
		if (n_samps == 1)
			cps->parameters.minimum_sample_value = cps->parameters.maximum_sample_value = cps->input_buffer[0];
		else
			cps->parameters.minimum_sample_value = cps->parameters.maximum_sample_value = 0;
		cps->parameters.derivative_level = cps->parameters.minimum_difference_value = cps->parameters.maximum_difference_value = 0;
		return(0);
	}

	set_deriv_level = 1;  // default
	if (cps->directives.find_derivative_level == TRUE_m12)
		set_deriv_level = 0xFF;
	else if (cps->directives.set_derivative_level == TRUE_m12)
		set_deriv_level = cps->parameters.goal_derivative_level;
	if (set_deriv_level != 1) {
		if (set_deriv_level == 0) {
			G_warning_message_m12("%s(): requested derivative level is zero\n", __FUNCTION__);
			CMP_find_extrema_m12(NULL, 0, NULL, NULL, cps);
			memcpy((void *) cps->parameters.derivative_buffer, (void *) cps->input_buffer, (size_t) (n_samps << 2));
			cps->parameters.derivative_level = cps->parameters.minimum_difference_value = cps->parameters.maximum_difference_value = 0;
			return(0);
		}
		cps->parameters.scrap_buffers = CMP_allocate_buffers_m12(cps->parameters.scrap_buffers, 1, n_samps, sizeof(si4), FALSE_m12, FALSE_m12);
	}
	
	// first derivative level (gets min & max sample values)
	input_buffer = cps->input_buffer;
	deriv_buffer = cps->parameters.derivative_buffer;
	si4_p1 = input_buffer + (n_samps - 1);
	si4_p2 = si4_p1 - 1;
	si4_p3 = deriv_buffer + (n_samps - 1);
	samp_min = samp_max = input_buffer[0];
	diff_min = diff_max = input_buffer[1] - input_buffer[0];
	deriv_level = (ui1) 1;
	n_diffs = n_samps - deriv_level;
	pos_inf_si4 = (si8) POS_INF_SI4_m12;
	neg_inf_si4 = (si8) NEG_INF_SI4_m12;
	for (i = n_diffs; i--;) {
		if (*si4_p1 < samp_min)
			samp_min = *si4_p1;
		else if (*si4_p1 > samp_max)
			samp_max = *si4_p1;
		si8_diff = (si8) *si4_p1-- - (si8) *si4_p2--;
		if (si8_diff > pos_inf_si4 || si8_diff < neg_inf_si4) {
			G_warning_message_m12("\n%s(): difference exceeds 4-byte integer range => returning derivative level zero\n", __FUNCTION__);
			CMP_find_extrema_m12(NULL, 0, NULL, NULL, cps);
			memcpy((void *) cps->parameters.derivative_buffer, (void *) cps->input_buffer, (size_t) (n_samps << 2));
			cps->parameters.derivative_level = cps->parameters.minimum_difference_value = cps->parameters.maximum_difference_value = 0;
			return(0);
		}
		diff = (si4) si8_diff;
		if (diff < diff_min)
			diff_min = diff;
		else if (diff > diff_max)
			diff_max = diff;
		*si4_p3-- = diff;
	}
	*si4_p3 = *si4_p1;  // first derivative initial value
	cps->parameters.minimum_sample_value = samp_min;
	cps->parameters.maximum_sample_value = samp_max;
	cps->parameters.minimum_difference_value = diff_min;
	cps->parameters.maximum_difference_value = diff_max;
	cps->parameters.derivative_level = 1;

	if (set_deriv_level == 1)
		return(1);
	
	// higher derivatives
	if (set_deriv_level == 0xFF)  // find_derivative_level option
		last_bins = CMP_count_bins_m12(cps, cps->parameters.derivative_buffer, deriv_level);
	
	while (--n_diffs) {
		input_buffer = cps->parameters.derivative_buffer;
		deriv_buffer = (si4 *) cps->parameters.scrap_buffers->buffer[0];  // need a scrap buffer for "find" option
		si4_p1 = input_buffer + (n_samps - 1);
		si4_p2 = si4_p1 - 1;
		si4_p3 = deriv_buffer + (n_samps - 1);
		diff_min = diff_max = input_buffer[deriv_level + 1] - input_buffer[deriv_level];
		for (i = n_diffs; i--;) {
			si8_diff = (si8) *si4_p1-- - (si8) *si4_p2--;
			if (si8_diff > pos_inf_si4 || si8_diff < neg_inf_si4) {
				cps->parameters.derivative_level = deriv_level;
				return(deriv_level);  // return previous derivative level level
			}
			diff = (si4) si8_diff;
			if (diff < diff_min)
				diff_min = diff;
			else if (diff > diff_max)
				diff_max = diff;
			*si4_p3-- = diff;
		}
		*si4_p3 = *si4_p1;  // derivative initial value
		++deriv_level;
		if (set_deriv_level == 0xFF) {  // find_derivative_level option
			n_bins = CMP_count_bins_m12(cps, deriv_buffer, deriv_level);
			if (n_bins < last_bins) {
				cps->parameters.minimum_difference_value = diff_min;
				cps->parameters.maximum_difference_value = diff_max;
				cps->parameters.derivative_level = deriv_level;
				last_bins = n_bins;
				memcpy((void *) input_buffer, (void *) deriv_buffer, (size_t) (n_samps << 2));  // copy into CPS derivative buffer (called "input_buffer" here)
			} else {
				--deriv_level;
				break;
			}
		} else {
			cps->parameters.minimum_difference_value = diff_min;
			cps->parameters.maximum_difference_value = diff_max;
			cps->parameters.derivative_level = deriv_level;
			memcpy((void *) input_buffer, (void *) deriv_buffer, (size_t) (n_samps << 2));  // copy into CPS derivative buffer (called "input_buffer" here)
			if (deriv_level == set_deriv_level)
				break;
		}
	}
	
	return(deriv_level);
}


void    CMP_encode_m12(FILE_PROCESSING_STRUCT_m12 *fps, si8 start_time, si4 acquisition_channel_number, ui4 number_of_samples)
{
	TERN_m12                        data_is_compressed, allow_lossy_compression;
	ui1				normality;
	void                            (*compression_f)(CMP_PROCESSING_STRUCT_m12 * cps);
	CMP_PROCESSING_STRUCT_m12	*cps;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (fps->universal_header->type_code != TIME_SERIES_DATA_FILE_TYPE_CODE_m12) {
		G_error_message_m12("%s(): FPS must be time series data\n", __FUNCTION__);
		return;
	}
	cps = fps->parameters.cps;
	CMP_cps_mutex_on_m12(cps);
	block_header = cps->block_header;
	if (cps->parameters.allocated_block_samples < block_header->number_of_samples) {
		if (CMP_reallocate_processing_struct_m12(fps, CMP_COMPRESSION_MODE_m12, (si8) number_of_samples, number_of_samples) == NULL) {
			G_error_message_m12("%s(): reallocation error\n", __FUNCTION__);
			CMP_cps_mutex_off_m12(cps);
			return;
		}
		block_header = cps->block_header;
	}

	// calling function must set cps->input_buffer to use anything other than cps->original_ptr
	if (cps->input_buffer == NULL) {
		if (cps->original_ptr == NULL)
			G_error_message_m12("%s(): input buffer is NULL\n", __FUNCTION__);
		else
			cps->input_buffer = cps->original_ptr;
	}
	
	// fill in passed header fields
	block_header->block_start_UID = CMP_BLOCK_START_UID_m12;
	block_header->start_time = start_time;
	block_header->acquisition_channel_number = acquisition_channel_number;
	block_header->number_of_samples = number_of_samples;
	
	// reset block flags
	block_header->block_flags = 0;
	
	// set up variable region
	CMP_set_variable_region_m12(cps);
	
	// discontinuity
	if (cps->parameters.discontinuity == TRUE_m12) {
		block_header->block_flags |= CMP_BF_DISCONTINUITY_MASK_m12;
		if (cps->directives.reset_discontinuity == TRUE_m12)
			cps->parameters.discontinuity = FALSE_m12;
	}
		
	// select compression
	// (compression algorithms are responsible for filling in: algorithm block flag, total_header_bytes, total_block_bytes, model_region_bytes, & model details)
	switch (cps->directives.algorithm) {
		case CMP_RED1_COMPRESSION_m12:
			compression_f = CMP_RED1_encode_m12;
			break;
		case CMP_PRED1_COMPRESSION_m12:
			compression_f = CMP_PRED1_encode_m12;
			break;
		case CMP_MBE_COMPRESSION_m12:
			compression_f = CMP_MBE_encode_m12;
			break;
		case CMP_VDS_COMPRESSION_m12:
			compression_f = CMP_VDS_encode_m12;
			break;
		case CMP_RED2_COMPRESSION_m12:
			compression_f = CMP_RED2_encode_m12;
			break;
		case CMP_PRED2_COMPRESSION_m12:
			compression_f = CMP_PRED2_encode_m12;
			break;
		default:
			G_error_message_m12("%s(): unrecognized compression algorithm (%u)\n", __FUNCTION__, cps->directives.algorithm);
			CMP_cps_mutex_off_m12(cps);
			return;
	}
	
	// detrend
	if (cps->directives.detrend_data == TRUE_m12) {
		CMP_detrend_m12(cps->input_buffer, cps->parameters.detrended_buffer, block_header->number_of_samples, cps);
		cps->input_buffer = cps->parameters.detrended_buffer;
	}
	
	// lossy compression
	data_is_compressed = FALSE_m12;
	if (compression_f != CMP_VDS_encode_m12) {
		allow_lossy_compression = TRUE_m12;
		if (cps->directives.require_normality == TRUE_m12) {
			normality = CMP_normality_score_m12(cps->input_buffer, block_header->number_of_samples);
			if (normality < cps->parameters.minimum_normality) {
				allow_lossy_compression = FALSE_m12;
				block_header->parameter_flags &= ~(CMP_PF_AMPLITUDE_SCALE_MASK_m12 | CMP_PF_FREQUENCY_SCALE_MASK_m12);
			}
		}
		if (allow_lossy_compression == TRUE_m12) {
			if (cps->directives.set_amplitude_scale == TRUE_m12 || cps->directives.find_amplitude_scale == TRUE_m12) {
				if (cps->directives.find_amplitude_scale == TRUE_m12)
					data_is_compressed = CMP_find_amplitude_scale_m12(cps, compression_f);
				else if (cps->directives.set_amplitude_scale == TRUE_m12)
					CMP_scale_amplitude_si4_m12(cps->input_buffer, cps->parameters.scaled_amplitude_buffer, block_header->number_of_samples, (sf8) cps->parameters.amplitude_scale, cps);
				cps->input_buffer = cps->parameters.scaled_amplitude_buffer;
			}
			if (cps->directives.set_frequency_scale == TRUE_m12 || cps->directives.find_frequency_scale == TRUE_m12) {
				if (cps->directives.find_frequency_scale == TRUE_m12)
					data_is_compressed = CMP_find_frequency_scale_m12(cps, compression_f);
				else if (cps->directives.set_frequency_scale == TRUE_m12)
					CMP_scale_frequency_si4_m12(cps->input_buffer, cps->parameters.scaled_frequency_buffer, block_header->number_of_samples, (sf8)cps->parameters.frequency_scale, cps);
				cps->input_buffer = cps->parameters.scaled_frequency_buffer;
			}
		}
	}
	
	// noise scores
	if (cps->directives.include_noise_scores == TRUE_m12) {
		// code not written yet
	}
	
	// compress
	if (data_is_compressed == FALSE_m12)
		(*compression_f)(cps);

	// encryption done in write_file_m12()
	// if done here, leave_decrypted FPS directive won't work
	// call would be: CMP_encrypt_m12(cps);

	// reset input_buffer (because this can be changed by internal library functions)
	cps->input_buffer = NULL;
	
	CMP_cps_mutex_off_m12(cps);
	
	return;
}


TERN_m12     CMP_encrypt_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	ui1				*key;
	si1				encryption_level;
	ui4				encryption_mask, encryption_bits;
	si8				encryption_bytes, encryptable_bytes;
	PASSWORD_DATA_m12		*pwd;
	CMP_PROCESSING_STRUCT_m12	*cps;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (fps->universal_header->type_code != TIME_SERIES_DATA_FILE_TYPE_CODE_m12) {
		G_error_message_m12("%s(): FPS must be time series data\n", __FUNCTION__);
		return(FALSE_m12);
	}
	pwd = fps->parameters.password_data;
	if (pwd == NULL)
		pwd = &globals_m12->password_data;
	cps = fps->parameters.cps;

	encryption_level = cps->directives.encryption_level;
	block_header = cps->block_header;
	encryption_bits = block_header->block_flags & CMP_BF_ENCRYPTION_MASK_m12;
	
	// check if block is already encrypted
	switch (encryption_bits) {
		case 0: // not encrypted
			break;
		case CMP_BF_ENCRYPTION_MASK_m12:
			G_warning_message_m12("%s(): Level 1 & 2 bits set in block => cannot encrypt\n", __FUNCTION__);
			return(FALSE_m12);
		case CMP_BF_LEVEL_1_ENCRYPTION_MASK_m12:
			if (encryption_level == LEVEL_1_ENCRYPTION_m12)
				return(TRUE_m12); // already encrypted
			CMP_decrypt_m12(fps); // encrypted, but at wrong level
			break;
		case CMP_BF_LEVEL_2_ENCRYPTION_MASK_m12:
			if (encryption_level == LEVEL_2_ENCRYPTION_m12)
				return(TRUE_m12); // already encrypted
			CMP_decrypt_m12(fps); // encrypted, but at wrong level
			break;
	}
	if (encryption_level == NO_ENCRYPTION_m12)
		return(TRUE_m12);
	
	// check access
	if (pwd->access_level >= encryption_level) {
		if (encryption_level == LEVEL_1_ENCRYPTION_m12) {
			key = pwd->level_1_encryption_key;
			encryption_mask = CMP_BF_LEVEL_1_ENCRYPTION_MASK_m12;
		} else {
			key = pwd->level_2_encryption_key;
			encryption_mask = CMP_BF_LEVEL_2_ENCRYPTION_MASK_m12;
		}
	} else {
		G_error_message_m12("%s(): Cannot encrypt data => insufficient access\n", __FUNCTION__);
		return(FALSE_m12);
	}
	
	// calculate encryption bytes
	encryptable_bytes = block_header->total_block_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m12;
	if (block_header->block_flags | CMP_BF_MBE_ENCODING_MASK_m12) {
		encryption_bytes = encryptable_bytes;
	} else {
		encryption_bytes = (block_header->total_header_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m12) + ENCRYPTION_BLOCK_BYTES_m12;
		if (encryption_bytes > encryptable_bytes)
			encryption_bytes = encryptable_bytes;
	}
	
	// encrypt
	AES_encrypt_m12((ui1 *) block_header + CMP_BLOCK_ENCRYPTION_START_OFFSET_m12, encryption_bytes, NULL, key);

	// set block flags to encrypted
	block_header->block_flags |= encryption_mask;
	
	return(TRUE_m12);
}


TERN_m12    CMP_find_amplitude_scale_m12(CMP_PROCESSING_STRUCT_m12 *cps, void (*compression_f)(CMP_PROCESSING_STRUCT_m12 *cps))
{
	TERN_m12                     	data_is_compressed;
	si8                     	i;
	si4				*input_buffer;
	sf8                     	original_size, goal_compression_ratio;
	sf8                     	low_sf, high_sf, mrr, mrr2, mrr5, sf_per_mrr;
	sf8                     	goal_low_bound, goal_high_bound, goal_mrr, goal_tol;
	sf4                     	new_scale_factor;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	input_buffer = cps->input_buffer;
	block_header = cps->block_header;
	data_is_compressed = FALSE_m12;

	if (cps->directives.use_compression_ratio == TRUE_m12) {
		goal_compression_ratio = cps->parameters.goal_ratio;
		goal_low_bound = goal_compression_ratio - cps->parameters.goal_tolerance;
		goal_high_bound = goal_compression_ratio + cps->parameters.goal_tolerance;
		cps->parameters.amplitude_scale = (sf4) 1.0;
		(*compression_f)(cps);
		data_is_compressed = TRUE_m12;
		original_size = (sf8) block_header->number_of_samples * (sf8) sizeof(si4);
		cps->parameters.actual_ratio = (sf8) block_header->total_block_bytes / original_size;
		if (cps->parameters.actual_ratio > goal_high_bound) {
			// loop until acceptable scale factor found
			for (i = cps->parameters.maximum_goal_attempts; i--;) {
				new_scale_factor = cps->parameters.amplitude_scale * (sf4) (cps->parameters.actual_ratio / goal_compression_ratio);
				if ((ABS_m12(new_scale_factor - cps->parameters.amplitude_scale) <= (sf4) 0.000001) || (new_scale_factor <= (sf4) 1.0))
					break;
				cps->parameters.amplitude_scale = new_scale_factor;
				(*compression_f)(cps);  // compress
				cps->parameters.actual_ratio = (sf8) block_header->total_block_bytes / original_size;
				if ((cps->parameters.actual_ratio <= goal_high_bound) && (cps->parameters.actual_ratio >= goal_low_bound))
					break;
			}
		}
	}
	else if (cps->directives.use_mean_residual_ratio == TRUE_m12) {
		// get residual ratio at sf 2 & 5 (roughly linear relationship: reasonable sample points)
		cps->parameters.amplitude_scale = (sf4) 2.0;
		CMP_generate_lossy_data_m12(cps, input_buffer, cps->decompressed_ptr, CMP_AMPLITUDE_SCALE_MODE_m12);
		mrr2 = CMP_calculate_mean_residual_ratio_m12(input_buffer, cps->decompressed_ptr, block_header->number_of_samples);
		if (mrr2 == (sf8) 0.0) {  // all zeros in block
			cps->parameters.amplitude_scale = (sf4) 1.0;
			cps->parameters.actual_ratio = (sf8) 0.0;
			(*compression_f)(cps);
			goto CMP_MRR_DONE_m12;
		}
		cps->parameters.amplitude_scale = (sf4) 5.0;
		CMP_generate_lossy_data_m12(cps, input_buffer, cps->decompressed_ptr, CMP_AMPLITUDE_SCALE_MODE_m12);
		mrr5 = CMP_calculate_mean_residual_ratio_m12(input_buffer, cps->decompressed_ptr, block_header->number_of_samples);
		sf_per_mrr = (sf8) 3.0 / (mrr5 - mrr2);
		// estimate starting points
		goal_mrr = cps->parameters.goal_ratio;
		goal_tol = cps->parameters.goal_tolerance;
		goal_low_bound = goal_mrr - goal_tol;
		goal_high_bound = goal_mrr + goal_tol;
		cps->parameters.amplitude_scale = (sf4)(((goal_mrr - mrr2) * sf_per_mrr) + (sf8)2.0);
		high_sf = ((goal_high_bound - mrr2) * sf_per_mrr) + (sf8) 2.0;
		high_sf *= (sf8) 2.0;  // empirically reasonable
		low_sf = (sf8) 1.0;
		for (i = cps->parameters.maximum_goal_attempts; i--;) {
			CMP_generate_lossy_data_m12(cps, input_buffer, cps->decompressed_ptr, CMP_AMPLITUDE_SCALE_MODE_m12);
			mrr = CMP_calculate_mean_residual_ratio_m12(input_buffer, cps->decompressed_ptr, block_header->number_of_samples);
			if (mrr < goal_low_bound)
				low_sf = (sf8) cps->parameters.amplitude_scale;
			else if (mrr > goal_high_bound)
				high_sf = (sf8) cps->parameters.amplitude_scale;
			else
				break;
			new_scale_factor = (sf4) ((low_sf + high_sf) / (sf8) 2.0);
			if (new_scale_factor <= (sf4) 1.0)
				break;
			cps->parameters.amplitude_scale = new_scale_factor;
			if ((high_sf - low_sf) < (sf8) 0.005)
				break;
		}
		cps->parameters.actual_ratio = mrr;
	} else {
		G_error_message_m12("%s(): either use_compression_ratio or use_mean_residual_ratio directive must be set (mode == %d)\n", __FUNCTION__, cps->directives.mode);
		return(data_is_compressed);
	} CMP_MRR_DONE_m12:
	
	return(data_is_compressed);
}


si8    *CMP_find_crits_m12(sf8 *data, si8 data_len, si8 *n_crits, si8 *crit_xs)
{
	const si1	PEAK = 1, TROUGH = -1;
	si1     	mode;
	si8     	nc, i, j, n, crit;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// find peaks & troughs (also see CMP_find_crits_2_m12)
	// if crit_xs == NULL, array is allocated & returned;
	
	if (data == NULL) {
		G_error_message_m12("%s(): NULL pointer passed", __FUNCTION__);
		return(NULL);
	}

	if (crit_xs == NULL)
		crit_xs = (si8 *) malloc_m12((size_t) (data_len << 3), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	// skip leading nans
	for (n = 0; isnan(data[n]) && n < data_len; ++n);
	     
	for (j = n; j < data_len; ++j)
		if (data[j] != data[n])
			break;
	
	crit_xs[0] = 0;
	if (j == data_len) {
		*n_crits = 2;
		crit_xs[1] = data_len - 1;
		return(crit_xs);
	}
	nc = 1;
	
	if (data[0] < data[j])
		mode = PEAK;
	else
		mode = TROUGH;
	
	i = j - 1;
	while (j < data_len) {
		if (mode == PEAK) {
			while (j < data_len) {
				if (data[j] > data[i])
					i = j++;
				else if (data[j] == data[i])
					++j;
				else if (data[j] < data[i])
					break;
				else  // nan
					++j;
			}
			mode = TROUGH;
		} else {  // mode == TROUGH
			while (j < data_len) {
				if (data[j] < data[i])
					i = j++;
				else if (data[j] == data[i])
					++j;
				else if (data[j] > data[i])
					break;
				else  // nan
					++j;
			}
			mode = PEAK;
		}
		if (i == (j - 1)) {
			crit = i;
		} else {
			crit = (i + j + 1) / 2;
			i = j - 1;
		}
		crit_xs[nc++] = crit;
	}
	
	if (crit_xs[nc - 1] != (data_len - 1))
		crit_xs[nc++] = (data_len - 1);
	
	*n_crits = nc;
	
	return(crit_xs);
}


void    CMP_find_crits_2_m12(sf8 *data, si8 data_len, si8 *n_peaks, si8 *peak_xs, si8 *n_troughs, si8 *trough_xs)
{
	const si1	PEAK = 1, TROUGH = 2;
	si1     	mode;
	si8     	np, nt, i, j, n, crit;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// CMP_find_crits_2(): find peaks & troughs separately (see CMP_find_crits_m12)
	
	if (data == NULL || peak_xs == NULL || trough_xs == NULL) {
		G_error_message_m12("%s(): NULL pointer passed", __FUNCTION__);
		return;
	}
	
	for (n = 0; isnan(data[n]) && n < data_len; ++n);
	     
	for (j = n + 1; j < data_len; ++j)
		if (data[j] != data[n])
			break;
	
	peak_xs[0] = trough_xs[0] = 0;
	if (j == data_len) {
		peak_xs[1] = trough_xs[1] = data_len - 1;
		*n_peaks = *n_troughs = 2;
		return;
	}
	np = nt = 1;
	
	if (data[0] < data[j])
		mode = PEAK;
	else
		mode = TROUGH;
	
	i = j - 1;
	while (j < data_len) {
		if (mode == PEAK) {
			while (j < data_len) {
				if (data[j] > data[i])
					i = j++;
				else if (data[j] == data[i])
					++j;
				else if (data[j] < data[i])
					break;
				else  // nan
					++j;
			}
			mode = TROUGH;
		} else {  // mode == TROUGH
			while (j < data_len) {
				if (data[j] < data[i])
					i = j++;
				else if (data[j] == data[i])
					++j;
				else if (data[j] > data[i])
					break;
				else  // nan
					++j;
			}
			mode = PEAK;
		}
		if (i == (j - 1)) {
			crit = i;
		} else {
			crit = (i + j + 1) / 2;
			i = j - 1;
		}
		if (mode == TROUGH)
			peak_xs[np++] = crit;
		else
			trough_xs[nt++] = crit;
	}
	
	if (peak_xs[np - 1] != (data_len - 1))
		peak_xs[np++] = (data_len - 1);
	if (trough_xs[nt - 1] != (data_len - 1))
		trough_xs[nt++] = (data_len - 1);
	
	*n_peaks = np;
	*n_troughs = nt;
	
	return;
}


void    CMP_find_extrema_m12(si4 *input_buffer, si8 len, si4 *minimum, si4 *maximum, CMP_PROCESSING_STRUCT_m12 *cps)
{
	si4     min, max;
	si8     i;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (cps != NULL) {
		len = cps->block_header->number_of_samples;
		input_buffer = cps->input_buffer;
	}
	
	min = max = *input_buffer;
	for (i = len; --i;) {
		if (*++input_buffer > max)
			max = *input_buffer;
		else if (*input_buffer < min)
			min = *input_buffer;
	}
	
	if (cps != NULL) {
		cps->parameters.minimum_sample_value = min;
		cps->parameters.maximum_sample_value = max;
	}
	if (minimum != NULL)
		*minimum = min;
	if (maximum != NULL)
		*maximum = max;
	
	// get extreme difference values
	if (cps != NULL && cps->parameters.derivative_buffer != NULL && cps->parameters.derivative_level > 0) {
		input_buffer = cps->parameters.derivative_buffer + (si8) cps->parameters.derivative_level;
		min = max = *input_buffer;
		len -= (si8) cps->parameters.derivative_level;
		for (i = len; --i;) {
			if (*++input_buffer > max)
				max = *input_buffer;
			else if (*input_buffer < min)
				min = *input_buffer;
		}
		cps->parameters.minimum_difference_value = min;
		cps->parameters.maximum_difference_value = max;
	}

	
	return;
}


TERN_m12	CMP_find_frequency_scale_m12(CMP_PROCESSING_STRUCT_m12 *cps, void (*compression_f)(CMP_PROCESSING_STRUCT_m12 *cps))
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// code not written yet
	
	return(TRUE_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void    CMP_free_buffers_m12(CMP_BUFFERS_m12 *buffers, TERN_m12 free_structure)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (buffers == NULL)
		return;
	
	if (buffers->locked == TRUE_m12) {
#if defined MACOS_m12 || defined LINUX_m12
		munlock((void *) buffers->buffer, (size_t) buffers->total_allocated_bytes);
#endif
#ifdef WINDOWS_m12
		VirtualUnlock((void *) buffers->buffer, (size_t) buffers->total_allocated_bytes);
#endif
	}
	free_m12((void *) buffers->buffer, __FUNCTION__);
	
	if (free_structure == TRUE_m12) {
		free_m12((void *) buffers, __FUNCTION__);
	} else {
		buffers->n_buffers = buffers->n_elements = buffers->element_size = 0;
		buffers->locked = FALSE_m12;
		buffers->buffer = NULL;
	}
	
	return;
}


TERN_m12    CMP_free_cache_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	TERN_m12	freed = FALSE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (cps->parameters.cache != NULL) {
		free_m12((void * ) cps->parameters.cache, __FUNCTION__);
		freed = TRUE_m12;
		cps->parameters.allocated_decompressed_samples = 0;
		cps->decompressed_data = cps->decompressed_ptr = cps->parameters.cache = NULL;
	}

	if (cps->parameters.cached_blocks) {
		free_m12((void *) cps->parameters.cached_blocks, __FUNCTION__);
		cps->parameters.cached_blocks = NULL;
		cps->parameters.cached_block_list_len = cps->parameters.cached_block_cnt = 0;
		freed = TRUE_m12;
	}
	
	return(freed);
}


void    CMP_free_processing_struct_m12(CMP_PROCESSING_STRUCT_m12 *cps, TERN_m12 free_cps_structure)
{
	CMP_DIRECTIVES_m12	saved_directives;
	CMP_PARAMETERS_m12	saved_parameters;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (cps == NULL) {
		G_warning_message_m12("%s(): trying to free a NULL CMP_PROCESSING_STRUCT_m12 => returning with no action\n", __FUNCTION__);
		return;
	}
	
	PROC_pthread_mutex_lock_m12(&cps->parameters.mutex);

	if (cps->original_data != NULL)
		free_m12((void *) cps->original_data, __FUNCTION__);
	
	if (cps->parameters.cache != NULL)  // decompressed_data is pointer into this
		free_m12((void *) cps->parameters.cache, __FUNCTION__);
	
	if (cps->parameters.keysample_buffer != NULL)
		free_m12((void *) cps->parameters.keysample_buffer, __FUNCTION__);
	
	if (cps->parameters.detrended_buffer != NULL)
		free_m12((void *) cps->parameters.detrended_buffer, __FUNCTION__);
	
	if (cps->parameters.scaled_amplitude_buffer != NULL)
		free_m12((void *) cps->parameters.scaled_amplitude_buffer, __FUNCTION__);
	
	if (cps->parameters.scaled_frequency_buffer != NULL)
		free_m12((void *) cps->parameters.scaled_frequency_buffer, __FUNCTION__);
	
	if (cps->parameters.scrap_buffers != NULL)
		CMP_free_buffers_m12(cps->parameters.scrap_buffers, TRUE_m12);
	
	if (cps->parameters.count != NULL)
		free_m12((void *) cps->parameters.count, __FUNCTION__);
	
	if (cps->parameters.cumulative_count != NULL)
		free_m12((void *) cps->parameters.cumulative_count, __FUNCTION__);
	
	if (cps->parameters.sorted_count != NULL)
		free_m12((void *) cps->parameters.sorted_count, __FUNCTION__);
	
	if (cps->parameters.minimum_range != NULL)
		free_m12((void *) cps->parameters.minimum_range, __FUNCTION__);
	
	if (cps->parameters.symbol_map != NULL)
		free_m12((void *) cps->parameters.symbol_map, __FUNCTION__);
	
	if (cps->parameters.VDS_input_buffers != NULL)
		CMP_free_buffers_m12(cps->parameters.VDS_input_buffers, TRUE_m12);
	if (cps->parameters.VDS_output_buffers != NULL)
		CMP_free_buffers_m12(cps->parameters.VDS_output_buffers, TRUE_m12);
	
	PROC_pthread_mutex_unlock_m12(&cps->parameters.mutex);
	PROC_pthread_mutex_destroy_m12(&cps->parameters.mutex);

	if (free_cps_structure == TRUE_m12) {
		free_m12((void *) cps, __FUNCTION__);
	} else {
		saved_directives = cps->directives;
		saved_parameters = cps->parameters;
		memset((void *) cps, 0, sizeof(CMP_PROCESSING_STRUCT_m12));
		cps->directives = saved_directives;
		cps->parameters = saved_parameters;
	}

	return;
}


void    CMP_generate_lossy_data_m12(CMP_PROCESSING_STRUCT_m12 *cps, si4 *input_buffer, si4 *output_buffer, ui1 mode)
{
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// generates lossy data from input_buffer to output_buffer
	// if input_buffer == output_buffer lossy data will be made in place
	block_header = cps->block_header;
	
	if (mode == CMP_AMPLITUDE_SCALE_MODE_m12) {
		// amplitude scale from input_buffer to scaled_amplitude_buffer (lossy)
		CMP_scale_amplitude_si4_m12(input_buffer, cps->parameters.scaled_amplitude_buffer, block_header->number_of_samples, (sf8) cps->parameters.amplitude_scale, cps);
		// unscale from scaled_amplitude_buffer to output_buffer
		CMP_unscale_amplitude_si4_m12(cps->parameters.scaled_amplitude_buffer, output_buffer, block_header->number_of_samples, (sf8) cps->parameters.amplitude_scale);
	} else if (mode == CMP_FREQUENCY_SCALE_MODE_m12) {
		// frequency scale from input_buffer to scaled_frequency_buffer (lossy)
		CMP_scale_frequency_si4_m12(input_buffer, cps->parameters.scaled_frequency_buffer, block_header->number_of_samples, (sf8) cps->parameters.frequency_scale, cps);
		// unscale from scaled_frequency_buffer to output_buffer
		CMP_unscale_frequency_si4_m12(cps->parameters.scaled_frequency_buffer, output_buffer, block_header->number_of_samples, (sf8) cps->parameters.frequency_scale);
	} else {
		G_error_message_m12("%s(): unrecognized lossy compression mode => no data generated\n", __FUNCTION__);
	}
	
	return;
}


void	CMP_generate_parameter_map_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	ui4				bit, flags, n_params, i, *p_map;
	CMP_BLOCK_FIXED_HEADER_m12	*bh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// add up parameter bytes (4 bytes for each bit set)
	bh = cps->block_header;
	flags = bh->parameter_flags;
	p_map = cps->parameters.block_parameter_map;
	for (bit = 1, n_params = i = 0; i < CMP_PF_PARAMETER_FLAG_BITS_m12; ++i, bit <<= 1)
		if (flags & bit)
			p_map[i] = n_params++;
	
	cps->parameters.number_of_block_parameters = (si4) n_params;
	bh->parameter_region_bytes = (ui2) (n_params * 4);
	
	return;
}


ui1    CMP_get_overflow_bytes_m12(CMP_PROCESSING_STRUCT_m12 *cps, ui4 mode, ui4 algorithm)
{
	ui1					bits_per_samp;
	ui2					flags;
	si8					i, val, abs_min, abs_max;
	CMP_RED_MODEL_FIXED_HEADER_m12		*RED_header;
	CMP_PRED_MODEL_FIXED_HEADER_m12		*PRED_header;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (mode == CMP_COMPRESSION_MODE_m12) {  // assumes extrema are known & derivative level is set
		if (cps->directives.find_overflow_bytes == TRUE_m12) {
			if (cps->parameters.derivative_level) {
				abs_min = ABS_m12((si8) cps->parameters.minimum_difference_value);   // cannot make 0x80000000 positive as si4, must use si8 here
				abs_max = ABS_m12((si8) cps->parameters.maximum_difference_value);
			} else {  // level zero => use raw data
				abs_min = ABS_m12((si8) cps->parameters.minimum_sample_value);
				abs_max = ABS_m12((si8) cps->parameters.maximum_sample_value);
			}
			val = (abs_min > abs_max) ? abs_min : abs_max;
			for (bits_per_samp = 1, i = val; i; i >>= 1)
				++bits_per_samp;
			if (algorithm == CMP_RED1_COMPRESSION_m12 || algorithm == CMP_RED2_COMPRESSION_m12) {
				RED_header = (CMP_RED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
				if (RED_header->flags & CMP_RED_FLAGS_POSITIVE_DERIVATIVES_MASK_m12)
					--bits_per_samp;  // don't need a sign bit
			}
			cps->parameters.overflow_bytes = (bits_per_samp + 7) >> 3;
		} else if (cps->directives.set_overflow_bytes == TRUE_m12) {
			if (cps->parameters.goal_overflow_bytes != 2 && cps->parameters.goal_overflow_bytes != 3) {
				G_warning_message_m12("%s(): overflow bytes must be 2-4 => setting to 4\n", __FUNCTION__);
				cps->parameters.goal_overflow_bytes = CMP_PARAMETERS_OVERFLOW_BYTES_DEFAULT_m12;  // 4
				cps->parameters.overflow_bytes = CMP_PARAMETERS_OVERFLOW_BYTES_DEFAULT_m12;  // 4
			}
		} else {
			cps->parameters.goal_overflow_bytes = CMP_PARAMETERS_OVERFLOW_BYTES_DEFAULT_m12;  // 4
			cps->parameters.overflow_bytes = CMP_PARAMETERS_OVERFLOW_BYTES_DEFAULT_m12;  // 4
		}
		// set block flag
		if (algorithm == CMP_RED1_COMPRESSION_m12 || algorithm == CMP_RED2_COMPRESSION_m12) {
			RED_header->flags &= ~CMP_RED_OVERFLOW_BYTES_MASK_m12;
			if (cps->parameters.overflow_bytes == 2)
				RED_header->flags |= CMP_RED_2_BYTE_OVERFLOWS_MASK_m12;
			else if	(cps->parameters.overflow_bytes == 3)
				RED_header->flags |= CMP_RED_3_BYTE_OVERFLOWS_MASK_m12;
		} else if (algorithm == CMP_PRED1_COMPRESSION_m12 || algorithm == CMP_PRED2_COMPRESSION_m12 ) {
			PRED_header = (CMP_PRED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
			PRED_header->flags &= ~CMP_PRED_OVERFLOW_BYTES_MASK_m12;
			if (cps->parameters.overflow_bytes == 2)
				PRED_header->flags |= CMP_PRED_2_BYTE_OVERFLOWS_MASK_m12;
			else if	(cps->parameters.overflow_bytes == 3)
				PRED_header->flags |= CMP_PRED_3_BYTE_OVERFLOWS_MASK_m12;
		}
	} else {  // CMP_DECOMPRESSION_MODE_m12
		if (algorithm == CMP_RED1_COMPRESSION_m12 || algorithm == CMP_RED2_COMPRESSION_m12) {
			RED_header = (CMP_RED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
			flags = RED_header->flags & CMP_RED_OVERFLOW_BYTES_MASK_m12;
			if (flags == CMP_RED_2_BYTE_OVERFLOWS_MASK_m12)
				cps->parameters.overflow_bytes =  2;
			else if (flags == CMP_RED_3_BYTE_OVERFLOWS_MASK_m12)
				cps->parameters.overflow_bytes =  3;
			else
				cps->parameters.overflow_bytes = CMP_PARAMETERS_OVERFLOW_BYTES_DEFAULT_m12;  // 4
		} else if (algorithm == CMP_PRED_COMPRESSION_m12) {
			PRED_header = (CMP_PRED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
			flags = PRED_header->flags & CMP_PRED_OVERFLOW_BYTES_MASK_m12;
			if (flags == CMP_PRED_2_BYTE_OVERFLOWS_MASK_m12)
				cps->parameters.overflow_bytes =  2;
			else if (flags == CMP_PRED_3_BYTE_OVERFLOWS_MASK_m12)
				cps->parameters.overflow_bytes =  3;
			else
				cps->parameters.overflow_bytes = CMP_PARAMETERS_OVERFLOW_BYTES_DEFAULT_m12;  // 4
		}
	}
	
	return(cps->parameters.overflow_bytes);
}


void    CMP_get_variable_region_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	ui1				*var_reg_ptr;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	block_header = cps->block_header;
	var_reg_ptr = (ui1 *) block_header + CMP_BLOCK_FIXED_HEADER_BYTES_m12;  // pointer to beginning of variable region
	
	// records region (user sets block_header->record_region_bytes)
	cps->block_records = var_reg_ptr;
	var_reg_ptr += block_header->record_region_bytes;
	
	// parameter region
	cps->block_parameters = (ui4 *) var_reg_ptr;
	CMP_generate_parameter_map_m12(cps);
	var_reg_ptr += block_header->parameter_region_bytes;
	
	// protected region
	// cps->protected_region = var_reg_ptr;  // no pointer to this in CPS
	var_reg_ptr += block_header->protected_region_bytes;
	
	// discretionary region (user sets block_header->discretionary_region_bytes)
	cps->discretionary_region = var_reg_ptr;
	var_reg_ptr += block_header->discretionary_region_bytes;
	
	// variable region bytes
	cps->parameters.variable_region_bytes = CMP_VARIABLE_REGION_BYTES_v1_m12(block_header);
	
	// model region (not part of variable region, but convenient to do this here)
	cps->parameters.model_region = var_reg_ptr;
	
	return;
}


TERN_m12	CMP_hex_to_int_m12(ui1 *in, ui1 *out, si4 len)
{
	ui1	hi_val, lo_val;
	si4	i;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// if "in" is null-terminated string, can pass zero for len
	// can be done in place i.e. "in" can == "out"
	
	if (*in == (ui1) '0' && ((*(in + 1) == (ui1) 'x') || (*(in + 1) == (ui1) 'X')))
		in += 2;
	
	if (len == 0)
		len = strlen((const char *) in) / 2;
	
	for (i = 0; i < len; ++i) {
		if (*in >= (ui1) 'a') {
			if(*in > (ui1) 'f')
				return(FALSE_m12);
			hi_val = (*in - (ui1) 'a') + 10;
		} else if (*in >= (ui1) 'A') {
			if(*in > (ui1) 'F')
				return(FALSE_m12);
			hi_val = (*in - (ui1) 'A') + 10;
		} else if (*in >= (ui1) '0') {
			if(*in > (ui1) '9')
				return(FALSE_m12);
			hi_val = *in - (ui1) '0';
		} else {
			return(FALSE_m12);
		}
		++in;
		if (*in >= (ui1) 'a') {
			if(*in > (ui1) 'f')
				return(FALSE_m12);
			lo_val = (*in - (ui1) 'a') + 10;
		} else if (*in >= (ui1) 'A') {
			if(*in > (ui1) 'F')
				return(FALSE_m12);
			lo_val = (*in - (ui1) 'A') + 10;
		} else if (*in >= (ui1) '0') {
			if(*in > (ui1) '9')
				return(FALSE_m12);
			lo_val = *in - (ui1) '0';
		} else {
			return(FALSE_m12);
		}
		++in;
		*out++ = (hi_val << 4) | lo_val;
	}
	
	return(TRUE_m12);
}


void	CMP_initialize_directives_m12(CMP_DIRECTIVES_m12 *directives, ui1 mode)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	directives->mode = mode;
	directives->algorithm = CMP_DIRECTIVES_ALGORITHM_DEFAULT_m12;
	directives->encryption_level = CMP_DIRECTIVES_ENCRYPTION_LEVEL_DEFAULT_m12;
	directives->cps_pointer_reset = CMP_DIRECTIVES_CPS_POINTER_RESET_DEFAULT_m12;
	directives->cps_caching = CMP_DIRECTIVES_CPS_CACHING_DEFAULT_m12;
	directives->fall_through_to_best_encoding = CMP_DIRECTIVES_FALL_THROUGH_TO_BEST_ENCODING_DEFAULT_m12;
	directives->reset_discontinuity = CMP_DIRECTIVES_RESET_DISCONTINUITY_DEFAULT_m12;
	directives->include_noise_scores = CMP_DIRECTIVES_INCLUDE_NOISE_SCORES_DEFAULT_m12;
	directives->no_zero_counts = CMP_DIRECTIVES_NO_ZERO_COUNTS_DEFAULT_m12;
	directives->set_derivative_level = CMP_DIRECTIVES_SET_DERIVATIVE_LEVEL_DEFAULT_m12;
	directives->find_derivative_level = CMP_DIRECTIVES_FIND_DERIVATIVE_LEVEL_DEFAULT_m12;
	directives->set_overflow_bytes = CMP_DIRECTIVES_SET_OVERFLOW_BYTES_DEFAULT_m12;
	directives->find_overflow_bytes = CMP_DIRECTIVES_FIND_OVERFLOW_BYTES_DEFAULT_m12;
	directives->convert_to_native_units = CMP_DIRECTIVES_CONVERT_TO_NATIVE_UNITS_DEFAULT_m12;
	directives->detrend_data = CMP_DIRECTIVES_DETREND_DATA_DEFAULT_m12;
	directives->require_normality = CMP_DIRECTIVES_REQUIRE_NORMALITY_DEFAULT_m12;
	directives->use_compression_ratio = CMP_DIRECTIVES_USE_COMPRESSION_RATIO_DEFAULT_m12;
	directives->use_mean_residual_ratio = CMP_DIRECTIVES_USE_MEAN_RESIDUAL_RATIO_DEFAULT_m12;
	directives->use_relative_ratio = CMP_DIRECTIVES_USE_RELATIVE_RATIO_DEFAULT_m12;
	directives->set_amplitude_scale = CMP_DIRECTIVES_SET_AMPLITUDE_SCALE_DEFAULT_m12;
	directives->find_amplitude_scale = CMP_DIRECTIVES_FIND_AMPLITUDE_SCALE_DEFAULT_m12;
	directives->set_frequency_scale = CMP_DIRECTIVES_SET_FREQUENCY_SCALE_DEFAULT_m12;
	directives->find_frequency_scale = CMP_DIRECTIVES_FIND_FREQUENCY_SCALE_DEFAULT_m12;
	directives->set_overflow_bytes = CMP_DIRECTIVES_SET_OVERFLOW_BYTES_DEFAULT_m12;
	directives->find_overflow_bytes = CMP_DIRECTIVES_FIND_OVERFLOW_BYTES_DEFAULT_m12;
	directives->VDS_scale_by_baseline = CMP_DIRECTIVES_VDS_SCALE_BY_BASELINE_DEFAULT_m12;
	
	return;
}


void	CMP_initialize_parameters_m12(CMP_PARAMETERS_m12 *parameters)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	PROC_pthread_mutex_init_m12(&parameters->mutex, NULL);
	parameters->cache = NULL;
	parameters->cached_blocks = NULL;
	parameters->cached_block_cnt = 0;
	parameters->cached_block_list_len = 0;
	parameters->block_start_index = 0;
	parameters->block_end_index = 0xFFFFFFFF;
	parameters->allocated_block_samples = 0;
	parameters->allocated_keysample_bytes = 0;
	parameters->allocated_compressed_bytes = 0;
	parameters->allocated_decompressed_samples = 0;
	parameters->discontinuity = CMP_PARAMETERS_DISCONTINUITY_DEFAULT_m12;
	parameters->goal_derivative_level = CMP_PARAMETERS_DERIVATIVE_LEVEL_DEFAULT_m12;
	parameters->derivative_level = 0;
	parameters->goal_overflow_bytes = CMP_PARAMETERS_OVERFLOW_BYTES_DEFAULT_m12;
	parameters->overflow_bytes = 0;
	parameters->number_of_block_parameters = 0;
	parameters->minimum_sample_value = CMP_PARAMETERS_MINIMUM_SAMPLE_VALUE_DEFAULT_m12;
	parameters->maximum_sample_value = CMP_PARAMETERS_MAXIMUM_SAMPLE_VALUE_DEFAULT_m12;
	parameters->user_number_of_records = CMP_USER_NUMBER_OF_RECORDS_DEFAULT_m12;
	parameters->user_record_region_bytes = CMP_USER_RECORD_REGION_BYTES_DEFAULT_m12;
	parameters->user_parameter_flags = CMP_USER_PARAMETER_FLAGS_DEFAULT_m12;
	parameters->protected_region_bytes = CMP_PROTECTED_REGION_BYTES_DEFAULT_m12;
	parameters->user_discretionary_region_bytes = CMP_USER_DISCRETIONARY_REGION_BYTES_DEFAULT_m12;
	parameters->variable_region_bytes = 0;
	parameters->goal_ratio = CMP_PARAMETERS_GOAL_RATIO_DEFAULT_m12;
	parameters->goal_tolerance = CMP_PARAMETERS_GOAL_TOLERANCE_DEFAULT_m12;
	parameters->maximum_goal_attempts = CMP_PARAMETERS_MAXIMUM_GOAL_ATTEMPTS_DEFAULT_m12;
	parameters->minimum_normality = CMP_PARAMETERS_MINIMUM_NORMALITY_DEFAULT_m12;
	parameters->amplitude_scale = CMP_PARAMETERS_AMPLITUDE_SCALE_DEFAULT_m12;
	parameters->frequency_scale = CMP_PARAMETERS_FREQUENCY_SCALE_DEFAULT_m12;
	parameters->VDS_sampling_frequency = FREQUENCY_NO_ENTRY_m12;
	parameters->VDS_LFP_high_fc = FREQUENCY_NO_ENTRY_m12;
	parameters->VDS_threshold = CMP_PARAMETERS_VDS_THRESHOLD_DEFAULT_m12;

	parameters->count = NULL;
	parameters->sorted_count = NULL;
	parameters->cumulative_count = NULL;
	parameters->minimum_range = NULL;
	parameters->symbol_map = NULL;
	parameters->VDS_input_buffers = NULL;
	parameters->VDS_output_buffers = NULL;
	parameters->filtps = NULL;
	parameters->n_filtps = 0;

	return;
}


TERN_m12	CMP_initialize_tables_m12(void)
{
	sf8					*cdf_table;
	CMP_VDS_THRESHOLD_MAP_ENTRY_m12		*threshold_map;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (global_tables_m12->CMP_normal_CDF_table != NULL)
		return(TRUE_m12);
	
	PROC_pthread_mutex_lock_m12(&global_tables_m12->CMP_mutex);
	if (global_tables_m12->CMP_normal_CDF_table != NULL) {
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->CMP_mutex);
		return(TRUE_m12);
	}

	if (global_tables_m12->CMP_normal_CDF_table == NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		cdf_table = (sf8 *) mxCalloc((mwSize) CMP_NORMAL_CDF_TABLE_ENTRIES_m12, (mwSize) sizeof(sf8));
	#else
		cdf_table = (sf8 *) calloc((size_t) CMP_NORMAL_CDF_TABLE_ENTRIES_m12, sizeof(sf8));
	#endif
		{
			sf8 temp[CMP_NORMAL_CDF_TABLE_ENTRIES_m12] = CMP_NORMAL_CDF_TABLE_m12;
			memcpy(cdf_table, temp, CMP_NORMAL_CDF_TABLE_ENTRIES_m12 * sizeof(sf8));
		}
		global_tables_m12->CMP_normal_CDF_table = cdf_table;
	}
	
	if (global_tables_m12->CMP_VDS_threshold_map == NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		threshold_map = (CMP_VDS_THRESHOLD_MAP_ENTRY_m12 *) mxCalloc((mwSize) CMP_VDS_THRESHOLD_MAP_TABLE_ENTRIES_m12, (mwSize) sizeof(CMP_VDS_THRESHOLD_MAP_ENTRY_m12));
	#else
		threshold_map = (CMP_VDS_THRESHOLD_MAP_ENTRY_m12 *) calloc((size_t) CMP_VDS_THRESHOLD_MAP_TABLE_ENTRIES_m12, sizeof(CMP_VDS_THRESHOLD_MAP_ENTRY_m12));
	#endif
		{
			CMP_VDS_THRESHOLD_MAP_ENTRY_m12 temp[CMP_VDS_THRESHOLD_MAP_TABLE_ENTRIES_m12] = CMP_VDS_THRESHOLD_MAP_TABLE_m12;
			memcpy(threshold_map, temp, CMP_VDS_THRESHOLD_MAP_TABLE_ENTRIES_m12 * sizeof(CMP_VDS_THRESHOLD_MAP_ENTRY_m12));
		}
		global_tables_m12->CMP_VDS_threshold_map = threshold_map;
	}
		
	PROC_pthread_mutex_unlock_m12(&global_tables_m12->CMP_mutex);

	return(TRUE_m12);
}


void	CMP_integrate_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	ui1				deriv_level;
	ui4				n_samps;
	si4				*deriv_buffer, *si4_p1, *si4_p2;
	si8				i;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// integrates in place from/to decompressed_ptr
	deriv_level = cps->parameters.derivative_level;
	if (deriv_level == 0)
		return;

	block_header = cps->block_header;
	n_samps = block_header->number_of_samples;
	deriv_buffer = cps->decompressed_ptr;
	do {
		si4_p2 = deriv_buffer + deriv_level;
		si4_p1 = si4_p2 - 1;
		for (i = n_samps - deriv_level; i--;)
			*si4_p2++ += *si4_p1++;
	} while (--deriv_level);

	return;
}


void    CMP_lad_reg_2_sf8_m12(sf8 *x_input_buffer, sf8 *y_input_buffer, si8 len, sf8 *m, sf8 *b)
{
	sf8		t, *xp, *yp, *buff, *bp, min_x, max_x, min_y, max_y, min_m, max_m;
	sf8             d, ma, ba, m_eps, b_eps, lad_eps, test_m, lad, upper_m, lower_m;
	si8             i;
	const sf8	safe_eps = DBL_EPSILON * (sf8) 1000.0;
	const sf8	thresh = safe_eps * (sf8) 10.0;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// linear least absolute deviation_regression (2 array input)

	// allocate
	buff = (sf8 *) malloc((size_t) len * sizeof(sf8));

	// setup
	xp = x_input_buffer;
	min_x = max_x = *xp;
	yp = y_input_buffer;
	min_y = max_y = *yp;
	for (i = len; --i;) {
		if (*++xp > max_x)
			max_x = *xp;
		else if (*xp < min_x)
			min_x = *xp;
		if (*++yp > max_y)
			max_y = *yp;
		else if (*yp < min_y)
			min_y = *yp;
	}
	upper_m = max_m = (max_y - min_y) / (max_x - min_x);
	lower_m = min_m = -max_m;
	d = max_m - min_m;

	// search
	while (d > thresh) {
		ma = (upper_m + lower_m) / (sf8) 2.0;
		bp = buff; xp = x_input_buffer; yp = y_input_buffer;
		for (i = len; i--;)
			*bp++ = *yp++ - (*xp++ * ma);
		ba = CMP_quantval_m12(buff, len, 0.5, 0, NULL);  // median
		bp = buff; lad = (sf8)0.0;
		for (i = len; i--;) {
			t = *bp++ - ba;
			lad += ABS_m12(t);
		}
		m_eps = ma + safe_eps;
		bp = buff; xp = x_input_buffer; yp = y_input_buffer;
		for (i = len; i--;)
			*bp++ = *yp++ - (*xp++ * m_eps);
		b_eps = CMP_quantval_m12(buff, len, 0.5, 0, NULL);  // median
		bp = buff; lad_eps = (sf8)0.0;
		for (i = len; i--;) {
			t = *bp++ - b_eps;
			lad_eps += ABS_m12(t);
		}
		test_m = lad_eps - lad;
		if (test_m > (sf8)0.0)
			upper_m = ma;
		else if (test_m < (sf8)0.0)
			lower_m = ma;
		else
			break;
		d = upper_m - lower_m;
	}

	*b = ba;
	*m = ma;

	// clean up
	free((void *) buff);

	return;
}


void    CMP_lad_reg_2_si4_m12(si4 *x_input_buffer, si4 *y_input_buffer, si8 len, sf8 *m, sf8 *b)
{
	sf8		*x, *y, t, *xp, *yp, *buff, *bp, min_x, max_x, min_y, max_y, min_m, max_m;
	sf8             d, ma, ba, m_eps, b_eps, lad_eps, test_m, lad, upper_m, lower_m;
	si8             i;
	const sf8	safe_eps = DBL_EPSILON * (sf8) 1000.0;
	const sf8	thresh = safe_eps * (sf8) 10.0;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// linear least absolute deviation_regression (2 array input)

	// allocate
	buff = (sf8 *) malloc((size_t) len * sizeof(sf8));
	x = (sf8 *) malloc((size_t) len * sizeof(sf8));
	y = (sf8 *) malloc((size_t) len * sizeof(sf8));

	// copy & cast
	for (xp = x, yp = y, i = len; i--;) {
		*xp++ = (sf8) *x_input_buffer++;
		*yp++ = (sf8) *y_input_buffer++;
	}

	// setup
	xp = x;
	min_x = max_x = *xp;
	yp = y;
	min_y = max_y = *yp;
	for (i = len; --i;) {
		if (*++xp > max_x)
			max_x = *xp;
		else if (*xp < min_x)
			min_x = *xp;
		if (*++yp > max_y)
			max_y = *yp;
		else if (*yp < min_y)
			min_y = *yp;
	}
	upper_m = max_m = (max_y - min_y) / (max_x - min_x);
	lower_m = min_m = -max_m;
	d = max_m - min_m;

	// search
	while (d > thresh) {
		ma = (upper_m + lower_m) / (sf8) 2.0;
		bp = buff; xp = x; yp = y;
		for (i = len; i--;)
			*bp++ = *yp++ - (*xp++ * ma);
		ba = CMP_quantval_m12(buff, len, 0.5, 0, NULL);  // median
		bp = buff; lad = (sf8)0.0;
		for (i = len; i--;) {
			t = *bp++ - ba;
			lad += ABS_m12(t);
		}
		m_eps = ma + safe_eps;
		bp = buff; xp = x; yp = y;
		for (i = len; i--;)
			*bp++ = *yp++ - (*xp++ * m_eps);
		b_eps = CMP_quantval_m12(buff, len, 0.5, 0, NULL);  // median
		bp = buff; lad_eps = (sf8)0.0;
		for (i = len; i--;) {
			t = *bp++ - b_eps;
			lad_eps += ABS_m12(t);
		}
		test_m = lad_eps - lad;
		if (test_m > (sf8)0.0)
			upper_m = ma;
		else if (test_m < (sf8)0.0)
			lower_m = ma;
		else
			break;
		d = upper_m - lower_m;
	}

	*b = ba;
	*m = ma;

	// clean up
	free((void *) buff);
	free((void *) x);
	free((void *) y);

	return;
}


void    CMP_lad_reg_sf8_m12(sf8 *y, si8 len, sf8 *m, sf8 *b)
{
	sf8     	lb, lm, t, *yp, *buff, *bp, min_y, max_y, min_m, max_m, m_sum;
	sf8     	d, m_eps, b_eps, lad_eps, test_m, lad, upper_m, lower_m;
	si8     	i;
	const sf8	safe_eps = DBL_EPSILON * (sf8) 1000.0;
	const sf8	thresh = safe_eps * (sf8) 10.0;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// least absolute differences linear regression
	// assumes x to be 1:length(x)
	// fit: y = mx + b
	
	// allocate
	buff = (sf8 *) malloc((size_t) len * sizeof(sf8));
	if (buff == NULL)
		G_error_message_m12("%s(): could not allocate enough memory\n", __FUNCTION__);
	
	// setup
	yp = y;
	min_y = max_y = *yp;
	for (i = len; --i;) {
		if (*++yp > max_y)
			max_y = *yp;
		else if (*yp < min_y)
			min_y = *yp;
	}
	lower_m = min_m = (min_y - max_y) / (sf8) (len - 1);
	upper_m = max_m  = -min_m;
	d = max_m - min_m;
	
	// search
	while (d > thresh) {
		lm = (upper_m + lower_m) / (sf8) 2.0;
		bp = buff; yp = y;
		m_sum = (sf8) 0.0;
		for (i = len; i--;)
			*bp++ = *yp++ - (m_sum += lm);
		lb = CMP_quantval_m12(buff, len, 0.5, FALSE_m12, NULL);  // median
		bp = buff; lad = (sf8) 0.0;
		for (i = len; i--;) {
			t = *bp++ - lb;
			lad += ABS_m12(t);
		}
		m_eps = lm + safe_eps;
		bp = buff; yp = y;
		m_sum = (sf8) 0.0;
		for (i = len; i--;)
			*bp++ = *yp++ - (m_sum += m_eps);
		b_eps = CMP_quantval_m12(buff, len, 0.5, FALSE_m12, NULL);  // median
		bp = buff; lad_eps = (sf8) 0.0;
		for (i = len; i--;) {
			t = *bp++ - b_eps;
			lad_eps += ABS_m12(t);
		}
		test_m = lad_eps - lad;
		if (test_m > (sf8) 0.0)
			upper_m = lm;
		else if (test_m < (sf8) 0.0)
			lower_m = lm;
		else
			break;
		d = upper_m - lower_m;
	}
	*b = lb;
	*m = lm;
	
	// clean up
	free(buff);
	
	return;
}


void    CMP_lad_reg_si4_m12(si4 *input_buffer, si8 len, sf8 *m, sf8 *b)
{
	sf8		*y, t, *yp, *buff, *bp, min_y, max_y, min_m, max_m, m_sum;
	sf8             d, ma, ba, m_eps, b_eps, lad_eps, test_m, lad, upper_m, lower_m;
	si8             i;
	const sf8	safe_eps = DBL_EPSILON * (sf8) 1000.0;
	const sf8	thresh = safe_eps * (sf8) 10.0;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// linear least absolute deviation_regression (1 array input)
	
	// allocate
	buff = (sf8 *) calloc((size_t) len, sizeof(sf8));
	y = (sf8 *) calloc((size_t) len, sizeof(sf8));
	
	// copy & cast
	for (yp = y, i = len; i--;)
		*yp++ = (sf8) *input_buffer++;
	
	// setup
	yp = y;
	min_y = max_y = *yp;
	for (i = len; --i;) {
		if (*++yp > max_y)
			max_y = *yp;
		else if (*yp < min_y)
			min_y = *yp;
	}
	upper_m = max_m = (max_y - min_y) / (sf8)(len - 1);
	lower_m = min_m = -max_m;
	d = max_m - min_m;
	
	// search
	while (d > thresh) {
		ma = (upper_m + lower_m) / (sf8) 2.0;
		bp = buff; yp = y;
		m_sum = (sf8) 0.0;
		for (i = len; i--;)
			*bp++ = *yp++ - (m_sum += ma);
		ba = CMP_quantval_m12(buff, len, 0.5, 0, NULL);  // median
		bp = buff; lad = (sf8) 0.0;
		for (i = len; i--;) {
			t = *bp++ - ba;
			lad += ABS_m12(t);
		}
		m_eps = ma + safe_eps;
		bp = buff; yp = y;
		m_sum = (sf8) 0.0;
		for (i = len; i--;)
			*bp++ = *yp++ - (m_sum += m_eps);
		b_eps = CMP_quantval_m12(buff, len, 0.5, 0, NULL);  // median
		bp = buff; lad_eps = (sf8) 0.0;
		for (i = len; i--;) {
			t = *bp++ - b_eps;
			lad_eps += ABS_m12(t);
		}
		test_m = lad_eps - lad;
		if (test_m > (sf8) 0.0)
			upper_m = ma;
		else if (test_m < (sf8) 0.0)
			lower_m = ma;
		else
			break;
		d = upper_m - lower_m;
	}
	
	*b = ba;
	*m = ma;
	
	// clean up
	free((void *) buff);
	free((void *) y);
	
	return;
	
}


sf8	*CMP_lin_interp_sf8_m12(sf8 *in_data, si8 in_len, sf8 *out_data, si8 out_len)
{
	sf8     x, inc, f_bot_x, bot_y, range;
	si8     i, bot_x, top_x, last_bot_x;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (out_data == NULL)
		out_data = (sf8 *) malloc_m12((size_t) (out_len << 3), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	if (in_len <= 1) {
		if (in_len == 0)
			return(NULL);
		for (i = 0; i < out_len; ++i)
			out_data[i] = in_data[0];
		return(out_data);
	}
	if (in_len == out_len) {
		memcpy((void *) out_data, (void *) in_data, (size_t) (in_len << 3));
		return(out_data);
	}
	
	// interpolate
	--in_len; --out_len;
	inc = (sf8) in_len / (sf8) out_len;
	
	out_data[0] = in_data[0];
	if (out_len <= (in_len << 1)) {  // downsample, or upsample ratio <= 2:1 (upsampling this way is faster than below)
		for (x = inc, i = 1; i < out_len; ++i, x += inc) {
			top_x = (bot_x = (si8) x) + 1;
			out_data[i] = (x - (sf8) bot_x) * (in_data[top_x] - in_data[bot_x]) + in_data[bot_x];
		}
	} else {  // upsample ratio > 2:1
		for (last_bot_x = -1, x = inc, i = 1; i < out_len; ++i, x += inc) {
			bot_x = (si8) x;
			if (bot_x != last_bot_x) {
				range = in_data[bot_x + 1] - in_data[bot_x];
				bot_y = in_data[bot_x];
				f_bot_x = (sf8) bot_x;
				last_bot_x = bot_x;
			}
			out_data[i] = ((x - f_bot_x) * range) + bot_y;
		}
	}
	out_data[out_len] = in_data[in_len];
	
	return(out_data);
}


si4	*CMP_lin_interp_si4_m12(si4 *in_data, si8 in_len, si4 *out_data, si8 out_len)
{
	sf8     x, inc, f_bot_x, bot_y, range;
	si8     i, bot_x, top_x, last_bot_x;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (out_data == NULL)
		out_data = (si4 *) malloc_m12((size_t) (out_len << 2), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	if (in_len <= 1) {
		if (in_len == 0)
			return(NULL);
		for (i = 0; i < out_len; ++i)
			out_data[i] = in_data[0];
		return(out_data);
	}
	if (in_len == out_len) {
		memcpy((void *) out_data, (void *) in_data, (size_t) (in_len << 2));
		return(out_data);
	}
	
	// interpolate
	--in_len; --out_len;
	inc = (sf8) in_len / (sf8) out_len;
	
	out_data[0] = in_data[0];
	if (out_len <= (in_len << 1)) {  // downsample, or upsample ratio <= 2:1
		for (x = inc, i = 1; i < out_len; ++i, x += inc) {
			top_x = (bot_x = (si8) x) + 1;
			out_data[i] = CMP_round_si4_m12((x - (sf8) bot_x) * ((sf8) in_data[top_x] - (sf8) in_data[bot_x]) + (sf8) in_data[bot_x]);
		}
	} else {  // upsample ratio > 2:1
		for (last_bot_x = -1, x = inc, i = 1; i < out_len; ++i, x += inc) {
			bot_x = (si8) x;
			if (bot_x != last_bot_x) {
				range = (sf8) in_data[bot_x + 1] - (sf8) in_data[bot_x];
				bot_y = (sf8) in_data[bot_x];
				f_bot_x = (sf8) bot_x;
				last_bot_x = bot_x;
			}
			out_data[i] = CMP_round_si4_m12(((x - f_bot_x) * range) + bot_y);
		}
	}
	out_data[out_len] = in_data[in_len];
	
	return(out_data);
}


void    CMP_lin_reg_2_si4_m12(si4 *x_input_buffer, si4 *y_input_buffer, si8 len, sf8 *m, sf8 *b)
{
	sf8                     sx, sy, sxx, sxy, n, mx, my, x_val, y_val;
	si8                     i;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// linear least_squares regression (2 array input)
	n = (sf8) len;
	sx = sy = sxx = sxy = (sf8) 0.0;
	for (i = len; i--;) {
		x_val = (sf8) *x_input_buffer++;
		y_val = (sf8) *y_input_buffer++;
		sx += x_val;
		sxx += x_val * x_val;
		sy += y_val;
		sxy += x_val * y_val;
	}
	
	mx = sx / n;
	my = sy / n;
	*m = (((sx * my) - sxy) / ((sx * mx) - sxx));
	*b = (my - (*m * mx));
		
	return;
}


void    CMP_lin_reg_si4_m12(si4 *input_buffer, si8 len, sf8 *m, sf8 *b)
{
	sf8	sx, sy, sxx, sxy, n, mx, my, c, val;
	si8	i;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// linear least_squares regression (1 array input)
	
	n = (sf8) len;
	sx = (n * (n + (sf8) 1.0)) / (sf8) 2.0;
	sxx = (n * (n + (sf8) 1.0) * ((n * (sf8) 2.0) + (sf8) 1.0)) / (sf8) 6.0;
	
	c = sy = sxy = (sf8) 0.0;
	for (i = len; i--;) {
		val = (sf8)*input_buffer++;
		sy += val;
		sxy += val * (c += (sf8) 1.0);
	}
	
	mx = sx / n;
	my = sy / n;
	*m = (((sx * my) - sxy) / ((sx * mx) - sxx));
	*b = (my - (*m * mx));
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	CMP_lock_buffers_m12(CMP_BUFFERS_m12 *buffers)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// lock
	if (buffers->locked != TRUE_m12) {
		buffers->locked = mlock_m12((void *) buffers->buffer, buffers->total_allocated_bytes, FALSE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		buffers->locked = TRUE_m12;
	}

	return;
}


void    CMP_MBE_decode_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	ui4				n_samps, total_header_bytes;
	si4				*si4_p, *init_val_p, bits_per_samp, n_derivs;
	si8				i, lmin;
	ui8				out_val, *in_word, mask, temp_mask, high_bits, in_word_val;
	ui1				in_bit;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	CMP_MBE_MODEL_FIXED_HEADER_m12	*MBE_header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// read header
	block_header = cps->block_header;
	n_samps = block_header->number_of_samples;
	MBE_header = (CMP_MBE_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
	lmin = (si8) MBE_header->minimum_value;
	bits_per_samp = (si4) MBE_header->bits_per_sample;
	n_derivs = (si4) MBE_header->derivative_level;
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->parameters.model_region + CMP_MBE_MODEL_FIXED_HEADER_BYTES_m12);
	for (i = 0; i < n_derivs; ++i)
		cps->decompressed_ptr[i] = *init_val_p++;
	
	// set parameters for return
	cps->parameters.derivative_level = n_derivs;

	// MBE decode
	// Note: can't use block_header->total_header_bytes in case input is VDS fall through
	total_header_bytes = (ui4) ((cps->parameters.model_region - (ui1 *) block_header) + CMP_MBE_MODEL_FIXED_HEADER_BYTES_m12 + (n_derivs * 4));
	in_word = (ui8 *) ((ui1 *) block_header + (total_header_bytes & ~((ui4) 7)));
	in_bit = (total_header_bytes & (ui4) 7) << 3;
	mask = ((ui8) 1 << bits_per_samp) - 1;
	si4_p = cps->decompressed_ptr + n_derivs;
	in_word_val = *in_word >> in_bit;
	for (i = n_samps - n_derivs; i--;) {
		out_val = in_word_val & mask;
		in_word_val >>= bits_per_samp;
		if ((in_bit += bits_per_samp) > 63) {
			in_word_val = *++in_word;
			if (in_bit &= 63) {
				temp_mask = ((ui8) 1 << in_bit) - 1;
				high_bits = in_word_val & temp_mask;
				out_val |= (high_bits << (bits_per_samp - in_bit));
				in_word_val >>= in_bit;
			}
		}
		*si4_p++ = (si4) ((si8) out_val + lmin);
	}
	
	// integrate derivatives
	CMP_integrate_m12(cps);

	return;
}


void    CMP_MBE_encode_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	ui1				n_derivs;
	si4				*init_out_vals, *si4_p, bits_per_samp;
	ui4				n_samps, n_deriv_samps, cmp_data_bytes;
	si8				i, cmp_data_bits, lmin, lmax;
	ui8				out_val, *out_word;
	ui1				out_bit, *output;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	CMP_MBE_MODEL_FIXED_HEADER_m12	*MBE_header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// compress from cps->input_buffer to cps->block header
	// (compression algorithms are responsible for filling in: algorithm block flag, total_block_bytes, total_header_bytes, model_region_bytes, & model details)
	
	// set algorithm block flag
	block_header = cps->block_header;
	block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
	block_header->block_flags |= CMP_BF_MBE_ENCODING_MASK_m12;

	MBE_header = (CMP_MBE_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
	if (MBE_header->flags & CMP_MBE_FLAGS_PREPROCESSED_MASK_m12) {
		lmin = MBE_header->minimum_value;
		n_derivs = MBE_header->derivative_level;
		bits_per_samp = MBE_header->bits_per_sample;
		MBE_header->flags &= ~CMP_MBE_FLAGS_PREPROCESSED_MASK_m12;  // reset preprocessed flag
	} else {
		MBE_header->derivative_level = n_derivs = CMP_differentiate_m12(cps);  // CMP_differentiate_m12() sets parameter mins & maxs
		if (n_derivs == 0xFF)
			return;
		if (n_derivs == 0) {
			lmin = (si8) cps->parameters.minimum_sample_value;
			lmax = (si8) cps->parameters.maximum_sample_value;
		} else {
			cps->input_buffer = cps->parameters.derivative_buffer;
			lmin = (si8) cps->parameters.minimum_difference_value;
			lmax = (si8) cps->parameters.maximum_difference_value;
		}
		for (bits_per_samp = 0, i = lmax - lmin; i; i >>= 1)
			++bits_per_samp;
		MBE_header->minimum_value = (si4) lmin;
		MBE_header->bits_per_sample = bits_per_samp;
	}
	
	// copy initial derivative values
	n_samps = block_header->number_of_samples;
	if (n_derivs) {
		init_out_vals = (si4 *) (cps->parameters.model_region + CMP_MBE_MODEL_FIXED_HEADER_BYTES_m12);
		for (i = 0; i < n_derivs; ++i)
			init_out_vals[i] = cps->input_buffer[i];
	}
	n_deriv_samps = n_samps - n_derivs;
	
	// calculate header bytes
	block_header->model_region_bytes = CMP_MBE_MODEL_FIXED_HEADER_BYTES_m12 + (n_derivs * 4);
	block_header->total_header_bytes = (cps->parameters.model_region - (ui1 *) block_header) + block_header->model_region_bytes;
	output = (ui1 *) block_header + block_header->total_header_bytes;
	
	// calculate total encoding bytes
	cmp_data_bits = (si8) n_deriv_samps * (si8) bits_per_samp;
	cmp_data_bytes = cmp_data_bits >> 3;
	if (cmp_data_bits & 7)
		++cmp_data_bytes;
	
	// MBE encode
	memset(output, 0, cmp_data_bytes);
	out_word = (ui8 *) block_header + (block_header->total_header_bytes >> 3);
	out_bit = (block_header->total_header_bytes & 7) << 3;
	si4_p = cps->input_buffer + n_derivs;
	out_val = 0;
	for (i = n_deriv_samps; i--;) {
		out_val = (ui8) ((si8) *si4_p++ - lmin);
		*out_word |= (out_val << out_bit);
		if ((out_bit += bits_per_samp) > 63) {
			out_bit &= 63;
			*++out_word = (out_val >> (bits_per_samp - out_bit));
		}
	}
	
	// fill in block header
	block_header->total_block_bytes = G_pad_m12((ui1 *) block_header, (si8) (cmp_data_bytes + block_header->total_header_bytes), 8);
	
	return;
}


// Mofified Akima cubic interpolation
// Attribution: modifications based on Matlab's adjustments to weights of Akima function
// Note: input x's are integers, output x's are floats
sf8	*CMP_mak_interp_sf8_m12(CMP_BUFFERS_m12 *in_bufs, si8 in_len, CMP_BUFFERS_m12 *out_bufs, si8 out_len)
{
	si8		*index, *si8_p1, *si8_p2;
	si8     	i, j, filled_slopes, in_nm1, tmp_delta_len;
	si8		*in_x;
	sf8     	*delta, *tmp_delta, *weights, *slopes;
	sf8		delta_0, delta_m1, delta_n, delta_n1;
	sf8		*sf8_p1, *sf8_p2, *sf8_p3, *sf8_p4, *sf8_p5, *sf8_p6;
	sf8		sf8_v1, sf8_v2, sf8_v3, sf8_v4;
	sf8 		*in_y, *dx, *out_x, *tmp_out_x, *out_y, *coefs[4];

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Note: This function strays from the usual medlib template in that it does not allocate its processing buffers if not passed.
	// This is just because this function inherently complex anyway, and because otherwise there would be too many arguments for my taste.

	// input buffers
	// allocate with in_bufs =  CMP_allocate_buffers_m12(NULL, CMP_MAK_INTERP_INPUT_BUFFERS_m12, in_len + CMP_MAK_INTERP_PAD_SAMPLES_m12, sizeof(sf8), FALSE_m12, FALSE_m12);
	in_y = (sf8 *) in_bufs->buffer[CMP_MAK_IN_Y_BUF];  // == 0
	in_x = (si8 *) in_bufs->buffer[CMP_MAK_IN_X_BUF];  // == 1
	dx = (sf8 *) in_bufs->buffer[2];
	tmp_delta = (sf8 *) in_bufs->buffer[3];
	slopes = (sf8 *) in_bufs->buffer[4];
	weights = (sf8 *) in_bufs->buffer[5];
	coefs[0] = (sf8 *) in_bufs->buffer[6];
	coefs[1] = (sf8 *) in_bufs->buffer[7];
	
	// output buffers
	// allocate with out_bufs = CMP_allocate_buffers_m12(NULL, CMP_MAK_INTERP_OUTPUT_BUFFERS_m12, out_len, sizeof(sf8), FALSE_m12, FALSE_m12);
	out_y = (sf8 *) out_bufs->buffer[CMP_MAK_OUT_Y_BUF];  // == 0
	out_x = (sf8 *) out_bufs->buffer[CMP_MAK_OUT_X_BUF];  // == 1
	tmp_out_x = (sf8 *) out_bufs->buffer[2];
	index = (si8 *) out_bufs->buffer[3];

	// special cases
	if (in_len <= 1) {
		if (in_len == 0)
			return(out_y);
		for (i = 0; i < out_len; ++i)
			out_y[i] = in_y[0];
		return(out_y);
	}
	if (in_len == out_len) {
		sf8_p1 = out_x;
		si8_p1 = in_x;
		for (i = in_len; i--;)  // check for non-linearly spaced interpolation
			if (*sf8_p1++ != (sf8) *si8_p1++)
				break;
		if (i == -1) {
			memcpy((void *) out_y, (void *) in_y, (size_t) (in_len << 3));
			return(out_y);
		}
	}

	in_nm1 = in_len - 1;
	tmp_delta_len = in_nm1 + 4;
	delta = tmp_delta + 2;
	si8_p1 = in_x;
	si8_p2 = in_x + 1;
	sf8_p1 = dx;
	sf8_p2 = delta;
	sf8_p3 = in_y;
	sf8_p4 = in_y + 1;
	for (i = in_nm1; i--;) {
		*sf8_p1 = (sf8) (*si8_p2++ - *si8_p1++); // dx
		*sf8_p2++ = (*sf8_p4++ - *sf8_p3++) / *sf8_p1++;  // delta = dy / dx
	}

	if (in_len > 2) {
		delta_0 = ((sf8) 2.0 * delta[0]) - delta[1];
		delta_m1 = ((sf8) 2.0 * delta_0) - delta[0];
		delta_n = ((sf8) 2.0 * delta[in_len - 2]) - delta[in_len - 3];
		delta_n1 = ((sf8) 2.0 * delta_n) - delta[in_len - 2];

		tmp_delta[0] = delta_m1;
		tmp_delta[1] = delta_0;
		tmp_delta[tmp_delta_len - 2] = delta_n;
		tmp_delta[tmp_delta_len - 1] = delta_n1;

		sf8_p1 = tmp_delta;
		sf8_p2 = tmp_delta + 1;
		sf8_p3 = weights;
		for (i = tmp_delta_len - 1; i--;) {
			sf8_v1 = *sf8_p1++;
			sf8_v2 = *sf8_p2++;
			sf8_v3 = (sf8_v1 + sf8_v2) / (sf8) 2.0;
			sf8_v3 = (sf8_v3 >= (sf8) 0.0) ? sf8_v3 : -sf8_v3;
			sf8_v4 = (sf8_v2 - sf8_v1);
			sf8_v4 = (sf8_v4 >= (sf8) 0.0) ? sf8_v4 : -sf8_v4;
			*sf8_p3++ = sf8_v3 + sf8_v4;
		}
		sf8_p1 = weights;
		sf8_p2 = weights + 2;
		sf8_p3 = tmp_delta + 1;
		sf8_p4 = tmp_delta + 2;
		sf8_p5 = slopes;
		for (i = in_len; i--;) {
			sf8_v1 = *sf8_p1 + *sf8_p2;
			if (sf8_v1 != 0.0)
				*sf8_p5++ = ((*sf8_p2++ * *sf8_p3++) + (*sf8_p1++ * *sf8_p4++)) / sf8_v1;
		}
		filled_slopes = (si8) (sf8_p5 - slopes);
	} else {
		slopes[0] = slopes[1] = delta[0];
		filled_slopes = (si8) 2;
	}
	// unfilled slopes need to be zeroed
	sf8_p1 = slopes + filled_slopes;
	for (i = in_len - filled_slopes; i--;)
		*sf8_p1++ = (sf8)  0.0;

	coefs[2] = slopes;
	coefs[3] = in_y;
	sf8_p1 = dx;
	sf8_p2 = slopes;
	sf8_p3 = slopes + 1;
	sf8_p4 = delta;
	sf8_p5 = coefs[0];
	sf8_p6 = coefs[1];
	for (i = in_nm1; i--;) {
		*sf8_p5++ = ((*sf8_p2 + *sf8_p3) - (*sf8_p4 * (sf8) 2.0)) / (*sf8_p1 * *sf8_p1);  // column 0
		*sf8_p6++ = ((*sf8_p4++ * (sf8) 3.0) - (*sf8_p2++ * (sf8) 2.0) - *sf8_p3++) / *sf8_p1++;  // column 1
	}

	for (i = 0, j = 0; i < out_len; ++i) {
		sf8_v1 = out_x[i];
		while (((sf8) in_x[j]) <= sf8_v1) {
			++j;
			if (j == in_nm1)
				break;
		}
		index[i] = j - 1;
		if (j == in_nm1) {
			for (++i, --j; i < out_len; ++i)
				index[i] = j;
			break;
		}
	}

	memcpy((void *) tmp_out_x, (void *) out_x, (size_t) (out_len << 3));  // don't destroy out_x (for repeat calls)
	sf8_p1 = tmp_out_x;
	si8_p1 = index;
	for (i = out_len; i--;)
		*sf8_p1++ -= in_x[*si8_p1++];
	sf8_p1 = out_y;
	sf8_p2 = coefs[0];
	si8_p1 = index;
	for (i = out_len; i--;)
		*sf8_p1++ = sf8_p2[*si8_p1++];

	for (i = 1; i < 4; ++i) {
		sf8_p1 = out_y;
		sf8_p2 = tmp_out_x;
		sf8_p3 = coefs[i];
		si8_p1 = index;
		for (j = out_len; j--; ++sf8_p1)
			*sf8_p1 = ((sf8) *sf8_p2++ * *sf8_p1) + sf8_p3[*si8_p1++];
	}

	return(out_y);
}


ui1     CMP_normality_score_m12(si4 *data, ui4 n_samps)
{
	sf8     sx, sx2, sy, sy2, sxy, mx, mx2, sd, val, z, r, n, *norm_cdf;
	sf8     num, den1, den2, cdf[CMP_NORMAL_CDF_TABLE_ENTRIES_m12];
	si8     i, count[CMP_NORMAL_CDF_TABLE_ENTRIES_m12] = {0};
	si4	*si4_p, bin;
	ui1     ks;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// Returns the correlation of the distribution in the data to that expected from a normal distribution.
	// Essentially a Kolmogorov-Smirnov test normalized to range [-1 to 0) = 0 & [0 to 1] = [0 to 254]. 255 is reserved for no entry.
	
	if (global_tables_m12->CMP_normal_CDF_table == NULL)
		CMP_initialize_tables_m12();
	norm_cdf = global_tables_m12->CMP_normal_CDF_table;

	// calculate mean & standard deviation
	n = (sf8) n_samps;
	si4_p = data;
	sx = sx2 = (sf8) 0.0;
	for (i = n_samps; i--;) {
		val = (sf8)*si4_p++;
		sx += val;
		sx2 += val * val;
	}
	mx = sx / n;
	mx2 = sx2 / n;
	sd = sqrt(mx2 - (mx * mx));
	
	// bin the samples
	si4_p = data;
	for (i = n_samps; i--;) {
		val = (sf8)*si4_p++;
		z = (val - mx) / sd;
		if (isnan(z))
			continue;
		bin = (si4) ((z + (sf8) 3.1) * (sf8) 10.0);
		if (bin < 0)
			bin = 0;
		else if (bin >= CMP_NORMAL_CDF_TABLE_ENTRIES_m12)
			bin = CMP_NORMAL_CDF_TABLE_ENTRIES_m12 - 1;
		++count[bin];
	}
	
	// generate data CDF
	cdf[0] = (sf8) count[0];
	for (i = 1; i < CMP_NORMAL_CDF_TABLE_ENTRIES_m12; ++i)
		cdf[i] = (sf8)count[i] + cdf[i - 1];
	
	// calculate correlation between data CDF and normal CDF
	sx = sx2 = sxy = (sf8) 0.0;
	sy = (sf8 )CMP_SUM_NORMAL_CDF_m12;
	sy2 = (sf8) CMP_SUM_SQ_NORMAL_CDF_m12;
	for (i = 0; i < CMP_NORMAL_CDF_TABLE_ENTRIES_m12; ++i) {
		sx += cdf[i];
		sx2 += cdf[i] * cdf[i];
		sxy += cdf[i] * norm_cdf[i];
	}
	
	num = (n * sxy) - (sx * sy);
	den1 = (n * sx2) - (sx * sx);
	den2 = (n * sy2) - (sy * sy);
	
	//  handle rounding errors
	if ((den1 <= (sf8) 0.0) || (den2 <= (sf8) 0.0))
		r = (sf8) 0.0;
	else
		r = num / (sqrt(den1) * sqrt(den2));
	
	// calculate Kolmogorov Smirnov correlation
	r += CMP_KS_CORRECTION_m12;
	if (r < (sf8) 0.0)
		r = (sf8) 0.0;
	else if (r > (sf8) 1.0)
		r = (sf8) 1.0;
	
	// return KS score (negative values set to zero, positive scaled to 0-254, 255 reserved for no entry)
	ks = (ui1) CMP_round_si4_m12(r * 254);     // ks = (ui1) CMP_round_si4_m12(sqrt(1.0 - (r * r)) * 254);  => I had this before, but I don't know why
	
	return(ks);
}


sf8	CMP_p2z_m12(sf8 p)
{
	const sf8	P_EPS = (sf8) 0.00000005;
	sf8     	z, low_z, high_z, temp_z, low_p, high_p, temp_p;
	
	
	// forward search
	low_z = (sf8) 0.0;
	high_p = CMP_z2p_m12(low_z);
	high_z = (sf8) 2.0;
	low_p = CMP_z2p_m12(high_z);
	while (low_p > p) {
		low_z = high_z;
		high_p = low_p;
		high_z *= (sf8) 2.0;
		low_p = CMP_z2p_m12(high_z);
	}
	
	// binary search
	while ((high_p - low_p) > P_EPS) {
		temp_z = (low_z + high_z) / (sf8) 2.0;
		temp_p = CMP_z2p_m12(temp_z);
		if (temp_p >= p) {
			high_p = temp_p;
			low_z = temp_z;
		} else {
			low_p = temp_p;
			high_z = temp_z;
		}
	}
	z = (low_z + high_z) / (sf8) 2.0;
	
	return(z);
}


void    CMP_PRED1_decode_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	TERN_m12	no_zero_counts;
	ui1		*comp_p, *ui1_p, *low_bound_high_byte_p, *high_bound_high_byte_p;
	ui1		*goal_bound_high_byte_p, prev_cat, overflow_bytes;
	ui1		*symbol_map[CMP_PRED_CATS_m12], *symbols;
	si1		*si1_p1, *si1_p2, *key_p;
	ui2		*bin_counts, *stats_entries, *count[CMP_PRED_CATS_m12];
	ui4		n_samps, n_derivs, n_keysample_bytes, total_stats_entries, sign_bit, sign_bytes;
	si4		*si4_p, *init_val_p, overflow_val;
	ui8		**minimum_range, **cumulative_count;
	ui8		low_bound, high_bound, prev_high_bound, goal_bound, range;
	si8		i, j;
	CMP_BLOCK_FIXED_HEADER_m12		*block_header;
	CMP_PRED_MODEL_FIXED_HEADER_m12		*PRED_header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// CMP decompress from block_header to decompressed_ptr
	block_header = cps->block_header;
	n_samps = block_header->number_of_samples;
	
	// zero samples, or only one value
	if (n_samps <= 1) {
		if (block_header->number_of_samples == 1)
			cps->decompressed_ptr[0] = *((si4 *) (cps->parameters.model_region + CMP_PRED_MODEL_FIXED_HEADER_BYTES_m12));
		cps->parameters.derivative_level = 0;
		return;
	}
	
	PRED_header = (CMP_PRED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
	n_derivs = PRED_header->derivative_level;
	n_keysample_bytes = PRED_header->number_of_keysample_bytes;
	stats_entries = PRED_header->numbers_of_statistics_bins;
	for (total_stats_entries = i = 0; i < CMP_PRED_CATS_m12; ++i)
		total_stats_entries += (ui4) stats_entries[i];
	
	// set parameters for return
	cps->parameters.derivative_level = n_derivs;
	
	// get block flags
	no_zero_counts = FALSE_m12;
	if (PRED_header->flags & CMP_PRED_FLAGS_NO_ZERO_COUNTS_MASK_m12)
		no_zero_counts = TRUE_m12;
	overflow_bytes = CMP_get_overflow_bytes_m12(cps, CMP_DECOMPRESSION_MODE_m12, CMP_PRED_COMPRESSION_m12);
	sign_bit = (ui4) 1 << ((overflow_bytes << 3) - 1);
	if (overflow_bytes == 4)
		sign_bytes = (ui4) 0;
	else  // Windows: shift of 32 bits is equated to shift of 0, so have to do this
		sign_bytes = (ui4) 0xFFFFFFFF << (overflow_bytes << 3);

	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->parameters.model_region + CMP_PRED_MODEL_FIXED_HEADER_BYTES_m12);
	for (i = 0; i < n_derivs; ++i)
		cps->decompressed_ptr[i] = *init_val_p++;

	// build symbol map, count arrays, & minimum ranges
	bin_counts = (ui2 *) init_val_p;
	symbols = (ui1 *) (bin_counts + total_stats_entries);
	cumulative_count = (ui8 **) cps->parameters.cumulative_count;
	minimum_range = (ui8 **) cps->parameters.minimum_range;
	for (i = 0; i < CMP_PRED_CATS_m12; ++i) {
		count[i] = bin_counts; bin_counts += stats_entries[i];
		symbol_map[i] = symbols; symbols += stats_entries[i];
		if (no_zero_counts == TRUE_m12) {  // TO DO: decide mapping scheme for unmapped symbols in symbol map
			// TO DO: copy count & symbol map to arrays with 256 elements
			for (j = stats_entries[i]; i < 256; ++i)
				count[i][j] = 1;
		}
		for (cumulative_count[i][0] = j = 0; j < stats_entries[i]; ++j) {
			cumulative_count[i][j + 1] = cumulative_count[i][j] + (ui8) count[i][j];
			minimum_range[i][j] = CMP_RED_TOTAL_COUNTS_m12 / count[i][j];
			if (CMP_RED_TOTAL_COUNTS_m12 > (count[i][j] * minimum_range[i][j]))
				++minimum_range[i][j];
		}
	}
	
	// range decode
	key_p = cps->parameters.keysample_buffer;
	prev_high_bound = goal_bound = low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m12;
	comp_p = (ui1 *) block_header + block_header->total_header_bytes;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	goal_bound_high_byte_p = ((ui1 *) &goal_bound) + 5;
	ui1_p = goal_bound_high_byte_p;
	*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
	*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
	prev_cat = CMP_PRED_NIL_m12;
		
	for (i = n_keysample_bytes; i;) {
		for (j = 0; range >= minimum_range[prev_cat][j];) {
			high_bound = low_bound + ((range * cumulative_count[prev_cat][j + 1]) >> 16);
			if (high_bound > goal_bound) {
				*key_p = symbol_map[prev_cat][j];
				if (!--i)
					goto PRED1_RANGE_DECODE_DONE_m12;
				range = high_bound - (low_bound = prev_high_bound);
				prev_cat = CMP_PRED_CAT_m12(*key_p); ++key_p;
				j = 0;
			} else {
				prev_high_bound = high_bound;
				++j;
			}
		}
		high_bound = low_bound + range;
		if (*low_bound_high_byte_p != *high_bound_high_byte_p) {
			ui1_p = goal_bound_high_byte_p;
			*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
			*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
			low_bound = 0;
			range = CMP_RED_MAXIMUM_RANGE_m12;
		} else {
			do {
				low_bound <<= 8;
				high_bound <<= 8;
				goal_bound = (goal_bound << 8) | (ui8) *comp_p++;
				range <<= 8;
			} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
			low_bound &= CMP_RED_RANGE_MASK_m12;
			goal_bound &= CMP_RED_RANGE_MASK_m12;
		}
		prev_high_bound = low_bound;
	} PRED1_RANGE_DECODE_DONE_m12:

	// generate derivatives from keysample data
	si4_p = cps->decompressed_ptr + n_derivs;
	si1_p1 = (si1 *) cps->parameters.keysample_buffer;
	for (i = n_samps - n_derivs; i--;) {
		if (*si1_p1 == CMP_SI1_KEYSAMPLE_FLAG_m12) {
			overflow_val = 0;
			++si1_p1;
			si1_p2 = (si1 *) &overflow_val;
			j = overflow_bytes; do {
				*si1_p2++ = *si1_p1++;
			} while (--j);
			if (overflow_val & sign_bit)
				overflow_val |= sign_bytes;
			*si4_p++ = overflow_val;
		} else {
			*si4_p++ = (si4) *si1_p1++;
		}
	}

	// integrate derivatives
	CMP_integrate_m12(cps);

	return;
}


void    CMP_PRED2_decode_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	TERN_m12	no_zero_counts, multiply_method;
	ui1		*comp_p, *ui1_p, prev_cat, overflow_bytes;
	ui1		*low_bound_high_byte_p, *high_bound_high_byte_p, *goal_bound_high_byte_p;
	ui1		*symbol_map[CMP_PRED_CATS_m12], *symbols;
	si1		*si1_p1, *si1_p2, *key_p;
	ui2		*bin_counts, *stats_entries, *count[CMP_PRED_CATS_m12], *tc;
	ui4		n_samps, n_derivs, n_keysample_bytes, total_stats_entries, sign_bit, sign_bytes;
	si4		*si4_p, *init_val_p, overflow_val;
	ui8		**minimum_range, **cumulative_count, *cc;
	ui8		low_bound, high_bound, prev_high_bound, goal_bound, range, target_cc;
	si8		i, j;
	sf8		average_steps, multiply_time;
	CMP_BLOCK_FIXED_HEADER_m12		*block_header;
	CMP_PRED_MODEL_FIXED_HEADER_m12		*PRED_header;
	HW_PERFORMANCE_SPECS_m12		*perf_specs;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
		
	// CMP decompress from block_header to decompressed_ptr
	block_header = cps->block_header;
	n_samps = block_header->number_of_samples;
	
	// zero samples, or only one value
	if (n_samps <= 1) {
		if (block_header->number_of_samples == 1)
			cps->decompressed_ptr[0] = *((si4 *) (cps->parameters.model_region + CMP_PRED_MODEL_FIXED_HEADER_BYTES_m12));
		cps->parameters.derivative_level = 0;
		return;
	}
	
	PRED_header = (CMP_PRED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
	n_derivs = PRED_header->derivative_level;
	n_keysample_bytes = PRED_header->number_of_keysample_bytes;
	stats_entries = PRED_header->numbers_of_statistics_bins;
	for (total_stats_entries = i = 0; i < CMP_PRED_CATS_m12; ++i)
		total_stats_entries += (ui4) stats_entries[i];
	
	// set parameters for return
	cps->parameters.derivative_level = n_derivs;
	
	// get block flags
	no_zero_counts = FALSE_m12;
	if (PRED_header->flags & CMP_PRED_FLAGS_NO_ZERO_COUNTS_MASK_m12)
		no_zero_counts = TRUE_m12;
	overflow_bytes = CMP_get_overflow_bytes_m12(cps, CMP_DECOMPRESSION_MODE_m12, CMP_PRED_COMPRESSION_m12);
	sign_bit = (ui4) 1 << ((overflow_bytes << 3) - 1);
	if (overflow_bytes == 4)
		sign_bytes = (ui4) 0;
	else  // Windows: shift of 32 bits is equated to shift of 0, so have to do this
		sign_bytes = (ui4) 0xFFFFFFFF << (overflow_bytes << 3);

	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->parameters.model_region + CMP_PRED_MODEL_FIXED_HEADER_BYTES_m12);
	for (i = 0; i < n_derivs; ++i)
		cps->decompressed_ptr[i] = *init_val_p++;

	// build symbol map, count arrays, & minimum ranges
	bin_counts = (ui2 *) init_val_p;
	symbols = (ui1 *) (bin_counts + total_stats_entries);
	cumulative_count = (ui8 **) cps->parameters.cumulative_count;
	minimum_range = (ui8 **) cps->parameters.minimum_range;
	for (i = 0; i < CMP_PRED_CATS_m12; ++i) {
		count[i] = bin_counts; bin_counts += stats_entries[i];
		symbol_map[i] = symbols; symbols += stats_entries[i];
		if (no_zero_counts == TRUE_m12) {  // TO DO: decide mapping scheme for unmapped symbols in symbol map
			// TO DO: copy count & symbol map to arrays with 256 elements
			for (j = stats_entries[i]; i < 256; ++i)
				count[i][j] = 1;
		}
		for (cumulative_count[i][0] = j = 0; j < stats_entries[i]; ++j) {
			cumulative_count[i][j + 1] = cumulative_count[i][j] + (ui8) count[i][j];
			minimum_range[i][j] = CMP_RED_TOTAL_COUNTS_m12 / count[i][j];
			if (CMP_RED_TOTAL_COUNTS_m12 > (count[i][j] * minimum_range[i][j]))
				++minimum_range[i][j];
		}
	}
	
	// determine decompression method
	perf_specs = &global_tables_m12->HW_params.performance_specs;
	if (perf_specs->integer_multiplications_per_sec == 0.0)
		HW_get_performance_specs_m12(FALSE_m12);
	for (average_steps = (sf8) 0.0, i = 0; i < CMP_PRED_CATS_m12; ++i) {
		tc = count[i];
		for (j = 0; j < stats_entries[i]; ++j)
			average_steps += (sf8) (j * (si8) tc[j]);
	}
	average_steps /= (sf8) (CMP_RED_TOTAL_COUNTS_m12 * CMP_PRED_CATS_m12);
	multiply_time = average_steps * perf_specs->nsecs_per_integer_multiplication;
	if (multiply_time < perf_specs->nsecs_per_integer_division)
		multiply_method = TRUE_m12;
	else
		multiply_method = FALSE_m12;

	// range decode
	key_p = cps->parameters.keysample_buffer;
	prev_high_bound = goal_bound = low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m12;
	comp_p = (ui1 *) block_header + block_header->total_header_bytes;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	goal_bound_high_byte_p = ((ui1 *) &goal_bound) + 5;
	ui1_p = goal_bound_high_byte_p;
	*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
	*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
	prev_cat = CMP_PRED_NIL_m12;
	
	if (multiply_method == TRUE_m12) {
		for (j = 0, i = n_keysample_bytes; i;) {
			while (range >= minimum_range[prev_cat][j]) {
				high_bound = low_bound + ((range * cumulative_count[prev_cat][j + 1]) >> 16);
				if (high_bound > goal_bound) {
					*key_p = symbol_map[prev_cat][j];
					if (!--i)
						goto PRED2_RANGE_DECODE_DONE_m12;
					range = high_bound - (low_bound = prev_high_bound);
					prev_cat = CMP_PRED_CAT_m12(*key_p); ++key_p;
					j = 0;
				} else {
					prev_high_bound = high_bound;
					++j;
				}
			}
			high_bound = low_bound + range;
			if (low_bound == high_bound || *low_bound_high_byte_p != *high_bound_high_byte_p) {
				ui1_p = goal_bound_high_byte_p;
				*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
				*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
				low_bound = 0;
				range = CMP_RED_MAXIMUM_RANGE_m12;
			} else {
				do {
					low_bound <<= 8;
					high_bound <<= 8;
					goal_bound = (goal_bound << 8) | (ui8) *comp_p++;
				} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
				low_bound &= CMP_RED_RANGE_MASK_m12;
				high_bound &= CMP_RED_RANGE_MASK_m12;
				goal_bound &= CMP_RED_RANGE_MASK_m12;
				range = high_bound - low_bound;
			}
			prev_high_bound = low_bound;
			if (j)
				prev_high_bound += (range * cumulative_count[prev_cat][j]) >> 16;
		}
	} else {  // division method
		for (j = 0, i = n_keysample_bytes; i;) {
			while (range >= minimum_range[prev_cat][j]) {
				high_bound = low_bound + ((range * cumulative_count[prev_cat][j + 1]) >> 16);
				if (high_bound > goal_bound) {
					*key_p = symbol_map[prev_cat][j];
					if (!--i)
						goto PRED2_RANGE_DECODE_DONE_m12;
					range = high_bound - (low_bound = prev_high_bound);
					prev_cat = CMP_PRED_CAT_m12(*key_p); ++key_p;
					target_cc =  ((goal_bound - low_bound) << 16) / range;
					cc = cumulative_count[prev_cat];
					for (j = 1; j < stats_entries[prev_cat]; ++j)
						if (target_cc <= cc[j])
							break;
					if (--j)
						prev_high_bound += (range * cumulative_count[prev_cat][j]) >> 16;
				} else {
					prev_high_bound = high_bound;
					++j;
				}
			}
			high_bound = low_bound + range;
			if (low_bound == high_bound || *low_bound_high_byte_p != *high_bound_high_byte_p) {
				ui1_p = goal_bound_high_byte_p;
				*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
				*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
				low_bound = 0;
				range = CMP_RED_MAXIMUM_RANGE_m12;
			} else {
				do {
					low_bound <<= 8;
					high_bound <<= 8;
					goal_bound = (goal_bound << 8) | (ui8) *comp_p++;
				} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
				low_bound &= CMP_RED_RANGE_MASK_m12;
				high_bound &= CMP_RED_RANGE_MASK_m12;
				goal_bound &= CMP_RED_RANGE_MASK_m12;
				range = high_bound - low_bound;
			}
			prev_high_bound = low_bound;
			target_cc =  ((goal_bound - low_bound) << 16) / range;
			cc = cumulative_count[prev_cat];
			for (j = 1; j < stats_entries[prev_cat]; ++j)
				if (target_cc <= cc[j])
					break;
			if (--j)
				prev_high_bound += (range * cumulative_count[prev_cat][j]) >> 16;
		}
	}
	PRED2_RANGE_DECODE_DONE_m12:

	// generate derivatives from keysample data
	si4_p = cps->decompressed_ptr + n_derivs;
	si1_p1 = (si1 *) cps->parameters.keysample_buffer;
	for (i = n_samps - n_derivs; i--;) {
		if (*si1_p1 == CMP_SI1_KEYSAMPLE_FLAG_m12) {
			overflow_val = 0;
			++si1_p1;
			si1_p2 = (si1 *) &overflow_val;
			j = overflow_bytes; do {
				*si1_p2++ = *si1_p1++;
			} while (--j);
			if (overflow_val & sign_bit)
				overflow_val |= sign_bytes;
			*si4_p++ = overflow_val;
		} else {
			*si4_p++ = (si4) *si1_p1++;
		}
	}

	// integrate derivatives
	CMP_integrate_m12(cps);

	return;
}


void    CMP_PRED1_encode_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	TERN_m12	no_zero_counts, use_raw;
	ui1		*low_bound_high_byte_p, *high_bound_high_byte_p, *ui1_p, prev_cat, n_derivs;
	ui1		*key_p, *comp_p, *symbols, **symbol_map, overflow_bytes;
	ui2		*bin_counts, *stats_entries;
	ui4		n_samps, n_keysamp_bytes, **count, n_deriv_samps, PRED_total_bytes, total_stats_entries, header_bytes;
	ui4		cat_total_counts[CMP_PRED_CATS_m12], goal_total_counts[CMP_PRED_CATS_m12], bin, fall_through_bytes, rem;
	si4		*deriv_p, *init_val_p, diff, bits_per_samp, raw_bits_per_samp;
	ui8		**cumulative_count, **minimum_range;
	ui8		range, high_bound, low_bound;
	si8		i, j, k, m, extra_counts, scaled_total_counts, MBE_data_bits;
	CMP_STATISTICS_BIN_m12			**sorted_count, temp_sorted_count;
	CMP_BLOCK_FIXED_HEADER_m12		*block_header;
	CMP_PRED_MODEL_FIXED_HEADER_m12		*PRED_header;
	CMP_MBE_MODEL_FIXED_HEADER_m12		*MBE_header;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// CMP compress from input_buffer to block_header
	
	// set algorithm block flag
	block_header = cps->block_header;
	block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
	block_header->block_flags |= CMP_BF_PRED1_ENCODING_MASK_m12;
	
	PRED_header = (CMP_PRED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
	n_samps = block_header->number_of_samples;
	PRED_header->flags = (ui1) 0;

	// zero or one or samples
	if (n_samps <= 1) {
		block_header->model_region_bytes = (ui2) CMP_PRED_MODEL_FIXED_HEADER_BYTES_m12;
		if (block_header->number_of_samples == 1) {
			*((si4 *) (cps->parameters.model_region + block_header->model_region_bytes)) = cps->input_buffer[0];  // note: no statistics
			block_header->model_region_bytes += sizeof(si4);
		}
		PRED_header->number_of_keysample_bytes = 0;
		PRED_header->derivative_level = 0;
		PRED_header->number_of_nil_statistics_bins = PRED_header->number_of_pos_statistics_bins = PRED_header->number_of_neg_statistics_bins = 0;
		block_header->total_header_bytes = (ui4) (cps->parameters.model_region - (ui1 *) block_header) + block_header->model_region_bytes;
		block_header->total_block_bytes = G_pad_m12((ui1 *) block_header, block_header->total_header_bytes, 8);
		return;
	}
	
	// calculate derivatives
	n_derivs = CMP_differentiate_m12(cps);

	// set up PRED arrays
	count = (ui4 **) cps->parameters.count;
	cumulative_count = (ui8 **) cps->parameters.cumulative_count;
	minimum_range = (ui8 **) cps->parameters.minimum_range;
	sorted_count = (CMP_STATISTICS_BIN_m12 **) cps->parameters.sorted_count;
	symbol_map = (ui1 **) cps->parameters.symbol_map;
	block_header = cps->block_header;

	// set model parameters
	PRED_header->derivative_level = n_derivs;
	no_zero_counts = FALSE_m12;
	if (cps->directives.no_zero_counts == TRUE_m12) {
		no_zero_counts = TRUE_m12;
		PRED_header->flags |= CMP_PRED_FLAGS_NO_ZERO_COUNTS_MASK_m12;
	}
	overflow_bytes = CMP_get_overflow_bytes_m12(cps, CMP_COMPRESSION_MODE_m12, CMP_PRED_COMPRESSION_m12);

	// generate count & build keysample array
	memset((void *) count[0], 0, CMP_RED_MAX_STATS_BINS_m12 * CMP_PRED_CATS_m12 * sizeof(ui4));
	key_p = (ui1 *) cps->parameters.keysample_buffer;
	deriv_p = cps->parameters.derivative_buffer + n_derivs;
	prev_cat = CMP_PRED_NIL_m12;
	n_deriv_samps = n_samps - (ui4) n_derivs;
	for (i = n_deriv_samps; i--;) {
		diff = *deriv_p++;
		if (diff < -127 || diff > 127) {
			ui1_p = (ui1 *) &diff;
			++count[prev_cat][*key_p++ = CMP_UI1_KEYSAMPLE_FLAG_m12];
			prev_cat = CMP_PRED_NEG_m12;
			j = overflow_bytes; do {
				++count[prev_cat][*key_p = *ui1_p++];
				prev_cat = CMP_PRED_CAT_m12(*key_p); ++key_p;  // do not increment within call to CAT
			} while (--j);
		} else {
			++count[prev_cat][*key_p = (ui1) diff];
			prev_cat = CMP_PRED_CAT_m12(*key_p); ++key_p;  // do not increment within call to CAT
		}
	}
	n_keysamp_bytes = (ui4) (key_p - (ui1 *) cps->parameters.keysample_buffer);
	
	// build sorted_count: interleave
	stats_entries = PRED_header->numbers_of_statistics_bins;
	for (total_stats_entries = i = 0; i < CMP_PRED_CATS_m12; ++i) {
		for (j = stats_entries[i] = 0, k = 255, m = 128; m--; ++j, --k) {
			if (count[i][j]) {
				sorted_count[i][stats_entries[i]].count = count[i][j];
				sorted_count[i][stats_entries[i]++].value = (si1) j;
			}
			if (count[i][k]) {
				sorted_count[i][stats_entries[i]].count = count[i][k];
				sorted_count[i][stats_entries[i]++].value = (si1) k;
			}
		}
		total_stats_entries += stats_entries[i];
	}

	// build sorted_count: bubble sort
	for (i = 0; i < CMP_PRED_CATS_m12; ++i) {
		m = stats_entries[i];
		do {
			for (j = 0, k = 1; k < m; ++k) {
				if (sorted_count[i][k - 1].count < sorted_count[i][k].count) {
					temp_sorted_count = sorted_count[i][k - 1];
					sorted_count[i][k - 1] = sorted_count[i][k];
					sorted_count[i][k] = temp_sorted_count;
					j = k;  // highest swap index
				}
			}
		} while ((m = j) > 1);
	}
	
	// get separate count for each category
	for (i = 0; i < CMP_PRED_CATS_m12; ++i)
		for (cat_total_counts[i] = j = 0; j < stats_entries[i]; ++j)
			cat_total_counts[i] += sorted_count[i][j].count;
	
	// scale count so that each category's total_counts equals (RED_TOTAL_COUNTS - 1)
	for (i = 0; i < CMP_PRED_CATS_m12; ++i) {
		goal_total_counts[i] = CMP_RED_TOTAL_COUNTS_m12 - 1;
		if (no_zero_counts == TRUE_m12)
			goal_total_counts[i] -= (256 - stats_entries[i]);  // reserve one count in each model category for all zero count bins
		// TO DO: decide mapping scheme for unmapped symbols in symbol map
	}

	for (i = 0; i < CMP_PRED_CATS_m12; ++i) {
		if (!stats_entries[i])
			continue;
		for (scaled_total_counts = j = 0; j < stats_entries[i]; ++j) {
			sorted_count[i][j].count = (ui4) (((((ui8) goal_total_counts[i] << 1) * (ui8) sorted_count[i][j].count) + (ui8) cat_total_counts[i]) / ((ui8) cat_total_counts[i] << 1));
			if (sorted_count[i][j].count == 0)
				sorted_count[i][j].count = 1;
			scaled_total_counts += (si8)sorted_count[i][j].count;
		}
		extra_counts = ((si8) goal_total_counts[i] - (si8) scaled_total_counts);
		if (extra_counts > 0) {
			do {
				for (j = 0; (j < stats_entries[i]) && extra_counts; ++j) {
					++sorted_count[i][j].count;
					--extra_counts;
				}
			} while (extra_counts);
		} else if (extra_counts < 0) {
			extra_counts = -extra_counts;
			do {
				for (j = stats_entries[i] - 1; (j >= 0) && extra_counts; --j) {
					if (sorted_count[i][j].count > 1) {
						--sorted_count[i][j].count;
						--extra_counts;
					}
				}
			} while (extra_counts);
		}
	}
	
	// build symbol maps, count arrays & minimum ranges
	for (i = 0; i < CMP_PRED_CATS_m12; ++i) {
		for (cumulative_count[i][0] = j = 0; j < stats_entries[i]; ++j) {
			symbol_map[i][(ui1) sorted_count[i][j].value] = (ui1) j;
			cumulative_count[i][j + 1] = cumulative_count[i][j] + (ui8) (count[i][j] = sorted_count[i][j].count);
			minimum_range[i][j] = CMP_RED_TOTAL_COUNTS_m12 / count[i][j];
			if (CMP_RED_TOTAL_COUNTS_m12 > (count[i][j] * minimum_range[i][j]))
				++minimum_range[i][j];
		}
	}
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->parameters.model_region + CMP_PRED_MODEL_FIXED_HEADER_BYTES_m12);
	for (i = 0; i < n_derivs; ++i)
		*init_val_p++ = cps->parameters.derivative_buffer[i];

	// write scaled counts & symbols into header
	bin_counts = (ui2 *) init_val_p;
	symbols = (ui1 *) (bin_counts + total_stats_entries);
	for (i = 0; i < CMP_PRED_CATS_m12; ++i) {
		for (j = 0; j < stats_entries[i]; ++j) {
			*bin_counts++ = (ui2) sorted_count[i][j].count;
			*symbols++ = sorted_count[i][j].value;
		}
	}
	
	// fill header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	block_header->model_region_bytes = (ui2) (ui2) (symbols - cps->parameters.model_region);
	block_header->total_header_bytes = (ui4) (symbols - (ui1 *) block_header);
	PRED_header->number_of_keysample_bytes = n_keysamp_bytes;
	
	// range encode
	key_p = (ui1 *) cps->parameters.keysample_buffer;
	comp_p = (ui1 *) block_header + block_header->total_header_bytes;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m12;
	prev_cat = CMP_PRED_NIL_m12;
	
	for (i = n_keysamp_bytes; i;) {
		for (; range >= minimum_range[prev_cat][bin = symbol_map[prev_cat][*key_p]]; key_p++) {
			high_bound = low_bound + ((range * cumulative_count[prev_cat][bin + 1]) >> 16);
			if (bin)
				low_bound += (range * cumulative_count[prev_cat][bin]) >> 16;
			range = high_bound - low_bound;
			if (!--i)
				break;
			prev_cat = CMP_PRED_CAT_m12(*key_p);
		}
		if ((*low_bound_high_byte_p != *high_bound_high_byte_p) || !i) {
			ui1_p = low_bound_high_byte_p;
			*comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--;
			*comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--;
			range = CMP_RED_MAXIMUM_RANGE_m12;
			low_bound = 0;
		} else {
			do {
				*comp_p++ = *low_bound_high_byte_p;
				low_bound <<= 8;
				high_bound <<= 8;
				range <<= 8;
			} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
			low_bound &= CMP_RED_RANGE_MASK_m12;
		}
	}
	
	// finish header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	PRED_total_bytes = (si8) (comp_p - (ui1 *) block_header);
	block_header->total_block_bytes = (ui4) G_pad_m12((ui1 *) block_header, PRED_total_bytes, 8);
	
	// calculate fall through encoding bytes
	if (cps->directives.fall_through_to_best_encoding == TRUE_m12) {
		for (raw_bits_per_samp = 0, i = (si8) cps->parameters.maximum_sample_value - (si8) cps->parameters.minimum_sample_value; i; i >>= 1)
			++raw_bits_per_samp;
		if (n_derivs) {
			for (bits_per_samp = 0, i = (si8) cps->parameters.maximum_difference_value - (si8) cps->parameters.minimum_difference_value; i; i >>= 1)
				++bits_per_samp;
			if (raw_bits_per_samp > bits_per_samp)  // this can happen in very noisy data
				use_raw = FALSE_m12;
			else
				use_raw = TRUE_m12;
		} else {
			use_raw = TRUE_m12;
		}
		if (use_raw == TRUE_m12) {
			bits_per_samp = raw_bits_per_samp;
			n_derivs = 0;
			n_deriv_samps = n_samps;
		}
		MBE_data_bits = (si8) n_deriv_samps * (si8) bits_per_samp;
		fall_through_bytes = (MBE_data_bits + 7) >> 3;
		header_bytes = cps->parameters.model_region - (ui1 *) block_header;  // fixed block bytes + variable region before model
		fall_through_bytes += header_bytes + CMP_MBE_MODEL_FIXED_HEADER_BYTES_m12 + (n_derivs * 4);
		if ((rem = fall_through_bytes & 7))  // pad bytes
			fall_through_bytes += 8 - rem;
		if (fall_through_bytes < block_header->total_block_bytes) {
			block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
			block_header->block_flags |= CMP_BF_MBE_ENCODING_MASK_m12;
			MBE_header = (CMP_MBE_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
			if (use_raw == TRUE_m12) {
				// cps->input_buffer = unchanged
				MBE_header->minimum_value = cps->parameters.minimum_sample_value;
				MBE_header->derivative_level = 0;
			} else {
				cps->input_buffer = cps->parameters.derivative_buffer;
				MBE_header->minimum_value = cps->parameters.minimum_difference_value;
				MBE_header->derivative_level = n_derivs;
			}
			MBE_header->bits_per_sample = bits_per_samp;
			MBE_header->flags = CMP_MBE_FLAGS_PREPROCESSED_MASK_m12;
			CMP_MBE_encode_m12(cps);
			return;
		}
	}

	return;
}


void    CMP_PRED2_encode_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	TERN_m12	no_zero_counts, use_raw;
	ui1		*low_bound_high_byte_p, *high_bound_high_byte_p, *ui1_p, prev_cat, n_derivs;
	ui1		*key_p, *comp_p, *symbols, **symbol_map, overflow_bytes;
	ui2		*bin_counts, *stats_entries;
	ui4		n_samps, n_keysamp_bytes, **count, n_deriv_samps, PRED_total_bytes, total_stats_entries, header_bytes;
	ui4		cat_total_counts[CMP_PRED_CATS_m12], goal_total_counts[CMP_PRED_CATS_m12], bin, fall_through_bytes, rem;
	si4		*deriv_p, *init_val_p, diff, bits_per_samp, raw_bits_per_samp;
	ui8		**cumulative_count, **minimum_range;
	ui8		range, high_bound, low_bound;
	si8		i, j, k, m, extra_counts, scaled_total_counts, MBE_data_bits;
	CMP_STATISTICS_BIN_m12			**sorted_count, temp_sorted_count;
	CMP_BLOCK_FIXED_HEADER_m12		*block_header;
	CMP_PRED_MODEL_FIXED_HEADER_m12		*PRED_header;
	CMP_MBE_MODEL_FIXED_HEADER_m12		*MBE_header;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// CMP compress from input_buffer to block_header
	
	// set algorithm block flag
	block_header = cps->block_header;
	block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
	block_header->block_flags |= CMP_BF_PRED2_ENCODING_MASK_m12;
	
	PRED_header = (CMP_PRED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
	n_samps = block_header->number_of_samples;
	PRED_header->flags = (ui1) 0;

	// zero or one or samples
	if (n_samps <= 1) {
		block_header->model_region_bytes = (ui2) CMP_PRED_MODEL_FIXED_HEADER_BYTES_m12;
		if (block_header->number_of_samples == 1) {
			*((si4 *) (cps->parameters.model_region + block_header->model_region_bytes)) = cps->input_buffer[0];  // note: no statistics
			block_header->model_region_bytes += sizeof(si4);
		}
		PRED_header->number_of_keysample_bytes = 0;
		PRED_header->derivative_level = 0;
		PRED_header->number_of_nil_statistics_bins = PRED_header->number_of_pos_statistics_bins = PRED_header->number_of_neg_statistics_bins = 0;
		block_header->total_header_bytes = (ui4) (cps->parameters.model_region - (ui1 *) block_header) + block_header->model_region_bytes;
		block_header->total_block_bytes = G_pad_m12((ui1 *) block_header, block_header->total_header_bytes, 8);
		return;
	}
	
	// calculate derivatives
	n_derivs = CMP_differentiate_m12(cps);

	// set up PRED arrays
	count = (ui4 **) cps->parameters.count;
	cumulative_count = (ui8 **) cps->parameters.cumulative_count;
	minimum_range = (ui8 **) cps->parameters.minimum_range;
	sorted_count = (CMP_STATISTICS_BIN_m12 **) cps->parameters.sorted_count;
	symbol_map = (ui1 **) cps->parameters.symbol_map;
	block_header = cps->block_header;

	// set model parameters
	PRED_header->derivative_level = n_derivs;
	no_zero_counts = FALSE_m12;
	if (cps->directives.no_zero_counts == TRUE_m12) {
		no_zero_counts = TRUE_m12;
		PRED_header->flags |= CMP_PRED_FLAGS_NO_ZERO_COUNTS_MASK_m12;
	}
	overflow_bytes = CMP_get_overflow_bytes_m12(cps, CMP_COMPRESSION_MODE_m12, CMP_PRED_COMPRESSION_m12);

	// generate count & build keysample array
	memset((void *) count[0], 0, CMP_RED_MAX_STATS_BINS_m12 * CMP_PRED_CATS_m12 * sizeof(ui4));
	key_p = (ui1 *) cps->parameters.keysample_buffer;
	deriv_p = cps->parameters.derivative_buffer + n_derivs;
	prev_cat = CMP_PRED_NIL_m12;
	n_deriv_samps = n_samps - (ui4) n_derivs;
	for (i = n_deriv_samps; i--;) {
		diff = *deriv_p++;
		if (diff < -127 || diff > 127) {
			ui1_p = (ui1 *) &diff;
			++count[prev_cat][*key_p++ = CMP_UI1_KEYSAMPLE_FLAG_m12];
			prev_cat = CMP_PRED_NEG_m12;
			j = overflow_bytes; do {
				++count[prev_cat][*key_p = *ui1_p++];
				prev_cat = CMP_PRED_CAT_m12(*key_p); ++key_p;  // do not increment within call to CAT
			} while (--j);
		} else {
			++count[prev_cat][*key_p = (ui1) diff];
			prev_cat = CMP_PRED_CAT_m12(*key_p); ++key_p;  // do not increment within call to CAT
		}
	}
	n_keysamp_bytes = (ui4) (key_p - (ui1 *) cps->parameters.keysample_buffer);
	
	// build sorted_count: interleave
	stats_entries = PRED_header->numbers_of_statistics_bins;
	for (total_stats_entries = i = 0; i < CMP_PRED_CATS_m12; ++i) {
		for (j = stats_entries[i] = 0, k = 255, m = 128; m--; ++j, --k) {
			if (count[i][j]) {
				sorted_count[i][stats_entries[i]].count = count[i][j];
				sorted_count[i][stats_entries[i]++].value = (si1) j;
			}
			if (count[i][k]) {
				sorted_count[i][stats_entries[i]].count = count[i][k];
				sorted_count[i][stats_entries[i]++].value = (si1) k;
			}
		}
		total_stats_entries += stats_entries[i];
	}

	// build sorted_count: bubble sort
	for (i = 0; i < CMP_PRED_CATS_m12; ++i) {
		m = stats_entries[i];
		do {
			for (j = 0, k = 1; k < m; ++k) {
				if (sorted_count[i][k - 1].count < sorted_count[i][k].count) {
					temp_sorted_count = sorted_count[i][k - 1];
					sorted_count[i][k - 1] = sorted_count[i][k];
					sorted_count[i][k] = temp_sorted_count;
					j = k;  // highest swap index
				}
			}
		} while ((m = j) > 1);
	}
	
	// get separate count for each category
	for (i = 0; i < CMP_PRED_CATS_m12; ++i)
		for (cat_total_counts[i] = j = 0; j < stats_entries[i]; ++j)
			cat_total_counts[i] += sorted_count[i][j].count;
	
	// scale count so that each category's total_counts equals (RED_TOTAL_COUNTS - 1)
	for (i = 0; i < CMP_PRED_CATS_m12; ++i) {
		goal_total_counts[i] = CMP_RED_TOTAL_COUNTS_m12 - 1;
		if (no_zero_counts == TRUE_m12)
			goal_total_counts[i] -= (256 - stats_entries[i]);  // reserve one count in each model category for all zero count bins
		// TO DO: decide mapping scheme for unmapped symbols in symbol map
	}

	for (i = 0; i < CMP_PRED_CATS_m12; ++i) {
		if (!stats_entries[i])
			continue;
		for (scaled_total_counts = j = 0; j < stats_entries[i]; ++j) {
			sorted_count[i][j].count = (ui4) (((((ui8) goal_total_counts[i] << 1) * (ui8) sorted_count[i][j].count) + (ui8) cat_total_counts[i]) / ((ui8) cat_total_counts[i] << 1));
			if (sorted_count[i][j].count == 0)
				sorted_count[i][j].count = 1;
			scaled_total_counts += (si8) sorted_count[i][j].count;
		}
		extra_counts = ((si8) goal_total_counts[i] - (si8) scaled_total_counts);
		if (extra_counts > 0) {
			do {
				for (j = 0; (j < stats_entries[i]) && extra_counts; ++j) {
					++sorted_count[i][j].count;
					--extra_counts;
				}
			} while (extra_counts);
		} else if (extra_counts < 0) {
			extra_counts = -extra_counts;
			do {
				for (j = stats_entries[i] - 1; (j >= 0) && extra_counts; --j) {
					if (sorted_count[i][j].count > 1) {
						--sorted_count[i][j].count;
						--extra_counts;
					}
				}
			} while (extra_counts);
		}
	}
	
	// build symbol maps, count arrays & minimum ranges
	for (i = 0; i < CMP_PRED_CATS_m12; ++i) {
		for (cumulative_count[i][0] = j = 0; j < stats_entries[i]; ++j) {
			symbol_map[i][(ui1) sorted_count[i][j].value] = (ui1) j;
			cumulative_count[i][j + 1] = cumulative_count[i][j] + (ui8) (count[i][j] = sorted_count[i][j].count);
			minimum_range[i][j] = CMP_RED_TOTAL_COUNTS_m12 / count[i][j];
			if (CMP_RED_TOTAL_COUNTS_m12 > (count[i][j] * minimum_range[i][j]))
				++minimum_range[i][j];
		}
	}
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->parameters.model_region + CMP_PRED_MODEL_FIXED_HEADER_BYTES_m12);
	for (i = 0; i < n_derivs; ++i)
		*init_val_p++ = cps->parameters.derivative_buffer[i];

	// write scaled counts & symbols into header
	bin_counts = (ui2 *) init_val_p;
	symbols = (ui1 *) (bin_counts + total_stats_entries);
	for (i = 0; i < CMP_PRED_CATS_m12; ++i) {
		for (j = 0; j < stats_entries[i]; ++j) {
			*bin_counts++ = (ui2) sorted_count[i][j].count;
			*symbols++ = sorted_count[i][j].value;
		}
	}
	
	// fill header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	block_header->model_region_bytes = (ui2) (ui2) (symbols - cps->parameters.model_region);
	block_header->total_header_bytes = (ui4) (symbols - (ui1 *) block_header);
	PRED_header->number_of_keysample_bytes = n_keysamp_bytes;
	
	// range encode
	key_p = (ui1 *) cps->parameters.keysample_buffer;
	comp_p = (ui1 *) block_header + block_header->total_header_bytes;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m12;
	prev_cat = CMP_PRED_NIL_m12;
	
	for (i = n_keysamp_bytes; i;) {
		for (; range >= minimum_range[prev_cat][bin = symbol_map[prev_cat][*key_p]]; key_p++) {
			high_bound = low_bound + ((range * cumulative_count[prev_cat][bin + 1]) >> 16);
			if (bin)
				low_bound += (range * cumulative_count[prev_cat][bin]) >> 16;
			range = high_bound - low_bound;
			if (!--i)
				break;
			prev_cat = CMP_PRED_CAT_m12(*key_p);
		}
		// full dump
		if (low_bound == high_bound || *low_bound_high_byte_p != *high_bound_high_byte_p || !i) {
			--high_bound;  // ensure goal < high bound on decode
			ui1_p = high_bound_high_byte_p;
			*comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--;
			*comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--;
			range = CMP_RED_MAXIMUM_RANGE_m12;
			low_bound = 0;
		} else {  // partial dump
			do {
				*comp_p++ = *high_bound_high_byte_p;
				low_bound <<= 8;
				high_bound <<= 8;
			} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
			low_bound &= CMP_RED_RANGE_MASK_m12;
			high_bound &= CMP_RED_RANGE_MASK_m12;
			range = high_bound - low_bound;
		}
	}
	
	// finish header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	PRED_total_bytes = (si8) (comp_p - (ui1 *) block_header);
	block_header->total_block_bytes = (ui4) G_pad_m12((ui1 *) block_header, PRED_total_bytes, 8);
	
	// calculate fall through encoding bytes
	if (cps->directives.fall_through_to_best_encoding == TRUE_m12) {
		for (raw_bits_per_samp = 0, i = (si8) cps->parameters.maximum_sample_value - (si8) cps->parameters.minimum_sample_value; i; i >>= 1)
			++raw_bits_per_samp;
		if (n_derivs) {
			for (bits_per_samp = 0, i = (si8) cps->parameters.maximum_difference_value - (si8) cps->parameters.minimum_difference_value; i; i >>= 1)
				++bits_per_samp;
			if (raw_bits_per_samp > bits_per_samp)  // this can happen in very noisy data
				use_raw = FALSE_m12;
			else
				use_raw = TRUE_m12;
		} else {
			use_raw = TRUE_m12;
		}
		if (use_raw == TRUE_m12) {
			bits_per_samp = raw_bits_per_samp;
			n_derivs = 0;
			n_deriv_samps = n_samps;
		}
		MBE_data_bits = (si8) n_deriv_samps * (si8) bits_per_samp;
		fall_through_bytes = (MBE_data_bits + 7) >> 3;
		header_bytes = cps->parameters.model_region - (ui1 *) block_header;  // fixed block bytes + variable region before model
		fall_through_bytes += header_bytes + CMP_MBE_MODEL_FIXED_HEADER_BYTES_m12 + (n_derivs * 4);
		if ((rem = fall_through_bytes & 7))  // pad bytes
			fall_through_bytes += 8 - rem;
		if (fall_through_bytes < block_header->total_block_bytes) {
			block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
			block_header->block_flags |= CMP_BF_MBE_ENCODING_MASK_m12;
			MBE_header = (CMP_MBE_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
			if (use_raw == TRUE_m12) {
				// cps->input_buffer = unchanged
				MBE_header->minimum_value = cps->parameters.minimum_sample_value;
				MBE_header->derivative_level = 0;
			} else {
				cps->input_buffer = cps->parameters.derivative_buffer;
				MBE_header->minimum_value = cps->parameters.minimum_difference_value;
				MBE_header->derivative_level = n_derivs;
			}
			MBE_header->bits_per_sample = bits_per_samp;
			MBE_header->flags = CMP_MBE_FLAGS_PREPROCESSED_MASK_m12;
			CMP_MBE_encode_m12(cps);
			return;
		}
	}

	return;
}


CMP_PROCESSING_STRUCT_m12	*CMP_reallocate_processing_struct_m12(FILE_PROCESSING_STRUCT_m12 *fps, ui4 mode, si8 data_samples, ui4 block_samples)
{
	TERN_m12			realloc_flag, freed;
	ui4				new_val;
	si4				i;
	si8				new_compressed_bytes, new_keysample_bytes, new_decompressed_samples;
	si8				mem_units_used, mem_units_avail, pad_samples;
	CHANNEL_m12			*chan;
	SESSION_m12			*sess;
	CMP_PROCESSING_STRUCT_m12 	*cps;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (fps->universal_header->type_code != TIME_SERIES_DATA_FILE_TYPE_CODE_m12) {
		G_error_message_m12("%s(): FPS must be time series data\n", __FUNCTION__);
		return(NULL);
	}
	cps = fps->parameters.cps;
	if (cps == NULL)
		return(NULL);
	
	realloc_flag = FALSE_m12;
	new_compressed_bytes = new_keysample_bytes = new_decompressed_samples = 0;
	
	if (cps->parameters.allocated_block_samples < block_samples)
		realloc_flag = TRUE_m12;
	
	switch (cps->directives.algorithm) {
		case CMP_RED_COMPRESSION_m12:
		case CMP_PRED_COMPRESSION_m12:
		case CMP_VDS_COMPRESSION_m12:
			new_val = CMP_MAX_KEYSAMPLE_BYTES_m12(block_samples);
			if (cps->parameters.allocated_keysample_bytes < new_val) {
				new_keysample_bytes = new_val;
				realloc_flag = TRUE_m12;
			}
			break;
	}
	
	switch (mode) {
		case CMP_COMPRESSION_MODE_m12:
			if (cps->parameters.allocated_compressed_bytes) {
				mem_units_used = (ui1 *) cps->block_header - fps->time_series_data;
				mem_units_avail = cps->parameters.allocated_compressed_bytes - mem_units_used;
				new_val = CMP_MAX_COMPRESSED_BYTES_m12(block_samples, 1);
				if (mem_units_avail < new_val) {
					new_compressed_bytes = new_val + mem_units_used;
					realloc_flag = TRUE_m12;
				}
			}
			if (cps->parameters.allocated_decompressed_samples) {
				mem_units_used = cps->decompressed_ptr - cps->decompressed_data;
				mem_units_avail = cps->parameters.allocated_decompressed_samples - mem_units_used;
				if (mem_units_avail < block_samples) {
					new_decompressed_samples = mem_units_used + block_samples;
					realloc_flag = TRUE_m12;
				}
			}
			break;
		case CMP_DECOMPRESSION_MODE_m12:
			if (cps->parameters.allocated_decompressed_samples != CMP_SELF_MANAGED_MEMORY_m12) {
				mem_units_used = cps->decompressed_ptr - cps->decompressed_data;
				mem_units_avail = cps->parameters.allocated_decompressed_samples - mem_units_used;
				if (mem_units_avail < data_samples) {
					new_decompressed_samples = mem_units_used + data_samples;
					realloc_flag = TRUE_m12;
				}
			}
			break;
		default:
			G_error_message_m12("%s(): No compression mode specified\n", __FUNCTION__);
			return(NULL);
	}
	
	if (realloc_flag == FALSE_m12)
		return(cps);

	// reallocate (free & alloc for speed - don't copy data)
	CMP_cps_mutex_on_m12(cps);
		
	if (new_compressed_bytes) // FPS_reallocate_processing_struct_m12() resets cps->block_header for time series data fps
		FPS_reallocate_processing_struct_m12(fps, new_compressed_bytes + UNIVERSAL_HEADER_BYTES_m12);
	
	if (new_keysample_bytes) {
		free_m12((void * ) cps->parameters.keysample_buffer, __FUNCTION__);
		if ((cps->parameters.keysample_buffer = (si1 *) calloc_m12((size_t) new_keysample_bytes, sizeof(ui1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12)) == NULL)
			goto CMP_REALLOC_CPS_FAIL_m12;
		cps->parameters.allocated_keysample_bytes = new_keysample_bytes;
	}
	
	if (new_decompressed_samples) {
		if (cps->decompressed_data != NULL)
			free_m12((void * ) cps->parameters.cache, __FUNCTION__);
		cps->decompressed_data = cps->decompressed_ptr = cps->parameters.cache = (si4 *) calloc_m12((size_t) new_decompressed_samples, sizeof(si4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		if (cps->decompressed_data == NULL)
			goto CMP_REALLOC_CPS_FAIL_m12;
		cps->parameters.allocated_decompressed_samples = new_decompressed_samples;
	}
		
	// reallocate the following if they were previously allocated
	if (cps->parameters.allocated_block_samples < block_samples) {
		if (cps->parameters.detrended_buffer != NULL) {
			free_m12((void * ) cps->parameters.detrended_buffer, __FUNCTION__);
			if ((cps->parameters.detrended_buffer = (si4 *) calloc_m12((size_t) block_samples, sizeof(si4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12)) == NULL)
				goto CMP_REALLOC_CPS_FAIL_m12;
		}
		if (cps->parameters.derivative_buffer != NULL) {
			free_m12((void * ) cps->parameters.derivative_buffer, __FUNCTION__);
			if ((cps->parameters.derivative_buffer = (si4 *) calloc_m12((size_t) block_samples, sizeof(si4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12)) == NULL)
				goto CMP_REALLOC_CPS_FAIL_m12;
		}
		if (cps->parameters.scaled_amplitude_buffer != NULL) {
			free_m12((void * ) cps->parameters.scaled_amplitude_buffer, __FUNCTION__);
			if ((cps->parameters.scaled_amplitude_buffer = (si4 *) calloc_m12((size_t) block_samples, sizeof(si4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12)) == NULL)
				goto CMP_REALLOC_CPS_FAIL_m12;
		}
		if (cps->parameters.scaled_frequency_buffer != NULL) {
			free_m12((void * ) cps->parameters.scaled_frequency_buffer, __FUNCTION__);
			if ((cps->parameters.scaled_frequency_buffer = (si4 *) calloc_m12((size_t) block_samples, sizeof(si4), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12)) == NULL)
				goto CMP_REALLOC_CPS_FAIL_m12;
		}
		if (cps->parameters.VDS_input_buffers != NULL) {
			if (mode == CMP_COMPRESSION_MODE_m12)
				pad_samples = CMP_VDS_LOWPASS_ORDER_m12 * 6;
			else
				pad_samples = CMP_MAK_PAD_SAMPLES_m12;
			CMP_allocate_buffers_m12(cps->parameters.VDS_input_buffers, CMP_VDS_INPUT_BUFFERS_m12, (si8) (block_samples + pad_samples), sizeof(sf8), FALSE_m12, FALSE_m12);
			CMP_allocate_buffers_m12(cps->parameters.VDS_output_buffers, CMP_VDS_OUTPUT_BUFFERS_m12, (si8) block_samples, sizeof(sf8), FALSE_m12, FALSE_m12);
		}
		cps->parameters.allocated_block_samples = block_samples;
	}
	
	CMP_cps_mutex_off_m12(cps);

	return(cps);
	
CMP_REALLOC_CPS_FAIL_m12:
	
	// try freeing caches on inactive channels
	chan = globals_m12->reference_channel;
	freed = FALSE_m12;
	if (chan) {
		sess = (SESSION_m12 *) chan;
		if (sess->type_code == LH_SESSION_m12) {
			for (i = 0; i < sess->number_of_time_series_channels; ++i) {
				chan = sess->time_series_channels[i];
				if (chan->type_code == LH_TIME_SERIES_CHANNEL_m12)
					if ((chan->flags & LH_CHANNEL_ACTIVE_m12) == 0)
						if (CMP_free_cache_m12(cps) == TRUE_m12)
							freed = TRUE_m12;
			}
		}
	}

	CMP_cps_mutex_off_m12(cps);

	if (freed == TRUE_m12) {
		cps = CMP_reallocate_processing_struct_m12(fps, mode, data_samples, block_samples);
		if (cps)
			return(cps);
	}
	
	return(NULL);
}


// Algorithm from Niklaus Wirth's book: "Algorithms + data structures = programs".
// Code here is adapted from code by Nicolas Devillard. Public domain.
sf8     CMP_quantval_m12(sf8 *x, si8 len, sf8 quantile, TERN_m12 preserve_input, sf8 *buff)
{
	TERN_m12        free_buff;
	sf8             q, fk, lo_p, lo_v, *lp, *mp, *last_mp, *lo_kp, *hi_kp;
	si8             lo_k;
	register sf8    v, t, *xip, *xjp;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (len == 1)
		return(*x);
	
	free_buff = FALSE_m12;
	if (preserve_input == TRUE_m12) {
		if (buff == NULL) {
			buff = (sf8 *) malloc((size_t) len << 3);
			free_buff = TRUE_m12;
		}
		memcpy((void *) buff, (void *) x, (size_t) (len << 3));
		x = buff;
	}
	
	if (quantile == (sf8)1.0) {
		lo_k = len - 2;
		lo_p = (sf8) 0.0;
	} else {
		fk = quantile * (sf8) (len - 1);
		lo_k = (si8) fk;
		lo_p = (sf8) 1.0 - (fk - (sf8) lo_k);
	}
	
	if (len == 2) {
		if (x[0] <= x[1])
			return((x[0] * lo_p) + (x[1] * (1.0 - lo_p)));
		return((x[1] * lo_p) + (x[0] * (1.0 - lo_p)));
	}
	
	lp = x;
	last_mp = mp = x + len - 1;
	lo_kp = x + lo_k;
	hi_kp = lo_kp + 1;
	while (lp < mp) {
		v = *lo_kp;
		xip = lp;
		xjp = mp;
		do {
			for (; *xip < v; ++xip);
			for (; v < *xjp; --xjp);
			if (xip <= xjp) {
				t = *xip;
				*xip++ = *xjp;
				*xjp-- = t;
			}
		} while (xip <= xjp);
		
		if (xjp < lo_kp)
			lp = xip;
		if (hi_kp < xip)
			last_mp = mp;
		if (lo_kp < xip)
			mp = xjp;
	}
	lo_v = *lo_kp;
	
	lp = lo_kp; mp = last_mp;
	while (lp < mp) {
		v = *hi_kp;
		xip = lp;
		xjp = mp;
		do {
			for (; *xip < v; ++xip);
			for (; v < *xjp; --xjp);
			if (xip <= xjp) {
				t = *xip;
				*xip++ = *xjp;
				*xjp-- = t;
			}
		} while (xip <= xjp);
		
		if (xjp < hi_kp)
			lp = xip;
		if (hi_kp < xip)
			mp = xjp;
	}
	
	q = (lo_v * lo_p) + (*hi_kp * ((sf8) 1.0 - lo_p));
	
	if (free_buff == TRUE_m12)
		free((void *) buff);
	
	return(q);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
ui1	CMP_random_byte_m12(ui4 *m_w, ui4 *m_z)
{
	ui1	rb;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// see fill_empty_password_bytes_m12() for initialization & usage
	
	*m_z = 0x00009069 * (*m_z & 0x0000FFFF) + (*m_z >> 0x10);
	*m_w = 0x00004650 * (*m_w & 0x0000FFFF) + (*m_w >> 0x10);
	rb = (ui1) (((*m_z << 0x10) + *m_w) % 0x00000100);
	
	return(rb);
}


void    CMP_rectify_m12(si4 *input_buffer, si4 *output_buffer, si8 len)
{
	si4        *si4_p1, *si4_p2;
	si8        i;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// rectify data from input_buffer to output_buffer
	// if input_buffer == output_buffer rectification will be done in place
	
	si4_p1 = input_buffer;
	si4_p2 = output_buffer;
	for (i = len; i--; ++si4_p1)
		*si4_p2++ = ABS_m12(*si4_p1);
	
	return;
}


void    CMP_RED1_decode_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	TERN_m12	pos_derivs, no_zero_counts;
	ui1		*comp_p, *low_bound_high_byte_p, *high_bound_high_byte_p, *goal_bound_high_byte_p;
	ui1		*ui1_p1, *ui1_p2, *symbol_map, n_derivs, overflow_bytes;
	si1		*si1_p1, *si1_p2, *key_p;
	ui2		*count;
	ui4		n_samps, n_keysample_bytes;
	si4		*si4_p, overflow_val, sign_bit, sign_bytes, *init_val_p;
	ui8		*minimum_range, *cumulative_count;
	ui8		low_bound, high_bound, prev_high_bound, goal_bound, range;
	si8		i, j, n_stats_entries;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	CMP_RED_MODEL_FIXED_HEADER_m12	*RED_header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// CMP decompress from block_header to decompressed_ptr
	block_header = cps->block_header;
	n_samps = block_header->number_of_samples;
	
	// zero or one or samples
	if (n_samps <= 1) {
		if (block_header->number_of_samples == 1)
			cps->decompressed_ptr[0] = *((si4 *) (cps->parameters.model_region + CMP_RED_MODEL_FIXED_HEADER_BYTES_m12));
		cps->parameters.derivative_level = 0;
		return;
	}

	RED_header = (CMP_RED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
	n_derivs = RED_header->derivative_level;
	n_keysample_bytes = RED_header->number_of_keysample_bytes;
	n_stats_entries = (si8) RED_header->number_of_statistics_bins;
	
	// set parameters for return
	cps->parameters.derivative_level = RED_header->derivative_level;
	
	// get block flags
	no_zero_counts = FALSE_m12;
	if (RED_header->flags & CMP_RED_FLAGS_NO_ZERO_COUNTS_MASK_m12)
		no_zero_counts = TRUE_m12;
	pos_derivs = FALSE_m12;
	if (RED_header->flags & CMP_RED_FLAGS_POSITIVE_DERIVATIVES_MASK_m12)
		pos_derivs = TRUE_m12;
	overflow_bytes = CMP_get_overflow_bytes_m12(cps, CMP_DECOMPRESSION_MODE_m12, CMP_RED_COMPRESSION_m12);
	sign_bit = (ui4) 1 << ((overflow_bytes << 3) - 1);
	if (overflow_bytes == 4)
		sign_bytes = (ui4) 0;
	else  // Windows: shift of 32 bits is equated to shift of 0, so have to do this
		sign_bytes = (ui4) 0xFFFFFFFF << (overflow_bytes << 3);
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->parameters.model_region + CMP_RED_MODEL_FIXED_HEADER_BYTES_m12);
	for (i = 0; i < n_derivs; ++i)
		cps->decompressed_ptr[i] = *init_val_p++;

	// build symbol map, count array, & minimum ranges
	count = (ui2 *) init_val_p;
	symbol_map = (ui1 *) (count + n_stats_entries);
	if (no_zero_counts == TRUE_m12) {  // TO DO: decide mapping scheme for unmapped symbols in symbol map
		for (i = n_stats_entries; i < 256; ++i)  // TO DO: copy count & symbol map to arrays with 256 elements
			count[i] = 1;
	}
	cumulative_count = (ui8 *) cps->parameters.cumulative_count;
	minimum_range = (ui8 *) cps->parameters.minimum_range;
	for (cumulative_count[0] = i = 0; i < n_stats_entries; ++i) {
		cumulative_count[i + 1] = cumulative_count[i] + (ui8) count[i];
		minimum_range[i] = CMP_RED_TOTAL_COUNTS_m12 / count[i];
		if (CMP_RED_TOTAL_COUNTS_m12 > (count[i] * minimum_range[i]))
			++minimum_range[i];
	}

	// range decode
	key_p = cps->parameters.keysample_buffer;
	prev_high_bound = goal_bound = low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m12;
	comp_p = symbol_map + n_stats_entries;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	goal_bound_high_byte_p = ((ui1 *) &goal_bound) + 5;
	ui1_p1 = goal_bound_high_byte_p;
	j = 6; do {
		*ui1_p1-- = *comp_p++;
	} while (--j);
	
	for (i = n_keysample_bytes; i;) {
		for (j = 0; range >= minimum_range[j];) {
			high_bound = low_bound + ((range * cumulative_count[j + 1]) >> 16);
			if (high_bound > goal_bound) {
				range = high_bound - (low_bound = prev_high_bound);
				*key_p = symbol_map[j];
				if (!--i)
					goto RED1_RANGE_DECODE_DONE_m12;
				++key_p;
				j = 0;
			} else {
				prev_high_bound = high_bound;
				++j;
			}
		}
		high_bound = low_bound + range;
		if (*low_bound_high_byte_p != *high_bound_high_byte_p) {
			ui1_p1 = goal_bound_high_byte_p;
			j = 6; do {
				*ui1_p1-- = *comp_p++;
			} while (--j);
			low_bound = 0;
			range = CMP_RED_MAXIMUM_RANGE_m12;
		} else {
			do {
				low_bound <<= 8;
				high_bound <<= 8;
				goal_bound = (goal_bound << 8) | (ui8) *comp_p++;
				range <<= 8;
			} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
			low_bound &= CMP_RED_RANGE_MASK_m12;
			goal_bound &= CMP_RED_RANGE_MASK_m12;
		}
		prev_high_bound = low_bound;
	} RED1_RANGE_DECODE_DONE_m12:
		
	// generate derivatives from keysample data
	si4_p = cps->decompressed_ptr + n_derivs;
	if (pos_derivs == TRUE_m12) {
		ui1_p1 = (ui1 *) cps->parameters.keysample_buffer;
		for (i = n_samps - n_derivs; i--;) {
			if (*ui1_p1 == CMP_POS_DERIV_KEYSAMPLE_FLAG_m12) {
				++ui1_p1;
				overflow_val = 0;
				ui1_p2 = (ui1 *) &overflow_val;
				j = overflow_bytes; do {
					*ui1_p2++ = *ui1_p1++;
				} while (--j);
				*si4_p++ = overflow_val;
			} else {
				*si4_p++ = (si4) *ui1_p1++;
			}
		}
	} else {
		si1_p1 = (si1 *) cps->parameters.keysample_buffer;
		for (i = n_samps - n_derivs; i--;) {
			if (*si1_p1 == CMP_SI1_KEYSAMPLE_FLAG_m12) {
				overflow_val = 0;
				++si1_p1;
				si1_p2 = (si1 *) &overflow_val;
				j = overflow_bytes; do {
					*si1_p2++ = *si1_p1++;
				} while (--j);
				if (overflow_val & sign_bit)
					overflow_val |= sign_bytes;
				*si4_p++ = overflow_val;
			} else {
				*si4_p++ = (si4) *si1_p1++;
			}
		}
	}
	
	// integrate derivatives
	CMP_integrate_m12(cps);
	
	return;
}


void    CMP_RED2_decode_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	TERN_m12	pos_derivs, no_zero_counts, multiply_method;
	ui1		*comp_p, *low_bound_high_byte_p, *high_bound_high_byte_p, *goal_bound_high_byte_p;
	ui1		*ui1_p1, *ui1_p2, *symbol_map, n_derivs, overflow_bytes;
	si1		*si1_p1, *si1_p2, *key_p;
	ui2		*count;
	ui4		n_samps, n_keysample_bytes;
	si4		*si4_p, overflow_val, sign_bit, sign_bytes, *init_val_p;
	ui8		*minimum_range, *cumulative_count;
	ui8		low_bound, high_bound, prev_high_bound, goal_bound, range, target_cc;
	si8		i, j, n_stats_entries;
	sf8		average_steps, multiply_time;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	CMP_RED_MODEL_FIXED_HEADER_m12	*RED_header;
	HW_PERFORMANCE_SPECS_m12		*perf_specs;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// CMP decompress from block_header to decompressed_ptr
	block_header = cps->block_header;
	n_samps = block_header->number_of_samples;
	
	// zero or one or samples
	if (n_samps <= 1) {
		if (block_header->number_of_samples == 1)
			cps->decompressed_ptr[0] = *((si4 *) (cps->parameters.model_region + CMP_RED_MODEL_FIXED_HEADER_BYTES_m12));
		cps->parameters.derivative_level = 0;
		return;
	}

	RED_header = (CMP_RED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
	n_derivs = RED_header->derivative_level;
	n_keysample_bytes = RED_header->number_of_keysample_bytes;
	n_stats_entries = (si8) RED_header->number_of_statistics_bins;
	
	// set parameters for return
	cps->parameters.derivative_level = RED_header->derivative_level;
	
	// get block flags
	no_zero_counts = FALSE_m12;
	if (RED_header->flags & CMP_RED_FLAGS_NO_ZERO_COUNTS_MASK_m12)
		no_zero_counts = TRUE_m12;
	pos_derivs = FALSE_m12;
	if (RED_header->flags & CMP_RED_FLAGS_POSITIVE_DERIVATIVES_MASK_m12)
		pos_derivs = TRUE_m12;
	overflow_bytes = CMP_get_overflow_bytes_m12(cps, CMP_DECOMPRESSION_MODE_m12, CMP_RED_COMPRESSION_m12);
	sign_bit = (ui4) 1 << ((overflow_bytes << 3) - 1);
	if (overflow_bytes == 4)
		sign_bytes = (ui4) 0;
	else  // Windows: shift of 32 bits is equated to shift of 0, so have to do this
		sign_bytes = (ui4) 0xFFFFFFFF << (overflow_bytes << 3);
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->parameters.model_region + CMP_RED_MODEL_FIXED_HEADER_BYTES_m12);
	for (i = 0; i < n_derivs; ++i)
		cps->decompressed_ptr[i] = *init_val_p++;

	// build symbol map, count array, & minimum ranges
	count = (ui2 *) init_val_p;
	symbol_map = (ui1 *) (count + n_stats_entries);
	if (no_zero_counts == TRUE_m12) {  // TO DO: decide mapping scheme for unmapped symbols in symbol map
		for (i = n_stats_entries; i < 256; ++i)  // TO DO: copy count & symbol map to arrays with 256 elements
			count[i] = 1;
	}
	cumulative_count = (ui8 *) cps->parameters.cumulative_count;
	minimum_range = (ui8 *) cps->parameters.minimum_range;
	for (cumulative_count[0] = i = 0; i < n_stats_entries; ++i) {
		cumulative_count[i + 1] = cumulative_count[i] + (ui8) count[i];
		minimum_range[i] = CMP_RED_TOTAL_COUNTS_m12 / count[i];
		if (CMP_RED_TOTAL_COUNTS_m12 > (count[i] * minimum_range[i]))
			++minimum_range[i];
	}

	// determine decompression method
	perf_specs = &global_tables_m12->HW_params.performance_specs;
	if (perf_specs->integer_multiplications_per_sec == 0.0)
		HW_get_performance_specs_m12(FALSE_m12);
	for (average_steps = (sf8) 0.0, i = 0; i < n_stats_entries; ++i)
		average_steps += (sf8) (i * (si8) count[i]);
	average_steps /= (sf8) CMP_RED_TOTAL_COUNTS_m12;
	multiply_time = average_steps * perf_specs->nsecs_per_integer_multiplication;
	if (multiply_time < perf_specs->nsecs_per_integer_division)
		multiply_method = TRUE_m12;
	else
		multiply_method = FALSE_m12;
	
	// range decode
	key_p = cps->parameters.keysample_buffer;
	prev_high_bound = goal_bound = low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m12;
	comp_p = symbol_map + n_stats_entries;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	goal_bound_high_byte_p = ((ui1 *) &goal_bound) + 5;
	ui1_p1 = goal_bound_high_byte_p;
	*ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++;
	*ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++;

	if (multiply_method == TRUE_m12) {
		for (j = 0, i = n_keysample_bytes; i;) {
			while (range >= minimum_range[j]) {
				high_bound = low_bound + ((range * cumulative_count[j + 1]) >> 16);
				if (high_bound > goal_bound) {
					*key_p++ = symbol_map[j];
					if (!--i)
						goto RED2_RANGE_DECODE_DONE_m12;
					range = high_bound - (low_bound = prev_high_bound);
					j = 0;
				} else {
					prev_high_bound = high_bound;
					++j;
				}
			}
			high_bound = low_bound + range;
			if (low_bound == high_bound || *low_bound_high_byte_p != *high_bound_high_byte_p) {
				ui1_p1 = goal_bound_high_byte_p;
				*ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++;
				*ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++;
				low_bound = 0;
				range = CMP_RED_MAXIMUM_RANGE_m12;
			} else {
				do {
					low_bound <<= 8;
					high_bound <<= 8;
					goal_bound = (goal_bound << 8) | (ui8) *comp_p++;
				} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
				low_bound &= CMP_RED_RANGE_MASK_m12;
				high_bound &= CMP_RED_RANGE_MASK_m12;
				goal_bound &= CMP_RED_RANGE_MASK_m12;
				range = high_bound - low_bound;
			}
			prev_high_bound = low_bound;
			if (j)
				prev_high_bound += (range * cumulative_count[j]) >> 16;
		}
	} else {  // division method
		for (j = 0, i = n_keysample_bytes; i;) {
			while (range >= minimum_range[j]) {
				high_bound = low_bound + ((range * cumulative_count[j + 1]) >> 16);
				if (high_bound > goal_bound) {
					*key_p++ = symbol_map[j];
					if (!--i)
						goto RED2_RANGE_DECODE_DONE_m12;
					range = high_bound - (low_bound = prev_high_bound);
					target_cc = ((goal_bound - low_bound) << 16) / range;
					for (j = 1; j < n_stats_entries; ++j)
						if (target_cc <= cumulative_count[j])
							break;
					if (--j)
						prev_high_bound += (range * cumulative_count[j]) >> 16;
				} else {
					prev_high_bound = high_bound;
					++j;
				}
			}
			high_bound = low_bound + range;
			if (low_bound == high_bound || *low_bound_high_byte_p != *high_bound_high_byte_p) {
				ui1_p1 = goal_bound_high_byte_p;
				*ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++;
				*ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++;
				low_bound = 0;
				range = CMP_RED_MAXIMUM_RANGE_m12;
			} else {
				do {
					low_bound <<= 8;
					high_bound <<= 8;
					goal_bound = (goal_bound << 8) | (ui8) *comp_p++;
				} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
				low_bound &= CMP_RED_RANGE_MASK_m12;
				high_bound &= CMP_RED_RANGE_MASK_m12;
				goal_bound &= CMP_RED_RANGE_MASK_m12;
				range = high_bound - low_bound;
			}
			prev_high_bound = low_bound;
			target_cc = ((goal_bound - low_bound) << 16) / range;
			for (j = 1; j < n_stats_entries; ++j)
				if (target_cc <= cumulative_count[j])
					break;
			if (--j)
				prev_high_bound += (range * cumulative_count[j]) >> 16;
		}
	}
	RED2_RANGE_DECODE_DONE_m12:
		
	// generate derivatives from keysample data
	si4_p = cps->decompressed_ptr + n_derivs;
	if (pos_derivs == TRUE_m12) {
		ui1_p1 = (ui1 *) cps->parameters.keysample_buffer;
		for (i = n_samps - n_derivs; i--;) {
			if (*ui1_p1 == CMP_POS_DERIV_KEYSAMPLE_FLAG_m12) {
				++ui1_p1;
				overflow_val = 0;
				ui1_p2 = (ui1 *) &overflow_val;
				j = overflow_bytes; do {
					*ui1_p2++ = *ui1_p1++;
				} while (--j);
				*si4_p++ = overflow_val;
			} else {
				*si4_p++ = (si4) *ui1_p1++;
			}
		}
	} else {
		si1_p1 = (si1 *) cps->parameters.keysample_buffer;
		for (i = n_samps - n_derivs; i--;) {
			if (*si1_p1 == CMP_SI1_KEYSAMPLE_FLAG_m12) {
				overflow_val = 0;
				++si1_p1;
				si1_p2 = (si1 *) &overflow_val;
				j = overflow_bytes; do {
					*si1_p2++ = *si1_p1++;
				} while (--j);
				if (overflow_val & sign_bit)
					overflow_val |= sign_bytes;
				*si4_p++ = overflow_val;
			} else {
				*si4_p++ = (si4) *si1_p1++;
			}
		}
	}
	
	// integrate derivatives
	CMP_integrate_m12(cps);
	
	return;
}


void    CMP_RED1_encode_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	TERN_m12	pos_derivs, no_zero_counts, use_raw;
	ui1		*low_bound_high_byte_p, *high_bound_high_byte_p, *ui1_p, ks_flag;
	ui1		*key_p, n_derivs, *comp_p, *symbols, *symbol_map, overflow_bytes;
	ui2		*bin_counts;
	ui4		*count, n_keysamp_bytes, RED_total_bytes, header_bytes;
	ui4		n_samps, n_deriv_samps, goal_total_counts, bin, fall_through_bytes, rem;
	si4		*deriv_p, *init_val_p, diff, bits_per_samp, raw_bits_per_samp;
	si4		low_d, high_d;
	ui8		*cumulative_count, *minimum_range;
	ui8		total_counts, range, high_bound, low_bound;
	si8		i, j, k, n_stats_entries, extra_counts, scaled_total_counts, MBE_data_bits;
	CMP_STATISTICS_BIN_m12		*sorted_count, temp_sorted_count;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	CMP_RED_MODEL_FIXED_HEADER_m12	*RED_header;
	CMP_MBE_MODEL_FIXED_HEADER_m12	*MBE_header;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// compress from input_buffer to block_header
	
	// set algorithm block flag
	block_header = cps->block_header;
	block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
	block_header->block_flags |= CMP_BF_RED1_ENCODING_MASK_m12;

	RED_header = (CMP_RED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
	n_samps = block_header->number_of_samples;
	RED_header->flags = (ui1) 0;

	// zero or one or samples
	if (n_samps <= 1) {
		block_header->model_region_bytes = (ui2) CMP_RED_MODEL_FIXED_HEADER_BYTES_m12;
		if (block_header->number_of_samples == 1) {
			*((si4 *) (cps->parameters.model_region + block_header->model_region_bytes)) = cps->input_buffer[0];  // note: no statistics
			block_header->model_region_bytes += sizeof(si4);
		}
		RED_header->number_of_keysample_bytes = 0;
		RED_header->derivative_level = 0;
		RED_header->number_of_statistics_bins = 0;
		block_header->total_header_bytes = (ui4) (cps->parameters.model_region - (ui1 *) block_header) + block_header->model_region_bytes;
		block_header->total_block_bytes = G_pad_m12((ui1 *) block_header, block_header->total_header_bytes, 8);
		return;
	}

	// calculate derivatives
	n_derivs = CMP_differentiate_m12(cps);

	// set up RED arrays
	count = (ui4 *) cps->parameters.count;
	cumulative_count = (ui8 *) cps->parameters.cumulative_count;
	minimum_range = (ui8 *) cps->parameters.minimum_range;
	sorted_count = (CMP_STATISTICS_BIN_m12 *) cps->parameters.sorted_count;
	symbol_map = (ui1 *) cps->parameters.symbol_map;
	block_header = cps->block_header;

	// set model parameters
	RED_header->derivative_level = n_derivs;
	pos_derivs = FALSE_m12;
	if (n_derivs && cps->parameters.minimum_difference_value > 0) {
		pos_derivs = TRUE_m12;
		RED_header->flags |= CMP_RED_FLAGS_POSITIVE_DERIVATIVES_MASK_m12;
	}
	no_zero_counts = FALSE_m12;
	if (cps->directives.no_zero_counts == TRUE_m12) {
		no_zero_counts = TRUE_m12;
		RED_header->flags |= CMP_RED_FLAGS_NO_ZERO_COUNTS_MASK_m12;
	}
	overflow_bytes = CMP_get_overflow_bytes_m12(cps, CMP_COMPRESSION_MODE_m12, CMP_RED_COMPRESSION_m12);

	// generate count & build keysample array
	if (pos_derivs == TRUE_m12) {
		low_d = 1; high_d = 255;
		ks_flag = CMP_POS_DERIV_KEYSAMPLE_FLAG_m12;  // == 0 (non-overflow range: 1 to 255)
	} else {
		low_d = -127; high_d = 127;
		ks_flag = CMP_UI1_KEYSAMPLE_FLAG_m12;  // == -128 (non-overflow range: -127 to +127)
	}
	memset((void *) count, 0, CMP_RED_MAX_STATS_BINS_m12 * sizeof(ui4));
	
	key_p = (ui1 *) cps->parameters.keysample_buffer;
	deriv_p = cps->parameters.derivative_buffer + n_derivs;
	n_deriv_samps = n_samps - n_derivs;
	for (i = n_deriv_samps; i--;) {
		diff = *deriv_p++;
		if (diff < low_d || diff > high_d) {
			ui1_p = (ui1 *) &diff;
			++count[*key_p++ = ks_flag];
			j = overflow_bytes; do {
				++count[*key_p++ = *ui1_p++];
			} while (--j);
		} else {
			++count[*key_p++ = (ui1) diff];
		}
	}
	n_keysamp_bytes = (ui4) (key_p - (ui1 *) cps->parameters.keysample_buffer);

	// build sorted_count
	if (pos_derivs == TRUE_m12) {
		for (i = n_stats_entries = 0; i < 256; ++i) {
			if (count[i]) {
				sorted_count[n_stats_entries].count = count[i];
				sorted_count[n_stats_entries++].pos_value = (ui1) i;
			}
		}
	} else {  // pos_derivs == FALSE_m12: interleave (to speed up sort)
		for (i = n_stats_entries = 0, j = 255, k = 128; k--; ++i, --j) {
			if (count[i]) {
				sorted_count[n_stats_entries].count = count[i];
				sorted_count[n_stats_entries++].value = (si1) i;
			}
			if (count[j]) {
				sorted_count[n_stats_entries].count = count[j];
				sorted_count[n_stats_entries++].value = (si1) j;
			}
		}
	}
	RED_header->number_of_statistics_bins = (ui2) n_stats_entries;
	
	// build sorted_count: bubble sort
	i = n_stats_entries;
	do {
		for (j = 0, k = 1; k < i; ++k) {
			if (sorted_count[k - 1].count < sorted_count[k].count) {
				temp_sorted_count = sorted_count[k - 1];
				sorted_count[k - 1] = sorted_count[k];
				sorted_count[k] = temp_sorted_count;
				j = k;  // highest swap index
			}
		}
	} while ((i = j) > 1);
		
	// scale count so that total counts equals (RED_TOTAL_COUNTS - 1)
	goal_total_counts = CMP_RED_TOTAL_COUNTS_m12 - 1;
	if (no_zero_counts == TRUE_m12) {
		goal_total_counts -= (256 - n_stats_entries); // reserve one count in model for all zero count bins
		// TO DO: decide mapping scheme for unmapped symbols in symbol map
	}
	total_counts = (ui8) n_keysamp_bytes;
	for (scaled_total_counts = i = 0; i < n_stats_entries; ++i) {
		sorted_count[i].count = (ui4) (((((ui8) goal_total_counts << 1) * (ui8) sorted_count[i].count) + total_counts) / (total_counts << 1));
		if (sorted_count[i].count == 0)
			sorted_count[i].count = 1;
		scaled_total_counts += (si8) sorted_count[i].count;
	}
	extra_counts = ((si8) goal_total_counts - (si8) scaled_total_counts);
	if (extra_counts > 0) {
		do {
			for (i = 0; (i < n_stats_entries) && extra_counts; ++i) {
				++sorted_count[i].count;
				--extra_counts;
			}
		} while (extra_counts);
	} else if (extra_counts < 0) {
		extra_counts = -extra_counts;
		do {
			for (i = n_stats_entries - 1; (i >= 0) && extra_counts; --i) {
				if (sorted_count[i].count > 1) {
					--sorted_count[i].count;
					--extra_counts;
				}
			}
		} while (extra_counts);
	}
	
	// build symbol map, count array & minimum ranges
	for (cumulative_count[0] = i = 0; i < n_stats_entries; ++i) {
		symbol_map[sorted_count[i].pos_value] = (ui1) i;
		cumulative_count[i + 1] = cumulative_count[i] + (ui8) (count[i] = sorted_count[i].count);
		minimum_range[i] = CMP_RED_TOTAL_COUNTS_m12 / count[i];
		if (CMP_RED_TOTAL_COUNTS_m12 > (count[i] * minimum_range[i]))
			++minimum_range[i];
	}
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->parameters.model_region + CMP_RED_MODEL_FIXED_HEADER_BYTES_m12);
	for (i = 0; i < n_derivs; ++i)
		*init_val_p++ = cps->parameters.derivative_buffer[i];

	// write scaled counts & symbols into header
	bin_counts = (ui2 *) init_val_p;
	symbols = (ui1 *) (bin_counts + n_stats_entries);
	for (i = 0; i < n_stats_entries; ++i) {
		*bin_counts++ = (ui2) sorted_count[i].count;
		*symbols++ = sorted_count[i].value;
	}
	
	// fill header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	block_header->model_region_bytes = (ui2) (symbols - cps->parameters.model_region);
	block_header->total_header_bytes = (ui4) (symbols - (ui1 *) block_header);
	RED_header->number_of_keysample_bytes = n_keysamp_bytes;

	// range encode
	key_p = (ui1 *) cps->parameters.keysample_buffer;
	comp_p = symbols;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m12;
	
	for (i = n_keysamp_bytes; i;) {
		for (; range >= minimum_range[bin = symbol_map[*key_p]]; key_p++) {
			high_bound = low_bound + ((range * cumulative_count[bin + 1]) >> 16);
			if (bin)
				low_bound += (range * cumulative_count[bin]) >> 16;
			range = high_bound - low_bound;
			if (!--i)
				break;
		}
		if ((*low_bound_high_byte_p != *high_bound_high_byte_p) || !i) {
			ui1_p = low_bound_high_byte_p;
			j = 6; do {
				*comp_p++ = *ui1_p--;
			} while (--j);
			range = CMP_RED_MAXIMUM_RANGE_m12;
			low_bound = 0;
		} else {
			do {
				*comp_p++ = *low_bound_high_byte_p;
				low_bound <<= 8;
				high_bound <<= 8;
				range <<= 8;
			} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
			low_bound &= CMP_RED_RANGE_MASK_m12;
		}
	}
		
	// finish header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	RED_total_bytes = (si8) (comp_p - (ui1 *) block_header);
	block_header->total_block_bytes = (ui4) G_pad_m12((ui1 *) block_header, RED_total_bytes, 8);
	
	// calculate fall through encoding bytes
	if (cps->directives.fall_through_to_best_encoding == TRUE_m12) {
		for (raw_bits_per_samp = 0, i = (si8) cps->parameters.maximum_sample_value - (si8) cps->parameters.minimum_sample_value; i; i >>= 1)
			++raw_bits_per_samp;
		if (n_derivs) {
			for (bits_per_samp = 0, i = (si8) cps->parameters.maximum_difference_value - (si8) cps->parameters.minimum_difference_value; i; i >>= 1)
				++bits_per_samp;
			if (raw_bits_per_samp > bits_per_samp)  // this can happen in very noisy data
				use_raw = FALSE_m12;
			else
				use_raw = TRUE_m12;
		} else {
			use_raw = TRUE_m12;
		}
		if (use_raw == TRUE_m12) {
			bits_per_samp = raw_bits_per_samp;
			n_derivs = 0;
			n_deriv_samps = n_samps;
		}
		MBE_data_bits = (si8) n_deriv_samps * (si8) bits_per_samp;
		fall_through_bytes = (MBE_data_bits + 7) >> 3;
		header_bytes = cps->parameters.model_region - (ui1 *) block_header;  // fixed block bytes + variable region before model
		fall_through_bytes += header_bytes + CMP_MBE_MODEL_FIXED_HEADER_BYTES_m12 + (n_derivs * 4);
		if ((rem = fall_through_bytes & 7))  // pad bytes
			fall_through_bytes += 8 - rem;
		if (fall_through_bytes < block_header->total_block_bytes) {
			block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
			block_header->block_flags |= CMP_BF_MBE_ENCODING_MASK_m12;
			MBE_header = (CMP_MBE_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
			if (use_raw == TRUE_m12) {
				// cps->input_buffer = unchanged
				MBE_header->minimum_value = cps->parameters.minimum_sample_value;
				MBE_header->derivative_level = 0;
			} else {
				cps->input_buffer = cps->parameters.derivative_buffer;
				MBE_header->minimum_value = cps->parameters.minimum_difference_value;
				MBE_header->derivative_level = n_derivs;
			}
			MBE_header->bits_per_sample = bits_per_samp;
			MBE_header->flags = CMP_MBE_FLAGS_PREPROCESSED_MASK_m12;
			CMP_MBE_encode_m12(cps);
			return;
		}
	}
		
	return;
}


void    CMP_RED2_encode_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	TERN_m12	pos_derivs, no_zero_counts, use_raw;
	ui1		*low_bound_high_byte_p, *high_bound_high_byte_p, *ui1_p, ks_flag;
	ui1		*key_p, n_derivs, *comp_p, *symbols, *symbol_map, overflow_bytes;
	ui2		*bin_counts;
	ui4		*count, n_keysamp_bytes, RED_total_bytes, header_bytes;
	ui4		n_samps, n_deriv_samps, goal_total_counts, bin, fall_through_bytes, rem;
	si4		*deriv_p, *init_val_p, diff, bits_per_samp, raw_bits_per_samp;
	si4		low_d, high_d;
	ui8		*cumulative_count, *minimum_range;
	ui8		total_counts, range, high_bound, low_bound;
	si8		i, j, k, n_stats_entries, extra_counts, scaled_total_counts, MBE_data_bits;
	CMP_STATISTICS_BIN_m12		*sorted_count, temp_sorted_count;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	CMP_RED_MODEL_FIXED_HEADER_m12	*RED_header;
	CMP_MBE_MODEL_FIXED_HEADER_m12	*MBE_header;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// compress from input_buffer to block_header
	
	// set algorithm block flag
	block_header = cps->block_header;
	block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
	block_header->block_flags |= CMP_BF_RED2_ENCODING_MASK_m12;

	RED_header = (CMP_RED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
	n_samps = block_header->number_of_samples;
	RED_header->flags = (ui1) 0;

	// zero or one or samples
	if (n_samps <= 1) {
		block_header->model_region_bytes = (ui2) CMP_RED_MODEL_FIXED_HEADER_BYTES_m12;
		if (block_header->number_of_samples == 1) {
			*((si4 *) (cps->parameters.model_region + block_header->model_region_bytes)) = cps->input_buffer[0];  // note: no statistics
			block_header->model_region_bytes += sizeof(si4);
		}
		RED_header->number_of_keysample_bytes = 0;
		RED_header->derivative_level = 0;
		RED_header->number_of_statistics_bins = 0;
		block_header->total_header_bytes = (ui4) (cps->parameters.model_region - (ui1 *) block_header) + block_header->model_region_bytes;
		block_header->total_block_bytes = G_pad_m12((ui1 *) block_header, block_header->total_header_bytes, 8);
		return;
	}

	// calculate derivatives
	n_derivs = CMP_differentiate_m12(cps);

	// set up RED arrays
	count = (ui4 *) cps->parameters.count;
	cumulative_count = (ui8 *) cps->parameters.cumulative_count;
	minimum_range = (ui8 *) cps->parameters.minimum_range;
	sorted_count = (CMP_STATISTICS_BIN_m12 *) cps->parameters.sorted_count;
	symbol_map = (ui1 *) cps->parameters.symbol_map;
	block_header = cps->block_header;

	// set model parameters
	RED_header->derivative_level = n_derivs;
	pos_derivs = FALSE_m12;
	if (n_derivs && cps->parameters.minimum_difference_value > 0) {
		pos_derivs = TRUE_m12;
		RED_header->flags |= CMP_RED_FLAGS_POSITIVE_DERIVATIVES_MASK_m12;
	}
	no_zero_counts = FALSE_m12;
	if (cps->directives.no_zero_counts == TRUE_m12) {
		no_zero_counts = TRUE_m12;
		RED_header->flags |= CMP_RED_FLAGS_NO_ZERO_COUNTS_MASK_m12;
	}
	overflow_bytes = CMP_get_overflow_bytes_m12(cps, CMP_COMPRESSION_MODE_m12, CMP_RED_COMPRESSION_m12);

	// generate count & build keysample array
	if (pos_derivs == TRUE_m12) {
		low_d = 1; high_d = 255;
		ks_flag = CMP_POS_DERIV_KEYSAMPLE_FLAG_m12;  // == 0 (non-overflow range: 1 to 255)
	} else {
		low_d = -127; high_d = 127;
		ks_flag = CMP_UI1_KEYSAMPLE_FLAG_m12;  // == -128 (non-overflow range: -127 to +127)
	}
	memset((void *) count, 0, CMP_RED_MAX_STATS_BINS_m12 * sizeof(ui4));
	
	key_p = (ui1 *) cps->parameters.keysample_buffer;
	deriv_p = cps->parameters.derivative_buffer + n_derivs;
	n_deriv_samps = n_samps - n_derivs;
	for (i = n_deriv_samps; i--;) {
		diff = *deriv_p++;
		if (diff < low_d || diff > high_d) {
			ui1_p = (ui1 *) &diff;
			++count[*key_p++ = ks_flag];
			j = overflow_bytes; do {
				++count[*key_p++ = *ui1_p++];
			} while (--j);
		} else {
			++count[*key_p++ = (ui1) diff];
		}
	}
	n_keysamp_bytes = (ui4) (key_p - (ui1 *) cps->parameters.keysample_buffer);

	// build sorted_count
	if (pos_derivs == TRUE_m12) {
		for (i = n_stats_entries = 0; i < 256; ++i) {
			if (count[i]) {
				sorted_count[n_stats_entries].count = count[i];
				sorted_count[n_stats_entries++].pos_value = (ui1) i;
			}
		}
	} else {  // pos_derivs == FALSE_m12: interleave (to speed up sort)
		for (i = n_stats_entries = 0, j = 255, k = 128; k--; ++i, --j) {
			if (count[i]) {
				sorted_count[n_stats_entries].count = count[i];
				sorted_count[n_stats_entries++].value = (si1) i;
			}
			if (count[j]) {
				sorted_count[n_stats_entries].count = count[j];
				sorted_count[n_stats_entries++].value = (si1) j;
			}
		}
	}
	RED_header->number_of_statistics_bins = (ui2) n_stats_entries;
	
	// build sorted_count: bubble sort
	i = n_stats_entries;
	do {
		for (j = 0, k = 1; k < i; ++k) {
			if (sorted_count[k - 1].count < sorted_count[k].count) {
				temp_sorted_count = sorted_count[k - 1];
				sorted_count[k - 1] = sorted_count[k];
				sorted_count[k] = temp_sorted_count;
				j = k;  // highest swap index
			}
		}
	} while ((i = j) > 1);
		
	// scale count so that total counts equals (RED_TOTAL_COUNTS - 1)
	goal_total_counts = CMP_RED_TOTAL_COUNTS_m12 - 1;
	if (no_zero_counts == TRUE_m12) {
		goal_total_counts -= (256 - n_stats_entries); // reserve one count in model for all zero count bins
		// TO DO: decide mapping scheme for unmapped symbols in symbol map
	}
	total_counts = (ui8) n_keysamp_bytes;
	for (scaled_total_counts = i = 0; i < n_stats_entries; ++i) {
		sorted_count[i].count = (ui4) (((((ui8) goal_total_counts << 1) * (ui8) sorted_count[i].count) + total_counts) / (total_counts << 1));
		if (sorted_count[i].count == 0)
			sorted_count[i].count = 1;
		scaled_total_counts += (si8) sorted_count[i].count;
	}
	extra_counts = ((si8) goal_total_counts - (si8) scaled_total_counts);
	if (extra_counts > 0) {
		do {
			for (i = 0; (i < n_stats_entries) && extra_counts; ++i) {
				++sorted_count[i].count;
				--extra_counts;
			}
		} while (extra_counts);
	} else if (extra_counts < 0) {
		extra_counts = -extra_counts;
		do {
			for (i = n_stats_entries - 1; (i >= 0) && extra_counts; --i) {
				if (sorted_count[i].count > 1) {
					--sorted_count[i].count;
					--extra_counts;
				}
			}
		} while (extra_counts);
	}
	
	// build symbol map, count array & minimum ranges
	for (cumulative_count[0] = i = 0; i < n_stats_entries; ++i) {
		symbol_map[sorted_count[i].pos_value] = (ui1) i;
		cumulative_count[i + 1] = cumulative_count[i] + (ui8) (count[i] = sorted_count[i].count);
		minimum_range[i] = CMP_RED_TOTAL_COUNTS_m12 / count[i];
		if (CMP_RED_TOTAL_COUNTS_m12 > (count[i] * minimum_range[i]))
			++minimum_range[i];
	}
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->parameters.model_region + CMP_RED_MODEL_FIXED_HEADER_BYTES_m12);
	for (i = 0; i < n_derivs; ++i)
		*init_val_p++ = cps->parameters.derivative_buffer[i];

	// write scaled counts & symbols into header
	bin_counts = (ui2 *) init_val_p;
	symbols = (ui1 *) (bin_counts + n_stats_entries);
	for (i = 0; i < n_stats_entries; ++i) {
		*bin_counts++ = (ui2) sorted_count[i].count;
		*symbols++ = sorted_count[i].value;
	}
	
	// fill header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	block_header->model_region_bytes = (ui2) (symbols - cps->parameters.model_region);
	block_header->total_header_bytes = (ui4) (symbols - (ui1 *) block_header);
	RED_header->number_of_keysample_bytes = n_keysamp_bytes;

	// range encode
	key_p = (ui1 *) cps->parameters.keysample_buffer;
	comp_p = symbols;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m12;
	
	for (i = n_keysamp_bytes; i;) {
		for (; range >= minimum_range[bin = symbol_map[*key_p]]; key_p++) {
			high_bound = low_bound + ((range * cumulative_count[bin + 1]) >> 16);
			if (bin)
				low_bound += (range * cumulative_count[bin]) >> 16;
			range = high_bound - low_bound;
			if (!--i)
				break;
		}
		// full dump
		if (low_bound == high_bound || *low_bound_high_byte_p != *high_bound_high_byte_p || !i) {
			--high_bound;  // ensure goal < high bound on decode
			ui1_p = high_bound_high_byte_p;
			*comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--;
			*comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--;
			range = CMP_RED_MAXIMUM_RANGE_m12;
			low_bound = 0;
		} else {  // partial dump
			do {
				*comp_p++ = *high_bound_high_byte_p;
				low_bound <<= 8;
				high_bound <<= 8;
			} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
			low_bound &= CMP_RED_RANGE_MASK_m12;
			high_bound &= CMP_RED_RANGE_MASK_m12;
			range = high_bound - low_bound;
		}
	}
		
	// finish header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	RED_total_bytes = (si8) (comp_p - (ui1 *) block_header);
	block_header->total_block_bytes = (ui4) G_pad_m12((ui1 *) block_header, RED_total_bytes, 8);
	
	// calculate fall through encoding bytes
	if (cps->directives.fall_through_to_best_encoding == TRUE_m12) {
		for (raw_bits_per_samp = 0, i = (si8) cps->parameters.maximum_sample_value - (si8) cps->parameters.minimum_sample_value; i; i >>= 1)
			++raw_bits_per_samp;
		if (n_derivs) {
			for (bits_per_samp = 0, i = (si8) cps->parameters.maximum_difference_value - (si8) cps->parameters.minimum_difference_value; i; i >>= 1)
				++bits_per_samp;
			if (raw_bits_per_samp > bits_per_samp)  // this can happen in very noisy data
				use_raw = FALSE_m12;
			else
				use_raw = TRUE_m12;
		} else {
			use_raw = TRUE_m12;
		}
		if (use_raw == TRUE_m12) {
			bits_per_samp = raw_bits_per_samp;
			n_derivs = 0;
			n_deriv_samps = n_samps;
		}
		MBE_data_bits = (si8) n_deriv_samps * (si8) bits_per_samp;
		fall_through_bytes = (MBE_data_bits + 7) >> 3;
		header_bytes = cps->parameters.model_region - (ui1 *) block_header;  // fixed block bytes + variable region before model
		fall_through_bytes += header_bytes + CMP_MBE_MODEL_FIXED_HEADER_BYTES_m12 + (n_derivs * 4);
		if ((rem = fall_through_bytes & 7))  // pad bytes
			fall_through_bytes += 8 - rem;
		if (fall_through_bytes < block_header->total_block_bytes) {
			block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
			block_header->block_flags |= CMP_BF_MBE_ENCODING_MASK_m12;
			MBE_header = (CMP_MBE_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
			if (use_raw == TRUE_m12) {
				// cps->input_buffer = unchanged
				MBE_header->minimum_value = cps->parameters.minimum_sample_value;
				MBE_header->derivative_level = 0;
			} else {
				cps->input_buffer = cps->parameters.derivative_buffer;
				MBE_header->minimum_value = cps->parameters.minimum_difference_value;
				MBE_header->derivative_level = n_derivs;
			}
			MBE_header->bits_per_sample = bits_per_samp;
			MBE_header->flags = CMP_MBE_FLAGS_PREPROCESSED_MASK_m12;
			CMP_MBE_encode_m12(cps);
			return;
		}
	}
		
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void    CMP_retrend_si4_m12(si4 *in_y, si4 *out_y, si8 len, sf8 m, sf8 b)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// retrend data from input_buffer to output_buffer
	// if input_buffer == output_buffer retrending data will be done in place
	
	while (len--)
		*out_y++ = CMP_round_si4_m12((sf8) *in_y++ + (b += m));
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void    CMP_retrend_2_sf8_m12(sf8 *in_x, sf8 *in_y, sf8 *out_y, si8 len, sf8 m, sf8 b)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// retrend data from in_y to out_y at specific x locations
	// if input_buffer == output_buffer retrending data will be done in place
	
	while (len--)
		*out_y++ = CMP_round_si4_m12((sf8) *in_y++ + (m * (sf8) *in_x++) + b);
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si2      CMP_round_si2_m12(sf8 val)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (isnan(val))
		return(NAN_SI2_m12);
	
	if (val >= (sf8) 0.0) {
		if ((val += (sf8) 0.5) > (sf8) POS_INF_SI2_m12)
			return(POS_INF_SI2_m12);
	} else {
		if ((val -= (sf8) 0.5) < (sf8) NEG_INF_SI2_m12)
			return(NEG_INF_SI2_m12);
	}
	
	return((si2) val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4      CMP_round_si4_m12(sf8 val)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (isnan(val))
		return(NAN_SI4_m12);
	
	if (val >= (sf8) 0.0) {
		if ((val += (sf8) 0.5) > (sf8) POS_INF_SI4_m12)
			return(POS_INF_SI4_m12);
	} else {
		if ((val -= (sf8) 0.5) < (sf8) NEG_INF_SI4_m12)
			return(NEG_INF_SI4_m12);
	}
	
	return((si4) val);
}


void    CMP_scale_amplitude_si4_m12(si4 *input_buffer, si4 *output_buffer, si8 len, sf8 scale_factor, CMP_PROCESSING_STRUCT_m12 *cps)
{
	si4	*si4_p1, *si4_p2;
	sf4	sf4_scale;
	sf8	inv_scale_factor;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// scale from input_buffer to output_buffer
	// if input_buffer == output_buffer scaling will be done in place
	
	// store scale in block parameter region
	// NOTE: block parameter region must be setup first
	if (cps != NULL) {
		// demote precision
		sf4_scale = (sf4) scale_factor;
		// store
		*((sf4 *) cps->block_parameters + cps->parameters.block_parameter_map[CMP_PF_AMPLITUDE_SCALE_IDX_m12]) = scale_factor;
		// promote back to sf8 (having only sf4 precision)
		scale_factor = (sf8) sf4_scale;
	}
	
	si4_p1 = input_buffer;
	si4_p2 = output_buffer;
	inv_scale_factor = (sf8) 1.0 / scale_factor;  // multiplication much faster than division on some systems
	while (len--)
		*si4_p2++ = CMP_round_si4_m12((sf8) *si4_p1++ * inv_scale_factor);

	return;
}


void    CMP_scale_frequency_si4_m12(si4 *input_buffer, si4 *output_buffer, si8 len, sf8 scale_factor, CMP_PROCESSING_STRUCT_m12 *cps)
{
	sf4	sf4_scale;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// scale from input_buffer to output_buffer
	// if input_buffer == output_buffer scaling will be done in place
	
	// store scale in block parameter region
	// NOTE: block parameter region must be setup first
	if (cps != NULL) {
		// demote precision
		sf4_scale = (sf4) scale_factor;
		// store
		*((sf4 *) cps->block_parameters + cps->parameters.block_parameter_map[CMP_PF_FREQUENCY_SCALE_IDX_m12]) = scale_factor;
		// promote back to sf8 (having only sf4 precision)
		scale_factor = (sf8) sf4_scale;
	}
	
	// actual frequency scaling not written yet
	
	return;
}


void    CMP_set_variable_region_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	ui1				*var_reg_ptr;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	block_header = cps->block_header;
	
	// reset variable region parameters
	block_header->number_of_records = cps->parameters.user_number_of_records;
	block_header->record_region_bytes = cps->parameters.user_record_region_bytes;
	block_header->parameter_flags = cps->parameters.user_parameter_flags;
	block_header->protected_region_bytes = cps->parameters.protected_region_bytes;
	block_header->discretionary_region_bytes = cps->parameters.user_discretionary_region_bytes;
	
	// records region
	var_reg_ptr = (ui1 *) block_header + CMP_BLOCK_FIXED_HEADER_BYTES_m12;  // pointer to start of variable region
	cps->block_records = var_reg_ptr;
	var_reg_ptr += block_header->record_region_bytes;
	
	// parameter region
	cps->block_parameters = (ui4 *) var_reg_ptr;
	
	// set library parameter flags
	if (cps->directives.detrend_data == TRUE_m12)
		block_header->parameter_flags |= (CMP_PF_INTERCEPT_MASK_m12 | CMP_PF_GRADIENT_MASK_m12);
	else
		block_header->parameter_flags &= ~(CMP_PF_INTERCEPT_MASK_m12 | CMP_PF_GRADIENT_MASK_m12);
	
	if (cps->directives.set_amplitude_scale == TRUE_m12 || cps->directives.find_amplitude_scale == TRUE_m12)
		block_header->parameter_flags |= CMP_PF_AMPLITUDE_SCALE_MASK_m12;
	else
		block_header->parameter_flags &= ~CMP_PF_AMPLITUDE_SCALE_MASK_m12;
	
	if (cps->directives.set_frequency_scale == TRUE_m12 || cps->directives.find_frequency_scale == TRUE_m12)
		block_header->parameter_flags |= CMP_PF_FREQUENCY_SCALE_MASK_m12;
	else
		block_header->parameter_flags &= ~CMP_PF_FREQUENCY_SCALE_MASK_m12;
	
	if (cps->directives.include_noise_scores == TRUE_m12)
		block_header->parameter_flags |= CMP_PF_NOISE_SCORES_MASK_m12;
	else
		block_header->parameter_flags &= ~CMP_PF_NOISE_SCORES_MASK_m12;
	
	CMP_generate_parameter_map_m12(cps);
	var_reg_ptr += block_header->parameter_region_bytes;
	
	// protected region
	// cps->protected_region = var_reg_ptr;
	var_reg_ptr += block_header->protected_region_bytes;
	
	// discretionary region
	cps->discretionary_region = var_reg_ptr;
	var_reg_ptr += block_header->discretionary_region_bytes;
	
	// variable region bytes
	cps->parameters.variable_region_bytes = CMP_VARIABLE_REGION_BYTES_v1_m12(block_header);
	
	// model region
	// NOTE: model region is NOT considered part of the variable region, but compression algorithms rely on this pointer being set
	// NOTE: model region bytes is set by compression function
	cps->parameters.model_region = var_reg_ptr;
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void      CMP_sf8_to_si4_m12(sf8 *sf8_arr, si4 *si4_arr, si8 len, TERN_m12 round)
{
	sf8	val;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (round == FALSE_m12) {
		while (len--)
			*si4_arr++ = (si4) *sf8_arr++;
		
		return;
	}

	while (len--) {
		val = *sf8_arr++;
		if (isnan(val)) {
			*si4_arr++ = NAN_SI4_m12;
			continue;
		}
		if (val >= (sf8) 0.0) {
			if ((val += (sf8) 0.5) > (sf8) POS_INF_SI4_m12) {
				*si4_arr++ = POS_INF_SI4_m12;
				continue;
			}
		} else {
			if ((val -= (sf8) 0.5) < (sf8) NEG_INF_SI4_m12) {
				*si4_arr++ = NEG_INF_SI4_m12;
				continue;
			}
		}
		*si4_arr++ = (si4) val;
	}
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void      CMP_sf8_to_si4_and_scale_m12(sf8 *sf8_arr, si4 *si4_arr, si8 len, sf8 scale)
{
	sf8	val;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	while (len--) {
		val = *sf8_arr++ * scale;
		if (isnan(val)) {
			*si4_arr++ = NAN_SI4_m12;
			continue;
		}
		if (val >= (sf8) 0.0) {
			if ((val += (sf8) 0.5) > (sf8) POS_INF_SI4_m12) {
				*si4_arr++ = POS_INF_SI4_m12;
				continue;
			}
		} else {
			if ((val -= (sf8) 0.5) < (sf8) NEG_INF_SI4_m12) {
				*si4_arr++ = NEG_INF_SI4_m12;
				continue;
			}
		}
		*si4_arr++ = (si4) val;
	}
	
	return;
}


void    CMP_show_block_header_m12(CMP_BLOCK_FIXED_HEADER_m12 *block_header)
{
	si1     hex_str[HEX_STRING_BYTES_m12(CRC_BYTES_m12)], time_str[TIME_STRING_BYTES_m12];
	ui4     i, mask;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	printf_m12("--------------- CMP Fixed Block Header - START ---------------\n");
	printf_m12("Block Start UID: 0x%lx\n", block_header->block_start_UID);
	if (block_header->block_CRC == CRC_NO_ENTRY_m12)
		printf_m12("Block CRC: no entry\n");
	else {
		STR_generate_hex_string_m12((ui1 *)&block_header->block_CRC, CRC_BYTES_m12, hex_str);
		printf_m12("Block CRC: %s\n", hex_str);
	}
	printf_m12("Block Flag Bits: ");
	for (i = 0, mask = 1; i < 32; ++i, mask <<= 1) {
		if (block_header->block_flags & mask)
			printf_m12("%d ", i);
	}
	printf_m12(" (value: 0x%08x)\n", block_header->block_flags);
	if (block_header->start_time == UUTC_NO_ENTRY_m12)
		printf_m12("Start Time: no entry\n");
	else {
		STR_time_string_m12(block_header->start_time, time_str, TRUE_m12, FALSE_m12, FALSE_m12);
		printf_m12("Start Time: %ld (¬µUTC), %s\n", block_header->start_time, time_str);
	}
	printf_m12("Acquisition Channel Number: %u\n", block_header->acquisition_channel_number);
	printf_m12("Total Block Bytes: %u\n", block_header->total_block_bytes);
	printf_m12("Number of Samples: %u\n", block_header->number_of_samples);
	printf_m12("Number of Records: %hu\n", block_header->number_of_records);
	printf_m12("Record Region Bytes: %hu\n", block_header->record_region_bytes);
	printf_m12("Parameter Flag Bits: ");
	for (i = 0, mask = 1; i < 32; ++i, mask <<= 1) {
		if (block_header->parameter_flags & mask)
			printf_m12("%d ", i);
	}
	printf_m12(" (value: 0x%08x)\n", block_header->parameter_flags);
	printf_m12("Parameter Region Bytes: %hu\n", block_header->parameter_region_bytes);
	printf_m12("Protected Region Bytes: %hu\n", block_header->protected_region_bytes);
	printf_m12("Discretionary Region Bytes: %hu\n", block_header->discretionary_region_bytes);
	printf_m12("Model Region Bytes: %hu\n", block_header->model_region_bytes);
	printf_m12("Total Header Bytes: %u\n", block_header->total_header_bytes);
	printf_m12("---------------- CMP Fixed Block Header - END ----------------\n\n");
	
	return;
}


void    CMP_show_block_model_m12(CMP_PROCESSING_STRUCT_m12 *cps, TERN_m12 recursed_call)
{
	ui1					*VDS_model_region;
	si1					*symbols, *time_alg, *amp_alg, *indent;
	ui2     				*counts;
	ui4					algorithm, mask, amp_alg_flag, time_alg_flag;
	si4					*derivs;
	si8     				i, total_counts;
	CMP_BLOCK_FIXED_HEADER_m12		*block_header;
	CMP_RED_MODEL_FIXED_HEADER_m12		*RED_header;
	CMP_PRED_MODEL_FIXED_HEADER_m12		*PRED_header;
	CMP_MBE_MODEL_FIXED_HEADER_m12		*MBE_header;
	CMP_VDS_MODEL_FIXED_HEADER_m12		*VDS_header;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	block_header = cps->block_header;

	// "recursed_call" argument is used internally for VDS models => call with FALSE_m12
	if (recursed_call == TRUE_m12) {
		indent = "\t";
	} else {
		indent = "";
		printf_m12("------------------- CMP Block Model - START ------------------\n");
	}
	switch (block_header->block_flags & CMP_BF_ALGORITHMS_MASK_m12) {
		case CMP_BF_RED1_ENCODING_MASK_m12:
		case CMP_BF_RED2_ENCODING_MASK_m12:
			RED_header = (CMP_RED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
			if (block_header->block_flags & CMP_BF_RED1_ENCODING_MASK_m12)
				printf_m12("%sModel: Range Encoded Derivatives 1 (RED1)\n", indent);
			else
				printf_m12("%sModel: Range Encoded Derivatives 2 (RED2)\n", indent);
			printf_m12("%sNumber of Keysample Bytes: %u\n", indent, RED_header->number_of_keysample_bytes);
			printf_m12("%sDerivative Level: %hhu\n", indent, RED_header->derivative_level);
			if (RED_header->derivative_level > 0) {
				derivs = (si4 *) (cps->parameters.model_region + CMP_RED_MODEL_FIXED_HEADER_BYTES_m12);
				if (RED_header->derivative_level == 1) {
					printf_m12("%sDerivative Initial Value: %d", indent, derivs[0]);
				} else {
					printf_m12("%sDerivative Initial Values: %d", indent, derivs[0]);
					for (i = 1; i < RED_header->derivative_level; ++i)
						printf_m12(", %d", derivs[i]);
				}
				printf_m12("\n");
			}
			printf_m12("%sRED Model Flag Bits: ", indent);
			for (i = 0, mask = 1; i < 16; ++i, mask <<= 1) {
				if (RED_header->flags & mask)
					printf_m12("%d ", i);
			}
			printf_m12(" (value: 0x%04x)\n", RED_header->flags);
			printf_m12("\n%sNumber of Statistics Bins: %hu  (counts are scaled)\n", indent, RED_header->number_of_statistics_bins);
			// end fixed RED model fields
			counts = (ui2 *) (cps->parameters.model_region + CMP_RED_MODEL_FIXED_HEADER_BYTES_m12 + (RED_header->derivative_level * 4));
			symbols = (si1 *) (counts + RED_header->number_of_statistics_bins);
			for (i = 0; i < RED_header->number_of_statistics_bins; ++i)
				printf_m12("%sbin %03d:    symbol: %hhd\tcount: %hu\n", indent, i, *symbols++, *counts++);
			break;
			
		case CMP_BF_PRED1_ENCODING_MASK_m12:
		case CMP_BF_PRED2_ENCODING_MASK_m12:
			PRED_header = (CMP_PRED_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
			if (block_header->block_flags & CMP_BF_PRED1_ENCODING_MASK_m12)
				printf_m12("%sModel: Predictive Range Encoded Derivatives 1 (PRED1)\n", indent);
			else
				printf_m12("%sModel: Predictive Range Encoded Derivatives 2 (PRED2)\n", indent);
			printf_m12("%sNumber of Keysample Bytes: %u\n", indent, PRED_header->number_of_keysample_bytes);
			printf_m12("%sDerivative Level: %hhu\n", indent, PRED_header->derivative_level);
			if (PRED_header->derivative_level > 0) {
				derivs = (si4 *) (cps->parameters.model_region + CMP_PRED_MODEL_FIXED_HEADER_BYTES_m12);
				if (PRED_header->derivative_level == 1) {
					printf_m12("%sDerivative Initial Value: %d", indent, derivs[0]);
				} else {
					printf_m12("%sDerivative Initial Values: %d", indent, derivs[0]);
					for (i = 1; i < PRED_header->derivative_level; ++i)
						printf_m12(", %d", derivs[i]);
				}
				printf_m12("\n");
			}
			printf_m12("%sPRED Model Flag Bits: ", indent);
			for (i = 0, mask = 1; i < 16; ++i, mask <<= 1) {
				if (PRED_header->flags & mask)
					printf_m12("%d ", i);
			}
			printf_m12(" (value: 0x%04x)\n", PRED_header->flags);
			// end fixed PRED model fields
			counts = (ui2 *) (cps->parameters.model_region + CMP_PRED_MODEL_FIXED_HEADER_BYTES_m12 + (PRED_header->derivative_level * 4));
			total_counts = (si8) (PRED_header->number_of_nil_statistics_bins + PRED_header->number_of_pos_statistics_bins + PRED_header->number_of_neg_statistics_bins);
			symbols = (si1 *) (counts + total_counts);
			printf_m12("\n%sNumber of NIL Statistics Bins: %hu  (counts are scaled)\n", indent, PRED_header->number_of_nil_statistics_bins);
			for (i = 0; i < PRED_header->number_of_nil_statistics_bins; ++i)
				printf_m12("%sbin %03d:    symbol: %hhd\tcount: %hu\n", indent, i, *symbols++, *counts++);
			printf_m12("\n%sNumber of POS Statistics Bins: %hu  (counts are scaled)\n", indent, PRED_header->number_of_pos_statistics_bins);
			for (i = 0; i < PRED_header->number_of_pos_statistics_bins; ++i)
				printf_m12("%sbin %03d:    symbol: %hhd\tcount: %hu\n", indent, i, *symbols++, *counts++);
			printf_m12("\n%sNumber of NEG Statistics Bins: %hu  (counts are scaled)\n", indent, PRED_header->number_of_neg_statistics_bins);
			for (i = 0; i < PRED_header->number_of_neg_statistics_bins; ++i)
				printf_m12("%sbin %03d:    symbol: %hhd\tcount: %hu\n", indent, i, *symbols++, *counts++);
			break;
			
		case CMP_BF_MBE_ENCODING_MASK_m12:
			MBE_header = (CMP_MBE_MODEL_FIXED_HEADER_m12 *) cps->parameters.model_region;
			printf_m12("%sModel: Minimal Bit Encoding (MBE)\n", indent);
			printf_m12("%sMinimum Value: %d\n", indent, MBE_header->minimum_value);
			printf_m12("%sBits per Sample: %hhu\n", indent, MBE_header->bits_per_sample);
			printf_m12("%sDerivative Level: %hhu\n", indent, MBE_header->derivative_level);
			if (MBE_header->derivative_level > 0) {
				derivs = (si4 *) (cps->parameters.model_region + CMP_MBE_MODEL_FIXED_HEADER_BYTES_m12);
				printf_m12("%sDerivative Initial Values: %d", indent, derivs[0]);
				for (i = 1; i < MBE_header->derivative_level; ++i)
					printf_m12(", %d", derivs[i]);
				printf_m12("\n");
			}
			printf_m12("%sMBE Model Flag Bits: ", indent);
			for (i = 0, mask = 1; i < 16; ++i, mask <<= 1) {
				if (MBE_header->flags & mask)
					printf_m12("%d ", i);
			}
			printf_m12(" (value: 0x%04x)\n", MBE_header->flags);
			break;
			
		case CMP_BF_VDS_ENCODING_MASK_m12:
			VDS_model_region = cps->parameters.model_region;
			VDS_header = (CMP_VDS_MODEL_FIXED_HEADER_m12 *) VDS_model_region;
			algorithm = VDS_header->flags & CMP_VDS_AMPLITUDE_ALGORITHMS_MASK_m12;
			switch (algorithm) {
				case CMP_VDS_FLAGS_AMPLITUDE_RED1_MASK_m12:
				case CMP_VDS_FLAGS_AMPLITUDE_RED2_MASK_m12:
					amp_alg = "RED";
					amp_alg_flag = CMP_BF_RED2_ENCODING_MASK_m12;  // either fine, headers same
					break;
				case CMP_VDS_FLAGS_AMPLITUDE_PRED1_MASK_m12:
				case CMP_VDS_FLAGS_AMPLITUDE_PRED2_MASK_m12:
					amp_alg = "PRED";
					amp_alg_flag = CMP_BF_PRED2_ENCODING_MASK_m12;  // either fine, headers same
					break;
				case CMP_VDS_FLAGS_AMPLITUDE_MBE_MASK_m12:
					amp_alg = "MBE";
					amp_alg_flag = CMP_BF_MBE_ENCODING_MASK_m12;
					break;
			}
			algorithm = VDS_header->flags & CMP_VDS_TIME_ALGORITHMS_MASK_m12;
			switch (algorithm) {
				case CMP_VDS_FLAGS_TIME_RED1_MASK_m12:
				case CMP_VDS_FLAGS_TIME_RED2_MASK_m12:
					time_alg = "RED";
					time_alg_flag = CMP_BF_RED2_ENCODING_MASK_m12;  // either fine, headers same
					break;
				case CMP_VDS_FLAGS_TIME_PRED1_MASK_m12:
				case CMP_VDS_FLAGS_TIME_PRED2_MASK_m12:
					time_alg = "PRED";
					time_alg_flag = CMP_BF_PRED2_ENCODING_MASK_m12;  // either fine, headers same
					break;
				case CMP_VDS_FLAGS_TIME_MBE_MASK_m12:
					time_alg = "MBE";
					time_alg_flag = CMP_BF_MBE_ENCODING_MASK_m12;
					break;
			}
			printf_m12("Model: Vectorized Data Stream (VDS)\n");
			printf_m12("Number of VDS Samples: %u\n", VDS_header->number_of_VDS_samples);
			printf_m12("Amplitude Block Total Bytes: %u\n", VDS_header->amplitude_block_total_bytes);
			printf_m12("Amplitude Block Model: %s\n", amp_alg);
			printf_m12("Amplitude Block Model Bytes: %hu\n", VDS_header->amplitude_block_model_bytes);
			printf_m12("Time Block Model: %s\n", time_alg);
			printf_m12("Time Block Model Bytes: %hu\n", VDS_header->time_block_model_bytes);
			printf_m12("VDS Model Flag Bits: ");
			for (i = 0, mask = 1; i < 32; ++i, mask <<= 1) {
				if (VDS_header->flags & mask)
					printf_m12("%d ", i);
			}
			printf_m12(" (value: 0x%08x)\n", VDS_header->flags);
			// show amplitude model
			printf_m12("\t============== VDS Amplitude Block Model - START =============\n");
			cps->parameters.model_region = VDS_model_region + CMP_VDS_MODEL_FIXED_HEADER_BYTES_m12;
			block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
			block_header->block_flags |= amp_alg_flag;
			CMP_show_block_model_m12(cps, TRUE_m12);
			printf_m12("\t=============== VDS Amplitude Block Model - END ==============\n");
			// show time model
			printf_m12("\t================ VDS Time Block Model - START ================\n");
			cps->parameters.model_region += VDS_header->amplitude_block_total_bytes;
			block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
			block_header->block_flags |= time_alg_flag;
			CMP_show_block_model_m12(cps, TRUE_m12);
			printf_m12("\t================= VDS Time Block Model - END =================\n");
			// restore base VDS model
			cps->parameters.model_region = VDS_model_region;
			block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
			block_header->block_flags |= CMP_BF_VDS_ENCODING_MASK_m12;
			break;
		default:
			G_error_message_m12("%s(): Unrecognized model (%u)\n", __FUNCTION__, block_header->block_flags & CMP_BF_ALGORITHMS_MASK_m12);
			break;
	}
	if (recursed_call != TRUE_m12)
		printf_m12("-------------------- CMP Block Model - END -------------------\n\n");
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void      CMP_si4_to_sf8_m12(si4 *si4_arr, sf8 *sf8_arr, si8 len)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	while (len--)
		*sf8_arr++ = (sf8) *si4_arr++;
	
	return;
}


// Code adapted from Numerical Recipes in C. Public domain.
sf8    *CMP_spline_interp_sf8_m12(sf8 *in_arr, si8 in_arr_len, sf8 *out_arr, si8 out_arr_len, CMP_BUFFERS_m12 *spline_bufs)
{
	TERN_m12	free_buffers;
	si8		i, lo_pt, hi_pt;
	sf8		*prev_y, *y, *next_y, *ty, out_x, out_x_inc, h, a, b;
	sf8		*d2y, *td2y, *prev_d2y, *next_d2y, *tu, *u, *prev_u, p, *tout;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// this version assumes input array is uniformly sampled; output array is uniformly sampled at new frequency
	// if out_arr is NULL, it is allocated and returned
	// if passing, allocate 3 buffers with (in_arr_len + CMP_SPLINE_TAIL_LEN_m12) elements of type sf8
	
	if (out_arr == NULL)
		out_arr = (sf8 *) malloc_m12((size_t) (out_arr_len << 3), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

	if (in_arr_len <= 1) {
		if (in_arr_len == 0)
			return(out_arr);
		for (i = 0; i < out_arr_len; ++i)
			out_arr[i] = in_arr[0];
		return(out_arr);
	}
	if (in_arr_len == out_arr_len) {
		memcpy(out_arr, in_arr, in_arr_len << 3);
		return(out_arr);
	}
	
	free_buffers = FALSE_m12;
	if (spline_bufs == NULL)
		free_buffers = TRUE_m12;
	spline_bufs = CMP_allocate_buffers_m12(spline_bufs, 3, in_arr_len + CMP_SPLINE_TAIL_LEN_m12, sizeof(sf8), FALSE_m12, FALSE_m12);  // also reallocates
	y = (sf8 *) spline_bufs->buffer[0];
	d2y = (sf8 *) spline_bufs->buffer[1];
	u = (sf8 *) spline_bufs->buffer[2];
	memcpy((void *) y, (void *) in_arr, (size_t) (in_arr_len << 3));

	for (h = 2.0 * y[in_arr_len - 1], i = 0; i < CMP_SPLINE_TAIL_LEN_m12; ++i)
		y[in_arr_len + i] = h - y[in_arr_len - 2 - i];
	
	// spline
	d2y[0] = u[0] = 0.0;
	prev_d2y = d2y;
	td2y = prev_d2y + 1;
	prev_y = y;
	ty = prev_y + 1;
	next_y = ty + 1;
	prev_u = u;
	tu = prev_u + 1;
	
	in_arr_len += CMP_SPLINE_TAIL_LEN_m12;
	for (i = in_arr_len; i--;) {
		p = (*prev_d2y++ * 0.5) + 2.0;
		*td2y++ = -0.5 / p;
		*tu = (*next_y++ - *ty) - (*ty - *prev_y++);
		++ty;
		*tu = (3.0 * *tu - 0.5 * *prev_u++) / p;
		++tu;
	}
	*td2y = 0.0;
	
	next_d2y = d2y + in_arr_len - 1;
	td2y = next_d2y - 1;
	tu = u + in_arr_len - 2;
	for (i = in_arr_len - 1; i--;) {
		*td2y = (*td2y * *next_d2y--) + *tu--;
		--td2y;
	}
	in_arr_len -= CMP_SPLINE_TAIL_LEN_m12;
	
	// splint
	out_x_inc = (sf8) in_arr_len / (sf8) out_arr_len;
	out_x = -out_x_inc;
	tout = out_arr;
	for (i = out_arr_len; i--;) {
		hi_pt = (lo_pt = (si4) (out_x += out_x_inc)) + 1;
		b = 1.0 - (a = (sf8) hi_pt - out_x);
		*tout++ = (a * y[lo_pt] + b * y[hi_pt] + ((a * a * a - a) * d2y[lo_pt] + (b * b * b - b) * d2y[hi_pt]) / 6.0);
	}
	
	// clean up
	if (free_buffers == TRUE_m12)
		CMP_free_buffers_m12(spline_bufs, TRUE_m12);
	
	return(out_arr);
}


// Code adapted from Numerical Recipes in C. Public domain.
si4    *CMP_spline_interp_si4_m12(si4 *in_arr, si8 in_arr_len, si4 *out_arr, si8 out_arr_len, CMP_BUFFERS_m12 *spline_bufs)
{
	TERN_m12	free_buffers;
	si4	*tin, *tout;
	si8	i, lo_pt, hi_pt;
	sf8	*prev_y, *y, *next_y, *ty, out_x, out_x_inc, h, a, b;
	sf8	*d2y, *td2y, *prev_d2y, *next_d2y, *tu, *u, *prev_u, p;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// this version assumes input array is uniformly sampled; output array is uniformly sampled at new frequency
	// if out_arr is NULL, it is allocated and returned
	
	if (out_arr == NULL)
		out_arr = (si4 *) malloc_m12((size_t) (out_arr_len << 2), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

	if (in_arr_len <= 1) {
		if (in_arr_len == 0)
			return(out_arr);
		for (i = 0; i < out_arr_len; ++i)
			out_arr[i] = in_arr[0];
		return(out_arr);
	}
	if (in_arr_len == out_arr_len) {
		memcpy(out_arr, in_arr, in_arr_len << 2);
		return(out_arr);
	}

	free_buffers = FALSE_m12;
	if (spline_bufs == NULL)
		free_buffers = TRUE_m12;
	spline_bufs = CMP_allocate_buffers_m12(spline_bufs, 3, in_arr_len, sizeof(sf8), FALSE_m12, FALSE_m12);  // also reallocates
	y = (sf8 *) spline_bufs->buffer[0];
	d2y = (sf8 *) spline_bufs->buffer[1];
	u = (sf8 *) spline_bufs->buffer[2];
	memcpy((void *) y, (void *) in_arr, (size_t) (in_arr_len << 3));

	for (tin = in_arr, ty = y, i = in_arr_len; i--;)
		*ty++ = (sf8) *tin++;
	
	for (h = 2.0 * y[in_arr_len - 1], i = 0; i < CMP_SPLINE_TAIL_LEN_m12; ++i)
		y[in_arr_len + i] = h - y[in_arr_len - 2 - i];
	
	// spline
	d2y[0] = u[0] = 0.0;
	prev_d2y = d2y;
	td2y = prev_d2y + 1;
	prev_y = y;
	ty = prev_y + 1;
	next_y = ty + 1;
	prev_u = u;
	tu = prev_u + 1;
	
	in_arr_len += CMP_SPLINE_TAIL_LEN_m12;
	for (i = 1; i <= in_arr_len - 2; i++) {
		p = (*prev_d2y++ * 0.5) + 2.0;
		*td2y++ = -0.5 / p;
		*tu = (*next_y++ - *ty) - (*ty - *prev_y++);
		++ty;
		*tu = (3.0 * *tu - 0.5 * *prev_u++) / p;
		++tu;
	}
	*td2y = 0.0;
	
	next_d2y = d2y + in_arr_len - 1;
	td2y = next_d2y - 1;
	tu = u + in_arr_len - 2;
	for (i = in_arr_len - 2; i >= 0; i--) {
		*td2y = (*td2y * *next_d2y--) + *tu--;
		--td2y;
	}
	in_arr_len -= CMP_SPLINE_TAIL_LEN_m12;
	
	// splint
	out_x_inc = (sf8) in_arr_len / (sf8) out_arr_len;
	out_x = -out_x_inc;
	tout = out_arr;
	for (i = 0; i < out_arr_len; i++) {
		hi_pt = (lo_pt = (si4) (out_x += out_x_inc)) + 1;
		b = 1.0 - (a = (sf8) hi_pt - out_x);
		*tout++ = (si4) ((a * y[lo_pt] + b * y[hi_pt] + ((a * a * a - a) * d2y[lo_pt] + (b * b * b - b) * d2y[hi_pt]) / 6.0) + 0.5);
	}
	
	// clean up
	if (free_buffers == TRUE_m12)
		CMP_free_buffers_m12(spline_bufs, TRUE_m12);

	return(out_arr);
}


sf8	CMP_splope_m12(sf8 *xa, sf8 *ya, sf8 *d2y, sf8 x, si8 lo_pt, si8 hi_pt)
{
	sf8	a, b, c, d, e, f, g, h;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// slope of splined array (characterized by d2y), at point x
	// useful for many things, but in particular finding precise locations of critical points in splined data

	a = xa[lo_pt];
	b = xa[hi_pt];
	c = ya[lo_pt];
	d = ya[hi_pt];
	e = d2y[lo_pt];
	f = d2y[hi_pt];
	g = b - a;

	h = (x * (e * b - f * a) + d - c) / g;
	h += (x * x * (f - e) + f * a * a - e * b * b) / (2.0 * g);
	h += g * (e - f) / 6.0;

	return(h);
}


sf8	CMP_trace_amplitude_m12(sf8 *y, sf8 *buffer, si8 len, TERN_m12 detrend)
{
	TERN_m12	free_buffer;
	si8		i;
	sf8		amp, *sf8_p1, *sf8_p2;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// returns the median of absolute value of the trace (after detrending, if requested)
	// if y == buffer: destructive to y
	// if buffer == NULL: buffer allocated & freed
	
	// allocate
	if (buffer == NULL) {
		buffer = (sf8 *) malloc((size_t) (len << 3));
		free_buffer = TRUE_m12;
	} else {
		free_buffer = FALSE_m12;
	}
	
	// detrend
	if (detrend == TRUE_m12) {
		CMP_detrend_sf8_m12(y, buffer, len);
		y = buffer;
	}
	
	// get absolute value trace
	sf8_p1 = buffer;
	sf8_p2 = y;
	for (i = len; i--;) {
		if (*sf8_p2 < (sf8) 0.0)
			*sf8_p1++ = -(*sf8_p2++);
		else
			*sf8_p1++ = *sf8_p2++;
	}
	
	// get amplitude
	amp = CMP_quantval_m12(buffer, len, 0.5, FALSE_m12, NULL);
	
	// clean up
	if (free_buffer == TRUE_m12)
		free((void *) buffer);
	
	return(amp);
}


si8     CMP_ts_sort_m12(si4 *x, si8 len, CMP_NODE_m12 *nodes, CMP_NODE_m12 *head, CMP_NODE_m12 *tail, si4 return_sorted_ts, ...)
{
	TERN_m12        free_nodes;
	CMP_NODE_m12	*last_node, *next_node, *prev_node, *np;
	si8             i, j, n_nodes;
	sf8             new_val;
	si4		*sorted_x;
	va_list         args;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// setup
	if (nodes == NULL) {
		nodes = (CMP_NODE_m12 *) calloc_m12((size_t)len, sizeof(CMP_NODE_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free_nodes = TRUE_m12;
	} else {
		free_nodes = FALSE_m12;
	}
	
	np = nodes;
	head->next = tail;
	head->val = (si4) NAN_SI4_m12;  // This is 0x80000000 because NEG_INF_SI4_m12 (0x80000001) could theoretically fail
	tail->val = (si4) POS_INF_SI4_m12;  // This is 0x7FFFFFFF
	tail->prev = head;
	
	// build linked list
	for (last_node = head, i = len; i--;) {
		new_val = *x++;
		if (new_val == last_node->val) {
			++last_node->count;
			continue;
		} else if (new_val > last_node->val) {
			for (next_node = last_node->next; new_val > next_node->val; next_node = next_node->next);
			if (new_val == next_node->val) {
				++next_node->count;
				last_node = next_node;
				continue;
			}
			prev_node = next_node->prev;
		} else {  // new_val < last_node->val
			for (prev_node = last_node->prev; new_val < prev_node->val; prev_node = prev_node->prev);
			if (new_val == prev_node->val) {
				++prev_node->count;
				last_node = prev_node;
				continue;
			}
			next_node = prev_node->next;
		}
		np->next = next_node;
		np->prev = prev_node;
		np->val = new_val;
		np->count = 1;
		last_node = prev_node->next = next_node->prev = np++;
	}
	n_nodes = np - nodes;
	
	// expand nodes back to sorted array, if requested
	if (return_sorted_ts == TRUE_m12) {
		va_start(args, return_sorted_ts);
		sorted_x = va_arg(args, si4 *);
		va_end(args);
		if (sorted_x == NULL) {
			G_warning_message_m12("%s(): passed sorted array pointer is NULL\n", __FUNCTION__);
		} else {
			for (i = n_nodes, np = head->next; i--; np = np->next)
				for (j = np->count; j--;)
					*sorted_x++ = np->val;
		}
	}
	
	if (free_nodes == TRUE_m12)
		free_m12((void *) nodes, __FUNCTION__);
	
	return(n_nodes);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	CMP_unlock_buffers_m12(CMP_BUFFERS_m12 *buffers)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// unlock
	if (buffers->locked != FALSE_m12) {
		buffers->locked = munlock_m12((void *) buffers->buffer, buffers->total_allocated_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		buffers->locked = FALSE_m12;
	}

	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void    CMP_unscale_amplitude_si4_m12(si4 *input_buffer, si4 *output_buffer, si8 len, sf8 scale_factor)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// unscale from input_buffer to output_buffer
	// if input_buffer == output_buffer unscaling will be done in place
	
	while (len--)
		*output_buffer++ = CMP_round_si4_m12((sf8) *input_buffer++ * scale_factor);

	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void    CMP_unscale_amplitude_sf8_m12(sf8 *input_buffer, sf8 *output_buffer, si8 len, sf8 scale_factor)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// unscale from input_buffer to output_buffer
	// if input_buffer == output_buffer unscaling will be done in place
	
	while (len--)
		*output_buffer++ = *input_buffer++ * scale_factor;

	return;
}


void    CMP_unscale_frequency_si4_m12(si4 *input_buffer, si4 *output_buffer, si8 len, sf8 scale_factor)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// not written yet
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
CMP_BLOCK_FIXED_HEADER_m12	*CMP_update_CPS_pointers_m12(FILE_PROCESSING_STRUCT_m12 *fps, ui1 flags)
{
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	CMP_PROCESSING_STRUCT_m12	*cps;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (fps->universal_header->type_code != TIME_SERIES_DATA_FILE_TYPE_CODE_m12) {
		G_error_message_m12("%s(): FPS must be time series data\n", __FUNCTION__);
		return(NULL);
	}
	cps = fps->parameters.cps;
	
	block_header = cps->block_header;
	if (flags & CMP_UPDATE_ORIGINAL_PTR_m12)
		cps->original_ptr += block_header->number_of_samples;
	else if (flags & CMP_RESET_ORIGINAL_PTR_m12)
		cps->original_ptr = cps->original_data;
	
	if (flags & CMP_UPDATE_BLOCK_HEADER_PTR_m12)
		cps->block_header = (CMP_BLOCK_FIXED_HEADER_m12 *) ((ui1 *) cps->block_header + block_header->total_block_bytes);
	else if (flags & CMP_RESET_BLOCK_HEADER_PTR_m12)
		cps->block_header = (CMP_BLOCK_FIXED_HEADER_m12 *) fps->data_pointers;
	
	if (flags & CMP_UPDATE_DECOMPRESSED_PTR_m12)
		cps->decompressed_ptr += block_header->number_of_samples;
	else if (flags & CMP_RESET_DECOMPRESSED_PTR_m12)
		cps->decompressed_ptr = cps->decompressed_data = cps->parameters.cache;

	return(cps->block_header);
}


void	CMP_VDS_decode_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	ui1				*VDS_model_region;
	ui4				VDS_total_header_bytes, number_of_samples, algorithm;
	ui4				start_sample;
	si4				*si4_p;
	sf4				*sf4_p;
	si8				i, *si8_p, offset, *in_x;
	sf8				amplitude_scale, *in_y, *out_x, *out_y, *sf8_p, val;
	void				*saved_cumulative_count_p, *saved_minimum_range_p;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	CMP_BUFFERS_m12			*VDS_in_bufs, *VDS_out_bufs;
	CMP_VDS_MODEL_FIXED_HEADER_m12	*VDS_header;
	
	
	// save values set by CMP_decode_m12();
	block_header = cps->block_header;
	number_of_samples = (si8) block_header->number_of_samples;
	VDS_model_region = cps->parameters.model_region;  // set by CMP_decode_m12()
	VDS_header = (CMP_VDS_MODEL_FIXED_HEADER_m12 *) VDS_model_region;
	VDS_total_header_bytes = block_header->total_header_bytes;
	
	// decode amplitude data
	block_header->number_of_samples = VDS_header->number_of_VDS_samples;
	cps->parameters.model_region = (ui1 *) block_header + (si8) VDS_total_header_bytes;
	block_header->total_header_bytes = VDS_total_header_bytes + VDS_header->amplitude_block_model_bytes;
	block_header->model_region_bytes = VDS_header->amplitude_block_model_bytes;
	algorithm = VDS_header->flags & CMP_VDS_AMPLITUDE_ALGORITHMS_MASK_m12;
	switch (algorithm) {
		case CMP_VDS_FLAGS_AMPLITUDE_RED1_MASK_m12:  // older VDS used RED for amplitudes - this should go away eventually
		case CMP_VDS_FLAGS_AMPLITUDE_RED2_MASK_m12:
			// change PRED buffers to RED
			saved_cumulative_count_p = cps->parameters.cumulative_count;
			saved_minimum_range_p = cps->parameters.minimum_range;
			cps->parameters.cumulative_count = *((void **) saved_cumulative_count_p);
			cps->parameters.minimum_range = *((void **) saved_minimum_range_p);
			// decode
			if (algorithm == CMP_VDS_FLAGS_AMPLITUDE_RED1_MASK_m12)
				CMP_RED1_decode_m12(cps);
			else
				CMP_RED2_decode_m12(cps);
			// restore PRED buffers
			cps->parameters.cumulative_count = saved_cumulative_count_p;
			cps->parameters.minimum_range = saved_minimum_range_p;
			break;
		case CMP_VDS_FLAGS_AMPLITUDE_PRED1_MASK_m12:
			CMP_PRED1_decode_m12(cps);
			break;
		case CMP_VDS_FLAGS_AMPLITUDE_PRED2_MASK_m12:
			CMP_PRED2_decode_m12(cps);
			break;
		case CMP_VDS_FLAGS_AMPLITUDE_MBE_MASK_m12:
			CMP_MBE_decode_m12(cps);
			break;
	}

	// set up VDS buffers
	cps->parameters.VDS_input_buffers = CMP_allocate_buffers_m12(cps->parameters.VDS_input_buffers, CMP_VDS_INPUT_BUFFERS_m12, (si8) (VDS_header->number_of_VDS_samples + CMP_MAK_PAD_SAMPLES_m12), sizeof(sf8), FALSE_m12, FALSE_m12);
	cps->parameters.VDS_output_buffers = CMP_allocate_buffers_m12(cps->parameters.VDS_output_buffers, CMP_VDS_OUTPUT_BUFFERS_m12, (si8) number_of_samples, sizeof(sf8), FALSE_m12, FALSE_m12);
	VDS_in_bufs = cps->parameters.VDS_input_buffers;
	in_y = (sf8 *) VDS_in_bufs->buffer[CMP_MAK_IN_Y_BUF];  // location specified by mak_interp()
	in_x = (si8 *) VDS_in_bufs->buffer[CMP_MAK_IN_X_BUF];  // location specified by mak_interp()
	VDS_out_bufs = cps->parameters.VDS_output_buffers;
	out_y = (sf8 *) VDS_out_bufs->buffer[CMP_MAK_OUT_Y_BUF];  // location specified by mak_interp()
	out_x = (sf8 *) VDS_out_bufs->buffer[CMP_MAK_OUT_X_BUF];  // location specified by mak_interp()

	// copy amplitudes to sf8 buffer
	CMP_si4_to_sf8_m12(cps->decompressed_ptr, in_y, (si8) VDS_header->number_of_VDS_samples);

	// apply amplitude scaling (if applied) here (b/c fewer samples)
	if (block_header->parameter_flags & CMP_PF_AMPLITUDE_SCALE_MASK_m12) {
		sf4_p = (sf4 *) cps->block_parameters;
		offset = (si8) cps->parameters.block_parameter_map[CMP_PF_AMPLITUDE_SCALE_IDX_m12];
		amplitude_scale = (sf8) *(sf4_p + offset);
		CMP_unscale_amplitude_sf8_m12(in_y, in_y, (si8) VDS_header->number_of_VDS_samples, amplitude_scale);
	}

	// decode time data
	block_header->total_header_bytes = VDS_total_header_bytes + VDS_header->amplitude_block_total_bytes + VDS_header->time_block_model_bytes;
	cps->parameters.model_region = (ui1 *) block_header + (si8) VDS_total_header_bytes + (si8) VDS_header->amplitude_block_total_bytes;
	block_header->model_region_bytes = VDS_header->time_block_model_bytes;
	algorithm = VDS_header->flags & CMP_VDS_TIME_ALGORITHMS_MASK_m12;
	switch (algorithm) {
		case CMP_VDS_FLAGS_TIME_RED1_MASK_m12:
		case CMP_VDS_FLAGS_TIME_RED2_MASK_m12:
			// change PRED amplitude buffers to RED time buffers
			saved_cumulative_count_p = cps->parameters.cumulative_count;
			saved_minimum_range_p = cps->parameters.minimum_range;
			cps->parameters.cumulative_count = *((void **) saved_cumulative_count_p);
			cps->parameters.minimum_range = *((void **) saved_minimum_range_p);
			if (algorithm == CMP_VDS_FLAGS_TIME_RED1_MASK_m12)
				CMP_RED1_decode_m12(cps);
			else
				CMP_RED2_decode_m12(cps);
			// restore PRED amplitude buffers
			cps->parameters.cumulative_count = saved_cumulative_count_p;
			cps->parameters.minimum_range = saved_minimum_range_p;
			break;
		case CMP_VDS_FLAGS_TIME_MBE_MASK_m12:
			CMP_MBE_decode_m12(cps);
			break;
	}
	
	// copy times to si8 buffer
	si8_p = in_x;
	si4_p = cps->decompressed_ptr;
	for (i = VDS_header->number_of_VDS_samples; i--;)
		*si8_p++ = (si8) *si4_p++;

	// reconstruct trace
	if (cps->directives.cps_caching == TRUE_m12) {
		start_sample = 0;
	} else {
		start_sample = cps->parameters.block_start_index;
		if (cps->parameters.block_end_index != 0xFFFFFFFF)
			number_of_samples = cps->parameters.block_end_index + 1;
		number_of_samples -= start_sample;
	}
	
	// build out array & interpolate
	sf8_p = out_x;  // create mak out_x array
	val = (sf8) start_sample - (sf8) 1.0;
	for (i = number_of_samples; i--;)
		*sf8_p++ = (val += (sf8) 1.0);
	CMP_mak_interp_sf8_m12(VDS_in_bufs, (si8) VDS_header->number_of_VDS_samples, VDS_out_bufs, (si8) number_of_samples);

	// copy interpolated data to decompressed buffer
	CMP_sf8_to_si4_m12(out_y, cps->decompressed_ptr, number_of_samples, TRUE_m12);

	// restore block_header
	block_header->number_of_samples = number_of_samples;
	block_header->total_header_bytes = VDS_total_header_bytes;
	block_header->model_region_bytes = (ui2) CMP_VDS_MODEL_FIXED_HEADER_BYTES_m12;
	cps->parameters.model_region = VDS_model_region;

	return;
}


void	CMP_VDS_encode_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	TERN_m12			change_made;
	ui1				*VDS_model_region, *VDS_amplitude_model_region, *VDS_time_model_region;
	ui4				VDS_number_of_samples, VDS_total_header_bytes;
	ui4				VDS_total_block_bytes, algorithm;
	si4				*si4_p, rounds, maximum_rounds;
	sf4				*sf4_p;
	si8				i, j, k, new_in_len, block_samps, poles, pad_samps, in_len, offset;
	si8				*in_x, *new_in_x, *si8_p1, *si8_p2, scale;
	sf8				VDS_alg_thresh, *out_x, *template, *sf8_p1, *sf8_p2, *sf8_p3, *in_y, *out_y;
	sf8				*abs_diffs, *quantval_buf, diff, thresh, baseline, *resids, max_dx, max_dy;
	void				*saved_count_p, *saved_sorted_count_p, *saved_symbol_map_p, *saved_cumulative_count_p, *saved_minimum_range_p;
	CMP_BUFFERS_m12			*VDS_in_bufs, *VDS_out_bufs;
	CMP_BLOCK_FIXED_HEADER_m12	*block_header;
	CMP_VDS_MODEL_FIXED_HEADER_m12	*VDS_header;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// VDS Buffer Map:
	// 	VDS_in_bufs[CMP_MAK_IN_Y_BUF] == VDS_in_bufs[0]: mak() in_y
	// 	VDS_in_bufs[CMP_MAK_IN_X_BUF] == VDS_in_bufs[1]: mak() in_x
	// 	VDS_in_bufs[8]:	template

       	// redirect to PRED for lossless encoding
	if (cps->parameters.VDS_threshold == (sf8) 0.0) {
		cps->directives.algorithm = CMP_PRED_COMPRESSION_m12;  // change directive so don't do this for every block
		CMP_PRED2_encode_m12(cps);
		return;
	}

	// convert user to algorithm threshold
	VDS_alg_thresh = CMP_VDS_get_theshold_m12(cps);

	// redirect to MBE for tiny blocks
	block_samps = (si8) cps->block_header->number_of_samples;
	if (block_samps < CMP_VDS_MINIMUM_SAMPLES_m12) {
		cps->block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
		cps->block_header->block_flags |= CMP_BF_MBE_ENCODING_MASK_m12;
		CMP_MBE_encode_m12(cps);
		return;
	}
	
	// allocate
	poles = FILT_POLES_m12(CMP_VDS_LOWPASS_ORDER_m12, 1);
	pad_samps = FILT_FILT_PAD_SAMPLES_m12(poles);
	cps->parameters.VDS_input_buffers = CMP_allocate_buffers_m12(cps->parameters.VDS_input_buffers, CMP_VDS_INPUT_BUFFERS_m12, block_samps + pad_samps, sizeof(sf8), FALSE_m12, FALSE_m12);
	cps->parameters.VDS_output_buffers = CMP_allocate_buffers_m12(cps->parameters.VDS_output_buffers, CMP_VDS_OUTPUT_BUFFERS_m12, block_samps, sizeof(sf8), FALSE_m12, FALSE_m12);
	VDS_in_bufs = cps->parameters.VDS_input_buffers;
	VDS_out_bufs = cps->parameters.VDS_output_buffers;

	// convert block samples to sf8 array
	in_y = (sf8 *) VDS_in_bufs->buffer[0];
	CMP_si4_to_sf8_m12(cps->input_buffer, in_y, block_samps);

	// generate template
	CMP_VDS_generate_template_m12(cps, block_samps);
	
	// get baseline
	template = (sf8 *) VDS_in_bufs->buffer[8];
	abs_diffs = (sf8 *) VDS_in_bufs->buffer[2];
	sf8_p1 = in_y;
	sf8_p2 = template;
	sf8_p3 = abs_diffs;
	for (i = block_samps; i--;) {
		diff = *sf8_p1++ - *sf8_p2++;
		*sf8_p3++ = (diff >= (sf8) 0.0) ? diff : -diff;
	}
	quantval_buf = (sf8 *) VDS_in_bufs->buffer[3];
	baseline = CMP_quantval_m12(abs_diffs, block_samps, 0.5, TRUE_m12, quantval_buf);

	// find critical points
	in_x = (si8 *) VDS_in_bufs->buffer[1];
	CMP_find_crits_m12(template, block_samps, &in_len, in_x);

	// put critical points into input mak arrays
	sf8_p1 = in_y;
	si8_p1 = in_x;
	for (i = in_len; i--;)
		*sf8_p1++ = template[*si8_p1++];

	// get absolute differences of critical point y values
	sf8_p1 = in_y;
	sf8_p2 = in_y + 1;
	sf8_p3 = abs_diffs;
	for (i = in_len; --i;) {
		diff = *sf8_p2++ - *sf8_p1++;
		*sf8_p3++ = (diff >= (sf8) 0.0) ? diff : -diff;
	}
	
	// eliminate spurious critical points
	sf8_p1 = abs_diffs;
	si8_p1 = si8_p2 = in_x + 1;
	thresh = baseline * VDS_alg_thresh;
	for (i = in_len; --i; ++si8_p1)
		if (*sf8_p1++ > thresh)
			*si8_p2++ = *si8_p1;
	in_len = si8_p2 - in_x;
	if (in_x[in_len - 1] != (block_samps - 1))
		in_x[in_len++] = block_samps - 1;

	// create out_x array
	out_x = (sf8 *) VDS_out_bufs->buffer[1];
	sf8_p1 = out_x + block_samps;
	for (i = block_samps; i--;)
		*--sf8_p1 = (sf8) i;
	
	// refine fit
	new_in_x = (si8 *) VDS_in_bufs->buffer[2];
	out_y = (sf8 *) VDS_out_bufs->buffer[0];
	resids = (sf8 *) VDS_out_bufs->buffer[2];
	maximum_rounds = cps->parameters.maximum_goal_attempts;
	rounds = 0;
	do {
		// copy anchors into mak input array
		sf8_p1 = in_y;
		si8_p1 = in_x;
		for (i = in_len; i--;)
			*sf8_p1++ = template[*si8_p1++];

		// fit anchor points
		CMP_mak_interp_sf8_m12(VDS_in_bufs, in_len, VDS_out_bufs, block_samps);

		// calculate residuals
		sf8_p1 = template;
		sf8_p2 = out_y;
		sf8_p3 = resids;
		for (i = block_samps; --i;) {
			diff = *sf8_p1++ - *sf8_p2++;
			*sf8_p3++ = (diff >= (sf8) 0.0) ? diff : -diff;
		}

		// add anchors
		change_made = FALSE_m12;
		new_in_x[0] = in_x[0];
		for (new_in_len = i = 1; i < in_len; ++i) {
			// add point that deviates maximally in segment, if it exceeds threshold
			for (max_dy = 0, k = in_x[i], j = in_x[i - 1] + 1; j < k; ++j) {
				if (resids[j] > max_dy) {
					max_dx = j;
					max_dy = resids[j];
				}
			}
			if (max_dy > thresh) {
				new_in_x[new_in_len++] = max_dx;
				change_made = TRUE_m12;
			}
			new_in_x[new_in_len++] = in_x[i];
		}

		// copy new anchor set into in_x
		if (change_made == TRUE_m12) {
			memcpy((void *) in_x, (void *) new_in_x, (size_t) (new_in_len << 3));
			in_len = new_in_len;
		}
	} while ((change_made == TRUE_m12) && (++rounds <= maximum_rounds));
	
	// could not reach requested fidelity: redirect to PRED for lossless encoding (this block only)
	if ((change_made == TRUE_m12) && (rounds > maximum_rounds)) {
		G_warning_message_m12("%s(): could not achieve requested fidelity in %d rounds => redirecting block to PRED\n", __FUNCTION__, maximum_rounds);
		CMP_PRED2_encode_m12(cps);
		return;
	}

	// scale data (if requested)
	if (cps->directives.VDS_scale_by_baseline == TRUE_m12) {
		if (baseline > (sf8) 1.0) {
			cps->directives.set_amplitude_scale = TRUE_m12;
			cps->parameters.amplitude_scale = (sf4) baseline;
			CMP_set_variable_region_m12(cps);
		} else {
			cps->directives.set_amplitude_scale = FALSE_m12;
			cps->parameters.amplitude_scale = (sf4) 1.0;
		}
	}
	if (cps->directives.set_amplitude_scale == TRUE_m12) {
		sf4_p = (sf4 *) cps->block_parameters;
		offset = (si8) cps->parameters.block_parameter_map[CMP_PF_AMPLITUDE_SCALE_IDX_m12];
		*(sf4_p + offset) = cps->parameters.amplitude_scale;
		scale = (sf8) cps->parameters.amplitude_scale;
		sf8_p1 = in_y;
		for (i = in_len; i--;)
			*sf8_p1++ /= scale;
	}
	
	// copy data to input buffer
	cps->input_buffer = (si4 *) VDS_in_bufs->buffer[8];  // use VDS template buffer (finished with template for this round)
	CMP_sf8_to_si4_m12(in_y, cps->input_buffer, in_len, TRUE_m12);

	// get VDS model info
	VDS_number_of_samples = (ui4) in_len;
	block_header = cps->block_header;
	VDS_model_region = cps->parameters.model_region;
	VDS_total_header_bytes = (ui4) (VDS_model_region - (ui1 *) block_header) + (ui4) CMP_VDS_MODEL_FIXED_HEADER_BYTES_m12;
	VDS_total_block_bytes = VDS_total_header_bytes;
	VDS_header = (CMP_VDS_MODEL_FIXED_HEADER_m12 *) VDS_model_region;
	VDS_header->number_of_VDS_samples = VDS_number_of_samples;
	VDS_header->flags = 0;

	// encode amplitudes
	block_header = cps->block_header;
	block_header->number_of_samples = VDS_number_of_samples;
	VDS_amplitude_model_region = (ui1 *) block_header + VDS_total_block_bytes;
	cps->parameters.model_region = VDS_amplitude_model_region;
	CMP_PRED2_encode_m12(cps); // start with PRED2 for amplitude - may fall through
	VDS_header->amplitude_block_total_bytes = block_header->total_block_bytes - VDS_total_block_bytes;
	VDS_header->amplitude_block_model_bytes = block_header->model_region_bytes;
	VDS_total_block_bytes = block_header->total_block_bytes;
	VDS_header->flags &= ~CMP_VDS_AMPLITUDE_ALGORITHMS_MASK_m12;
	algorithm = block_header->block_flags & CMP_BF_ALGORITHMS_MASK_m12;
	switch (algorithm) {
		case CMP_BF_PRED2_ENCODING_MASK_m12:
			VDS_header->flags |= CMP_VDS_FLAGS_AMPLITUDE_PRED2_MASK_m12;
			break;
		case CMP_BF_MBE_ENCODING_MASK_m12:
			VDS_header->flags |= CMP_VDS_FLAGS_AMPLITUDE_MBE_MASK_m12;
			break;
	}
	
	// encode times
	si4_p = cps->input_buffer;
	si8_p1 = in_x;
	for (i = VDS_number_of_samples; i--;)
		*si4_p++ = (si4) *si8_p1++;
	
	// change PRED amplitude buffers to RED time buffers
	saved_count_p = cps->parameters.count;
	saved_sorted_count_p = cps->parameters.sorted_count;
	saved_symbol_map_p = cps->parameters.symbol_map;
	saved_cumulative_count_p = cps->parameters.cumulative_count,
	saved_minimum_range_p = cps->parameters.minimum_range,
	cps->parameters.count = *((void **) saved_count_p);
	cps->parameters.sorted_count = *((void **) saved_sorted_count_p);
	cps->parameters.symbol_map = *((void **) saved_symbol_map_p);
	cps->parameters.cumulative_count = *((void **) saved_cumulative_count_p);
	cps->parameters.minimum_range = *((void **) saved_minimum_range_p);

	VDS_time_model_region = (ui1 *) block_header + VDS_total_block_bytes;
	cps->parameters.model_region = VDS_time_model_region;
	CMP_RED2_encode_m12(cps); // start with RED2 for times - may fall through
	VDS_header->time_block_model_bytes = block_header->model_region_bytes;
	VDS_header->flags &= ~CMP_VDS_TIME_ALGORITHMS_MASK_m12;
	algorithm = block_header->block_flags & CMP_BF_ALGORITHMS_MASK_m12;
	switch (algorithm) {
		case CMP_BF_RED2_ENCODING_MASK_m12:
			VDS_header->flags |= CMP_VDS_FLAGS_TIME_RED2_MASK_m12;
			break;
		case CMP_BF_MBE_ENCODING_MASK_m12:
			VDS_header->flags |= CMP_VDS_FLAGS_TIME_MBE_MASK_m12;
			break;
	}
	
	// restore PRED amplitude buffers
	cps->parameters.count = saved_count_p;
	cps->parameters.sorted_count = saved_sorted_count_p;
	cps->parameters.symbol_map = saved_symbol_map_p;
	cps->parameters.cumulative_count = saved_cumulative_count_p;
	cps->parameters.minimum_range = saved_minimum_range_p;

	// set block back to VDS values
	block_header->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m12;
	block_header->block_flags |= CMP_BF_VDS_ENCODING_MASK_m12;
	block_header->number_of_samples = (ui4) block_samps;
	block_header->total_header_bytes = VDS_total_header_bytes;
	block_header->model_region_bytes = (ui2) CMP_VDS_MODEL_FIXED_HEADER_BYTES_m12;
	cps->parameters.model_region = VDS_model_region;
	
	return;
}


void	CMP_VDS_generate_template_m12(CMP_PROCESSING_STRUCT_m12 *cps, si8 data_len)
{
	TERN_m12			LFP_filter, realloc_flag;
	si8				i, j, block_samps, *extrema, n_extrema, min_cutoff;
	sf8				*y, *smooth, *transients, *template, samp_freq, LFP_high_fc;
	sf8				*sf8_p1, *sf8_p2, *sf8_p3;
	FILT_PROCESSING_STRUCT_m12	*min_filtps, *lfp_filtps;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// Function assumes VDS buffers are allocated
	// Buffer Map:
	// 	VDS_in_bufs[CMP_MAK_IN_Y_BUF] == VDS_in_bufs[0]: y
	// 	VDS_in_bufs[CMP_MAK_IN_X_BUF] == VDS_in_bufs[1]: x (not used, but don't touch)
	// 	VDS_in_bufs[2]:	excise_transients() smooth_data & LFP filt_data
	// 	VDS_in_bufs[3]:	excise_transients() transients
	// 	VDS_in_bufs[4]:	excise_transients() extrema
	//	VDS_in_bufs[7]:	filter() buffer
	//	VDS_in_bufs[8]:	template buffer
	
	samp_freq = cps->parameters.VDS_sampling_frequency;
	LFP_high_fc = cps->parameters.VDS_LFP_high_fc;
	block_samps = (si8) cps->block_header->number_of_samples;
	y = (sf8 *) cps->parameters.VDS_input_buffers->buffer[0];

	LFP_filter = FALSE_m12;
	if (LFP_high_fc != (sf8) 0.0)
		LFP_filter = TRUE_m12;
	
	// get filter processing struct: minimal filter
	min_cutoff = samp_freq / (sf8) FILT_VDS_MIN_SAMPS_PER_CYCLE_m12;  
	realloc_flag = FALSE_m12;
	if (cps->parameters.n_filtps < (FILT_VDS_TEMPLATE_MIN_PS_m12 + 1) || cps->parameters.filtps == NULL) {
		realloc_flag = TRUE_m12;
		cps->parameters.n_filtps = FILT_VDS_TEMPLATE_MIN_PS_m12 + 1;
		cps->parameters.filtps = (void **) realloc_m12((void *) cps->parameters.filtps, sizeof(void *) * cps->parameters.n_filtps, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		min_filtps = (FILT_PROCESSING_STRUCT_m12 *) (cps->parameters.filtps[FILT_VDS_TEMPLATE_MIN_PS_m12] = NULL);
	} else {
		min_filtps = (FILT_PROCESSING_STRUCT_m12 *) cps->parameters.filtps[FILT_VDS_TEMPLATE_MIN_PS_m12];
		if (min_filtps == NULL)
			realloc_flag = TRUE_m12;
		else if (min_filtps->order != CMP_VDS_LOWPASS_ORDER_m12)
			realloc_flag = TRUE_m12;
		else if (min_filtps->type != FILT_LOWPASS_TYPE_m12)
			realloc_flag = TRUE_m12;
		else if (min_filtps->sampling_frequency != samp_freq)
			realloc_flag = TRUE_m12;
		else if (min_filtps->cutoffs[0] != min_cutoff)
			realloc_flag = TRUE_m12;
	}
	if (realloc_flag == TRUE_m12) {
		if (min_filtps != NULL)
			FILT_free_processing_struct_m12(min_filtps, FALSE_m12, FALSE_m12, FALSE_m12, TRUE_m12);
		cps->parameters.filtps[FILT_VDS_TEMPLATE_MIN_PS_m12] = (void *) FILT_initialize_processing_struct_m12(CMP_VDS_LOWPASS_ORDER_m12, FILT_LOWPASS_TYPE_m12, samp_freq, block_samps, FALSE_m12, FALSE_m12, FALSE_m12, (RETURN_ON_FAIL_m12 | SUPPRESS_WARNING_OUTPUT_m12), min_cutoff);
		min_filtps = (FILT_PROCESSING_STRUCT_m12 *) cps->parameters.filtps[FILT_VDS_TEMPLATE_MIN_PS_m12];
	}
	
	// get filter processing struct: LFP filter (user specified cutoff)
	if (LFP_filter == TRUE_m12) {
		realloc_flag = FALSE_m12;
		if (cps->parameters.n_filtps < (FILT_VDS_TEMPLATE_LFP_PS_m12 + 1)) {
			realloc_flag = TRUE_m12;
			cps->parameters.n_filtps = FILT_VDS_TEMPLATE_LFP_PS_m12 + 1;
			cps->parameters.filtps = (void **) realloc_m12((void *) cps->parameters.filtps, sizeof(void *) * cps->parameters.n_filtps, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			cps->parameters.filtps[FILT_VDS_TEMPLATE_LFP_PS_m12] = NULL;
			lfp_filtps = (FILT_PROCESSING_STRUCT_m12 *) cps->parameters.filtps[FILT_VDS_TEMPLATE_LFP_PS_m12];
		} else {
			lfp_filtps = (FILT_PROCESSING_STRUCT_m12 *) cps->parameters.filtps[FILT_VDS_TEMPLATE_LFP_PS_m12];
			if (lfp_filtps == NULL)
				realloc_flag = TRUE_m12;
			else if (lfp_filtps->order != CMP_VDS_LOWPASS_ORDER_m12)
				realloc_flag = TRUE_m12;
			else if (lfp_filtps->type != FILT_LOWPASS_TYPE_m12)
				realloc_flag = TRUE_m12;
			else if (lfp_filtps->sampling_frequency != samp_freq)
				realloc_flag = TRUE_m12;
			else if (lfp_filtps->cutoffs[0] != LFP_high_fc)
				realloc_flag = TRUE_m12;
		}
		if (realloc_flag == TRUE_m12) {
			if (lfp_filtps != NULL)
				FILT_free_processing_struct_m12(lfp_filtps, FALSE_m12, FALSE_m12, FALSE_m12, TRUE_m12);
			cps->parameters.filtps[FILT_VDS_TEMPLATE_LFP_PS_m12] = (void *) FILT_initialize_processing_struct_m12(CMP_VDS_LOWPASS_ORDER_m12, FILT_LOWPASS_TYPE_m12, samp_freq, block_samps, FALSE_m12, FALSE_m12, FALSE_m12, (RETURN_ON_FAIL_m12 | SUPPRESS_WARNING_OUTPUT_m12), LFP_high_fc);
			lfp_filtps = (FILT_PROCESSING_STRUCT_m12 *) cps->parameters.filtps[FILT_VDS_TEMPLATE_LFP_PS_m12];
		}
		// put smooth data into offset position
		smooth = (sf8 *) cps->parameters.VDS_input_buffers->buffer[2];
		lfp_filtps->filt_data = smooth;  // smooth data will end up in buffer 2
		lfp_filtps->orig_data = FILT_OFFSET_ORIG_DATA_m12(lfp_filtps);  // offset smooth data for filtering
		cps->parameters.VDS_input_buffers->buffer[2] = (void *) lfp_filtps->orig_data;  // offset smooth data (buffer 2) pointer
	}
	
	// excise transients
	FILT_excise_transients_m12(cps, data_len, &n_extrema);
	extrema = (si8 *) cps->parameters.VDS_input_buffers->buffer[4];
	transients = (sf8 *) cps->parameters.VDS_input_buffers->buffer[3];

	// set up template minimal filter
	template = (sf8 *) cps->parameters.VDS_input_buffers->buffer[8];
	min_filtps->filt_data = template;
	min_filtps->orig_data = FILT_OFFSET_ORIG_DATA_m12(min_filtps);
	
	if (LFP_filter == TRUE_m12) {
		// lowpass filter smooth data
		cps->parameters.VDS_input_buffers->buffer[2] = smooth;  // reset buffer 2 pointer (smooth data)
		lfp_filtps->data_length = data_len;
		lfp_filtps->buffer = (sf8 *) cps->parameters.VDS_input_buffers->buffer[7];
		FILT_filtfilt_m12(lfp_filtps);
	
		// add transients and smooth data into template
		sf8_p1 = smooth;
		sf8_p2 = transients;
		sf8_p3 = min_filtps->orig_data;  // offset template
		for (i = data_len; i--;)
			*sf8_p3++ = *sf8_p1++ + *sf8_p2++;
	} else {
		// copy input data into offset template
		memcpy((void *) min_filtps->orig_data, (void *) y, (size_t) (data_len << 3));  // offset template
	}
	
	// minimal filter template
	min_filtps->data_length = data_len;
	min_filtps->buffer = (sf8 *) cps->parameters.VDS_input_buffers->buffer[7];
	FILT_filtfilt_m12(min_filtps);
	
	// fix extrema in template
	for (i = 0; i < n_extrema; ++i) {
		j = extrema[i];
		template[j] = y[j];
	}
	
	// Exit Buffer Map:
	// 	VDS_in_bufs[CMP_MAK_IN_Y_BUF] == VDS_in_bufs[0]: y (not touched)
	// 	VDS_in_bufs[CMP_MAK_IN_X_BUF] == VDS_in_bufs[1]: x (not touched)
	// 	VDS_in_bufs[2 - 7]: available
	//	VDS_in_bufs[8]:	template
	
	return;
}


sf8	CMP_VDS_get_theshold_m12(CMP_PROCESSING_STRUCT_m12 *cps)
{
	static TERN_m12			thresh_change_noted = FALSE_m12;
	TERN_m12			no_filt;
	si4				i, low_i, high_i;
	sf8				prop, user_thresh, alg_thresh;
	CMP_VDS_THRESHOLD_MAP_ENTRY_m12	*thresh_map;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (global_tables_m12->CMP_VDS_threshold_map == NULL)
		CMP_initialize_tables_m12();
	thresh_map = global_tables_m12->CMP_VDS_threshold_map;
	
	user_thresh = cps->parameters.VDS_threshold;
	if (cps->parameters.VDS_LFP_high_fc == 0.0)
		no_filt = TRUE_m12;
	else
		no_filt = FALSE_m12;

	if (user_thresh > (sf8) 10.0) {
		if (thresh_change_noted == FALSE_m12) {
			if (user_thresh == (sf8) 11.0)
				G_message_m12("%s: This threshold goes to 11 :)\n", __FUNCTION__);
			else
				G_warning_message_m12("%s: the VDS threshold range is 0 to 10 => setting to 10\n", __FUNCTION__);
			thresh_change_noted = TRUE_m12;
		}
		cps->parameters.VDS_threshold = 10.0;
		if (no_filt == TRUE_m12)
			return(thresh_map[CMP_VDS_THRESHOLD_MAP_TABLE_ENTRIES_m12 - 1].algorithm_threshold_no_filt);
		else
			return(thresh_map[CMP_VDS_THRESHOLD_MAP_TABLE_ENTRIES_m12 - 1].algorithm_threshold_LFP);
	}

	if (user_thresh < (sf8) 0.0) {
		G_warning_message_m12("%s: the VDS threshold range is 0 to 10 => setting to 0\n", __FUNCTION__);
		if (no_filt == TRUE_m12)
			return(thresh_map[0].algorithm_threshold_no_filt);
		else
			return(thresh_map[0].algorithm_threshold_LFP);
	}

	for (i = 1; i < CMP_VDS_THRESHOLD_MAP_TABLE_ENTRIES_m12; ++i)
		if (user_thresh < thresh_map[i].user_threshold)
			break;
	
	high_i = i;
	low_i = i - 1;
	if (user_thresh == thresh_map[low_i].user_threshold) {
		if (no_filt == TRUE_m12)
			return(thresh_map[low_i].algorithm_threshold_no_filt);
		else
			return(thresh_map[low_i].algorithm_threshold_LFP);
	}
	
	// interpolate
	prop = (user_thresh - thresh_map[low_i].user_threshold) / (thresh_map[high_i].user_threshold - thresh_map[low_i].user_threshold);
	if (no_filt == TRUE_m12) {
		alg_thresh = (1.0 - prop) * thresh_map[low_i].algorithm_threshold_no_filt;
		alg_thresh += prop * thresh_map[high_i].algorithm_threshold_no_filt;
	} else {
		alg_thresh = (1.0 - prop) * thresh_map[low_i].algorithm_threshold_LFP;
		alg_thresh += prop * thresh_map[high_i].algorithm_threshold_LFP;
	}
	
	return(alg_thresh);
}


sf8	CMP_z2p_m12(sf8 z)
{
	sf8	fna, fnb, fnc, t, p;
	
	
	if (z < (sf8) 0.0)
		z = -z;
	
	t = (sf8) 1.0 / ((sf8) 1.0 + ((sf8) 0.2316419 * z));
	fna = (sf8) -1.82125598 + (t * (sf8) 1.33027443);
	fnb = (sf8) 0.3989423 * t * exp(-z * z / (sf8) 2.0);
	fnc = fnb * ((sf8) 0.31938153 + (t * ((sf8) -0.35656378 + (t * ((sf8) 1.78147794 + (t * fna))))));
	p = fnc * (sf8) 2.0;
	
	return(p);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void    CMP_zero_buffers_m12(CMP_BUFFERS_m12 *buffers)
{
	ui1	*zero_start;
	ui8	pointer_bytes, bytes_to_zero;
	
	
	pointer_bytes = buffers->n_buffers * sizeof(void *);
	bytes_to_zero = buffers->total_allocated_bytes - pointer_bytes;
	zero_start = (ui1 *) buffers->buffer + pointer_bytes;
	
	memset((void *) zero_start, 0, (size_t) bytes_to_zero);
	
	return;
}



//********************************//
// MARK: CHECKSUM FUNCTIONS  (CRC)
//********************************//

// ATTRIBUTION
//
// Basic CRC-32 manipulation routines
// by Mark Adler (madler@alumni.caltech.edu)
// placed in the public domain 29 Apr 2015
//
// "This library provides general CRC calculation & validation functions and an
// operation to combine the CRCs of two sequences of bytes into a single CRC.
// The routines in this libary only work with the particular CRC-32 polynomial
// provided here."
//
// Minor modifications for compatibility with the MED Library.


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
ui4	CRC_calculate_m12(const ui1 *block_ptr, si8 block_bytes)
{
	ui4	crc;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	crc = CRC_update_m12(block_ptr, block_bytes, CRC_START_VALUE_m12);
	
	return(crc);
}


ui4     CRC_combine_m12(ui4 block_1_crc, ui4 block_2_crc, si8 block_2_bytes)
{
	ui4     n, col;
	ui4     even[32];    // even-power-of-two zeros operator
	ui4     odd[32];     // odd-power-of-two zeros operator
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// degenerate case (also disallow negative lengths)
	if (block_2_bytes <= 0)
		return(block_1_crc);
	
	// put operator for one zero bit in odd
	odd[0] = CRC_POLYNOMIAL_m12;
	col = 1;
	for (n = 1; n < 32; n++) {
		odd[n] = col;
		col <<= 1;
	}
	
	// put operator for two zero bits in even
	CRC_matrix_square_m12(even, odd);
	
	// put operator for four zero bits in odd
	CRC_matrix_square_m12(odd, even);
	
	// apply block_2_bytes zeros to crc1 (first square will put the operator for one zero byte, eight zero bits, in even)
	do {
		// apply zeros operator for this bit of block_2_bytes
		CRC_matrix_square_m12(even, odd);
		if (block_2_bytes & 1)
			block_1_crc = CRC_matrix_times_m12(even, block_1_crc);
		block_2_bytes >>= 1;
		
		// if no more bits set, then done
		if (block_2_bytes == 0)
			break;
		
		// another iteration of the loop with odd and even swapped
		CRC_matrix_square_m12(odd, even);
		if (block_2_bytes & 1)
			block_1_crc = CRC_matrix_times_m12(odd, block_1_crc);
		block_2_bytes >>= 1;
		
		// if no more bits set, then done
	} while (block_2_bytes != 0);
	
	return(block_1_crc ^ block_2_crc);
}


TERN_m12	CRC_initialize_tables_m12(void)
{
	ui4	**crc_table, c, n, k;
	si8	dim1_bytes, dim2_bytes, content_bytes, total_bytes;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (global_tables_m12->CRC_table != NULL)
		return(TRUE_m12);

	PROC_pthread_mutex_lock_m12(&global_tables_m12->CRC_mutex);
	if (global_tables_m12->CRC_table != NULL) {  // may have been done by another thread while waiting
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->CRC_mutex);
		return(TRUE_m12);
	}

	if (global_tables_m12->CRC_table == NULL) {
		
		// allocate (2D but not AT)
		dim1_bytes = CRC_TABLES_m12 * sizeof(ui4 *) ;
		dim2_bytes = CRC_TABLE_ENTRIES_m12 * sizeof(ui4);
		content_bytes = CRC_TABLES_m12 * dim2_bytes;
		total_bytes = dim1_bytes + content_bytes;
	#ifdef MATLAB_PERSISTENT_m12
		crc_table = (ui4 **) mxCalloc((mwSize) total_bytes, (mwSize) sizeof(ui1));
	#else
		crc_table = (ui4 **) calloc((size_t) total_bytes, sizeof(ui1));
	#endif
		crc_table[0] = (ui4 *) (crc_table + CRC_TABLES_m12);
		for (k = 1; k < CRC_TABLES_m12; ++k)
			crc_table[k] = crc_table[k - 1] + CRC_TABLE_ENTRIES_m12;

		// generate a crc for every 8-bit value
		for (n = 0; n < CRC_TABLE_ENTRIES_m12; n++) {
			for (c = n, k = 0; k < 8; k++)
				c = c & 1 ? CRC_POLYNOMIAL_m12 ^ (c >> 1) : c >> 1;
			crc_table[0][n] = c;
		}
		
		// generate crc for each value followed by one, two, and three zeros, and then the byte reversal of those as well as the first table
		for (n = 0; n < CRC_TABLE_ENTRIES_m12; n++) {
			c = crc_table[0][n];
			crc_table[4][n] = CRC_SWAP32_m12(c);
			for (k = 1; k < 4; k++) {
				c = crc_table[0][c & 0xff] ^ (c >> 8);
				crc_table[k][n] = c;
				crc_table[k + 4][n] = CRC_SWAP32_m12(c);
			}
		}
		
		global_tables_m12->CRC_table = crc_table;
	}
	
	PROC_pthread_mutex_unlock_m12(&global_tables_m12->CRC_mutex);

	return(TRUE_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void    CRC_matrix_square_m12(ui4 *square, const ui4 *mat)
{
	ui4     n;
	
	
	for (n = 0; n < 32; n++)
		square[n] = CRC_matrix_times_m12(mat, mat[n]);
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
ui4      CRC_matrix_times_m12(const ui4 *mat, ui4 vec)
{
	ui4     sum;
	
	
	sum = 0;
	while (vec) {
		if (vec & 1)
			sum ^= *mat;
		vec >>= 1;
		mat++;
	}
	
	return(sum);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
ui4	CRC_update_m12(const ui1 *block_ptr, si8 block_bytes, ui4 current_crc)
{
	ui4			**crc_table;
	register ui4            c;
	register const ui4	*ui4_buf;
	
	
	if (global_tables_m12->CRC_table == NULL)
		CRC_initialize_tables_m12();
	
	crc_table = global_tables_m12->CRC_table;
	
	c = ~current_crc;
	
	// bring block_ptr to 4 byte alignment
	while (block_bytes && ((ui8) block_ptr & (ui8) 3)) {
		c = crc_table[0][(c ^ (ui4) *block_ptr++) & (ui4) 0xff] ^ (c >> 8);
		block_bytes--;
	}
	
	// calculate CRC in 32 byte chunks
	ui4_buf = (const ui4*) block_ptr;
	while (block_bytes >= 32) {
		c ^= *ui4_buf++;
		c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24];
		c ^= *ui4_buf++;
		c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24];
		c ^= *ui4_buf++;
		c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24];
		c ^= *ui4_buf++;
		c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24];
		c ^= *ui4_buf++;
		c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24];
		c ^= *ui4_buf++;
		c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24];
		c ^= *ui4_buf++;
		c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24];
		c ^= *ui4_buf++;
		c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24];
		block_bytes -= 32;
	}
	
	// process remaining bytes in 4 byte chunks
	while (block_bytes >= 4) {
		c ^= *ui4_buf++;
		c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24];
		block_bytes -= 4;
	}
	block_ptr = (const ui1 *) ui4_buf;
	
	// process remaining bytes as single bytes
	while (block_bytes--)
		c = crc_table[0][(c ^ (ui4) *block_ptr++) & (ui4) 0xff] ^ (c >> 8);
	
	return(~c);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
TERN_m12	CRC_validate_m12(const ui1 *block_ptr, si8 block_bytes, ui4 crc_to_validate)
{
	ui4	crc;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	crc = CRC_calculate_m12(block_ptr, block_bytes);
	
	if (crc == crc_to_validate)
		return(TRUE_m12);
	
	return(FALSE_m12);
}



//*******************************//
// MARK: DATABASE FUNCTIONS  (DB)
//*******************************//

// Currently these functions only support postgres databases.

#ifdef DATABASE_m12
TERN_m12	DB_check_result_m12(PGresult *result)
{
	TERN_m12		result_ok;
	si1			*res_type;
	ExecStatusType		rstat;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	result_ok = TRUE_m12;
	rstat = PQresultStatus(result);
	switch (rstat) {
		case PGRES_EMPTY_QUERY:
			res_type = "PGRES_EMPTY_QUERY";
			result_ok = FALSE_m12;
			break;
		case PGRES_COMMAND_OK:
			res_type = "PGRES_COMMAND_OK";
			break;
		case PGRES_TUPLES_OK:
			res_type = "PGRES_TUPLES_OK";
			break;
		case PGRES_COPY_OUT:
			res_type = "PGRES_COPY_OUT";
			break;
		case PGRES_COPY_IN:
			res_type = "PGRES_COPY_IN";
			break;
		case PGRES_BAD_RESPONSE:
			res_type = "PGRES_BAD_RESPONSE";
			result_ok = FALSE_m12;
			break;
		case PGRES_NONFATAL_ERROR:
			res_type = "PGRES_NONFATAL_ERROR";
			result_ok = FALSE_m12;
			break;
		case PGRES_FATAL_ERROR:
			res_type = "PGRES_FATAL_ERROR";
			result_ok = FALSE_m12;
			break;
		case PGRES_COPY_BOTH:
			res_type = "PGRES_COPY_BOTH";
			break;
		default:
			res_type = "UNKNOWN RESULT TYPE";
			result_ok = FALSE_m12;
			break;
	}
	
	if (result_ok == FALSE_m12)
		G_warning_message_m12("%s(): postgres result: %s", __FUNCTION__, res_type);
	
	return(result_ok);
}
#endif


#ifdef DATABASE_m12
PGresult	*DB_execute_command_m12(PGconn *conn, si1 *command, si4 *rows, si4 expected_rows, const si1 *function, ui4 behavior_on_fail)
{
	extern GLOBALS_m12	*globals_m12;
	PGresult		*result;
	TERN_m12		result_ok;
	si4			local_rows;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	result = PQexec(conn, command);
	result_ok = DB_check_result_m12(result);
	
	if (result_ok == FALSE_m12) {
		PQclear(result);
		if (rows != NULL)
			*rows = 0;
		if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
			(void) fprintf_m12(stderr, "%c\n\t%s(): command \"%s\" failed\n", 7, __FUNCTION__, command);
			(void) fprintf_m12(stderr, "\tpostgres error: %s\n", PQerrorMessage(conn));
			if (function != NULL)
				(void) fprintf_m12(stderr, "\tcalled from function %s()\n", function);
			if (behavior_on_fail & RETURN_ON_FAIL_m12)
				(void) fprintf_m12(stderr, "\t=> returning NULL\n\n");
			else if (behavior_on_fail & EXIT_ON_FAIL_m12)
				(void) fprintf_m12(stderr, "\t=> exiting child / program\n\n");
			fflush(stderr);
		}
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			return(NULL);
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(1);
	}

	local_rows = PQntuples(result);
	if (rows != NULL)
		*rows = local_rows;
	
	if (expected_rows != DB_EXPECTED_ROWS_NO_ENTRY_m12) {
		if (local_rows != expected_rows) {
			if (!(behavior_on_fail & SUPPRESS_WARNING_OUTPUT_m12)) {
				(void) fprintf_m12(stderr, "%c\n\t%s(): rows != expected_rows\n\tcalled from function %s()\n\n", 7, __FUNCTION__, function);
				fflush(stderr);
			}
		}
	}

	return(result);
}
#endif



//**********************************//
// MARK: DATA MATRIX FUNCTIONS  (DM)
//**********************************//

pthread_rval_m12	DM_channel_thread_m12(void *ptr)
{
	TERN_m12			filter, trace_ranges;
	ui1				*data_base, *min_base, *max_base;
	si2				*si2_p1, *si2_p2, *si2_p3;
	si4				i, seg_idx, filt_type, *seg_samps, n_cutoffs, order, filt_poles, pad_samps, bint_mode;
	si4				*si4_p1, *si4_p2, *si4_p3;
	sf4				*sf4_p1, *sf4_p2, *sf4_p3;
	si8				j, k, chan_idx, n_raw_samps, n_seg_samps, required_in_buf_len, chan_offset, samp_offset;
	size_t				n_out_bufs, maj_ptr_bytes;
	si8				*si8_p;
	sf8				*raw_samps, *rsp, raw_samp_freq, cutoff_ratio, cr2, sf_ratio, scale, b, m, q;
	sf8				fc1, fc2, *sf8_p1, *sf8_p2, *sf8_p3, *sf8_p4, *sf8_p5, *sf8_p6, x, inc;
	sf8				*out_buf, *out_mins, *out_maxs, *unfiltered_raw_samps, trace_min, trace_max;
	CHANNEL_m12			*chan;
	SEGMENT_m12			*seg;
	TIME_SLICE_m12			*slice;
	CMP_PROCESSING_STRUCT_m12	*cps;
	FILT_PROCESSING_STRUCT_m12      *filtps;
	DATA_MATRIX_m12			*dm;
	PROC_THREAD_INFO_m12		*pi;
	DM_CHANNEL_THREAD_INFO_m12	*ci;

#ifdef FN_DEBUG_m12
#ifndef MATLAB_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
#endif
	
	pi = (PROC_THREAD_INFO_m12 *) ptr;
	pi->status = PROC_THREAD_RUNNING_m12;
	
	ci = (DM_CHANNEL_THREAD_INFO_m12 *) (pi->arg);
	dm = ci->dm;
	chan = ci->chan;
	chan_idx = ci->chan_idx;
	slice = &chan->time_slice;
	seg_idx = G_get_segment_index_m12(slice->start_segment_number);
	raw_samp_freq = chan->segments[seg_idx]->metadata_fps->metadata->time_series_section_2.sampling_frequency;  // use first open segment so don't require ephemeral metadata
	n_raw_samps = TIME_SLICE_SAMPLE_COUNT_m12(slice);
	
	// Note: trace ranges are rarely used for long: so don't leave memory allocated if not needed
	if (dm->flags & DM_TRACE_RANGES_m12) {
		trace_ranges = TRUE_m12;
	} else {
		trace_ranges = FALSE_m12;
		if (dm->out_bufs[chan_idx] != NULL)
			if (dm->out_bufs[chan_idx]->n_buffers != 1)
				CMP_free_buffers_m12(dm->out_bufs[chan_idx], FALSE_m12);  // will be allocated below
	}

	// set up for filtering
	required_in_buf_len = n_raw_samps;
	filter = FALSE_m12;
	order = 3;
	fc1 = fc2 = (sf8) 0.0;
	if (dm->flags & DM_FILT_MASK_m12) {
		switch (dm->flags & DM_FILT_MASK_m12) {
			case DM_FILT_ANTIALIAS_m12:
			case DM_FILT_LOWPASS_m12:
				filt_type = FILT_LOWPASS_TYPE_m12;
				fc1 = dm->filter_high_fc;
				n_cutoffs = 1;
				break;
			case DM_FILT_HIGHPASS_m12:
				filt_type = FILT_HIGHPASS_TYPE_m12;
				fc1 = dm->filter_low_fc;
				n_cutoffs = 1;
				break;
			case DM_FILT_BANDPASS_m12:
				filt_type = FILT_BANDPASS_TYPE_m12;
				fc1 = dm->filter_low_fc;
				fc2 = dm->filter_high_fc;
				n_cutoffs = 2;
				break;
			case DM_FILT_BANDSTOP_m12:
				filt_type = FILT_BANDSTOP_TYPE_m12;
				fc1 = dm->filter_low_fc;
				fc2 = dm->filter_high_fc;
				n_cutoffs = 2;
				break;
		}
		cutoff_ratio = fc1 / raw_samp_freq;  // fc1 always less than fc2
		cr2 = (sf8) 0.0;
		if (n_cutoffs == 2)
			cr2 = fc2 / raw_samp_freq;
		if (cutoff_ratio < (sf8) 0.5 && cr2 < (sf8) 0.5) {  // can't filter above Nyquist
			filter = TRUE_m12;
			if (cutoff_ratio >= (sf8) 3.14e-05)  // empirically determined
				order = 4;
			filt_poles = FILT_POLES_m12(order, n_cutoffs);
			pad_samps = FILT_FILT_PAD_SAMPLES_m12(filt_poles);
			required_in_buf_len += pad_samps;
		}
	}
	if (dm->flags & DM_FILT_ANTIALIAS_m12)
		if (dm->sample_count >= n_raw_samps)  // upsampling - no need to antialias
			filter = FALSE_m12;

	// allocate processing buffers
	dm->in_bufs[chan_idx] = CMP_allocate_buffers_m12(dm->in_bufs[chan_idx], 3, required_in_buf_len, sizeof(sf8), FALSE_m12, FALSE_m12);
	n_out_bufs = 1;
	if (trace_ranges == TRUE_m12)
		n_out_bufs = 3;
	if ((dm->flags & DM_FMT_CHANNEL_MAJOR_m12) && (dm->flags & DM_TYPE_SF8_m12)) {  // special case - put results directly in output array(s)
		if (dm->out_bufs[chan_idx] != NULL) {
			CMP_free_buffers_m12(dm->out_bufs[chan_idx], TRUE_m12);
			dm->out_bufs[chan_idx] = NULL;
		}
	} else {
		dm->out_bufs[chan_idx] = CMP_allocate_buffers_m12(dm->out_bufs[chan_idx], n_out_bufs, dm->valid_sample_count, sizeof(sf8), FALSE_m12, FALSE_m12);
	}

	// initialize filter
	if (filter == TRUE_m12) {
		filtps = FILT_initialize_processing_struct_m12(order, filt_type, raw_samp_freq, n_raw_samps, FALSE_m12, FALSE_m12, FALSE_m12, (SUPPRESS_OUTPUT_m12 | RETURN_ON_FAIL_m12), fc1, fc2);
		if (filtps == NULL) {
			G_warning_message_m12("%s(): filter error => not filtering\n", __FUNCTION__);
			raw_samps = dm->in_bufs[chan_idx]->buffer[0];
			filter = FALSE_m12;
		} else {
			filtps->filt_data = dm->in_bufs[chan_idx]->buffer[1];
			filtps->buffer = dm->in_bufs[chan_idx]->buffer[2];
			if (trace_ranges == TRUE_m12)  // need a copy of raw data for trace ranges
				filtps->orig_data = dm->in_bufs[chan_idx]->buffer[0];
			else  // put data directly into filt_data array to skip initial copy in FILT_filtfilt_m12()
				filtps->orig_data = FILT_OFFSET_ORIG_DATA_m12(filtps);
			raw_samps = filtps->orig_data;
		}
	} else {  // no filtering
		raw_samps = dm->in_bufs[chan_idx]->buffer[0];
	}

	// put segmented channel si4 data into a single sf8 array
	rsp = raw_samps;
	for (i = 0, j = seg_idx; i < slice->number_of_segments; ++i, ++j) {
		seg = chan->segments[j];
		cps = seg->time_series_data_fps->parameters.cps;
		seg_samps = cps->decompressed_data;
		n_seg_samps = TIME_SLICE_SAMPLE_COUNT_S_m12(seg->time_slice);
		for (k = n_seg_samps; k--;)
			*rsp++ = (sf8) *seg_samps++;
	}

	// filter
	if (filter == TRUE_m12) {
		FILT_filtfilt_m12(filtps);
		raw_samps = filtps->filt_data;
		FILT_free_processing_struct_m12(filtps, FALSE_m12, FALSE_m12, FALSE_m12, TRUE_m12);
	}

	// set up output buffers
	if ((dm->flags & DM_FMT_CHANNEL_MAJOR_m12) && (dm->flags & DM_TYPE_SF8_m12)) {
		// special case - put results directly in output array(s)
		chan_offset = chan_idx * dm->sample_count;
		if (dm->flags & DM_2D_INDEXING_m12) {
			out_buf = *((sf8 **) dm->data) + chan_offset;
			if (trace_ranges == TRUE_m12) {
				out_mins =  *((sf8 **) dm->range_minima) + chan_offset;
				out_maxs =  *((sf8 **) dm->range_maxima) + chan_offset;
			}
		} else {
			out_buf = (sf8 *) dm->data + chan_offset;
			if (trace_ranges == TRUE_m12) {
				out_mins = (sf8 *) dm->range_minima + chan_offset;
				out_maxs = (sf8 *) dm->range_maxima + chan_offset;
			}
		}
	} else {
		out_buf = dm->out_bufs[chan_idx]->buffer[0];
		if (trace_ranges == TRUE_m12) {
			out_mins = dm->out_bufs[chan_idx]->buffer[1];
			out_maxs = dm->out_bufs[chan_idx]->buffer[2];
		}
	}
	
	// binterpolate
	switch (dm->flags & DM_INTRP_BINTRP_MASK_d1) {
		case DM_INTRP_BINTRP_MDPT_m12:
			bint_mode = CMP_CENT_MODE_MIDPOINT_m12;
			break;
			break;
		case DM_INTRP_BINTRP_MEDN_m12:
			bint_mode = CMP_CENT_MODE_MEDIAN_m12;
			break;
		case DM_INTRP_BINTRP_FAST_m12:
			bint_mode = CMP_CENT_MODE_FASTEST_m12;
			break;
		case DM_INTRP_BINTRP_MEAN_m12:
			bint_mode = CMP_CENT_MODE_MEAN_m12;
			break;
	}
	if (trace_ranges == TRUE_m12)
		unfiltered_raw_samps = (sf8 *) dm->in_bufs[chan_idx]->buffer[0];
	switch (dm->flags & DM_INTRP_MASK_m12) {
		case DM_INTRP_LINEAR_m12:
			CMP_lin_interp_sf8_m12(raw_samps, n_raw_samps, out_buf, dm->valid_sample_count);
			if (trace_ranges == TRUE_m12)
				CMP_binterpolate_sf8_m12(unfiltered_raw_samps, n_raw_samps, NULL, dm->valid_sample_count, CMP_CENT_MODE_NONE_m12, trace_ranges, out_mins, out_maxs);
			break;
		case DM_INTRP_MAKIMA_m12:
			// set up makima buffers
			dm->mak_in_bufs[chan_idx] = CMP_allocate_buffers_m12(dm->mak_in_bufs[chan_idx], CMP_MAK_INPUT_BUFFERS_m12, n_raw_samps + CMP_MAK_PAD_SAMPLES_m12, sizeof(sf8), FALSE_m12, FALSE_m12);
			dm->mak_out_bufs[chan_idx] = CMP_allocate_buffers_m12(dm->mak_out_bufs[chan_idx], CMP_MAK_OUTPUT_BUFFERS_m12, dm->valid_sample_count, sizeof(sf8), FALSE_m12, FALSE_m12);
			dm->mak_in_bufs[chan_idx]->buffer[CMP_MAK_IN_Y_BUF] = raw_samps;  // this is OK with CMP_BUFFERS_m12
			sf8_p1 = (sf8 *) dm->mak_in_bufs[chan_idx]->buffer[CMP_MAK_IN_X_BUF];
			for (x = (sf8) -1.0, i = n_raw_samps; i--;)
				*sf8_p1++ = (x += (sf8) 1.0);
			sf8_p1 = (sf8 *) dm->mak_out_bufs[chan_idx]->buffer[CMP_MAK_OUT_X_BUF];
			inc = (sf8) n_raw_samps / (sf8) (dm->valid_sample_count - 1);
			for (x = (sf8) -inc, i = dm->valid_sample_count; i--;)
				*sf8_p1++ = (x += inc);
			dm->mak_out_bufs[chan_idx]->buffer[CMP_MAK_OUT_Y_BUF] = out_buf;  // this is OK with CMP_BUFFERS_m12
			// interpolate
			CMP_mak_interp_sf8_m12(dm->mak_in_bufs[chan_idx], n_raw_samps, dm->mak_out_bufs[chan_idx], dm->valid_sample_count);
			if (trace_ranges == TRUE_m12)
				CMP_binterpolate_sf8_m12(unfiltered_raw_samps, n_raw_samps, NULL, dm->valid_sample_count, CMP_CENT_MODE_NONE_m12, trace_ranges, out_mins, out_maxs);
			break;
		case DM_INTRP_SPLINE_m12:
			dm->spline_bufs[chan_idx] = CMP_allocate_buffers_m12(dm->spline_bufs[chan_idx], 3, n_raw_samps + CMP_SPLINE_TAIL_LEN_m12, sizeof(sf8), FALSE_m12, FALSE_m12);
			CMP_spline_interp_sf8_m12(raw_samps, n_raw_samps, out_buf, dm->valid_sample_count, dm->spline_bufs[chan_idx]);
			if (trace_ranges == TRUE_m12)
				CMP_binterpolate_sf8_m12(unfiltered_raw_samps, n_raw_samps, NULL, dm->valid_sample_count, CMP_CENT_MODE_NONE_m12, trace_ranges, out_mins, out_maxs);
			break;
		case DM_INTRP_BINTRP_MDPT_m12:
		case DM_INTRP_BINTRP_MEAN_m12:
		case DM_INTRP_BINTRP_MEDN_m12:
		case DM_INTRP_BINTRP_FAST_m12:
			CMP_binterpolate_sf8_m12(raw_samps, n_raw_samps, out_buf, dm->valid_sample_count, bint_mode, trace_ranges, out_mins, out_maxs);
			break;
		case DM_INTRP_UP_MAKIMA_DN_LINEAR_m12:
			sf_ratio = dm->sampling_frequency / raw_samp_freq;
			if (sf_ratio > DM_INTRP_MAKIMA_UPSAMPLE_SF_RATIO_m12) {
				// set up makima buffers
				dm->mak_in_bufs[chan_idx] = CMP_allocate_buffers_m12(dm->mak_in_bufs[chan_idx], CMP_MAK_INPUT_BUFFERS_m12, n_raw_samps + CMP_MAK_PAD_SAMPLES_m12, sizeof(sf8), FALSE_m12, FALSE_m12);
				dm->mak_out_bufs[chan_idx] = CMP_allocate_buffers_m12(dm->mak_out_bufs[chan_idx], CMP_MAK_OUTPUT_BUFFERS_m12, dm->valid_sample_count, sizeof(sf8), FALSE_m12, FALSE_m12);
				dm->mak_in_bufs[chan_idx]->buffer[CMP_MAK_IN_Y_BUF] = (void *) raw_samps;  // this is OK with CMP_BUFFERS_m12
				si8_p = (si8 *) dm->mak_in_bufs[chan_idx]->buffer[CMP_MAK_IN_X_BUF] + (n_raw_samps - 1);
				for (i = n_raw_samps; i--;)
					*si8_p-- = i;
				sf8_p1 = (sf8 *) dm->mak_out_bufs[chan_idx]->buffer[CMP_MAK_OUT_X_BUF];
				inc = ((sf8) (n_raw_samps - 1) / (sf8) (dm->valid_sample_count - 1));
				for (x = -inc, i = dm->valid_sample_count; i--;)
					*sf8_p1++ = (x += inc);
				dm->mak_out_bufs[chan_idx]->buffer[CMP_MAK_OUT_Y_BUF] = (void *) out_buf;  // this is OK with CMP_BUFFERS_m12
				// interpolate
				CMP_mak_interp_sf8_m12(dm->mak_in_bufs[chan_idx], n_raw_samps, dm->mak_out_bufs[chan_idx], dm->valid_sample_count);
			} else {
				CMP_lin_interp_sf8_m12(raw_samps, n_raw_samps, out_buf, dm->valid_sample_count);
			}
			if (trace_ranges == TRUE_m12)
				CMP_binterpolate_sf8_m12(unfiltered_raw_samps, n_raw_samps, NULL, dm->valid_sample_count, CMP_CENT_MODE_NONE_m12, trace_ranges, out_mins, out_maxs);
			break;
		case DM_INTRP_UP_SPLINE_DN_LINEAR_m12:  // default (faster & less memory than DM_INTRP_UP_MAKIMA_DN_LINEAR_m12, but not as pretty)
		default:
			sf_ratio = dm->sampling_frequency / raw_samp_freq;
			if (sf_ratio >= DM_INTRP_SPLINE_UPSAMPLE_SF_RATIO_m12) {
				dm->spline_bufs[chan_idx] = CMP_allocate_buffers_m12(dm->spline_bufs[chan_idx], 3, n_raw_samps + CMP_SPLINE_TAIL_LEN_m12, sizeof(sf8), FALSE_m12, FALSE_m12);
				CMP_spline_interp_sf8_m12(raw_samps, n_raw_samps, out_buf, dm->valid_sample_count, dm->spline_bufs[chan_idx]);
			} else {
				CMP_lin_interp_sf8_m12(raw_samps, n_raw_samps, out_buf, dm->valid_sample_count);
			}
			if (trace_ranges == TRUE_m12)
				CMP_binterpolate_sf8_m12(unfiltered_raw_samps, n_raw_samps, NULL, dm->valid_sample_count, CMP_CENT_MODE_NONE_m12, trace_ranges, out_mins, out_maxs);
			break;
	}
	
	// scale
	scale = dm->scale_factor;
	if (dm->flags & DM_SCALE_m12 && scale != 1.0) {
		sf8_p1 = out_buf;
		i = dm->valid_sample_count;
		if (trace_ranges == TRUE_m12) {
			sf8_p2 = out_mins;
			sf8_p3 = out_maxs;
			while (i--) {
				*sf8_p1++ *= scale;
				*sf8_p2++ *= scale;
				*sf8_p3++ *= scale;
			}
		} else {
			while (i--)
				*sf8_p1++ *= scale;
		}
	}
	
	// detrend
	if (dm->flags & DM_DETREND_m12) {
		CMP_lad_reg_sf8_m12(out_buf, dm->valid_sample_count, &m, &b);
		sf8_p1 = out_buf;
		i = dm->valid_sample_count;
		if (trace_ranges == TRUE_m12) {
			sf8_p2 = out_mins;
			sf8_p3 = out_maxs;
			while (i--) {
				*sf8_p1++ -= (q = (b += m));
				*sf8_p2++ -= q;
				*sf8_p3++ -= q;
			}
		} else {
			while (i--)
				*sf8_p1++ -= (b += m);
		}
	}
	
	// trace extrema
	if (dm->flags & DM_TRACE_EXTREMA_m12) {
		sf8_p1 = out_buf;
		trace_min = trace_max = *sf8_p1++;
		for (i = dm->valid_sample_count - 1; i--; ++sf8_p1) {
			if (trace_min > *sf8_p1)
				trace_min = *sf8_p1;
			else if (trace_max < *sf8_p1)
				trace_max = *sf8_p1;
		}
		switch (dm->flags & DM_TYPE_MASK_m12) {
			case DM_TYPE_SI2_m12:
				((si2 *) dm->trace_minima)[chan_idx] = CMP_round_si2_m12(trace_min);
				((si2 *) dm->trace_maxima)[chan_idx] = CMP_round_si2_m12(trace_max);
				break;
			case DM_TYPE_SI4_m12:
				((si4 *) dm->trace_minima)[chan_idx] = CMP_round_si4_m12(trace_min);
				((si4 *) dm->trace_maxima)[chan_idx] = CMP_round_si4_m12(trace_max);
				break;
			case DM_TYPE_SF4_m12:
				((sf4 *) dm->trace_minima)[chan_idx] = (sf4) trace_min;
				((sf4 *) dm->trace_maxima)[chan_idx] = (sf4) trace_max;
				break;
			case DM_TYPE_SF8_m12:
				((sf8 *) dm->trace_minima)[chan_idx] = trace_min;
				((sf8 *) dm->trace_maxima)[chan_idx] = trace_max;
				break;
			default:
				G_warning_message_m12("%s(): invalid element size => returning\n");
				pi->status = PROC_THREAD_FINISHED_m12;
				return((pthread_rval_m12) 0);
		}
	}

	// put data in target arrays
	data_base = (ui1 *) dm->data;
	min_base = (ui1 *) dm->range_minima;
	max_base = (ui1 *) dm->range_maxima;
	if (dm->flags & DM_2D_INDEXING_m12) {
		maj_ptr_bytes = dm->maj_dim * sizeof(void *);
		data_base += maj_ptr_bytes;
		min_base += maj_ptr_bytes;
		max_base += maj_ptr_bytes;
	}
	if (dm->flags & DM_FMT_CHANNEL_MAJOR_m12)
		chan_offset = chan_idx * dm->sample_count;
	else  // DM_FMT_SAMPLE_MAJOR_m12
		samp_offset = dm->channel_count;
	
	switch (dm->flags & DM_TYPE_MASK_m12) {
		case DM_TYPE_SI2_m12:
			if (dm->flags & DM_FMT_CHANNEL_MAJOR_m12) {
				sf8_p1 = out_buf;
				si2_p1 = (si2 *) data_base + chan_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m12) {
					sf8_p2 = out_mins;
					si2_p2 = (si2 *) min_base + chan_offset;
					sf8_p3 = out_maxs;
					si2_p3 = (si2 *) max_base + chan_offset;
					while (i--) {
						*si2_p1++ = CMP_round_si2_m12(*sf8_p1++);
						*si2_p2++ = CMP_round_si2_m12(*sf8_p2++);
						*si2_p3++ = CMP_round_si2_m12(*sf8_p3++);
					}
				} else {
					while (i--)
						*si2_p1++ = CMP_round_si2_m12(*sf8_p1++);
				}
			} else {  // DM_FMT_SAMPLE_MAJOR_m12
				sf8_p1 = out_buf;
				si2_p1 = ((si2 *) data_base + chan_idx) - samp_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m12) {
					sf8_p2 = out_mins;
					si2_p2 = (si2 *) min_base + chan_idx - samp_offset;
					sf8_p3 = out_maxs;
					si2_p3 = (si2 *) max_base + chan_idx - samp_offset;
					while (i--) {
						*(si2_p1 += samp_offset) = CMP_round_si2_m12(*sf8_p1++);
						*(si2_p2 += samp_offset) = CMP_round_si2_m12(*sf8_p2++);
						*(si2_p3 += samp_offset) = CMP_round_si2_m12(*sf8_p3++);
					}
				} else {
					while (i--)
						*(si2_p1 += samp_offset) = CMP_round_si2_m12(*sf8_p1++);
				}
			}
			break;
		case DM_TYPE_SI4_m12:
			if (dm->flags & DM_FMT_CHANNEL_MAJOR_m12) {
				sf8_p1 = out_buf;
				si4_p1 = (si4 *) data_base + chan_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m12) {
					sf8_p2 = out_mins;
					si4_p2 = (si4 *) min_base + chan_offset;
					sf8_p3 = out_maxs;
					si4_p3 = (si4 *) max_base + chan_offset;
					while (i--) {
						*si4_p1++ = CMP_round_si4_m12(*sf8_p1++);
						*si4_p2++ = CMP_round_si4_m12(*sf8_p2++);
						*si4_p3++ = CMP_round_si4_m12(*sf8_p3++);
					}
				} else {
					while (i--)
						*si4_p1++ = CMP_round_si2_m12(*sf8_p1++);
				}
			} else {  // DM_FMT_SAMPLE_MAJOR_m12
				sf8_p1 = out_buf;
				si4_p1 = ((si4 *) data_base + chan_idx) - samp_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m12) {
					sf8_p2 = out_mins;
					si4_p2 = (si4 *) min_base + chan_idx - samp_offset;
					sf8_p3 = out_maxs;
					si4_p3 = (si4 *) max_base + chan_idx - samp_offset;
					while (i--) {
						*(si4_p1 += samp_offset) = CMP_round_si4_m12(*sf8_p1++);
						*(si4_p2 += samp_offset) = CMP_round_si4_m12(*sf8_p2++);
						*(si4_p3 += samp_offset) = CMP_round_si4_m12(*sf8_p3++);
					}
				} else {
					while (i--)
						*(si4_p1 += samp_offset) = CMP_round_si4_m12(*sf8_p1++);
				}

			}
			break;
		case DM_TYPE_SF4_m12:
			if (dm->flags & DM_FMT_CHANNEL_MAJOR_m12) {
				sf8_p1 = out_buf;
				sf4_p1 = (sf4 *) data_base + chan_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m12) {
					sf8_p2 = out_mins;
					sf4_p2 = (sf4 *) min_base + chan_offset;
					sf8_p3 = out_maxs;
					sf4_p3 = (sf4 *) max_base + chan_offset;
					while (i--) {
						*sf4_p1++ = (sf4) *sf8_p1++;
						*sf4_p2++ = (sf4) *sf8_p2++;
						*sf4_p3++ = (sf4) *sf8_p3++;
					}
				} else {
					while (i--)
						*sf4_p1++ = (sf4) *sf8_p1++;
				}
			} else {  // DM_FMT_SAMPLE_MAJOR_m12
				sf8_p1 = out_buf;
				sf4_p1 = ((sf4 *) data_base + chan_idx) - samp_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m12) {
					sf8_p2 = out_mins;
					sf4_p2 = (sf4 *) min_base + chan_idx - samp_offset;
					sf8_p3 = out_maxs;
					sf4_p3 = (sf4 *) max_base + chan_idx - samp_offset;
					while (i--) {
						*(sf4_p1 += samp_offset) = (sf4) *sf8_p1++;
						*(sf4_p2 += samp_offset) = (sf4) *sf8_p2++;
						*(sf4_p3 += samp_offset) = (sf4) *sf8_p3++;
					}
				} else {
					while (i--)
						*(sf4_p1 += samp_offset) = (sf4) *sf8_p1++;
				}

			}
			break;
		case DM_TYPE_SF8_m12:
			// DM_FMT_CHANNEL_MAJOR_m12 written directly into output buffers
			if (dm->flags & DM_FMT_SAMPLE_MAJOR_m12) {
				sf8_p1 = out_buf;
				sf8_p4 = ((sf8 *) data_base + chan_idx) - samp_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m12) {
					sf8_p2 = out_mins;
					sf8_p5 = (sf8 *) min_base + chan_idx - samp_offset;
					sf8_p3 = out_maxs;
					sf8_p6 = (sf8 *) max_base + chan_idx - samp_offset;
					while (i--) {
						*(sf8_p4 += samp_offset) = *sf8_p1++;
						*(sf8_p5 += samp_offset) = *sf8_p2++;
						*(sf8_p6 += samp_offset) = *sf8_p3++;
					}
				} else {
					while (i--)
						*(sf8_p4 += samp_offset) = *sf8_p1++;
				}
			}
			break;
	}

	pi->status = PROC_THREAD_FINISHED_m12;

	return((pthread_rval_m12) 0);
}


void	DM_free_matrix_m12(DATA_MATRIX_m12 *matrix, TERN_m12 free_structure)
{
	si8	i;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (matrix == NULL) {
		G_warning_message_m12("%s(): attempting to free NULL structure\n", __FUNCTION__);
		return;
	}
	
	if (matrix->data != NULL)
		free_m12(matrix->data, __FUNCTION__);
	
	if (matrix->range_minima != NULL)
		free_m12(matrix->range_minima, __FUNCTION__);
	
	if (matrix->range_maxima != NULL)
		free_m12(matrix->range_maxima, __FUNCTION__);
	
	if (matrix->contigua != NULL)
		free_m12((void *) matrix->contigua, __FUNCTION__);

	if (matrix->in_bufs != NULL) {
		for (i = 0; i < matrix->n_proc_bufs; ++i) {
			CMP_free_buffers_m12(matrix->in_bufs[i], TRUE_m12);
			CMP_free_buffers_m12(matrix->out_bufs[i], TRUE_m12);
		}
		free_m12((void *) matrix->in_bufs, __FUNCTION__);
		free_m12((void *) matrix->out_bufs, __FUNCTION__);
	}
	
	if (matrix->mak_in_bufs != NULL) {
		for (i = 0; i < matrix->n_proc_bufs; ++i) {
			CMP_free_buffers_m12(matrix->mak_in_bufs[i], TRUE_m12);
			CMP_free_buffers_m12(matrix->mak_out_bufs[i], TRUE_m12);
		}
		free_m12((void *) matrix->mak_in_bufs, __FUNCTION__);
		free_m12((void *) matrix->mak_out_bufs, __FUNCTION__);
	}

	if (matrix->spline_bufs != NULL) {
		for (i = 0; i < matrix->n_proc_bufs; ++i)
			CMP_free_buffers_m12(matrix->spline_bufs[i], TRUE_m12);
		free_m12((void *) matrix->spline_bufs, __FUNCTION__);
	}

	if (free_structure == TRUE_m12) {
		free_m12((void *) matrix, __FUNCTION__);
	} else {
		matrix->data = NULL;
		matrix->range_minima = NULL;
		matrix->range_maxima = NULL;
		matrix->range_maxima = NULL;
		matrix->contigua = NULL;
		matrix->number_of_contigua = 0;
		matrix->in_bufs = NULL;
		matrix->out_bufs = NULL;
		matrix->spline_bufs = NULL;
		matrix->n_proc_bufs = 0;
	}

	return;
}


DATA_MATRIX_m12 *DM_get_matrix_m12(DATA_MATRIX_m12 *matrix, SESSION_m12 *sess, TIME_SLICE_m12 *slice, si4 varargs, ...)  // varargs: si8 out_samp_count, sf8 out_sf, ui8 flags, sf8 scale, sf8 fc1, sf8 fc2
{
	TERN_m12			changed_to_relative, ret_val;
	ui1				*data_base, *minima_base, *maxima_base;
	si2				si2_pad;
	si4				search_mode, seg_idx, si4_pad;
	sf4				sf4_pad;
	ui8				tmp_ui8;
	si8				i, j, old_maj_dim, old_min_dim, old_el_size, old_offset, new_offset, samp_offset;
	si8				req_num_samps, ref_num_samps, bytes_per_sample, bytes_per_channel, data_end, contig_samples;
	si8				gap_start, gap_end, gap_len, common_offset, gap_offset, tmp_si8;
	sf8 				ratio, duration, fc1, fc2, req_samp_secs, ref_samp_secs, ref_samp_freq, sf8_pad, tmp_sf8;
	void				*pattern;
	size_t				new_data_bytes, curr_bytes, new_bytes, trace_extrema_bytes, n_elements, pattern_sz, bytes_to_move;
	va_list				args;
	CHANNEL_m12			*chan, *ref_chan;
	TIME_SLICE_m12			passed_slice_copy, *req_slice, *sess_slice;
	PROC_THREAD_INFO_m12		*proc_thread_infos, *pi;
	DM_CHANNEL_THREAD_INFO_m12	*chan_thread_infos, *ci;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// USAGE:
	// Session must have been opened by caller (so mapping mechanism, active channels, etc. are set), but session is not read.
	// The desired extents are specified in the session TIME_SLICE by the caller.
	// DM_get_matrix_m12() may need to change the time extents of the slice depending on the DM flags and discontinuities.
	// DM_get_matrix_m12() will call G_read_session_m12() once the required times have been determined.

	// NOTE:
	// DM_EXTMD_COUNT_AND_FREQ_m12: If the caller wants a fixed number of valid output samples, at a specific output frequency, they should set this flag,
	// and fill in both of these values. DM_get_matrix_m12() will use the slice start time, or start sample number, but adjust the end time if there are
	// discontinuities. The session time slice will reflect what actually occured upon return.
	// DM_EXTMD_COUNT_AND_FREQ_m12 is not compatible with DM_DSCNT_NAN_m12 or DM_DSCNT_ZERO_m12. If these are set the function will return.
	// If discontinuity information is desired with DM_EXTMD_COUNT_AND_FREQ_m12, set DM_DSCNT_CONTIG_m12. This is because DM_EXTMD_COUNT_AND_FREQ_m12
	// implies the caller wants only valid sample values & also, if padding were requested, the number of output samples could be enormous.
	
	// NOTE: This function handles a lot of options. I don't like creating subfunctions with pieces that won't be used anywhere else.
	// As a result, it is behemoth, and somewhat difficult to follow.  Apologies to my fellow coders that need to dig into it.
	
	// DM_get_matrix_m12() varargs: si8 out_samp_count, sf8 out_sf, ui8 flags, sf8 scale, sf8 fc1, sf8 fc2
	//
	// IMPORTANT: pass correct types for varargs - compiler cannot promote / convert to proper type because it doesn't know what they should be
	//
	// varargs DM_FILT_LOWPASS_m12 set: fc1 == high_cutoff
	// varargs DM_FILT_HIGHPASS_m12 set: fc1 == low_cutoff
	// varargs DM_FILT_BANDPASS_m12 set: fc1 == low_cutoff, fc2 == high_cutoff
	// varargs DM_FILT_BANDSTOP_m12 set: fc1 == low_cutoff, fc2 == high_cutoff
	// varargs matrix == NULL: flags, out_samp_count, out_samp_freq are passed (fc1 & fc2 must be filled in, but if not used, 0.0 should be passed as place holders)

	if (sess == NULL) {
		G_warning_message_m12("%s(): NULL session => returning\n", __FUNCTION__);
		return(NULL);
	}
	if (!(sess->flags & LH_OPEN_m12)) {
		G_warning_message_m12("%s(): session not open => returning\n", __FUNCTION__);
		return(NULL);
	}
	if (slice == NULL)  // if no slice passed, session slice is used, but may be modified
		slice = &sess->time_slice;
	if ((search_mode = G_get_search_mode_m12(slice)) == FALSE_m12)  // ensure there's a valid limit pair
		return(NULL);

	// allocate matrix structure
	if (matrix == NULL)
		matrix = (DATA_MATRIX_m12 *) calloc_m12((size_t) 1, sizeof(DATA_MATRIX_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	if (varargs == TRUE_m12) {  // varargs: si8 out_samp_count, sf8 out_sf, ui8 flags, sf8 scale, sf8 fc1, sf8 fc2
		// pass zero for anything you don't want to change
		va_start(args, varargs);
		tmp_si8 = va_arg(args, si8);
		if (tmp_si8)
			matrix->sample_count = tmp_si8;
		tmp_sf8 = va_arg(args, sf8);
		if (tmp_sf8 > 0.0)
			matrix->sampling_frequency = tmp_sf8;
		tmp_ui8 = va_arg(args, ui8);
		if (tmp_ui8)
			matrix->flags = tmp_ui8;
		tmp_sf8 = va_arg(args, sf8);
		if (tmp_sf8 != 0.0)  // to change from scaling to non-scaling, you must pass 1.0 for the scale factor, otherwise it is interpreted as a skip
			matrix->scale_factor = tmp_sf8;
		fc1 = va_arg(args, sf8);
		fc2 = va_arg(args, sf8);
		va_end(args);
	}
	old_maj_dim = matrix->maj_dim;
	old_min_dim = matrix->min_dim;
	old_el_size = matrix->el_size;
	
	// check maximum input defaults
	if (matrix->sample_count == DM_MAXIMUM_INPUT_COUNT_m12 || matrix->sampling_frequency == DM_MAXIMUM_INPUT_FREQUENCY_m12) {
		if (matrix->sample_count == DM_MAXIMUM_INPUT_COUNT_m12) {  // change count to frequency mode
			matrix->flags &= ~DM_EXTMD_SAMP_COUNT_m12;
			matrix->flags |= DM_EXTMD_SAMP_FREQ_m12;
			matrix->sample_count = 0;
		}
		matrix->sampling_frequency = globals_m12->maximum_time_series_frequency;
	}
		
	switch (matrix->flags & DM_EXTMD_MASK_m12) {
		case DM_EXTMD_SAMP_COUNT_m12:
			if (matrix->sample_count <= 0) {
				G_warning_message_m12("%s(): DM_EXTMD_SAMP_COUNT_m12 must specify matrix sample count => returning\n", __FUNCTION__);
				return(NULL);
			}
			break;
		case DM_EXTMD_SAMP_FREQ_m12:
			if (matrix->sampling_frequency <= (sf8) 0.0) {
				G_warning_message_m12("%s(): DM_EXTMD_SAMP_FREQ_m12 must specify matrix sampling frequency => returning\n", __FUNCTION__);
				return(NULL);
			}
			break;
		default:
			G_warning_message_m12("%s(): invalid extents mode (DM_EXTMD_SAMP_COUNT_m12 or DM_EXTMD_SAMP_FREQ_m12) => returning\n", __FUNCTION__);
			return(NULL);
	}
	if ((matrix->flags & (DM_EXTMD_ABSOLUTE_LIMITS_m12 | DM_EXTMD_RELATIVE_LIMITS_m12)) == 0) {
		G_warning_message_m12("%s(): either DM_EXTMD_ABSOLUTE_LIMITS_m12 or DM_EXTMD_RELATIVE_LIMITS_m12 extents mode must be selected => returning\n", __FUNCTION__);
		return(NULL);

	}
	if ((matrix->flags & DM_EXTMD_ABSOLUTE_LIMITS_m12) && (matrix->flags & DM_EXTMD_RELATIVE_LIMITS_m12)) {
		G_warning_message_m12("%s(): DM_EXTMD_ABSOLUTE_LIMITS_m12 and DM_EXTMD_RELATIVE_LIMITS_m12 extents modes are mutually exclusive => returning\n", __FUNCTION__);
		return(NULL);

	}
	
	// set slice parameters by extents limits
	passed_slice_copy = *slice;  // passed slice not modified
	req_slice = &passed_slice_copy;  // this slice may be modified
	
	if (req_slice->conditioned == FALSE_m12)
		G_condition_time_slice_m12(req_slice);
	if (search_mode == TIME_SEARCH_m12)
		req_samp_secs = (sf8) TIME_SLICE_DURATION_m12(req_slice) / (sf8) 1000000.0;  // requested time in seconds
	else  // search_mode == SAMPLE_SEARCH_m12
		req_num_samps = TIME_SLICE_SAMPLE_COUNT_m12(req_slice);  // requested samples read (on reference channel)
	ref_chan = globals_m12->reference_channel;
	seg_idx = G_get_segment_index_m12(FIRST_OPEN_SEGMENT_m12);
	ref_samp_freq = ref_chan->segments[seg_idx]->metadata_fps->metadata->time_series_section_2.sampling_frequency;  // use first open segment so don't require ephemeral metadata
	changed_to_relative = FALSE_m12;
	switch (matrix->flags & DM_EXTMD_LIMIT_MASK_m12) {
		case DM_EXTMD_ABSOLUTE_LIMITS_m12:
			if (search_mode == SAMPLE_SEARCH_m12) {
				req_slice->start_time = G_uutc_for_sample_number_m12((LEVEL_HEADER_m12 *) sess, req_slice->start_sample_number, FIND_START_m12);
				if (matrix->flags & DM_PAD_MASK_m12) {  // convert to relative time search
					duration = (sf8) TIME_SLICE_SAMPLE_COUNT_m12(req_slice) / ref_samp_freq;
					req_slice->end_time = req_slice->start_time + (si8) (duration + (sf8) 0.5) - (si8) 1;
					changed_to_relative = TRUE_m12;
				} else {  // no padding
					req_slice->end_time = G_uutc_for_sample_number_m12((LEVEL_HEADER_m12 *) sess, req_slice->end_sample_number, FIND_END_m12);
				}
			}
			break;
		case DM_EXTMD_RELATIVE_LIMITS_m12:
			if (search_mode == TIME_SEARCH_m12) {
				if ((matrix->flags & DM_PAD_MASK_m12) == 0) {  // no padding
					req_slice->start_sample_number = G_sample_number_for_uutc_m12((LEVEL_HEADER_m12 *) sess, req_slice->start_time, FIND_CURRENT_m12);
					duration = (sf8) TIME_SLICE_DURATION_m12(req_slice) / (sf8) 1e6;  // convert to seconds
					req_slice->end_sample_number = req_slice->start_sample_number + (si8) ((ref_samp_freq * duration) + (sf8) 0.5) - (si8) 1;  // relative samples
					req_slice->end_time = G_uutc_for_sample_number_m12((LEVEL_HEADER_m12 *) sess, req_slice->end_sample_number, FIND_END_m12);
				}
			} else {  // search_mode == SAMPLE_SEARCH_m12
				if (matrix->flags & DM_PAD_MASK_m12) {  // convert to relative time search
					duration = (sf8) TIME_SLICE_SAMPLE_COUNT_m12(req_slice) / ref_samp_freq;
					req_slice->start_time = G_uutc_for_sample_number_m12((LEVEL_HEADER_m12 *) sess, req_slice->start_sample_number, FIND_START_m12);
					req_slice->end_time = req_slice->start_time + (si8) (duration + (sf8) 0.5) - (si8) 1;
				} else {  // no padding
					req_slice->start_time = G_uutc_for_sample_number_m12((LEVEL_HEADER_m12 *) sess, req_slice->start_sample_number, FIND_START_m12);
					req_slice->end_time = G_uutc_for_sample_number_m12((LEVEL_HEADER_m12 *) sess, req_slice->end_sample_number, FIND_END_m12);
				}
			}
			break;
		default:
			G_warning_message_m12("%s(): invalid extents limits (DM_EXTMD_ABSOLUTE_LIMITS_m12 or DM_EXTMD_RELATIVE_LIMITS_m12) => returning\n", __FUNCTION__);
			return(NULL);
	}

	req_slice->start_sample_number = req_slice->end_sample_number = SAMPLE_NUMBER_NO_ENTRY_m12;  // all extents now changed to time (for variable frequency channels)
	if (matrix->flags & DM_EXTMD_RELATIVE_LIMITS_m12 || changed_to_relative == TRUE_m12)  // force re-evaluation of segment range for relative modes
		req_slice->number_of_segments = UNKNOWN_m12;

	// read session
	if (G_read_session_m12(sess, req_slice) == NULL)
		return(NULL);
	sess_slice = &sess->time_slice;  // filled in with actual values
	
	// return a NULL matrix if there is no data found
	if (sess_slice->number_of_segments == UNKNOWN_m12)
		return(NULL);
	
	// get output sample count & sampling frequency
	ref_num_samps = TIME_SLICE_SAMPLE_COUNT_S_m12(ref_chan->time_slice);  // actual samples read (on reference channel)
	ref_samp_secs = (sf8) ref_num_samps / ref_samp_freq;  // elapsed sample time, ignoring discontinuities
	switch (matrix->flags & DM_EXTMD_MASK_m12) {
		case DM_EXTMD_SAMP_COUNT_m12:
			if (search_mode == TIME_SEARCH_m12)
				ratio = ref_samp_secs / req_samp_secs;
			else  // search_mode == SAMPLE_SEARCH_m12
				ratio = (sf8) ref_num_samps / (sf8) req_num_samps;
			matrix->valid_sample_count = (si8) round((sf8) matrix->sample_count * ratio);
			if (matrix->valid_sample_count > matrix->sample_count)
				matrix->valid_sample_count = matrix->sample_count;  // rounding error - valid count can only be less than or equal to requested count
			if ((matrix->flags & DM_PAD_MASK_m12) == 0)  // sample count doesn't change if padded
				matrix->sample_count = matrix->valid_sample_count;
			matrix->sampling_frequency = (sf8) matrix->valid_sample_count / ref_samp_secs;
			break;
		case DM_EXTMD_SAMP_FREQ_m12:
			matrix->valid_sample_count = (si8) round(matrix->sampling_frequency * ref_samp_secs);
			if (matrix->flags & DM_PAD_MASK_m12) {
				if (search_mode == SAMPLE_SEARCH_m12)
					req_samp_secs = (sf8) req_num_samps / ref_samp_freq;
				matrix->sample_count = (si8) round(matrix->sampling_frequency * req_samp_secs);
			} else {
				matrix->sample_count = matrix->valid_sample_count;
			}
			break;
	}

	// set scaling
	if (matrix->scale_factor == 0.0)  // calloc value
		matrix->scale_factor = 1.0;  // no scaling

	// set filter cutoffs
	if (matrix->flags & DM_FILT_MASK_m12) {
		if (varargs == TRUE_m12) {  // caller passed cutoffs as varargs
			switch (matrix->flags & DM_FILT_MASK_m12) {
				case DM_FILT_LOWPASS_m12:
					if (fc1 > 0.0)
						matrix->filter_high_fc = fc1;
					break;
				case DM_FILT_HIGHPASS_m12:
					if (fc1 > 0.0)
						matrix->filter_low_fc = fc1;
					break;
				case DM_FILT_BANDPASS_m12:
				case DM_FILT_BANDSTOP_m12:
					if (fc1 > 0.0)
						matrix->filter_low_fc = fc1;
					if (fc2 > 0.0)
						matrix->filter_high_fc = fc2;
					break;
			}
		}
		switch (matrix->flags & DM_FILT_MASK_m12) {
			case DM_FILT_ANTIALIAS_m12:
				matrix->filter_high_fc = matrix->sampling_frequency / FILT_ANTIALIAS_FREQ_DIVISOR_DEFAULT_m12;
			case DM_FILT_LOWPASS_m12:
				matrix->filter_low_fc = NAN;  // nan("");
				break;
			case DM_FILT_HIGHPASS_m12:
				matrix->filter_high_fc = NAN;  // nan("");
				break;
			case DM_FILT_BANDPASS_m12:
			case DM_FILT_BANDSTOP_m12:
				break;
		}
	}

	// get active channel count
	for (matrix->channel_count = i = 0; i < sess->number_of_time_series_channels; ++i) {
		chan = sess->time_series_channels[i];
		if (chan->flags & LH_CHANNEL_ACTIVE_m12)
			++matrix->channel_count;
	}
	if (matrix->channel_count == 0) {
		G_warning_message_m12("%s(): invalid channel count => returning\n", __FUNCTION__);
		return(NULL);
	}

	// get matrix dimensions
	if ((matrix->flags & DM_FMT_MASK_m12) == 0) {  // does not check if multiple flags set
		G_warning_message_m12("%s(): invalid format => returning\n", __FUNCTION__);
		return(NULL);
	}
	if (matrix->flags & DM_FMT_SAMPLE_MAJOR_m12) {
		matrix->maj_dim = matrix->sample_count;
		matrix->min_dim = matrix->channel_count;
	} else {  // DM_FMT_CHANNEL_MAJOR_m12
		matrix->maj_dim = matrix->channel_count;
		matrix->min_dim = matrix->sample_count;
	}
	
	// get element size
	switch (matrix->flags & DM_TYPE_MASK_m12) {
		case DM_TYPE_SI2_m12:
			matrix->el_size = 2;
			break;
		case DM_TYPE_SI4_m12:
		case DM_TYPE_SF4_m12:
			matrix->el_size = 4;
			break;
		case DM_TYPE_SF8_m12:
			matrix->el_size = 8;
			break;
		default:
			G_warning_message_m12("%s(): invalid element size => returning\n", __FUNCTION__);
			return(NULL);
	}
	
	// allocate channel processing buffer pointers
	if (matrix->n_proc_bufs < matrix->channel_count) {
		if (matrix->in_bufs == NULL) {
			matrix->in_bufs = (CMP_BUFFERS_m12 **) calloc_m12((size_t) matrix->channel_count, sizeof(CMP_BUFFERS_m12 *), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			matrix->out_bufs = (CMP_BUFFERS_m12 **) calloc_m12((size_t) matrix->channel_count, sizeof(CMP_BUFFERS_m12 *), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			if (matrix->flags & (DM_INTRP_MAKIMA_m12 | DM_INTRP_UP_MAKIMA_DN_LINEAR_m12)) {
				matrix->mak_in_bufs = (CMP_BUFFERS_m12 **) calloc_m12((size_t) matrix->channel_count, sizeof(CMP_BUFFERS_m12 *), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
				matrix->mak_out_bufs = (CMP_BUFFERS_m12 **) calloc_m12((size_t) matrix->channel_count, sizeof(CMP_BUFFERS_m12 *), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			}
			if (matrix->flags & (DM_INTRP_SPLINE_m12 | DM_INTRP_UP_SPLINE_DN_LINEAR_m12))
				matrix->spline_bufs = (CMP_BUFFERS_m12 **) calloc_m12((size_t) matrix->channel_count, sizeof(CMP_BUFFERS_m12 *), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		} else {
			curr_bytes = matrix->n_proc_bufs * sizeof(CMP_BUFFERS_m12 *);
			new_bytes = matrix->channel_count * sizeof(CMP_BUFFERS_m12 *);
			matrix->in_bufs = (CMP_BUFFERS_m12 **) recalloc_m12(matrix->in_bufs, curr_bytes, new_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			matrix->out_bufs = (CMP_BUFFERS_m12 **) recalloc_m12(matrix->out_bufs, curr_bytes, new_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			if (matrix->flags & (DM_INTRP_MAKIMA_m12 | DM_INTRP_UP_MAKIMA_DN_LINEAR_m12)) {
				matrix->mak_in_bufs = (CMP_BUFFERS_m12 **) recalloc_m12((void *) matrix->mak_in_bufs, curr_bytes, new_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
				matrix->mak_in_bufs = (CMP_BUFFERS_m12 **) recalloc_m12((void *) matrix->mak_out_bufs, curr_bytes, new_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			}
			if (matrix->flags & (DM_INTRP_SPLINE_m12 | DM_INTRP_UP_SPLINE_DN_LINEAR_m12))
				matrix->spline_bufs = (CMP_BUFFERS_m12 **) recalloc_m12(matrix->spline_bufs, curr_bytes, new_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		}
		matrix->n_proc_bufs = matrix->channel_count;
	}
	if (matrix->flags & DM_TRACE_EXTREMA_m12) {
		if (matrix->n_proc_bufs < matrix->channel_count || matrix->el_size > old_el_size) {
			if (matrix->trace_minima != NULL) {
				free_m12(matrix->trace_minima, __FUNCTION__);
				free_m12(matrix->trace_maxima, __FUNCTION__);
				matrix->trace_minima = matrix->trace_maxima = NULL;
			}
		}
		if (matrix->trace_minima == NULL) {
			trace_extrema_bytes = matrix->channel_count * matrix->el_size;
			matrix->trace_minima = malloc_m12(trace_extrema_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			matrix->trace_maxima = malloc_m12(trace_extrema_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		}
	}

	// allocate matrix return contents
	new_data_bytes = matrix->maj_dim * matrix->min_dim * matrix->el_size;
	if (matrix->flags & DM_2D_INDEXING_m12) {
		new_data_bytes += matrix->maj_dim * sizeof(void *);
		if (matrix->maj_dim != old_maj_dim || matrix->min_dim != old_min_dim || matrix->el_size != old_el_size)  // everthing must match
			matrix->data_bytes = 0;  // force failure below
	}
	if (matrix->data_bytes < (si8) new_data_bytes) {
		matrix->data_bytes = (si8) new_data_bytes;
		if (matrix->data != NULL) {
			free_m12((void *) matrix->data, __FUNCTION__);
			if (matrix->range_minima != NULL) {  // always paired
				free_m12((void *) matrix->range_minima, __FUNCTION__);
				free_m12((void *) matrix->range_maxima, __FUNCTION__);
				matrix->range_minima = matrix->range_maxima = NULL;
			}
		}
		if (matrix->flags & DM_2D_INDEXING_m12)
			matrix->data = (void *) malloc_2D_m12(matrix->maj_dim, matrix->min_dim, matrix->el_size, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		else
			matrix->data = malloc_m12(new_data_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		if (matrix->flags & DM_TRACE_RANGES_m12) {
			if (matrix->flags & DM_2D_INDEXING_m12) {
				matrix->range_minima = (void *) malloc_2D_m12(matrix->maj_dim, matrix->min_dim, matrix->el_size, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
				matrix->range_maxima = (void *) malloc_2D_m12(matrix->maj_dim, matrix->min_dim, matrix->el_size, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			} else {
				matrix->range_minima = malloc_m12(new_data_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
				matrix->range_maxima = malloc_m12(new_data_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			}
		}
	}

	// set up thread infos
	pi = proc_thread_infos = (PROC_THREAD_INFO_m12 *) calloc((size_t) matrix->channel_count, sizeof(PROC_THREAD_INFO_m12));
	ci = chan_thread_infos = (DM_CHANNEL_THREAD_INFO_m12 *) calloc((size_t) matrix->channel_count, sizeof(DM_CHANNEL_THREAD_INFO_m12));
	for (i = j = 0; i < matrix->channel_count; ++j) {
		chan = sess->time_series_channels[j];
		if (chan->flags & LH_CHANNEL_ACTIVE_m12) {
			pi->thread_f = DM_channel_thread_m12;
			pi->thread_label = "DM_channel_thread_m12";
			pi->priority = PROC_HIGH_PRIORITY_m12;
			pi->arg = (void *) ci;
			ci->dm = matrix;
			ci->chan = chan;
			ci->chan_idx = i++;
			++pi; ++ci;
		}
	}
	
	// debug threads
//	for (i = 0; i < matrix->channel_count; ++i)
//		DM_channel_thread_m12((void *) (proc_thread_infos + i));
//	ret_val = TRUE_m12;
	
	// launch channel threads; don't wait for completion
	ret_val = PROC_distribute_jobs_m12(proc_thread_infos, matrix->channel_count, 0, FALSE_m12);  // default reserved cores
	if (ret_val == FALSE_m12) {
		G_warning_message_m12("%s(): channel thread error => returning\n", __FUNCTION__);
		return(NULL);
	}

	// get contigua
	if (matrix->flags & DM_DSCNT_MASK_m12) {
		if (matrix->contigua != NULL) {
			free_m12((void *) matrix->contigua, __FUNCTION__);
			matrix->contigua = NULL;
			matrix->number_of_contigua = 0;
		}
		matrix->number_of_contigua = G_build_contigua_m12((LEVEL_HEADER_m12 *) sess);
		// make contigua indices matrix relative
		if (matrix->number_of_contigua) {
			matrix->contigua = (CONTIGUON_m12 *) calloc_m12((size_t) matrix->number_of_contigua, sizeof(CONTIGUON_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			memcpy(matrix->contigua, sess->contigua, matrix->number_of_contigua * sizeof(CONTIGUON_m12));
			tmp_sf8 = matrix->sampling_frequency / (sf8) 1e6;
			if (matrix->flags & DM_PAD_MASK_m12) {
				// sf = (sf8) matrix->sampling_frequency / (sf8) 1e6;
				for (i = 0; i < matrix->number_of_contigua; ++i) {
					matrix->contigua[i].start_sample_number = (si8) round((matrix->contigua[i].start_time - sess_slice->start_time) * tmp_sf8);
					matrix->contigua[i].end_sample_number = (si8) round((matrix->contigua[i].end_time - sess_slice->start_time) * tmp_sf8);
				}
			} else {  // not padded
				for (samp_offset = i = 0; i < matrix->number_of_contigua; ++i) {
					matrix->contigua[i].start_sample_number = samp_offset;
					duration = (sf8) ((matrix->contigua[i].end_time - matrix->contigua[i].start_time) + 1);
					samp_offset += (si8) round(duration * tmp_sf8);
					matrix->contigua[i].end_sample_number = samp_offset;
					if (matrix->contigua[i].end_sample_number > matrix->contigua[i].start_sample_number)
						--matrix->contigua[i].end_sample_number;
				}
			}
			matrix->contigua[matrix->number_of_contigua - 1].end_sample_number = matrix->sample_count - 1;
		}
	}

	// wait for channel threads
	ret_val = PROC_wait_jobs_m12(proc_thread_infos, matrix->channel_count);
	free((void *) proc_thread_infos);
	free((void *) chan_thread_infos);

	// check results
	if (ret_val == FALSE_m12) {
		G_warning_message_m12("%s(): channel thread error => returning\n", __FUNCTION__);
		return(NULL);
	}

	// padding options (big pain in the ass)
	if ((matrix->flags & DM_PAD_MASK_m12) && (matrix->number_of_contigua > 1)) {
		// changed extents mode warning
		if (changed_to_relative == TRUE_m12)
			G_warning_message_m12("%s(): discontinuity => extents mode temporarily changed from absolute to relative\n", __FUNCTION__);
		// set patterns up for padding
		switch (matrix->flags & DM_TYPE_MASK_m12) {
			case DM_TYPE_SI2_m12:
				si2_pad = (si2) 0;
				if (matrix->flags & DM_DSCNT_NAN_m12)
					si2_pad = NAN_SI2_m12;
				pattern = (void *) &si2_pad;
				pattern_sz = 2;
				break;
			case DM_TYPE_SI4_m12:
				si4_pad = (si4) 0;
				if (matrix->flags & DM_DSCNT_NAN_m12)
					si4_pad = NAN_SI4_m12;
				pattern = (void *) &si4_pad;
				pattern_sz = 4;
				break;
			case DM_TYPE_SF4_m12:
				sf4_pad = (sf4) 0.0;
				if (matrix->flags & DM_DSCNT_NAN_m12)
					sf4_pad = NAN;
				pattern = (void *) &sf4_pad;
				pattern_sz = 4;
				break;
			case DM_TYPE_SF8_m12:
				sf8_pad = (sf8) 0.0;
				if (matrix->flags & DM_DSCNT_NAN_m12)
					sf8_pad = NAN;
				pattern = (void *) &sf8_pad;
				pattern_sz = 8;
				break;

		}
		// set up for indexing
		data_base = (ui1 *) matrix->data;
		if (matrix->flags & DM_2D_INDEXING_m12) {
			if (matrix->flags & DM_FMT_SAMPLE_MAJOR_m12)
				data_base += matrix->sample_count * sizeof(void *);
			else  // DM_FMT_CHANNEL_MAJOR_m12
				data_base += matrix->channel_count * sizeof(void *);
		}
		if (matrix->flags & DM_TRACE_RANGES_m12) {
			minima_base = (ui1 *) matrix->range_minima;
			if (matrix->flags & DM_2D_INDEXING_m12) {
				if (matrix->flags & DM_FMT_SAMPLE_MAJOR_m12)
					minima_base += matrix->sample_count * sizeof(void *);
				else  // DM_FMT_CHANNEL_MAJOR_m12
					minima_base += matrix->channel_count * sizeof(void *);
			}
			maxima_base = (ui1 *) matrix->range_maxima;
			if (matrix->flags & DM_2D_INDEXING_m12) {
				if (matrix->flags & DM_FMT_SAMPLE_MAJOR_m12)
					maxima_base += matrix->sample_count * sizeof(void *);
				else  // DM_FMT_CHANNEL_MAJOR_m12
					maxima_base += matrix->channel_count * sizeof(void *);
			}
		}

		// loop backwards over contigua
		data_end = matrix->valid_sample_count;
		gap_end = matrix->sample_count;
		for (i = matrix->number_of_contigua; i--;) {
			contig_samples = (matrix->contigua[i].start_sample_number - matrix->contigua[i].start_sample_number) + 1;
			gap_start = matrix->contigua[i].end_sample_number + 1;
			gap_len = gap_end - gap_start;
			if (matrix->flags & DM_FMT_SAMPLE_MAJOR_m12) {
				// move block
				bytes_per_sample = matrix->channel_count * matrix->el_size;
				old_offset = (data_end - contig_samples) * bytes_per_sample;
				new_offset = bytes_per_sample * matrix->contigua[i].start_sample_number;
				bytes_to_move = bytes_per_sample * contig_samples;
				memmove((void *) (data_base + new_offset), (void *) (data_base + old_offset), bytes_to_move);
				if (matrix->flags & DM_TRACE_RANGES_m12) {
					memmove((void *) (minima_base + new_offset), (void *) (minima_base + old_offset), bytes_to_move);
					memmove((void *) (maxima_base + new_offset), (void *) (maxima_base + old_offset), bytes_to_move);
				}
				// fill gap
				if (gap_len > 0) {
					n_elements = gap_len * matrix->channel_count;
					gap_offset = gap_len * bytes_per_sample;
					memset_m12(data_base + gap_offset, pattern, pattern_sz, n_elements);
					if (matrix->flags & DM_TRACE_RANGES_m12) {
						memset_m12(minima_base + gap_offset, pattern, pattern_sz, n_elements);
						memset_m12(maxima_base + gap_offset, pattern, pattern_sz, n_elements);
					}
				}
			} else {  // DM_FMT_CHANNEL_MAJOR_m12
				// move blocks
				bytes_per_sample = matrix->el_size;
				bytes_per_channel = bytes_per_sample * matrix->sample_count;
				common_offset = bytes_per_channel * matrix->channel_count;
				old_offset = common_offset + ((data_end - contig_samples) * bytes_per_sample);
				new_offset = common_offset + (bytes_per_sample * matrix->contigua[i].start_sample_number);
				bytes_to_move = bytes_per_sample * contig_samples;
				for (j = matrix->channel_count; j--;) {
					old_offset -= bytes_per_channel;
					new_offset -= bytes_per_channel;
					memmove((void *) (data_base + new_offset), (void *) (data_base + old_offset), bytes_to_move);
					if (matrix->flags & DM_TRACE_RANGES_m12) {
						memmove((void *) (minima_base + new_offset), (void *) (minima_base + old_offset), bytes_to_move);
						memmove((void *) (maxima_base + new_offset), (void *) (maxima_base + old_offset), bytes_to_move);
					}
					// fill gap
					if (gap_len > 0) {
						gap_offset = new_offset + (gap_start * bytes_per_sample);
						memset_m12(data_base + gap_offset, pattern, pattern_sz, n_elements);
						if (matrix->flags & DM_TRACE_RANGES_m12) {
							memset_m12(minima_base + gap_offset, pattern, pattern_sz, gap_len);
							memset_m12(maxima_base + gap_offset, pattern, pattern_sz, gap_len);
						}
					}
				}
			}
			gap_end = matrix->contigua[i].start_sample_number;
			data_end -= contig_samples;
		}
	}

	// free contigua, if just used for padding
	if (!(matrix->flags & DM_DSCNT_CONTIG_m12) && matrix->number_of_contigua) {
		free_m12((void *) matrix->contigua, __FUNCTION__);
		matrix->contigua = NULL;
		matrix->number_of_contigua = 0;
	}
	
	return(matrix);
}


void	DM_show_flags_m12(ui8 flags)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	printf_m12("\nData Matrix Flags:\n------------------\n");
	if (flags == DM_NO_FLAGS_m12) {
		printf_m12("no data matrix flags set\n");
		return;
	}
	if (flags & DM_TYPE_SI2_m12)
		printf_m12("DM_TYPE_SI2_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_TYPE_SI2_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_TYPE_SI4_m12)
		printf_m12("DM_TYPE_SI4_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_TYPE_SI4_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_TYPE_SF4_m12)
		printf_m12("DM_TYPE_SF4_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_TYPE_SF4_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_TYPE_SF8_m12)
		printf_m12("DM_TYPE_SF8_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_TYPE_SF8_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_2D_INDEXING_m12)
		printf_m12("DM_2D_INDEXING_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_2D_INDEXING_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_FMT_SAMPLE_MAJOR_m12)
		printf_m12("DM_FMT_SAMPLE_MAJOR_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_FMT_SAMPLE_MAJOR_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_FMT_CHANNEL_MAJOR_m12)
		printf_m12("DM_FMT_CHANNEL_MAJOR_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_FMT_CHANNEL_MAJOR_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_EXTMD_SAMP_COUNT_m12)
		printf_m12("DM_EXTMD_SAMP_COUNT_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_EXTMD_SAMP_COUNT_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_EXTMD_SAMP_FREQ_m12)
		printf_m12("DM_EXTMD_SAMP_FREQ_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_EXTMD_SAMP_FREQ_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_EXTMD_ABSOLUTE_LIMITS_m12)
		printf_m12("DM_EXTMD_ABSOLUTE_LIMITS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_EXTMD_ABSOLUTE_LIMITS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_EXTMD_RELATIVE_LIMITS_m12)
		printf_m12("DM_EXTMD_RELATIVE_LIMITS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_EXTMD_RELATIVE_LIMITS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_SCALE_m12)
		printf_m12("DM_SCALE_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_SCALE_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_FILT_LOWPASS_m12)
		printf_m12("DM_FILT_LOWPASS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_FILT_LOWPASS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_FILT_HIGHPASS_m12)
		printf_m12("DM_FILT_HIGHPASS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_FILT_HIGHPASS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_FILT_BANDPASS_m12)
		printf_m12("DM_FILT_BANDPASS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_FILT_BANDPASS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_FILT_BANDSTOP_m12)
		printf_m12("DM_FILT_BANDSTOP_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_FILT_BANDSTOP_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_FILT_ANTIALIAS_m12)
		printf_m12("DM_FILT_ANTIALIAS_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_FILT_ANTIALIAS_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_INTRP_LINEAR_m12)
		printf_m12("DM_INTRP_LINEAR_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_INTRP_LINEAR_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_INTRP_MAKIMA_m12)
		printf_m12("DM_INTRP_MAKIMA_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_INTRP_MAKIMA_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_INTRP_SPLINE_m12)
		printf_m12("DM_INTRP_SPLINE_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_INTRP_SPLINE_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_INTRP_UP_MAKIMA_DN_LINEAR_m12)
		printf_m12("DM_INTRP_UP_MAKIMA_DN_LINEAR_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_INTRP_UP_MAKIMA_DN_LINEAR_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_INTRP_UP_SPLINE_DN_LINEAR_m12)
		printf_m12("DM_INTRP_UP_SPLINE_DN_LINEAR_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_INTRP_UP_SPLINE_DN_LINEAR_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_INTRP_BINTRP_MDPT_m12)
		printf_m12("DM_INTRP_BINTRP_MDPT_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_INTRP_BINTRP_MDPT_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_INTRP_BINTRP_MEAN_m12)
		printf_m12("DM_INTRP_BINTRP_MEAN_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_INTRP_BINTRP_MEAN_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_INTRP_BINTRP_MEDN_m12)
		printf_m12("DM_INTRP_BINTRP_MEDN_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_INTRP_BINTRP_MEDN_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_INTRP_BINTRP_FAST_m12)
		printf_m12("DM_INTRP_BINTRP_FAST_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_INTRP_BINTRP_FAST_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_TRACE_RANGES_m12)
		printf_m12("DM_TRACE_RANGES_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_TRACE_RANGES_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_TRACE_EXTREMA_m12)
		printf_m12("DM_TRACE_EXTREMA_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_TRACE_EXTREMA_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_DETREND_m12)
		printf_m12("DM_DETREND_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_DETREND_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_DSCNT_CONTIG_m12)
		printf_m12("DM_DSCNT_CONTIG_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_DSCNT_CONTIG_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_DSCNT_NAN_m12)
		printf_m12("DM_DSCNT_NAN_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_DSCNT_NAN_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);
	if (flags & DM_DSCNT_ZERO_m12)
		printf_m12("DM_DSCNT_ZERO_m12: %strue%s\n", TC_RED_m12, TC_RESET_m12);
	else
		printf_m12("DM_DSCNT_ZERO_m12: %sfalse%s\n", TC_BLUE_m12, TC_RESET_m12);

	printf_m12("\n");
	
	return;
}


DATA_MATRIX_m12 *DM_transpose_m12(DATA_MATRIX_m12 **in_matrix_p, DATA_MATRIX_m12 **out_matrix_p)
{
	TERN_m12		false_in_place;
	DATA_MATRIX_m12		*in_matrix, *out_matrix;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// if in_matrix == out_matrix, done in place; if out_matrix == NULL, allocated and returned
	// if out_matrix is passed, it is presumed to have same memory allocation as in_matrix

	if (in_matrix_p == NULL) {
		G_warning_message_m12("%s(): in_matrix pointer is NULL => returning without transposition\n", __FUNCTION__);
		return(NULL);
	}
	in_matrix = *in_matrix_p;
	if (in_matrix == NULL) {
		G_warning_message_m12("%s(): in_matrix is NULL => returning without transposition\n", __FUNCTION__);
		return(NULL);
	}
	if (out_matrix_p == NULL)
		out_matrix = NULL;
	else
		out_matrix = *out_matrix_p;
	
	false_in_place = FALSE_m12;
	if (in_matrix == out_matrix) {
		if (in_matrix->flags & DM_2D_INDEXING_m12) {  // in-place algorithm does not handle 2D indexing
			out_matrix = NULL;  // force allocation of out matrix below
			false_in_place = TRUE_m12;
		} else {
			DM_transpose_in_place_m12(in_matrix, in_matrix->data);
			if (in_matrix->flags & DM_TRACE_RANGES_m12) {
				DM_transpose_in_place_m12(in_matrix, in_matrix->range_minima);
				DM_transpose_in_place_m12(in_matrix, in_matrix->range_maxima);
			}
			return(in_matrix);
		}
	}
	
	if (out_matrix != NULL) {  // 2D indexing requires reallocation for transposition
		if (out_matrix->flags & DM_2D_INDEXING_m12) {
			if (in_matrix->maj_dim != out_matrix->min_dim || in_matrix->min_dim != out_matrix->maj_dim) {
				DM_free_matrix_m12(out_matrix, TRUE_m12);
				out_matrix = NULL;  // force allocation of out matrix below
			}
		}
	}
	
	if (out_matrix == NULL) {
		out_matrix = (DATA_MATRIX_m12 *) calloc_m12((size_t) 1, sizeof(DATA_MATRIX_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		out_matrix->channel_count = in_matrix->channel_count;
		out_matrix->sample_count = in_matrix->sample_count;
		out_matrix->filter_low_fc = in_matrix->filter_low_fc;
		out_matrix->filter_high_fc = in_matrix->filter_high_fc;
		out_matrix->flags = in_matrix->flags;
		out_matrix->maj_dim = in_matrix->min_dim;
		out_matrix->min_dim = in_matrix->maj_dim;
		out_matrix->el_size = in_matrix->el_size;
		out_matrix->data_bytes = in_matrix->data_bytes;
		if (out_matrix->flags & DM_2D_INDEXING_m12)
			out_matrix->data = (void *) malloc_2D_m12(out_matrix->maj_dim, out_matrix->min_dim, out_matrix->el_size, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		else
			out_matrix->data = malloc_m12(out_matrix->data_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		if (out_matrix->flags & DM_TRACE_RANGES_m12) {
			if (out_matrix->flags & DM_2D_INDEXING_m12) {
				out_matrix->range_minima = (void *) malloc_2D_m12(out_matrix->maj_dim, out_matrix->min_dim, out_matrix->el_size, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
				out_matrix->range_maxima = (void *) malloc_2D_m12(out_matrix->maj_dim, out_matrix->min_dim, out_matrix->el_size, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			} else {
				out_matrix->range_minima = (void *) malloc_m12(out_matrix->data_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
				out_matrix->range_maxima = (void *) malloc_m12(out_matrix->data_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			}
		}
		if (out_matrix->flags & DM_TRACE_EXTREMA_m12) {
			out_matrix->trace_minima = malloc_m12((size_t) (out_matrix->channel_count * out_matrix->el_size), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			memcpy((void *) out_matrix->trace_minima, (void *) in_matrix->trace_minima, (size_t) (out_matrix->channel_count * out_matrix->el_size));
			out_matrix->trace_maxima = malloc_m12((size_t) (out_matrix->channel_count * out_matrix->el_size), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			memcpy((void *) out_matrix->trace_maxima, (void *) in_matrix->trace_maxima, (size_t) (out_matrix->channel_count * out_matrix->el_size));
		}
		out_matrix->number_of_contigua = in_matrix->number_of_contigua;
		if (out_matrix->number_of_contigua) {
			out_matrix->contigua = malloc_m12((size_t) out_matrix->number_of_contigua * sizeof(CONTIGUON_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			memcpy((void *) out_matrix->contigua, (void *) in_matrix->contigua, (size_t) (out_matrix->number_of_contigua * sizeof(CONTIGUON_m12)));
		}
		out_matrix->n_proc_bufs = 0;  // don't reallocate processing buffers: DM_get_matrix_m12() will do it if it's called
	}
	
	// transpose
	DM_transpose_out_of_place_m12(in_matrix, out_matrix, in_matrix->data, out_matrix->data);
	if (out_matrix->flags & DM_TRACE_RANGES_m12) {
		DM_transpose_out_of_place_m12(in_matrix, out_matrix, in_matrix->range_minima, out_matrix->range_minima);
		DM_transpose_out_of_place_m12(in_matrix, out_matrix, in_matrix->range_maxima, out_matrix->range_maxima);
	}
	
	if (out_matrix_p != NULL)
		*out_matrix_p = out_matrix;
	if (false_in_place == TRUE_m12) {
		DM_free_matrix_m12(in_matrix, TRUE_m12);
		*in_matrix_p = out_matrix;
	}
	
	// return
	return(out_matrix);
}


void	DM_transpose_in_place_m12(DATA_MATRIX_m12 *matrix, void *base)
{
	ui1	*swap_arr;
	si2	*si2_p, si2_tmp_val, si2_last_val;
	si4	*si4_p, si4_tmp_val, si4_last_val;
	sf4	*sf4_p, sf4_tmp_val, sf4_last_val;
	sf8	*sf8_p, sf8_tmp_val, sf8_last_val;
	si8	data_len, swap_cnt, maj_dim, min_dim, old_pos, new_pos, old_maj_idx, old_min_idx, lowest_swapped;
	
	
	// make swap array
	data_len = matrix->maj_dim * matrix->min_dim;
	swap_arr = (ui1 *) calloc((size_t) data_len, sizeof(ui1));

	// transpose
	maj_dim = matrix->maj_dim;
	min_dim = matrix->min_dim;
	swap_cnt = 0;
	lowest_swapped = old_pos = 0;
	switch (matrix->flags & DM_TYPE_MASK_m12) {
		case DM_TYPE_SI2_m12:
			si2_p = (si2 *) base;
			si2_last_val = si2_p[old_pos];
			while (swap_cnt < data_len) {
				if (swap_arr[old_pos]) {
					for (old_pos = lowest_swapped; swap_arr[++old_pos];);
					lowest_swapped = old_pos;  // will be swapped
					si2_last_val = si2_p[old_pos];
				} else {
					old_maj_idx = old_pos / min_dim;
					old_min_idx = old_pos % min_dim;
					new_pos = (old_min_idx * old_maj_idx) + old_maj_idx;
					si2_tmp_val = si2_p[new_pos];
					si2_p[new_pos] = si2_last_val;
					si2_last_val = si2_tmp_val;
					swap_arr[old_pos] = 1;
					old_pos = new_pos;
					++swap_cnt;
				}
			}
			break;
		case DM_TYPE_SI4_m12:
			si4_p = (si4 *) base;
			si4_last_val = si4_p[old_pos];
			while (swap_cnt < data_len) {
				if (swap_arr[old_pos]) {
					for (old_pos = lowest_swapped; swap_arr[++old_pos];);
					lowest_swapped = old_pos;  // will be swapped
					si4_last_val = si4_p[old_pos];
				} else {
					old_maj_idx = old_pos / min_dim;
					old_min_idx = old_pos % min_dim;
					new_pos = (old_min_idx * old_maj_idx) + old_maj_idx;
					si4_tmp_val = si4_p[new_pos];
					si4_p[new_pos] = si4_last_val;
					si4_last_val = si4_tmp_val;
					swap_arr[old_pos] = 1;
					old_pos = new_pos;
					++swap_cnt;
				}
			}
			break;
		case DM_TYPE_SF4_m12:
			sf4_p = (sf4 *) base;
			sf4_last_val = sf4_p[old_pos];
			while (swap_cnt < data_len) {
				if (swap_arr[old_pos]) {
					for (old_pos = lowest_swapped; swap_arr[++old_pos];);
					lowest_swapped = old_pos;  // will be swapped
					sf4_last_val = sf4_p[old_pos];
				} else {
					old_maj_idx = old_pos / min_dim;
					old_min_idx = old_pos % min_dim;
					new_pos = (old_min_idx * old_maj_idx) + old_maj_idx;
					sf4_tmp_val = sf4_p[new_pos];
					sf4_p[new_pos] = sf4_last_val;
					sf4_last_val = sf4_tmp_val;
					swap_arr[old_pos] = 1;
					old_pos = new_pos;
					++swap_cnt;
				}
			}
			break;
		case DM_TYPE_SF8_m12:
			sf8_p = (sf8 *) base;
			sf8_last_val = sf8_p[old_pos];
			while (swap_cnt < data_len) {
				if (swap_arr[old_pos]) {
					for (old_pos = lowest_swapped; swap_arr[++old_pos];);
					lowest_swapped = old_pos;  // will be swapped
					sf8_last_val = sf8_p[old_pos];
				} else {
					old_maj_idx = old_pos / min_dim;
					old_min_idx = old_pos % min_dim;
					new_pos = (old_min_idx * old_maj_idx) + old_maj_idx;
					sf8_tmp_val = sf8_p[new_pos];
					sf8_p[new_pos] = sf8_last_val;
					sf8_last_val = sf8_tmp_val;
					swap_arr[old_pos] = 1;
					old_pos = new_pos;
					++swap_cnt;
				}
			}
			break;
	}
	free((void *) swap_arr);
	
	// swap dimensions
	matrix->maj_dim = min_dim;
	matrix->min_dim = maj_dim;
	
	return;
}


void	DM_transpose_out_of_place_m12(DATA_MATRIX_m12 *in_matrix, DATA_MATRIX_m12 *out_matrix, void *in_base, void *out_base)
{
	si2	*si2_p1, *si2_p2;
	si4	*si4_p1, *si4_p2;
	sf4	*sf4_p1, *sf4_p2;
	sf8	*sf8_p1, *sf8_p2;
	si8	i, j, out_min_dim, out_maj_dim;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// this function is used internally in DM_tranpose_m12()
	// this function could be threaded
	
	out_min_dim = out_matrix->min_dim = in_matrix->maj_dim;
	out_maj_dim = out_matrix->maj_dim = in_matrix->min_dim;
	if (in_matrix->flags & DM_2D_INDEXING_m12)
		in_base = (void *) ((ui1 *) in_base + (in_matrix->maj_dim * sizeof(void *)));
	if (out_matrix->flags & DM_2D_INDEXING_m12)
		out_base = (void *) ((ui1 *) out_base + (out_matrix->maj_dim * sizeof(void *)));

	switch (out_matrix->flags & DM_TYPE_MASK_m12) {
		case DM_TYPE_SI2_m12:
			si2_p1 = (si2 *) in_base;
			for (i = 0; i < out_min_dim; ++i) {
				si2_p2 = (si2 *) out_base + i;
				for (j = out_maj_dim; j--; si2_p2 += out_min_dim)
					*si2_p2 = *si2_p1++;
			}
			break;
		case DM_TYPE_SI4_m12:
			si4_p1 = (si4 *) in_base;
			for (i = 0; i < out_min_dim; ++i) {
				si4_p2 = (si4 *) out_base + i;
				for (j = out_maj_dim; j--; si4_p2 += out_min_dim)
					*si4_p2 = *si4_p1++;
			}
			break;
		case DM_TYPE_SF4_m12:
			sf4_p1 = (sf4 *) in_base;
			for (i = 0; i < out_min_dim; ++i) {
				sf4_p2 = (sf4 *) out_base + i;
				for (j = out_maj_dim; j--; sf4_p2 += out_min_dim)
					*sf4_p2 = *sf4_p1++;
			}
			break;
		case DM_TYPE_SF8_m12:
			sf8_p1 = (sf8 *) in_base;
			for (i = 0; i < out_min_dim; ++i) {
				sf8_p2 = (sf8 *) out_base + i;
				for (j = out_maj_dim; j--; sf8_p2 += out_min_dim)
					*sf8_p2 = *sf8_p1++;
			}
			break;
	}
	
	return;
}



//*******************************//
// MARK: FILTER FUNCTIONS  (FILT)
//*******************************//

// ATTRIBUTION
//
// Some of the filter code was adapted from Matlab functions.
// MathWorks Inc. (www.mathworks.com)
//
// The c code in this library was written entirely from scratch.

QUANTFILT_DATA_m12	*FILT_alloc_quantfilt_data_m12(si8 len, si8 span)
{
	QUANTFILT_DATA_m12	*qd;
	
	
	qd = (QUANTFILT_DATA_m12 *) calloc_m12((size_t) 1, sizeof(QUANTFILT_DATA_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	qd->x = (sf8 *) calloc_m12((size_t) len, sizeof(sf8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

	qd->qx = (sf8 *) calloc_m12((size_t) len, sizeof(sf8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	qd->nodes = (FILT_NODE_m12 *) calloc_m12((size_t) (span + 1), sizeof(FILT_NODE_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	return(qd);
}


void	FILT_balance_m12(sf8 **a, si4 poles)
{
	sf8    radix, sqrdx, c, r, g, f, s;
	si4     i, j, done;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	radix = FILT_RADIX_m12;
	sqrdx = radix * radix;
	done = 0;
	while (!done) {
		done = 1;
		for (i = 0; i < poles; i++) {
			r = c = (sf8) 0.0;
			for (j = 0; j < poles; j++)
				if (j != i) {
					c += FILT_ABS_m12(a[j][i]);
					r += FILT_ABS_m12(a[i][j]);
				}
			if (c != (sf8) 0.0 && r != (sf8) 0.0) {
				g = r / radix;
				f = (sf8) 1.0;
				s = c + r;
				while (c < g) {
					f *= radix;
					c *= sqrdx;
				}
				g = r * radix;
				while (c > g) {
					f /= radix;
					c /= sqrdx;
				}
				if (((c + r) / f) < ((sf8) 0.95 * s)) {
					done = 0;
					g = 1.0 / f;
					for (j = 0; j < poles; j++)
						a[i][j] *= g;
					for (j = 0; j < poles; j++)
						a[j][i] *= f;
				}
			}
		}
	}
	
	return;
}


si4	FILT_butter_m12(FILT_PROCESSING_STRUCT_m12 *filtps)
{
	si4			i, j, n_fcs, offset, idx, order, poles, is_odd;
	sf8			samp_freq, fcs[2], *den, sum_num, sum_den;
	sf8			u[2], pi, half_pi, bw, wn, w, *r, *num, ratio;
	sf8            		**a, **inv_a, **ta1, **ta2, *b, *bt, *c, t;
	FILT_COMPLEX_m12	csum_num, csum_den, cratio, *ckern;
	FILT_COMPLEX_m12	*p, tc, *eigs, *cden, *rc, *cnum;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// check input
	switch(filtps->type) {
		case FILT_LOWPASS_TYPE_m12:
		case FILT_BANDPASS_TYPE_m12:
		case FILT_HIGHPASS_TYPE_m12:
		case FILT_BANDSTOP_TYPE_m12:
			break;
		default:
			if (!(filtps->behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12))
				G_error_message_m12("%s(): nrecognized filter type: %d \n", __FUNCTION__, filtps->type);
			if (filtps->behavior_on_fail & EXIT_ON_FAIL_m12)
				exit_m12(1);
			return(-1);
	}
	samp_freq = filtps->sampling_frequency;
	fcs[0] = filtps->cutoffs[0];
	n_fcs = ((filtps->type == FILT_LOWPASS_TYPE_m12) || (filtps->type == FILT_HIGHPASS_TYPE_m12)) ? 1 : 2;
	if (n_fcs == 2)
		fcs[1] = filtps->cutoffs[1];
	order = filtps->order;
	filtps->n_poles = poles = n_fcs * order;
	is_odd = order % 2;
	
	// step 1: get analog, pre-warped frequencies
	pi = (sf8) M_PI;
	half_pi = pi / (sf8) 2.0;
	for (i = 0; i < n_fcs; ++i)
		u[i] = (sf8) 4.0 * tan((pi * fcs[i]) / samp_freq);
	
	// step 2: convert to low-pass prototype estimate
	switch (filtps->type) {
		case FILT_LOWPASS_TYPE_m12:
			wn = u[0];
			break;
		case FILT_BANDPASS_TYPE_m12:
			bw = u[1] - u[0];
			wn = sqrt(u[0] * u[1]);
			break;
		case FILT_HIGHPASS_TYPE_m12:
			wn = u[0];
			break;
		case FILT_BANDSTOP_TYPE_m12:
			bw = u[1] - u[0];
			wn = sqrt(u[0] * u[1]);
			break;
	}
	
	// step 3: Get N-th order Butterworth analog lowpass prototype
	p = (FILT_COMPLEX_m12 *) calloc((size_t) order, sizeof(FILT_COMPLEX_m12));
	for (i = 1; i < order; i += 2) {
		p[i - 1].imag = ((pi * (sf8) i) / (sf8) (2 * order)) + half_pi;
		FILT_complex_exp_m12(p + i - 1, p + i - 1);
	}
	for (i = 1; i < order; i += 2) {
		p[i].real = p[i - 1].real;
		p[i].imag = -p[i - 1].imag;
	}
	if (is_odd)
		p[order - 1].real = (sf8) -1.0;

	j = order - 1;  // sort into ascending order, by real values
	if (is_odd) --j;
	for (i = 0; j > i; ++i, --j) {
		tc = p[i];
		p[i] = p[j];
		p[j] = tc;
	}
	
	// Transform to state-space
	a = (sf8 **) calloc_2D_m12((size_t) poles, (size_t) poles, sizeof(sf8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	inv_a = (sf8 **) calloc_2D_m12((size_t) poles, (size_t) poles, sizeof(sf8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	ta1 = (sf8 **) calloc_2D_m12((size_t) poles, (size_t) poles, sizeof(sf8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	ta2 = (sf8 **) calloc_2D_m12((size_t) poles, (size_t) poles, sizeof(sf8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	b = (sf8 *) calloc((size_t) poles, sizeof(sf8));
	bt = (sf8 *) calloc((size_t) poles, sizeof(sf8));
	c = (sf8 *) calloc((size_t) poles, sizeof(sf8));
	
	if ((offset = is_odd))
		a[0][0] = (sf8) -1.0;
	for (i = 0; i < order - 1; i += 2) {
		if ((idx = i + offset))
			a[i + offset][idx - 1] = (sf8) 1.0;
		a[i + offset][i + offset] = p[i].real + p[i + 1].real;
		a[i + offset][i + offset + 1] = (sf8) -1.0;
		a[i + offset + 1][i + offset] = (sf8) 1.0;
	}
	b[order - 1] = (sf8) 1.0;
	c[order - 1] = (sf8) 1.0;
	
	// step 4: Transform to lowpass, bandpass, highpass, or bandstop of desired Wn
	switch (filtps->type) {
		case FILT_LOWPASS_TYPE_m12:
			for (i = 0; i < order; ++i) {
				for (j = 0; j < order; ++j)
					a[i][j] *= wn;
				b[i] *= wn;
			}
			break;
		case FILT_BANDPASS_TYPE_m12:
			for (i = 0; i < order; ++i) {
				for (j = 0; j < order; ++j) {
					a[i][j] *= bw;
				}
				a[i][i + order] = wn;
				a[i + order][i] = -wn;
			}
			b[0] = bw;
			break;
		case FILT_HIGHPASS_TYPE_m12:
			for (i = 0; i < order; ++i) {
				c[i] = (sf8) -1.0;
				b[i] = wn;
			}
			for (i = is_odd; i < order; i += 2) {
				c[i + 1] = a[i][i];
				b[i] = (sf8) 0.0;
			}
			// d = (sf8) 1.0;
			FILT_invert_matrix_m12(a, inv_a, order);
			
			for (i = 0; i < order; ++i)
				for (j = 0; j < order; ++j)
					a[i][j] = wn * inv_a[i][j];
			break;
		case FILT_BANDSTOP_TYPE_m12:
			for (i = 0; i < order; ++i) {
				c[i] = (sf8) -1.0;
				b[i] = bw;
			}
			for (i = is_odd; i < order; i += 2) {
				c[i + 1] = a[i][i];
				b[i] = (sf8) 0.0;
			}
			FILT_invert_matrix_m12(a, inv_a, order);
			for (i = 0; i < order; ++i) {
				for (j = 0; j < order; ++j) {
					a[i][j] = bw * inv_a[i][j];
				}
				a[i][i + order] = wn;
				a[i + order][i] = -wn;
			}
			break;
	}

	// step 5: Use bilinear transformation to find discrete equivalent
	t = (sf8) 0.25;
	for (i = 0; i < poles; ++i) {
		for (j = 0; j < poles; ++j) {
			ta1[i][j] = t * a[i][j];
			ta2[i][j] = -ta1[i][j];
		}
		ta1[i][i] += (sf8) 1.0;
		ta2[i][i] += (sf8) 1.0;
	}
	
	FILT_invert_matrix_m12(ta2, inv_a, poles);
	
	FILT_mat_mult_m12((void *) inv_a, (void *) ta1, (void *) a, poles, poles, poles);
	
	FILT_mat_mult_m12((void *) c, (void *) inv_a, (void *) bt, 1, poles, poles);
	t = sqrt((sf8) 0.5);
	for (i = 0; i < poles; ++i)
		c[i] = bt[i] * t;
	
	FILT_mat_mult_m12((void *) bt, (void *) b, (void *) &t, 1, poles, 1);
	
	FILT_mat_mult_m12((void *) inv_a, (void *) b, (void *) bt, poles, poles, 1);
	t = (sf8) 1.0 / sqrt((sf8) 2.0);
	for (i = 0; i < poles; ++i)
		b[i] = bt[i] * t;
	
	// Transform to zero-pole-gain and polynomial forms
	eigs = (FILT_COMPLEX_m12 *) calloc((size_t) poles, sizeof(FILT_COMPLEX_m12));
	FILT_unsymmeig_m12(a, poles, eigs);
	
	den = (sf8 *) calloc_m12((size_t) (poles + 1), sizeof(sf8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	cden = (FILT_COMPLEX_m12 *) calloc((size_t) (poles + 1), sizeof(FILT_COMPLEX_m12));
	cden[0].real = (sf8) 1.0;
	for (i = 0; i < poles; ++i) {
		for (j = i + 1; j--;) {
			FILT_complex_mult_m12(eigs + i, cden + j, &tc);
			cden[j + 1].real -= tc.real;
			cden[j + 1].imag -= tc.imag;
		}
	}
	for (i = 0; i <= poles; ++i)
		den[i] = cden[i].real;
	
	// generate numerator
	r = (sf8 *) calloc((size_t) (poles + 1), sizeof(sf8));
	rc = (FILT_COMPLEX_m12 *) calloc((size_t) (poles + 1), sizeof(FILT_COMPLEX_m12));
	wn = (sf8) 2.0 * atan2(wn, 4.0);
	
	switch (filtps->type) {
		case FILT_LOWPASS_TYPE_m12:
			for (i = 0; i < poles; ++i)
				r[i] = (sf8) -1.0;
			break;
		case FILT_BANDPASS_TYPE_m12:
			for (i = 0; i < order; ++i) {
				r[i] = (sf8) 1.0;
				r[i + order] = (sf8) -1.0;
			}
			w = -wn;
			break;
		case FILT_HIGHPASS_TYPE_m12:
			for (i = 0; i < poles; ++i)
				r[i] = (sf8) 1.0;
			w = -pi;
			break;
		case FILT_BANDSTOP_TYPE_m12:
			tc.real = (sf8) 0.0;
			tc.imag = wn;
			FILT_complex_exp_m12(&tc, &tc);
			for (i = 0; i < poles; i += 2) {
				rc[i].real = tc.real;
				rc[i].imag = tc.imag;
				rc[i + 1].real = tc.real;
				rc[i + 1].imag = -tc.imag;
			}
			break;
	}
	
	num = (sf8 *) calloc_m12((size_t) (poles + 1), sizeof(sf8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	cnum = (FILT_COMPLEX_m12 *) calloc((size_t) (poles + 1), sizeof(FILT_COMPLEX_m12));
	if (filtps->type == FILT_BANDSTOP_TYPE_m12) {
		cnum[0].real = (sf8) 1.0;
		for (i = 0; i < poles; ++i) {
			for (j = i + 1; j--;) {
				FILT_complex_mult_m12(rc + i, cnum + j, &tc);
				cnum[j + 1].real -= tc.real;
				cnum[j + 1].imag -= tc.imag;
			}
		}
		for (i = 0; i <= poles; ++i)
			num[i] = cnum[i].real;
	} else {
		num[0] = (sf8) 1.0;
		for (i = 0; i < poles; ++i)
			for (j = i + 1; j--;)
				num[j + 1] -= r[i] * num[j];
	}
						
	// normalize
	ckern = (FILT_COMPLEX_m12 *) calloc((size_t) (poles + 1), sizeof(FILT_COMPLEX_m12));
	if ((filtps->type == FILT_LOWPASS_TYPE_m12) || (filtps->type == FILT_BANDSTOP_TYPE_m12)) {
		sum_num = sum_den = (sf8) 0.0;
		for (i = 0; i <= poles; ++i) {
			sum_num += num[i];
			sum_den += den[i];
		}
		ratio = sum_den / sum_num;
		for (i = 0; i <= poles; ++i)
			num[i] *= ratio;
	} else {
		tc.real = (sf8) 0.0;
		for (i = 0; i <= poles; ++i) {
			tc.imag = w * (sf8) i;
			FILT_complex_exp_m12(&tc, ckern + i);
			cnum[i].real = num[i];
			cnum[i].imag = (sf8) 0.0;
			cden[i].real = den[i];
			cden[i].imag = (sf8) 0.0;
		}
		csum_num.real = csum_den.real = csum_num.imag = csum_den.imag = (sf8) 0.0;
		for (i = 0; i <= poles; ++i) {
			FILT_complex_mult_m12(ckern + i, cnum + i, &tc);
			csum_num.real += tc.real;
			csum_num.imag += tc.imag;
			FILT_complex_mult_m12(ckern + i, cden + i, &tc);
			csum_den.real += tc.real;
			csum_den.imag += tc.imag;
		}
		FILT_complex_div_m12(&csum_den, &csum_num, &cratio);
		for (i = 0; i <= poles; ++i) {
			FILT_complex_mult_m12(cnum + i, &cratio, &tc);
			num[i] = tc.real;
		}
	}

	// clean up
	free_m12((void *) a, __FUNCTION__);
	free_m12((void *) inv_a, __FUNCTION__);
	free_m12((void *) ta1, __FUNCTION__);
	free_m12((void *) ta2, __FUNCTION__);
	free((void *) p);
	free((void *) b);
	free((void *) bt);
	free((void *) c);
	free((void *) cden);
	free((void *) cnum);
	free((void *) eigs);
	free((void *) r);
	free((void *) rc);
	free((void *) ckern);

	// check output
	for (i = 0; i <= poles; ++i) {
		if (isnan(num[i]) || isinf(num[i]) || isnan(den[i]) || isinf(den[i])) {
			if (filtps->behavior_on_fail & EXIT_ON_FAIL_m12)
				exit_m12(FILT_BAD_FILTER_m12);
			if (filtps->behavior_on_fail & RETURN_ON_FAIL_m12) {
				free_m12((void *) den, __FUNCTION__);
				free_m12((void *) num, __FUNCTION__);
				filtps->numerators = filtps->denominators = NULL;
				return(FILT_BAD_FILTER_m12);
			}
		}
	}
	filtps->numerators = num;
	filtps->denominators = den;
	
	return(0);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	FILT_complex_div_m12(FILT_COMPLEX_m12 *a, FILT_COMPLEX_m12 *b, FILT_COMPLEX_m12 *quotient)  //  returns a / b
{
	FILT_COMPLEX_m12	ta, tb;
	sf8			den;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	ta = *a;  // copy in case in place
	tb = *b;
	den = (tb.real * tb.real) + (tb.imag * tb.imag);
	quotient->real = ((ta.real * tb.real) + (ta.imag * tb.imag)) / den;
	quotient->imag = ((ta.imag * tb.real) - (ta.real * tb.imag)) / den;
	
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	FILT_complex_exp_m12(FILT_COMPLEX_m12 *exponent, FILT_COMPLEX_m12 *ans)
{
	FILT_COMPLEX_m12	t;
	sf8            		c;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	t = *exponent;  // copy in case in place
	c = exp(t.real);
	ans->real = c * cos(t.imag);
	ans->imag = c * sin(t.imag);
	
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	FILT_complex_mult_m12(FILT_COMPLEX_m12 *a, FILT_COMPLEX_m12 *b, FILT_COMPLEX_m12 *product)
{
	FILT_COMPLEX_m12    ta, tb;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	ta = *a;  // copy in case in place
	tb = *b;
	product->real = (ta.real * tb.real) - (ta.imag * tb.imag);
	product->imag = (ta.real * tb.imag) + (ta.imag * tb.real);
	
	
	return;
}


void	FILT_elmhes_m12(sf8 **a, si4 poles)
{
	si4     i, j, m;
	sf8	x, y, t1;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	for (m = 1; m < (poles - 1); m++) {
		x = (sf8) 0.0;
		i = m;
		for (j = m; j < poles; j++) {
			if (FILT_ABS_m12(a[j][m-1]) > FILT_ABS_m12(x)) {
				x = a[j][m - 1];
				i = j;
			}
		}
		if (i != m) {
			for (j = m - 1; j < poles; j++) {
				t1 = a[i][j];
				a[i][j] = a[m][j];
				a[m][j] = t1;
			}
			for (j = 0; j < poles; j++) {
				t1 = a[j][i];
				a[j][i] = a[j][m];
				a[j][m] = t1;
			}
		}
		if (x != (sf8) 0.0) {
			for (i = m + 1; i < poles; i++) {
				y = a[i][m - 1];
				if (y != (sf8) 0.0) {
					y /= x;
					a[i][m - 1] = y;
					for (j = m; j < poles; j++)
						a[i][j] -= (y * a[m][j]);
					for (j = 0; j < poles; j++)
						a[j][m] += (y * a[j][i]);
				}
			}
		}
	}
	
	
	return;
}


void	FILT_excise_transients_m12(CMP_PROCESSING_STRUCT_m12 *cps, si8 len, si8 *n_extrema)
{
	si8	i, j, span, ext_x, *ex, wind_start, wind_end, n_ext, wind_len;
	sf8	samp_freq, LFP_high_fc, *y, *qy, *sy, *ty, *jy, *try, ext_y;
	sf8	baseline, VDS_alg_thresh, thresh, *sf8_p1, *sf8_p2, *sf8_p3;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// Function assumes VDS buffers are allocated
	// VDS Buffer Map:
	// 	VDS_in_bufs[0]:	in_y
	// 	VDS_in_bufs[1]: in_x (not used here, but don't touch)
	// 	VDS_in_bufs[2]:	excise_transients() smooth_data
	// 	VDS_in_bufs[3]:	excise_transients() transients
	// 	VDS_in_bufs[4]:	excise_transients() extrema
	// 	VDS_in_bufs[5-8]: scrap buffers (at this point in VDS)

	samp_freq = cps->parameters.VDS_sampling_frequency;
	LFP_high_fc = cps->parameters.VDS_LFP_high_fc;
	y = (sf8 *) cps->parameters.VDS_input_buffers->buffer[0];
	
	// median filter (to buffer 5)
	if (LFP_high_fc > (sf8) 0.0)
		span = (si8) round(samp_freq / LFP_high_fc);
	else
		span = (si8) round(samp_freq / (sf8) 500.0);  // assume 500 Hz is enough frequency resolution
	if (span < 12)
		span = 12;  // minimum of 3 cycles at 4 samples/cycle
	if (len < span) {  // not tested
		memcpy(cps->parameters.VDS_input_buffers->buffer[2], cps->parameters.VDS_input_buffers->buffer[0], (size_t) (len << 3));  // copy original data to smooth_data
		memset(cps->parameters.VDS_input_buffers->buffer[3], 0, (size_t) (len << 3));  // zero transients
		memset(cps->parameters.VDS_input_buffers->buffer[4], 0, (size_t) (len << 3));  // zero extrema
		*n_extrema = 0;
		return;
	}
	qy = (sf8 *) cps->parameters.VDS_input_buffers->buffer[5];
	FILT_quantfilt_m12(y, qy, len, (sf8) 0.5, span, FILT_TRUNCATE_m12);
	
	// generate smooth trace (to buffer 2)
	sy = (sf8 *) cps->parameters.VDS_input_buffers->buffer[2];
	sf8_p1 = y;
	sf8_p2 = qy;
	sf8_p3 = sy;
	for (i = len; i--;)
		*sf8_p3++ = *sf8_p1++ - *sf8_p2++;
	
	// generate threshold trace (to buffer 6)
	ty = (sf8 *) cps->parameters.VDS_input_buffers->buffer[6];
	sf8_p1 = sy;
	sf8_p2 = ty;
	for (i = len; i--; ++sf8_p1)
		*sf8_p2++ = (*sf8_p1 >= 0.0) ? *sf8_p1 : -*sf8_p1;

	// get baseline & threshold (buffer 7 used as scrap)
	jy = (sf8 *) cps->parameters.VDS_input_buffers->buffer[7];
	baseline = CMP_quantval_m12(ty, len, (sf8) 0.5, TRUE_m12, jy);
	VDS_alg_thresh = CMP_VDS_get_theshold_m12(cps);
	thresh = ((VDS_alg_thresh + (sf8) 6.0) / (sf8) 2.0) * baseline;
	
	// zero transients array (buffer 3)
	try = (sf8 *) cps->parameters.VDS_input_buffers->buffer[3];
	memset((void *) try, 0, (size_t) (len << 3));

	// set up extrema array (buffer 4)
	n_ext = 0;
	ex = (si8 *) cps->parameters.VDS_input_buffers->buffer[4];
	
	// excision loop
	for (i = 0; i < len;) {
		if (ty[i] > thresh) {
			wind_start = wind_end = i;
			if (sy[i] >= 0) {  // find transient window (upgoing)
				for (; wind_start >= 0; --wind_start)
					if (sy[wind_start] < 0)
						break;
				for (; wind_start >= 0; --wind_start)
					if (sy[wind_start] > 0)
						break;
				for (; wind_end < len; ++wind_end)
					if (sy[wind_end] < 0)
						break;
				for (; wind_end < len; ++wind_end)
					if (sy[wind_end] > 0)
						break;
			} else {  // find transient window (downgoing)
				for (; wind_start; --wind_start)
					if (sy[wind_start] > 0)
						break;
				for (; wind_start; --wind_start)
					if (sy[wind_start] < 0)
						break;
				for (; wind_end < len; ++wind_end)
					if (sy[wind_end] > 0)
						break;
				for (; wind_end < len; ++wind_end)
					if (sy[wind_end] < 0)
						break;
			}
			// correct for window overshoot
			++wind_start;
			--wind_end;
			
			// copy smooth contents into transients array & get extrema
			wind_len = (wind_end - wind_start) - 1;
			if (wind_len > 1) {
				ext_x = wind_start;
				ext_y = sy[wind_start];
				if (sy[i] >= 0) {  // upgoing
					for (j = wind_start; j <= wind_end; ++j) {
						try[j] = sy[j];
						if (ext_y < sy[j]) {
							ext_y = sy[j];
							ext_x = j;
						}
					}
				} else {  // downgoing
					for (j = wind_start; j <= wind_end; ++j) {
						try[j] = sy[j];
						if (ext_y > sy[j]) {
							ext_y = sy[j];
							ext_x = j;
						}
					}
				}
				// add extreme values
				ex[n_ext++] = ext_x;
			}
						
			// update for next loop
			i = wind_end;
			
		} else {  // ty[i] <= thresh
			++i;
		}
	}
	
	// finish smooth trace: add quantfilt trace back, or replace with quantfilt trace in transient windows
	sf8_p1 = try;
	sf8_p2 = qy;
	sf8_p3 = sy;
	for (i = len; i--;) {
		if (*sf8_p1++ == (sf8) 0.0)
			*sf8_p3++ += *sf8_p2++;
		else
			*sf8_p3++ = *sf8_p2++;
	}
	*n_extrema = n_ext;

	return;
}

				
si4	FILT_filtfilt_m12(FILT_PROCESSING_STRUCT_m12 *filtps)
{
	TERN_m12        	free_z_flag, free_buf_flag;
	si4	        	padded_data_len, pad_len, pad_lenx2, poles;
	si8	        	i, j, k, m, data_len;
	sf8	        	dx2, zc[FILT_MAX_ORDER_m12 * 2], t1, t2;
	sf8 	        	*num, *den, *data, *filt_data, *z, *buf, *dp, *fdp;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// filter data from filtps->orig_data into filtps->filt_data
	// if filtps->orig_data == filtps->filt_data, filtering done in place, but the target array must have room for the pads
	// if orig_data == (filt_data + pad_len) caller put data directly into the filt_data array with room for pad - skip initial copy
	// pad_len == (order * n_cutoffs * 3) => see FILT_OFFSET_ORIG_DATA_m12() macro.
	
	// todo: save states of zc for recurrent calls => skip padding & initial conditions
	
	// error check
	if (filtps->orig_data == NULL) {
		if (!(filtps->behavior_on_fail & SUPPRESS_WARNING_OUTPUT_m12))
			G_warning_message_m12("%s(): No data passed", __FUNCTION__);
		if (filtps->behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(1);
		return(FILT_BAD_DATA_m12);
	}
	poles = filtps->n_poles;
	pad_len = poles * FILT_PAD_SAMPLES_PER_POLE_m12;
	pad_lenx2 = pad_len << 1;
	data_len = filtps->data_length;
	if (data_len < pad_len) {
		if (!(filtps->behavior_on_fail & SUPPRESS_WARNING_OUTPUT_m12)) {
			if (filtps->type == FILT_LOWPASS_TYPE_m12 || filtps->type == FILT_HIGHPASS_TYPE_m12)
				G_warning_message_m12("%s(): At least %d data points required for a filter of order %d\n", __FUNCTION__, pad_len, filtps->order);
			else
				G_warning_message_m12("%s(): At least %d data points required for a filter of order %d with two cutoffs\n", __FUNCTION__, pad_len, filtps->order);
		}
		if (filtps->behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(1);
		memmove(filtps->filt_data, filtps->orig_data, data_len * sizeof(sf8));
		return(FILT_BAD_DATA_m12);
	}
	
	num = filtps->numerators;
	den = filtps->denominators;
	filt_data = filtps->filt_data;
	free_z_flag = FALSE_m12;
	if (filtps->initial_conditions == NULL) {
		FILT_generate_initial_conditions_m12(filtps);
		free_z_flag = TRUE_m12;
	}
	z = filtps->initial_conditions;
	free_buf_flag = FALSE_m12;
	if (filtps->buffer == NULL) {
		filtps->buffer = (sf8 *) calloc((size_t) data_len + pad_lenx2, sizeof(sf8));
		free_buf_flag = TRUE_m12;
	}
	buf = filtps->buffer;
	data = filtps->orig_data;
	
	// copy data to filt_data with room for pads
	if (data == filt_data) {  // just shift data by pad_len  [ equivalent: memmove((void *) (filt_data + pad_len), (void *) data, data_len * sizeof(sf8)); ]
		dp = data + data_len;
		fdp = dp + pad_len;
		for (i = data_len; i--;)
			*--fdp = *--dp;
	} else if (data != FILT_OFFSET_ORIG_DATA_m12(filtps)) {
		memcpy((void *) (filt_data + pad_len), (void *) data, data_len * sizeof(sf8));  // memcpy typically faster, but cannot overlap
	}
	// else: caller put data directly into the filt_data array with room for pad - skip copy
	
	// front pad
	dx2 = data[0] * (sf8) 2.0;
	for (i = 0, j = pad_len; j; ++i, --j)
		filt_data[i] = dx2 - data[j];
	// back pad
	padded_data_len = data_len + pad_lenx2;
	dx2 = data[data_len - 1] * (sf8) 2.0;
	for (i = data_len + pad_len, j = data_len - 2; i < padded_data_len; ++i, --j)
		filt_data[i] = dx2 - data[j];
	
	// copy and initialize initial conditions
	for (i = 0; i < poles; ++i)
		zc[i] = z[i] * filt_data[0];
	
	// forward filter from filt_data to buffer
	for (i = 0; i < padded_data_len; ++i) {
		t1 = filt_data[i];
		t2 = (num[0] * t1) + zc[0];
		for (j = 1; j < poles; ++j)
			zc[j - 1] = (num[j] * t1) - (den[j] * t2) + zc[j];
		zc[poles - 1] = (num[poles] * t1) - (den[poles] * t2);
		buf[i] = t2;
	}
	
	// copy and initialize initial conditions
	for (i = 0; i < poles; ++i)
		zc[i] = z[i] * buf[padded_data_len - 1];
	
	// reverse filter from buffer to filt_data
	for (i = padded_data_len - 1, k = pad_len; k--;) {
		t1 = buf[i--];
		t2 = (num[0] * t1) + zc[0];
		for (j = 1; j < poles; ++j)
			zc[j - 1] = (num[j] * t1) - (den[j] * t2) + zc[j];
		zc[poles - 1] = (num[poles] * t1) - (den[poles] * t2);
	}
	for (m = i - pad_len, k = data_len; k--;) {
		t1 = buf[i--];
		t2 = (num[0] * t1) + zc[0];
		for (j = 1; j < poles; ++j)
			zc[j - 1] = (num[j] * t1) - (den[j] * t2) + zc[j];
		zc[poles - 1] = (num[poles] * t1) - (den[poles] * t2);
		filt_data[m--] = t2;
	}
	
	// free as required
	if (free_z_flag == TRUE_m12) {
		free_m12((void *) z, __FUNCTION__);
		filtps->initial_conditions = NULL;
	}
	if (free_buf_flag == TRUE_m12) {
		free((void *) buf);
		filtps->buffer = NULL;
	}
	
	return(0);
}


void	FILT_free_CPS_filtps_m12(CMP_PROCESSING_STRUCT_m12 *cps, TERN_m12 free_orig_data, TERN_m12 free_filt_data, TERN_m12 free_buffer)
{
	si4				i;
	FILT_PROCESSING_STRUCT_m12	*filtps;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	
	if (cps->parameters.filtps == NULL)
		return;
	for (i = 0; i < cps->parameters.n_filtps; ++i) {
		filtps = (FILT_PROCESSING_STRUCT_m12 *) cps->parameters.filtps[i];
		if (filtps != NULL)
			FILT_free_processing_struct_m12(filtps, free_orig_data, free_filt_data, free_buffer, TRUE_m12);
	}
	free_m12((void *) cps->parameters.filtps, __FUNCTION__);
	cps->parameters.filtps = NULL;
	cps->parameters.n_filtps = 0;
	
	return;
}


void	FILT_free_processing_struct_m12(FILT_PROCESSING_STRUCT_m12 *filtps, TERN_m12 free_orig_data, TERN_m12 free_filt_data, TERN_m12 free_buffer, TERN_m12 free_structure)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (filtps == NULL) {
		G_warning_message_m12("%s(): trying to free a NULL FILT_PROCESSING_STRUCT_m12", __FUNCTION__);
		return;
	}
	if (filtps->numerators != NULL)
		free_m12((void *) filtps->numerators, __FUNCTION__);
	if (filtps->denominators != NULL)
		free_m12((void *) filtps->denominators, __FUNCTION__);
	if (filtps->initial_conditions != NULL)
		free_m12((void *) filtps->initial_conditions, __FUNCTION__);
	if (filtps->orig_data != NULL)
		if (free_orig_data == TRUE_m12)  // IMPORTANT: if keeping orig_data, caller should have a copy of address to free when they're done to avoid a memory leak
			if (filtps->orig_data != filtps->filt_data)  // simple filter-in-place arrangement
				if (filtps->orig_data != FILT_OFFSET_ORIG_DATA_m12(filtps))  // efficient filter-in-place arrangement
					free_m12((void *) filtps->orig_data, __FUNCTION__);
	if (filtps->filt_data != NULL)
		if (free_filt_data == TRUE_m12)  // IMPORTANT: if keeping filt_data, caller should have a copy of address to free when they're done to avoid a memory leak
			free_m12((void *) filtps->filt_data, __FUNCTION__);
	if (filtps->buffer != NULL)
		if (free_buffer == TRUE_m12)
			free_m12((void *) filtps->buffer, __FUNCTION__);
	
	if (free_structure == TRUE_m12) {
		free_m12((void *) filtps, __FUNCTION__);
	} else {
		filtps->data_length = 0;
		filtps->numerators = NULL;
		filtps->denominators = NULL;
		filtps->initial_conditions = NULL;
		filtps->orig_data = NULL;
		filtps->filt_data = NULL;
		filtps->buffer = NULL;
	}
	
	return;
}


void	FILT_free_quantfilt_data_m12(QUANTFILT_DATA_m12 *qd, TERN_m12 free_structure)
{
	if (qd == NULL)
		return;
	
	if (qd->x != NULL)
		free_m12((void *) qd->x, __FUNCTION__);
	if (qd->qx != NULL)
		free_m12((void *) qd->qx, __FUNCTION__);
	if (qd->nodes != NULL)
		free_m12((void *) qd->nodes, __FUNCTION__);

	if (free_structure == TRUE_m12)
		free_m12((void *) qd, __FUNCTION__);
	
	return;
}


void	FILT_generate_initial_conditions_m12(FILT_PROCESSING_STRUCT_m12 *filtps)
{
	si4     i, j, poles;
	sf8	**q, *rhs, *z, *num, *den;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	poles = filtps->n_poles;
	num = filtps->numerators;
	den = filtps->denominators;
	q = (sf8 **) calloc_2D_m12((size_t) poles, (size_t) poles, sizeof(sf8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	rhs = (sf8 *) calloc((size_t) poles, sizeof(sf8));
	z = filtps->initial_conditions = (sf8 *) calloc_m12((size_t) poles, sizeof(sf8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	q[0][0] = (sf8) 1.0 + den[1];
	for (i = 1, j = 2; i < poles; ++i, ++j)
		q[i][0] = den[j];
	for (i = 1; i < poles; ++i) {
		q[i - 1][i] = (sf8) -1.0;
		q[i][i] = (sf8) 1.0;
	}
	for (i = 0, j = 1; i < poles; ++i, ++j)
		rhs[i] = num[j] - (num[0] * den[j]);
	
	FILT_invert_matrix_m12(q, q, poles);
	FILT_mat_mult_m12(q, rhs, z, poles, poles, 1);
		
	free_m12((void *) q, __FUNCTION__);
	free((void *) rhs);
	
	return;
}


void	FILT_hqr_m12(sf8 **a, si4 poles, FILT_COMPLEX_m12 *eigs)
{
	si4     nn, m, l, k, j, its, i, mmin, max;
	sf8    z, y, x, w, v, u, t, s, r, q, p, anorm, eps, t1, t2, t3, t4;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	anorm = (sf8) 0.0;
	eps = FILT_EPS_SF8_m12;
	
	for (i = 0; i < poles; i++) {
		max = ((i - 1) > 0) ? (i - 1) : 0;
		for (j = max; j < poles; j++) {
			anorm += FILT_ABS_m12(a[i][j]);
		}
	}
	
	nn = poles - 1;
	t = (sf8) 0.0;
	while (nn >= 0) {
		its = 0;
		do {
			for (l = nn; l > 0; l--) {
				t1 = FILT_ABS_m12(a[l - 1][l - 1]);
				t2 = FILT_ABS_m12(a[l][l]);
				s = t1 + t2;
				if (s == (sf8) 0.0)
					s = anorm;
				t1 = FILT_ABS_m12(a[l][l - 1]);
				if (t1 <= (eps * s)) {
					a[l][l - 1] = (sf8) 0.0;
					break;
				}
			}
			x = a[nn][nn];
			if (l == nn) {
				eigs[nn].real = x + t;
				eigs[nn--].imag = (sf8) 0.0;
			} else {
				y = a[nn - 1][nn - 1];
				w = a[nn][nn - 1] * a[nn - 1][nn];
				if (l == (nn - 1)) {
					p = (sf8) 0.5 * (y - x);
					q = (p * p) + w;
					z = sqrt(FILT_ABS_m12(q));
					x += t;
					if (q >= (sf8) 0.0) {
						t1 = FILT_SIGN_m12(z, p);
						z = p + t1;
						eigs[nn - 1].real = eigs[nn].real = x + z;
						if (z != (sf8) 0.0)
							eigs[nn].real = x - w / z;
					} else {
						eigs[nn].real = x + p;
						eigs[nn].imag = -z;
						eigs[nn - 1].real = eigs[nn].real;
						eigs[nn - 1].imag = -eigs[nn].imag;
					}
					nn -= 2;
				} else {
					if (its == 30) {
						G_error_message_m12("Too many iterations in hqr\n");
						exit_m12(1);
					}
					if (its == 10 || its == 20) {
						t += x;
						for (i = 0; i < nn + 1; i++)
							a[i][i] -= x;
						t1 = FILT_ABS_m12(a[nn][nn - 1]);
						t2 = FILT_ABS_m12(a[nn - 1][nn - 2]);
						s = t1 + t2;
						y = x = (sf8) 0.75 * s;
						w = (sf8) -0.4375 * s * s;
					}
					++its;
					for (m = nn - 2; m >= l; m--) {
						z = a[m][m];
						r = x - z;
						s = y - z;
						p = ((r * s - w) / a[m + 1][m]) + a[m][m + 1];
						q = a[m + 1][m + 1] - z - r - s;
						r = a[m + 2][m + 1];
						t1 = FILT_ABS_m12(p);
						t2 = FILT_ABS_m12(q);
						t3 = FILT_ABS_m12(r);
						s = t1 + t2 + t3;
						p /= s;
						q /= s;
						r /= s;
						if (m == l)
							break;
						t1 = FILT_ABS_m12(a[m][m - 1]);
						t2 = FILT_ABS_m12(q);
						t3 = FILT_ABS_m12(r);
						u = t1 * (t2 + t3);
						t1 = FILT_ABS_m12(p);
						t2 = FILT_ABS_m12(a[m - 1][m - 1]);
						t3 = FILT_ABS_m12(z);
						t4 = FILT_ABS_m12(a[m + 1][m + 1]);
						v = t1 * (t2 + t3 + t4);
						if (u <= (eps * v))
							break;
					}
					for (i = m; i < (nn - 1); i++) {
						a[i + 2][i] = (sf8) 0.0;
						if (i != m)
							a[i + 2][i - 1] = (sf8) 0.0;
					}
					for (k = m; k < nn; k++) {
						if (k != m) {
							p = a[k][k - 1];
							q = a[k + 1][k - 1];
							r = (sf8) 0.0;
							if (k + 1 != nn)
								r = a[k + 2][k - 1];
							t1 = FILT_ABS_m12(p);
							t2 = FILT_ABS_m12(q);
							t3 = FILT_ABS_m12(r);
							if ((x = t1 + t2 + t3) != (sf8) 0.0) {
								p /= x;
								q /= x;
								r /= x;
							}
						}
						t1 = sqrt((p * p) + (q * q) + (r * r));
						s = FILT_SIGN_m12(t1, p);
						if (s != 0.0) {
							if (k == m) {
								if (l != m)
									a[k][k - 1] = -a[k][k - 1];
							} else
								a[k][k - 1] = -s * x;
							p += s;
							x = p / s;
							y = q / s;
							z = r / s;
							q /= p;
							r /= p;
							for (j = k; j < (nn + 1); j++) {
								p = a[k][j] + (q * a[k + 1][j]);
								if ((k + 1) != nn) {
									p += r * a[k + 2][j];
									a[k + 2][j] -= p * z;
								}
								a[k + 1][j] -= p * y;
								a[k][j] -= p * x;
							}
							mmin = nn < (k + 3) ? nn : k + 3;
							for (i = l; i < (mmin + 1); i++) {
								p = (x * a[i][k]) + (y * a[i][k + 1]);
								if ((k + 1) != nn) {
									p += z * a[i][k + 2];
									a[i][k + 2] -= p * r;
								}
								a[i][k + 1] -= p * q;
								a[i][k] -= p;
							}
						}
					}
				}
			}
		} while ((l + 1) < nn);
	}
	
	return;
}


FILT_PROCESSING_STRUCT_m12      *FILT_initialize_processing_struct_m12(si4 order, si4 type, sf8 samp_freq, si8 data_len, TERN_m12 alloc_orig_data, TERN_m12 alloc_filt_data, TERN_m12 alloc_buffer, ui4 behavior_on_fail, sf8 cutoff_1, ...)
{
	si8			        pad_samples, buf_len;
	FILT_PROCESSING_STRUCT_m12	*filtps;
	va_list			        arg_p;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// allocate
	filtps = (FILT_PROCESSING_STRUCT_m12 *) calloc_m12((size_t) 1, sizeof(FILT_PROCESSING_STRUCT_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);  // calloc b/c need zeroes in all fields
	
	// populate
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)  // filtps has it's own behavior_on_fail so filter functions can be thread-safe
		filtps->behavior_on_fail = globals_m12->behavior_on_fail;
	else
		filtps->behavior_on_fail = behavior_on_fail;
	filtps->order = filtps->n_poles = order;
	filtps->type = type;
	filtps->sampling_frequency = samp_freq;
	filtps->data_length = data_len;
	filtps->order = filtps->n_poles = order;
	filtps->cutoffs[0] = cutoff_1;
	
	if (type == FILT_BANDPASS_TYPE_m12 || type == FILT_BANDSTOP_TYPE_m12) {
		va_start(arg_p, cutoff_1);
		filtps->cutoffs[1] = va_arg(arg_p, sf8);
		va_end(arg_p);
		filtps->n_poles *= 2;  // (poles == order * cutoffs)
	}
	
	// build filter
	if (FILT_butter_m12(filtps) == FILT_BAD_FILTER_m12) {
		if (!(filtps->behavior_on_fail & SUPPRESS_OUTPUT_m12))
			G_warning_message_m12("%s(): bad filter\n", __FUNCTION__);
		if (filtps->behavior_on_fail & RETURN_ON_FAIL_m12) {
			free_m12((void *) filtps, __FUNCTION__);
			return(NULL);
		}
		if (filtps->behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(-1);
	}
	FILT_generate_initial_conditions_m12(filtps);

	// allocate
	filtps->orig_data = filtps->filt_data = filtps->buffer = NULL;
	if (alloc_orig_data == TRUE_m12)
		filtps->orig_data = (sf8 *) malloc_m12((size_t) data_len << 3, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	pad_samples = 2 * (FILT_PAD_SAMPLES_PER_POLE_m12 * filtps->n_poles);  // (FILT_PAD_SAMPLES_PER_POLE_m12 for each pole at front & back)
	buf_len = data_len + pad_samples;  // filt_data & buffer must have room for pads
	if (alloc_filt_data == TRUE_m12)
		filtps->filt_data = (sf8 *) malloc_m12((size_t) buf_len << 3, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	if (alloc_buffer == TRUE_m12)
		filtps->buffer = (sf8 *) malloc_m12((size_t) buf_len << 3, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

	return(filtps);
}


void	FILT_invert_matrix_m12(sf8 **a, sf8 **inv_a, si4 order)  // done in place if a == inv_a
{
	si4	*indxc, *indxr, *ipiv;
	si4	i, icol, irow, j, k, l, ll;
	sf8	big, dum, pivinv, temp;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	indxc = (si4 *) calloc((size_t) order, sizeof(si4));
	indxr = (si4 *) calloc((size_t) order, sizeof(si4));
	ipiv = (si4 *) calloc((size_t) order, sizeof(si4));
	
	if (inv_a != a) {
		for (i = 0; i < order; i++)
			for (j = 0; j < order; j++)
				inv_a[i][j] = a[i][j];
	}
	
	for (i = 0; i < order; i++) {
		big = (sf8) 0.0;
		for (j = 0; j < order; j++)
			if (ipiv[j] != 1)
				for (k = 0; k < order; k++) {
					if (ipiv[k] == 0) {
						if (FILT_ABS_m12(inv_a[j][k]) >= big) {
							big = FILT_ABS_m12(inv_a[j][k]);
							irow = j;
							icol = k;
						}
					}
				}
		++ipiv[icol];
		if (irow != icol) {
			for (l = 0; l < order; l++) {
				temp = inv_a[irow][l];
				inv_a[irow][l] = inv_a[icol][l];
				inv_a[icol][l] = temp;
			}
		}
		indxr[i] = irow;
		indxc[i] = icol;
		if (inv_a[icol][icol] == (sf8) 0.0) {
			G_error_message_m12("invert_matrix: Singular Matrix\n");
			exit_m12(1);
		}
		pivinv = (sf8) 1.0 / inv_a[icol][icol];
		inv_a[icol][icol] = (sf8) 1.0;
		for (l = 0; l < order; l++)
			inv_a[icol][l] *= pivinv;
		for (ll = 0; ll < order; ll++) {
			if (ll != icol) {
				dum = inv_a[ll][icol];
				inv_a[ll][icol] = (sf8) 0.0;
				for (l = 0; l < order;l++)
					inv_a[ll][l] -= inv_a[icol][l] * dum;
			}
		}
	}
	
	for (l = order - 1; l >= 0; l--) {
		if (indxr[l] != indxc[l]) {
			for (k = 0; k < order; k++) {
				temp = inv_a[k][indxr[l]];
				inv_a[k][indxr[l]] = inv_a[k][indxc[l]];
				inv_a[k][indxc[l]] = temp;
			}
		}
	}
	
	free((void *) ipiv);
	free((void *) indxr);
	free((void *) indxc);
	
	return;
}


// Special thanks to Tej Stead for his work on this algorithm
sf8	FILT_line_noise_filter_m12(sf8 *y, sf8 *fy, si8 len, sf8 samp_freq, sf8 line_freq, si8 cycles_per_template, TERN_m12 calculate_score, TERN_m12 fast_mode, CMP_BUFFERS_m12 *lnf_buffers)
{
	TERN_m12			free_buffers;
	si4				filt_order, n_harmonics;
	FILT_PROCESSING_STRUCT_m12	*filtps;
	si8				i, j, k, int_samps_per_cycle, n_templates, template_trace_len, last_template_start;
	sf8				samps_per_cycle, min_y, max_y, *sf8_p1, *sf8_p2, *sf8_p3;
	sf8				*low_y, *high_y, **template_mtx, *template_trace, *template_buf;
	sf8				amp_y, amp_n, high_f, max_high_f, sum, offset, score;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// if zero passed for cycles_per_template, it is set to line frequency cycles in 1 second
	// returns score == proportion of line noise in unfiltered data (range 0 - 1; -1 indicates errpr, nan indicates no score)
	
	filt_order = 4;  // degenerate above 4 for these settings
	free_buffers = FALSE_m12;
	if (lnf_buffers == NULL)
		free_buffers = TRUE_m12;
	lnf_buffers = CMP_allocate_buffers_m12(lnf_buffers, 4, len + (6 * filt_order), sizeof(sf8), FALSE_m12, FALSE_m12);  // also reallocates
	
	if (cycles_per_template == 0)  // default
		cycles_per_template = (si4) round(line_freq);
	samps_per_cycle = samp_freq / line_freq;

	int_samps_per_cycle = (si8) round(samps_per_cycle);
	// if (samps_per_cycle ~= ((sf8) int_samps_per_cycle)) {
		// could upsample data to nearest integer factor
		// ... but won't make a significant difference
	// }
	n_templates = len / int_samps_per_cycle;
	if (n_templates < cycles_per_template) {
		memcpy((void *) fy, (void *) y, (size_t) (len << 3));
		return((sf8) -1.0);  // error
	}
	
	// get min & max of input trace
	sf8_p1 = y;
	min_y = max_y = *sf8_p1++;
	for (i = len; --i; ++sf8_p1) {
		if (*sf8_p1 < min_y)
			min_y = *sf8_p1;
		else if (*sf8_p1 > max_y)
			max_y = *sf8_p1;
	}

	// generate low frequency trace (pass below 1/2 line frequency)
	filtps = FILT_initialize_processing_struct_m12(filt_order, FILT_LOWPASS_TYPE_m12, samp_freq, len, FALSE_m12, FALSE_m12, FALSE_m12, USE_GLOBAL_BEHAVIOR_m12, (line_freq / (sf8) 2.0));
	filtps->orig_data = y;
	filtps->filt_data = (sf8 *) lnf_buffers->buffer[0];
	filtps->buffer = (sf8 *) lnf_buffers->buffer[1];
	FILT_filtfilt_m12(filtps);
	FILT_free_processing_struct_m12(filtps, FALSE_m12, FALSE_m12, FALSE_m12, TRUE_m12);
	low_y = (sf8 *) lnf_buffers->buffer[0];

	// subtract low frequencies from input (into fy)
	sf8_p1 = fy;  // passed
	sf8_p2 = y;  // passed
	sf8_p3 = low_y;  // in buf 0
	for (i = len; i--;)
		*sf8_p1++ = *sf8_p2++ - *sf8_p3++;
	high_y = fy;

	// make template matrix
	n_templates = len / int_samps_per_cycle;
	template_mtx = (sf8 **) malloc(int_samps_per_cycle * sizeof(sf8 *));
	for (i = 0; i < int_samps_per_cycle; ++i)
		template_mtx[i] = (sf8 *) malloc(n_templates << 3);
	for (i = k = 0; i < n_templates; ++i)
		for (j = 0; j < int_samps_per_cycle; ++j, ++k)
			template_mtx[j][i] = high_y[k];

	// quantfilt along sample dimension
	template_buf = (sf8 *) lnf_buffers->buffer[1];
	for (i = 0; i < int_samps_per_cycle; ++i) {
		FILT_quantfilt_m12(template_mtx[i], template_buf, n_templates, 0.5, cycles_per_template, FILT_EXTRAPOLATE_m12);
		memcpy(template_mtx[i], template_buf, (n_templates << 3));
	}
	
	// build template trace (into buf 1)
	template_trace = (sf8 *) lnf_buffers->buffer[1];
	for (i = k = 0; i < n_templates; ++i)
		for (j = 0; j < int_samps_per_cycle; ++j, ++k)
			template_trace[k] = template_mtx[j][i];
	template_trace_len = int_samps_per_cycle * n_templates;
	last_template_start = template_trace_len - int_samps_per_cycle;
	for (i = last_template_start, j = template_trace_len; j < len; ++i, ++j)
		template_trace[j] = template_trace[i];
	
	// smooth template
	if (fast_mode == FALSE_m12) {  // The operations below make the cleanest data, but the difference is minor. If you need speed, use fast_mode.
		n_harmonics = 10;
		high_f = (sf8) n_harmonics * line_freq;
		max_high_f = samp_freq / (sf8) 5.0;  // limit to at least 5 samps/cycle
		if (high_f > max_high_f)
			high_f = max_high_f;
		filtps = FILT_initialize_processing_struct_m12(filt_order, FILT_LOWPASS_TYPE_m12, samp_freq, len, FALSE_m12, FALSE_m12, FALSE_m12, USE_GLOBAL_BEHAVIOR_m12, high_f);
		filtps->orig_data = template_trace;  // in buf 1
		filtps->filt_data = (sf8 *) lnf_buffers->buffer[2];
		filtps->buffer = (sf8 *) lnf_buffers->buffer[3];
		FILT_filtfilt_m12(filtps);
		FILT_free_processing_struct_m12(filtps, FALSE_m12, FALSE_m12, FALSE_m12, TRUE_m12);
		template_trace = (sf8 *) lnf_buffers->buffer[2];  // bufs 1 & 3 now available
		
		// subtract any residual offset (mean is OK here, but just do full cycles)
		sum = 0.0;
		sf8_p1 = template_trace;
		for (i = template_trace_len; i--;)
			sum += *sf8_p1++;
		offset = sum / (sf8) template_trace_len;
		sf8_p1 = template_trace;
		for (i = len; i--;)
			*sf8_p1++ -= offset;
	} else {  // just do a quick 5 point moving average filter
		FILT_moving_average_m12(template_trace, (sf8 *) lnf_buffers->buffer[2], len, 5, FILT_TRUNCATE_m12);
		template_trace = (sf8 *) lnf_buffers->buffer[2];
	}
	
	// calculate score
	if (calculate_score == TRUE_m12) {  // If you need speed, and can do without the score, make this FALSE.
		// get amplitude of high_y
		amp_y = CMP_trace_amplitude_m12(high_y, (sf8 *) lnf_buffers->buffer[1], len, FALSE_m12);
		
		// get amplitude of template trace
		amp_n = CMP_trace_amplitude_m12(template_trace, (sf8 *) lnf_buffers->buffer[1], len, FALSE_m12);
		
		score = amp_n / (amp_n + amp_y);
	} else {
		score = NAN;
	}
			
	// subtract template, restore low frequencies, & correct overflows (from filtering)
	sf8_p1 = fy; // == high_y;
	sf8_p2 = low_y;  // in buf 0
	sf8_p3 = template_trace;  // now in buf 2
	for (i = len; i--; ++sf8_p1) {
		*sf8_p1 += (*sf8_p2++ - *sf8_p3++);
		if (*sf8_p1 < min_y)
			*sf8_p1 = min_y;
		else if (*sf8_p1 > max_y)
			*sf8_p1 = max_y;
	}
	
	// clean up
	for (i = 0; i < int_samps_per_cycle; ++i)
		free((void *) template_mtx[i]);
	free((void *) template_mtx);
	if (free_buffers == TRUE_m12)
		CMP_free_buffers_m12(lnf_buffers, TRUE_m12);
	
	return(score);
}


void	FILT_mat_mult_m12(void *a, void *b, void *product, si4 outer_dim1, si4 inner_dim, si4 outer_dim2)
{
	si4	i, j, k, v1, v2, vp;
	sf8	sum, t1, t2, *av, **am, *bv, **bm, *pv, **pm;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if ((outer_dim1 == 1) || (inner_dim == 1)) {
		av = (sf8 *) a;
		v1 = 1;
	} else {
		am = (sf8 **) a;
		v1 = 0;
	}
	if ((outer_dim2 == 1) || (inner_dim == 1)) {
		bv = (sf8 *) b;
		v2 = 1;
	} else {
		bm = (sf8 **) b;
		v2 = 0;
	}
	if ((outer_dim1 == 1) || (outer_dim2 == 1)) {
		pv = (sf8 *) product;
		vp = 1;
	} else {
		pm = (sf8 **) product;
		vp = 0;
	}
	
	for (i = 0; i < outer_dim1; ++i) {
		for (j = 0; j < outer_dim2; ++j) {
			sum = 0.0;
			for (k = 0; k < inner_dim; ++k) {
				t1 = (v1) ? av[k] : am[i][k];
				t2 = (v2) ? bv[k] : bm[k][j];
				sum += t1 * t2;
			}
			if (vp) {
				if (outer_dim1 == 1)
					pv[j] = sum;
				else
					pv[i] = sum;
			} else {
				pm[i][j] = sum;
			}
		}
	}
	
	
	return;
}


sf8	*FILT_moving_average_m12(sf8 *x, sf8 *ax, si8 len, si8 span, si1 tail_option_code)
{
	si8	i;
	sf8	sum, length, val, *in_tail_p, *in_head_p, *out_p, *end_x_p;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (ax == NULL)
		ax = malloc_m12((size_t) (len << 3), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		
	// make span odd
	if (!(span & 1))
		++span;
	
	// initial window
	in_tail_p = in_head_p = x;
	end_x_p = x + len;
	out_p = ax;
	
	switch (tail_option_code) {
		case FILT_TRUNCATE_m12:
			sum = *out_p++ = *in_head_p++;
			length = (sf8) 1.0;
			while (length < (sf8) span) {
				sum += *in_head_p++;
				sum += *in_head_p++;
				*out_p++ = sum / (length += (sf8) 2.0);
			}
			break;
		case FILT_EXTRAPOLATE_m12:
			sum = 0.0;
			for (i = span; i--;)
				sum += *in_head_p++;
			val = sum / (sf8) span;
			for (i = (span >> 1) + 1; i--;)
				*out_p++ = val;
			break;
		case FILT_ZEROPAD_m12:
			sum = 0.0;
			for (i = span; i--;)
				sum += *in_head_p++;
			memset((void *) ax, 0, (size_t) ((span >> 1) + 1) << 3);
			out_p = ax + ((span >> 1) + 1);
			break;
		default:
			G_warning_message_m12("%s(): unrecognized tail option\n", __FUNCTION__);
			return(NULL);
	}
	
	// slide window
	length = (sf8) span;
	while (in_head_p < end_x_p) {
		sum -= *in_tail_p++;
		sum += *in_head_p++;
		*out_p++ = sum / length;
	}
	
	// terminal window
	switch (tail_option_code) {
		case FILT_TRUNCATE_m12:
			while (in_tail_p < end_x_p) {
				sum -= *in_tail_p++;
				sum -= *in_tail_p++;
				*out_p++ = sum / (length -= (sf8) 2.0);
			}
			*out_p = x[len - 1];
			break;
		case FILT_EXTRAPOLATE_m12:
			val = *(out_p - 1);
			end_x_p = ax + len;
			while (out_p < end_x_p)
				*out_p++ = val;
			break;
		case FILT_ZEROPAD_m12:
			val = 0.0;
			end_x_p = ax + len;
			while (out_p < end_x_p)
				*out_p++ = val;
			break;
	}

	return(ax);
}


sf8    *FILT_noise_floor_filter_m12(sf8 *data, sf8 *filt_data, si8 data_len, sf8 rel_thresh, sf8 abs_thresh, CMP_BUFFERS_m12 *nff_buffers)
{
	register si8	i, j, k;
	TERN_m12	free_buffers;
	si8		n_peaks, n_troughs, *peak_xs, *trough_xs, x, xm1, dlm1;
	sf8		*peak_env, *trough_env, *mean_env, *env_diffs, base, baseline, dy, step, *quantval_buf, thresh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (filt_data == NULL)
		filt_data = (sf8 *) malloc_m12((size_t) (data_len << 3), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

	free_buffers = FALSE_m12;
	if (nff_buffers == NULL)
		free_buffers = TRUE_m12;
	nff_buffers = CMP_allocate_buffers_m12(nff_buffers, 4, data_len, sizeof(sf8), FALSE_m12, FALSE_m12);  // also reallocates
	peak_xs = (si8 *) nff_buffers->buffer[0];
	trough_xs = (si8 *) nff_buffers->buffer[1];
	peak_env = (sf8 *) nff_buffers->buffer[2];
	trough_env = (sf8 *) nff_buffers->buffer[3];
	
	// find critical points
	CMP_find_crits_2_m12(data, data_len, &n_peaks, peak_xs, &n_troughs, trough_xs);
	if (n_peaks == 0)
		return(NULL);
	
	// create peak envelope
	peak_env[0] = data[0];
	x = peak_xs[0];
	for (i = 1; i < n_peaks; ++i) {
		xm1 = x;
		x = peak_xs[i];
		base = data[xm1];
		dy = data[x] - base;
		step = dy / (sf8) (x - xm1);
		for (j = xm1 + 1; j <= x; ++j)
			peak_env[j] = (base += step);
	}
	
	// create trough envelope
	trough_env[0] = data[0];
	x = trough_xs[0];
	for (i = 1; i < n_troughs; ++i) {
		xm1 = x;
		x = trough_xs[i];
		base = data[xm1];
		dy = data[x] - base;
		step = dy / (sf8) (x - xm1);
		for (j = xm1 + 1; j <= x; ++j)
			trough_env[j] = (base += step);
	}
	
	// transform envelopes to means & differences
	env_diffs = peak_env;
	mean_env = trough_env;
	for (i = 0; i < data_len; ++i) {
		env_diffs[i] -= trough_env[i];
		mean_env[i] += env_diffs[i] / (sf8) 2.0;
	}

	// get median of envelope difference time series
	if (rel_thresh > 0.0) {
		quantval_buf = (sf8 *) trough_xs;
		baseline = CMP_quantval_m12(env_diffs, data_len, 0.5, TRUE_m12, quantval_buf);
		thresh = (baseline / (sf8) 2.0) * rel_thresh;
	} else {
		thresh = abs_thresh;
	}

	// replace large dy with original data
	dlm1 = data_len - 1;;
	for (i = 1, j = 0, k = 2; i < dlm1; ++i, ++j, ++k) {
		if (env_diffs[i] > thresh) {
			if (env_diffs[j] <= thresh && env_diffs[k] <= thresh)   // skip points that exceed thresh for just 1 sample
				continue;
			mean_env[i] = data[i];
		}
	}
	
	// copy to output
	memcpy((void *) filt_data, (void *) mean_env, (size_t) (data_len << 3));
	
	// release resources
	if (free_buffers == TRUE_m12)
		CMP_free_buffers_m12(nff_buffers, TRUE_m12);
	
	return(filt_data);
}


sf8	*FILT_quantfilt_m12(sf8 *x, sf8 *qx, si8 len, sf8 quantile, si8 span, si1 tail_option_code)
{
	FILT_NODE_m12	*nodes, head, tail, *new_node, *prev_new_node, *curr_node, *next_node, *prev_node, *low_q_node, *oldest_node;
	si8     	i, new_span, out_idx, in_idx, low_q_idx, oldest_idx, last_sliding_out_idx, odd_span;
	sf8     	new_val, prev_new_val, temp_idx, low_val_q, high_val_q, low_q_val, high_q_val, true_q_val, q_shift, oldest_val;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// setup
	if (len < span)
		span = len;
	if (qx == NULL) // caller responsible for freeing qx
		qx = (sf8 *) calloc_m12((size_t) len, sizeof(sf8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	nodes = (FILT_NODE_m12 *) calloc((size_t) (span + 1), sizeof(FILT_NODE_m12));
	new_node = nodes;
	head.val = -DBL_MAX;
	head.next = new_node;
	tail.val = DBL_MAX;
	tail.prev = new_node;
	new_node->val = x[0];
	new_node->next = &tail;
	new_node->prev = &head;
	in_idx = 1;
	out_idx = 0;
	odd_span = span & 1;

	if (odd_span) {
		qx[out_idx++] = prev_new_val = new_node->val;
		prev_new_node = new_node++;
	} else {  // even span
		prev_new_node = new_node++;
		prev_new_val = prev_new_node->val;
		new_val = new_node->val = x[in_idx++];
		if (new_val < prev_new_val) {
			new_node->next = prev_new_node;
			new_node->prev = prev_new_node->prev;
			prev_new_node->prev = new_node;
			head.next = new_node;
		} else {
			new_node->next = prev_new_node->next;
			new_node->prev = prev_new_node;
			prev_new_node->next = new_node;
			tail.prev = new_node;
		}
		low_q_node = head.next;
		low_q_val = low_q_node->val;
		high_q_val = (low_q_node->next)->val;
		qx[out_idx++] = (((sf8) 1.0 - quantile) * low_q_val) + (quantile * high_q_val);
		prev_new_node = new_node++;
		prev_new_val = new_val;
	}

	// fill initial node array
	while (in_idx < span) {
		 
		// insert a new node
		new_val = new_node->val = x[in_idx++];
		curr_node = prev_new_node;
		if (new_val >= prev_new_val) {
			// search forward
			while (1) {
				next_node = curr_node->next;
				if (new_val < next_node->val)
					break;
				curr_node = next_node;
			}
			// insert new_node after curr_node
			new_node->prev = curr_node;
			new_node->next = next_node;
			curr_node->next = new_node;
			next_node->prev = new_node;
		} else {  // new_val < prev_new_val
			// search backward
			while (1) {
				prev_node = curr_node->prev;
				if (new_val >= prev_node->val)
					break;
				curr_node = prev_node;
			}
			// insert new_node before curr_node
			new_node->next = curr_node;
			new_node->prev = prev_node;
			curr_node->prev = new_node;
			prev_node->next = new_node;
		}
		
		// insert another new node
		prev_new_node = new_node++;
		prev_new_val = new_val;
		new_val = new_node->val = x[in_idx++];
		curr_node = prev_new_node;
		if (new_val >= prev_new_val) {
			// search forward
			while (1) {
				next_node = curr_node->next;
				if (new_val < next_node->val)
					break;
				curr_node = next_node;
			}
			// insert new_node after curr_node
			new_node->prev = curr_node;
			new_node->next = next_node;
			curr_node->next = new_node;
			next_node->prev = new_node;
		} else {  // new_val < prev_new_val
			// search backward
			while (1) {
				prev_node = curr_node->prev;
				if (new_val >= prev_node->val)
					break;
				curr_node = prev_node;
			}
			// insert new_node before curr_node
			new_node->next = curr_node;
			new_node->prev = prev_node;
			curr_node->prev = new_node;
			prev_node->next = new_node;
		}

		// calculate output
		if (quantile != (sf8) 1.0) {
			temp_idx = quantile * (sf8) (in_idx - 1);
			low_q_idx = (ui8) temp_idx;
			high_val_q = temp_idx - (sf8) low_q_idx;
			low_val_q = (sf8) 1.0 - high_val_q;
			curr_node = head.next;
			for (i = low_q_idx; i--;)
				curr_node = curr_node->next;
			low_q_val = (low_q_node = curr_node)->val;
			high_q_val = (low_q_node->next)->val;
			qx[out_idx++] = (low_q_val * low_val_q) + (high_q_val * high_val_q);
		} else {  // quantile == 1.0
			qx[out_idx++] = (curr_node = tail.prev)->val;
		}
		
		// update loop variables
		prev_new_node = new_node++;
		prev_new_val = new_val;
	}
	
	// handle other tail options (for initial window)
	if (tail_option_code == FILT_EXTRAPOLATE_m12) {
		true_q_val = qx[out_idx - 1];
		for (i = out_idx - 1; i--;)
			qx[i] = true_q_val;
	} else if (tail_option_code == FILT_ZEROPAD_m12) {
		for (i = out_idx - 1; i--;)
			qx[i] = (sf8) 0.0;
	}
		
	// slide window (main loop)
	oldest_idx = 0;
	oldest_node = nodes;
	oldest_val = oldest_node->val;
	low_q_node = curr_node;
	low_q_val = low_q_node->val;
	while (in_idx < len) {
		
		// insert new value into empty node
		new_node->val = new_val = x[in_idx];
		curr_node = prev_new_node;
		if (new_val >= prev_new_val) {
			// search forward
			while (1) {
				next_node = curr_node->next;
				if (new_val < next_node->val)
					break;
				curr_node = next_node;
			}
			// insert new_node after curr_node
			new_node->prev = curr_node;
			new_node->next = next_node;
			curr_node->next = new_node;
			next_node->prev = new_node;
		} else {  // new_val < prev_new_val
			// search backward
			while (1) {
				prev_node = curr_node->prev;
				if (new_val >= prev_node->val)
					break;
				curr_node = prev_node;
			}
			// insert new_node before curr_node
			new_node->next = curr_node;
			new_node->prev = prev_node;
			curr_node->prev = new_node;
			prev_node->next = new_node;
		}
		
		// update q node
		if (new_val >= low_q_val) {
			q_shift = (sf8) 0.5;
		} else {  // new_val < low_q_val
			q_shift = (sf8) -0.5;
		}
		if (oldest_val > low_q_val) {
			q_shift -= (sf8) 0.5;
		} else if (oldest_val < low_q_val) {
			q_shift += (sf8) 0.5;
		} else {  // oldest_val == low_q_val
			if (oldest_node == low_q_node) {
				q_shift *= (sf8) 2.0;
			} else {  // oldest_node != low_q_node
				q_shift += (sf8) 0.5;
			}
		}
		
		// remove oldest node
		(oldest_node->prev)->next = oldest_node->next;
		(oldest_node->next)->prev = oldest_node->prev;
		
		// update q node
		if (q_shift == (sf8) 1.0)
			low_q_node = low_q_node->next;
		else if (q_shift == (sf8) -1.0)
			low_q_node = low_q_node->prev;
		
		// output new q value
		if (quantile != (sf8) 1.0) {
			low_q_val = low_q_node->val;
			high_q_val = (low_q_node->next)->val;
			qx[out_idx] = (low_q_val * low_val_q) + (high_q_val * high_val_q);
		} else {  // quantile == 1.0
			qx[out_idx] = low_q_val = (low_q_node = tail.prev)->val;
		}
		
		// update rotating indices
		prev_new_node = new_node;
		prev_new_val = new_val;
		new_node = oldest_node;
		if (++oldest_idx > span)
		    oldest_idx = 0;
		oldest_node = nodes + oldest_idx;
		oldest_val = oldest_node->val;
		
		// update non-rotating indices
		++in_idx;
		++out_idx;
	}
	
	// build terminal window (for "truncate" tail option)
	last_sliding_out_idx = out_idx;
	if (tail_option_code == FILT_TRUNCATE_m12) {
		for (new_span = span - 3; new_span > 0; new_span -= 2) {
			
			// remove oldest node
			(oldest_node->prev)->next = oldest_node->next;
			(oldest_node->next)->prev = oldest_node->prev;
			if (++oldest_idx > span)
			    oldest_idx = 0;
			oldest_node = nodes + oldest_idx;

			// remove next oldest node
			(oldest_node->prev)->next = oldest_node->next;
			(oldest_node->next)->prev = oldest_node->prev;
			if (++oldest_idx > span)
			    oldest_idx = 0;
			oldest_node = nodes + oldest_idx;

			// calculate output
			if (quantile != (sf8) 1.0) {
				temp_idx = quantile * (sf8) new_span;
				low_q_idx = (ui8) temp_idx;
				high_val_q = temp_idx - (sf8) low_q_idx;
				low_val_q = (sf8) 1.0 - high_val_q;
				low_q_node = head.next;
				for (i = low_q_idx; i--;)
					low_q_node = low_q_node->next;
				low_q_val = low_q_node->val;
				high_q_val = (low_q_node->next)->val;
				qx[out_idx++] = (low_q_val * low_val_q) + (high_q_val * high_val_q);
			} else {  // quantile == 1.0
				qx[out_idx++] = (tail.prev)->val;
			}
		}
		qx[len - 1] = x[len - 1];
	}
	
	// handle other tail options (for terminal window)
	else if (tail_option_code == FILT_EXTRAPOLATE_m12) {
		true_q_val = qx[last_sliding_out_idx - 1];
		for (i = last_sliding_out_idx; i < len; ++i)
			qx[i] = true_q_val;
	} else if (tail_option_code == FILT_ZEROPAD_m12) {
		for (i = last_sliding_out_idx; i < len; ++i)
			qx[i] = (sf8) 0.0;
	}
	
	// clean up
	free(nodes);

	return(qx);
}


QUANTFILT_DATA_m12	*FILT_quantfilt_head_m12(QUANTFILT_DATA_m12 *qd, ...)  // varargs: sf8 *x, sf8 *qx, si8 len, sf8 quantile, si8 span, si4 tail_option_code
{
	si1 			tail_option_code;
	si8     		i, len, span, out_idx, in_idx, low_q_idx, odd_span;
	sf8     		*x, *qx, quantile, new_val, prev_new_val, temp_idx, low_val_q, high_val_q, low_q_val, high_q_val, true_q_val;
	FILT_NODE_m12		*head, *tail, *new_node, *prev_new_node, *curr_node, *next_node, *prev_node, *low_q_node;
	va_list			args;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// setup
	if (qd == NULL) {
		qd = (QUANTFILT_DATA_m12 *) calloc_m12((size_t) 1, sizeof(QUANTFILT_DATA_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		// get varargs
		va_start(args, qd);
		qd->x = va_arg(args, sf8 *);
		qd->qx = va_arg(args, sf8 *);
		qd->len = va_arg(args, si8);
		qd->quantile = va_arg(args, sf8);
		qd->span = va_arg(args, si8);
		qd->tail_option_code = (si1) va_arg(args, si4);
		va_end(args);
	}

	// allocate
	if (qd->qx == NULL)
		qd->qx = (sf8 *) calloc_m12((size_t) qd->len, sizeof(sf8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	if (qd->nodes == NULL)
		qd->nodes = (FILT_NODE_m12 *) calloc_m12((size_t) (qd->span + 1), sizeof(FILT_NODE_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

	// get temp variables
	len = qd->len;
	span = qd->span;
	if (len < span)
		span = len;
	tail_option_code = qd->tail_option_code;
	head = &qd->head;
	tail = &qd->tail;
	x = qd->x;
	qx = qd->qx;
	quantile = qd->quantile;

	new_node = qd->nodes;
	head->val = -DBL_MAX;
	head->next = new_node;
	tail->val = DBL_MAX;
	tail->prev = new_node;
	new_node->val = x[0];
	new_node->next = tail;
	new_node->prev = head;
	in_idx = 1;
	out_idx = 0;
	odd_span = span & 1;
	
	
	if (odd_span) {
		qx[out_idx++] = prev_new_val = new_node->val;
		prev_new_node = new_node++;
	} else {  // even span
		prev_new_node = new_node++;
		prev_new_val = prev_new_node->val;
		new_val = new_node->val = x[in_idx++];
		if (new_val < prev_new_val) {
			new_node->next = prev_new_node;
			new_node->prev = prev_new_node->prev;
			prev_new_node->prev = new_node;
			head->next = new_node;
		} else {
			new_node->next = prev_new_node->next;
			new_node->prev = prev_new_node;
			prev_new_node->next = new_node;
			tail->prev = new_node;
		}
		low_q_node = head->next;
		low_q_val = low_q_node->val;
		high_q_val = (low_q_node->next)->val;
		qx[out_idx++] = (((sf8) 1.0 - quantile) * low_q_val) + (quantile * high_q_val);
		prev_new_node = new_node++;
		prev_new_val = new_val;
	}
	
	// fill initial node array
	while (in_idx < span) {
		
		// insert a new node
		new_val = new_node->val = x[in_idx++];
		curr_node = prev_new_node;
		if (new_val >= prev_new_val) {
			// search forward
			while (1) {
				next_node = curr_node->next;
				if (new_val < next_node->val)
					break;
				curr_node = next_node;
			}
			// insert new_node after curr_node
			new_node->prev = curr_node;
			new_node->next = next_node;
			curr_node->next = new_node;
			next_node->prev = new_node;
		} else {  // new_val < prev_new_val
			// search backward
			while (1) {
				prev_node = curr_node->prev;
				if (new_val >= prev_node->val)
					break;
				curr_node = prev_node;
			}
			// insert new_node before curr_node
			new_node->next = curr_node;
			new_node->prev = prev_node;
			curr_node->prev = new_node;
			prev_node->next = new_node;
		}
		
		// insert another new node
		prev_new_node = new_node++;
		prev_new_val = new_val;
		new_val = new_node->val = x[in_idx++];
		curr_node = prev_new_node;
		if (new_val >= prev_new_val) {
			// search forward
			while (1) {
				next_node = curr_node->next;
				if (new_val < next_node->val)
					break;
				curr_node = next_node;
			}
			// insert new_node after curr_node
			new_node->prev = curr_node;
			new_node->next = next_node;
			curr_node->next = new_node;
			next_node->prev = new_node;
		} else {  // new_val < prev_new_val
			// search backward
			while (1) {
				prev_node = curr_node->prev;
				if (new_val >= prev_node->val)
					break;
				curr_node = prev_node;
			}
			// insert new_node before curr_node
			new_node->next = curr_node;
			new_node->prev = prev_node;
			curr_node->prev = new_node;
			prev_node->next = new_node;
		}
		
		// calculate output
		if (quantile != (sf8) 1.0) {
			temp_idx = quantile * (sf8) (in_idx - 1);
			low_q_idx = (ui8) temp_idx;
			high_val_q = temp_idx - (sf8) low_q_idx;
			low_val_q = (sf8) 1.0 - high_val_q;
			curr_node = head->next;
			for (i = low_q_idx; i--;)
				curr_node = curr_node->next;
			low_q_val = (low_q_node = curr_node)->val;
			high_q_val = (low_q_node->next)->val;
			qx[out_idx++] = (low_q_val * low_val_q) + (high_q_val * high_val_q);
		} else {  // quantile == 1.0
			qx[out_idx++] = (curr_node = tail->prev)->val;
		}
		
		// update loop variables
		prev_new_node = new_node++;
		prev_new_val = new_val;
	}
	
	// handle other tail options (for initial window)
	if (tail_option_code == FILT_EXTRAPOLATE_m12) {
		true_q_val = qx[out_idx - 1];
		for (i = out_idx - 1; i--;)
			qx[i] = true_q_val;
	} else if (tail_option_code == FILT_ZEROPAD_m12) {
		for (i = out_idx - 1; i--;)
			qx[i] = (sf8) 0.0;
	}
	
	// set structure variables
	qd->oldest_idx = 0;
	qd->oldest_node = qd->nodes;
	qd->curr_node = curr_node;
	qd->in_idx = in_idx;
	qd->out_idx = out_idx;
	qd->low_val_q = low_val_q;
	qd->high_val_q = high_val_q;

	return(qd);
}
	

void	FILT_quantfilt_mid_m12(QUANTFILT_DATA_m12 *qd)
{
	si8     	len, span, out_idx, in_idx, oldest_idx;
	sf8     	*x, *qx, quantile, new_val, prev_new_val, low_val_q, high_val_q, low_q_val, high_q_val, q_shift, oldest_val;
	FILT_NODE_m12	*nodes, *new_node, *prev_new_node, *tail, *curr_node, *next_node, *prev_node, *low_q_node, *oldest_node;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// get temp variables
	len = qd->len;
	span = qd->span;
	if (len < span)
		span = len;
	x = qd->x;
	qx = qd->qx;
	oldest_idx = qd->oldest_idx;
	nodes = qd->nodes;
	tail = &qd->tail;
	oldest_node = qd->oldest_node;
	low_q_node = qd->curr_node;
	in_idx = qd->in_idx;
	out_idx = qd->out_idx;
	quantile = qd->quantile;
	low_val_q = qd->low_val_q;
	high_val_q = qd->high_val_q;


	// slide window (main loop)
	low_q_val = low_q_node->val;
	while (in_idx < len) {
		
		// insert new value into empty node
		new_node->val = new_val = x[in_idx];
		curr_node = prev_new_node;
		if (new_val >= prev_new_val) {
			// search forward
			while (1) {
				next_node = curr_node->next;
				if (new_val < next_node->val)
					break;
				curr_node = next_node;
			}
			// insert new_node after curr_node
			new_node->prev = curr_node;
			new_node->next = next_node;
			curr_node->next = new_node;
			next_node->prev = new_node;
		} else {  // new_val < prev_new_val
			// search backward
			while (1) {
				prev_node = curr_node->prev;
				if (new_val >= prev_node->val)
					break;
				curr_node = prev_node;
			}
			// insert new_node before curr_node
			new_node->next = curr_node;
			new_node->prev = prev_node;
			curr_node->prev = new_node;
			prev_node->next = new_node;
		}
		
		// update q node
		if (new_val >= low_q_val) {
			q_shift = (sf8) 0.5;
		} else {  // new_val < low_q_val
			q_shift = (sf8) -0.5;
		}
		if (oldest_val > low_q_val) {
			q_shift -= (sf8) 0.5;
		} else if (oldest_val < low_q_val) {
			q_shift += (sf8) 0.5;
		} else {  // oldest_val == low_q_val
			if (oldest_node == low_q_node) {
				q_shift *= (sf8) 2.0;
			} else {  // oldest_node != low_q_node
				q_shift += (sf8) 0.5;
			}
		}
		
		// remove oldest node
		(oldest_node->prev)->next = oldest_node->next;
		(oldest_node->next)->prev = oldest_node->prev;
		
		// update q node
		if (q_shift == (sf8) 1.0)
			low_q_node = low_q_node->next;
		else if (q_shift == (sf8) -1.0)
			low_q_node = low_q_node->prev;
		
		// output new q value
		if (quantile != (sf8) 1.0) {
			low_q_val = low_q_node->val;
			high_q_val = (low_q_node->next)->val;
			qx[out_idx] = (low_q_val * low_val_q) + (high_q_val * high_val_q);
		} else {  // quantile == 1.0
			qx[out_idx] = low_q_val = (low_q_node = tail->prev)->val;
		}
		
		// update rotating indices
		prev_new_node = new_node;
		prev_new_val = new_val;
		new_node = oldest_node;
		if (++oldest_idx > span)
			oldest_idx = 0;
		oldest_node = nodes + oldest_idx;
		oldest_val = oldest_node->val;
		
		// update non-rotating indices
		++in_idx;
		++out_idx;
	}
	
	// set structure variables
	qd->oldest_idx = oldest_idx;
	qd->oldest_node = oldest_node;
	qd->curr_node = curr_node;
	qd->in_idx = in_idx;
	qd->out_idx = out_idx;
	
	return;
}


void	FILT_quantfilt_tail_m12(QUANTFILT_DATA_m12 *qd)
{
	si8     	i, len, span, new_span, out_idx, low_q_idx, oldest_idx, last_sliding_out_idx;
	sf8     	*x, *qx, quantile, temp_idx, low_val_q, high_val_q, low_q_val, high_q_val, true_q_val;
	FILT_NODE_m12	*nodes, *head, *tail, *low_q_node, *oldest_node;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// get temp variables
	x = qd->x;
	qx = qd->qx;
	nodes = qd->nodes;
	oldest_idx = qd->oldest_idx;
	oldest_node = qd->oldest_node;
	low_q_node = qd->curr_node;
	out_idx = qd->out_idx;
	quantile = qd->quantile;
	span = qd->span;
	len = qd->len;
	if (len < span)
		span = len;
	head = &qd->head;
	tail = &qd->tail;
	
	// build terminal window (for "truncate" tail option)
	last_sliding_out_idx = out_idx;
	if (qd->tail_option_code == FILT_TRUNCATE_m12) {
		for (new_span = span - 3; new_span > 0; new_span -= 2) {
			
			// remove oldest node
			(oldest_node->prev)->next = oldest_node->next;
			(oldest_node->next)->prev = oldest_node->prev;
			if (++oldest_idx > span)
			    oldest_idx = 0;
			oldest_node = nodes + oldest_idx;

			// remove next oldest node
			(oldest_node->prev)->next = oldest_node->next;
			(oldest_node->next)->prev = oldest_node->prev;
			if (++oldest_idx > span)
			    oldest_idx = 0;
			oldest_node = nodes + oldest_idx;

			// calculate output
			if (qd->quantile != (sf8) 1.0) {
				temp_idx = quantile * (sf8) new_span;
				low_q_idx = (ui8) temp_idx;
				high_val_q = temp_idx - (sf8) low_q_idx;
				low_val_q = (sf8) 1.0 - high_val_q;
				low_q_node = head->next;
				for (i = low_q_idx; i--;)
					low_q_node = low_q_node->next;
				low_q_val = low_q_node->val;
				high_q_val = (low_q_node->next)->val;
				qx[out_idx++] = (low_q_val * low_val_q) + (high_q_val * high_val_q);
			} else {  // quantile == 1.0
				qx[out_idx++] = (tail->prev)->val;
			}
		}
		qx[len - 1] = x[len - 1];
	}
	
	// handle other tail options (for terminal window)
	else if (qd->tail_option_code == FILT_EXTRAPOLATE_m12) {
		true_q_val = qx[last_sliding_out_idx - 1];
		for (i = last_sliding_out_idx; i < len; ++i)
			qx[i] = true_q_val;
	} else if (qd->tail_option_code == FILT_ZEROPAD_m12) {
		for (i = last_sliding_out_idx; i < len; ++i)
			qx[i] = (sf8) 0.0;
	}
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     FILT_sf8_sort_m12(const void *n1, const void *n2)
{
	if (*((sf8 *) n1) > *((sf8 *) n2))
		return(1);
	else if (*((sf8 *) n1) < *((sf8 *) n2))
		return(-1);
	
	return(0);
}


void	FILT_show_processing_struct_m12(FILT_PROCESSING_STRUCT_m12 *filt_ps)
{
	si4	i;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	printf_m12("\n\n----------- Filter Processing Structure - START ----------\n");
	printf_m12("behavior_on_fail: %u\n", filt_ps->behavior_on_fail);
	printf_m12("order: %d\n", filt_ps->order);
	printf_m12("n_poles: %d\n", filt_ps->n_poles);
	printf_m12("type: %d\n", filt_ps->type);
	printf_m12("sampling_frequency: %lf\n", filt_ps->sampling_frequency);
	printf_m12("data_length: %ld\n", filt_ps->data_length);
	printf_m12("cutoffs[0]: %lf\n", filt_ps->cutoffs[0]);
	if (filt_ps->type == FILT_BANDPASS_TYPE_m12 || filt_ps->type == FILT_BANDSTOP_TYPE_m12)
		printf_m12("cutoffs[1]: %lf\n", filt_ps->cutoffs[1]);
	if (filt_ps->numerators == NULL) {
		printf_m12("numerators: NULL\n");
	} else {
		for (i = 0; i <= filt_ps->n_poles; ++i)
			printf_m12("numerators[%d]: %lf\n", i, filt_ps->numerators[i]);
	}
	if (filt_ps->denominators == NULL) {
		printf_m12("denominators: NULL\n");
	} else {
		for (i = 0; i <= filt_ps->n_poles; ++i)
			printf_m12("denominators[%d]: %lf\n", i, filt_ps->denominators[i]);
	}
	if (filt_ps->initial_conditions == NULL) {
		printf_m12("initial_conditions: NULL\n");
	} else {
		for (i = 0; i < filt_ps->n_poles; ++i)
			printf_m12("initial_conditions[%d]: %lf\n", i, filt_ps->initial_conditions[i]);
	}
	if (filt_ps->orig_data)
		printf_m12("orig_data: NULL\n");
	else
		printf_m12("orig_data: assigned\n");
	if (filt_ps->filt_data)
		printf_m12("filt_data: NULL\n");
	else
		printf_m12("filt_data: assigned\n");
	if (filt_ps->buffer)
		printf_m12("buffer: NULL\n");
	else
		printf_m12("buffer: assigned\n");
	printf_m12("------------ Filter Processing Structure - END -----------\n\n");

	return;
}


void	FILT_unsymmeig_m12(sf8 **a, si4 poles, FILT_COMPLEX_m12 *eigs)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	FILT_balance_m12(a, poles);
	FILT_elmhes_m12(a, poles);
	FILT_hqr_m12(a, poles, eigs);
	
	return;
}



//***************************************//
// MARK: FILE PROCESSING FUNCTIONS  (FPS)
//***************************************//

FILE_PROCESSING_STRUCT_m12	*FPS_allocate_processing_struct_m12(FILE_PROCESSING_STRUCT_m12 *fps, si1 *full_file_name, ui4 type_code, si8 raw_data_bytes, LEVEL_HEADER_m12 *parent, FILE_PROCESSING_STRUCT_m12 *proto_fps, si8 bytes_to_copy)
{
	TERN_m12			free_fps;
	UNIVERSAL_HEADER_m12		*uh;
	CMP_PROCESSING_STRUCT_m12	*cps;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// allocate FPS
	free_fps = FALSE_m12;
	if (fps == NULL) {
		fps = (FILE_PROCESSING_STRUCT_m12 *) calloc_m12((size_t) 1, sizeof(FILE_PROCESSING_STRUCT_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free_fps = TRUE_m12;
	} else if (fps->parameters.raw_data != NULL) {
		free_m12((void *) fps->parameters.raw_data, __FUNCTION__);
		fps->parameters.raw_data = NULL;
	}
	if (parent != NULL)
		fps->parent = (void *) parent;
	if (full_file_name != NULL)
		if (*full_file_name)
			strncpy_m12(fps->full_file_name, full_file_name, FULL_FILE_NAME_BYTES_m12);
	if (*fps->full_file_name && type_code == UNKNOWN_TYPE_CODE_m12)
		type_code = G_MED_type_code_from_string_m12(fps->full_file_name);

	// allocate raw_data
	(void) FPS_initialize_parameters_m12(&fps->parameters);
	if (raw_data_bytes == FPS_FULL_FILE_m12) {  // use this to allocate a memory mapped file also
		fps->parameters.raw_data_bytes = raw_data_bytes = G_file_length_m12(NULL, fps->full_file_name);
	} else {  // all files start with universal header
		if (raw_data_bytes == FPS_UNIVERSAL_HEADER_ONLY_m12)
			fps->parameters.raw_data_bytes = raw_data_bytes = UNIVERSAL_HEADER_BYTES_m12;
		else
			fps->parameters.raw_data_bytes = (raw_data_bytes += UNIVERSAL_HEADER_BYTES_m12);
	}
	fps->parameters.raw_data = (ui1 *) calloc_m12((size_t) raw_data_bytes, sizeof(ui1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	uh = fps->universal_header = (UNIVERSAL_HEADER_m12 *) fps->parameters.raw_data;
	fps->number_of_items = 0;

	// if a prototype FILE_PROCESSING_STRUCT_m12 was passed - copy its directives, password data, universal_header, and raw data
	if (proto_fps != NULL) {
		fps->directives = proto_fps->directives;
		fps->parameters.password_data = proto_fps->parameters.password_data;
		bytes_to_copy += UNIVERSAL_HEADER_BYTES_m12;  // all files start with universal header
		if ((bytes_to_copy > proto_fps->parameters.raw_data_bytes) || (bytes_to_copy > raw_data_bytes))
			G_error_message_m12("%s(): copy request size exceeds available data or space => no copying done\n", __FUNCTION__);
		else
			memcpy(fps->parameters.raw_data, proto_fps->parameters.raw_data, bytes_to_copy);
		uh->type_code = type_code;
		uh->header_CRC = uh->body_CRC = CRC_START_VALUE_m12;
		uh->number_of_entries = 0;
		uh->maximum_entry_size = 0;
	} else {
		(void) FPS_initialize_directives_m12(&fps->directives);  // set directives to defaults
		G_initialize_universal_header_m12(fps, type_code, FALSE_m12, FALSE_m12);
	}
	G_generate_UID_m12(&uh->file_UID);
	uh->provenance_UID = uh->file_UID;  // if not originating file, caller should change provenance_UID to file_UID of originating file
	if (fps->parameters.password_data == NULL)
		fps->parameters.password_data = &globals_m12->password_data;

	// set appropriate pointers (also set maximum entry size where it's a fixed value)
	fps->data_pointers = fps->parameters.raw_data + UNIVERSAL_HEADER_BYTES_m12;
	switch (type_code) {
		case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
			uh->maximum_entry_size = TIME_SERIES_INDEX_BYTES_m12;
			break;
		case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
			cps = fps->parameters.cps;
			if (cps != NULL) {
				cps->block_header = (CMP_BLOCK_FIXED_HEADER_m12 *) fps->data_pointers;
				cps->parameters.allocated_compressed_bytes = raw_data_bytes - UNIVERSAL_HEADER_BYTES_m12;
			}
			break;
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
			uh->maximum_entry_size = METADATA_BYTES_m12;
			uh->number_of_entries = 1;
			break;
		case VIDEO_INDICES_FILE_TYPE_CODE_m12:
			uh->maximum_entry_size = VIDEO_INDEX_BYTES_m12;
			break;
		case RECORD_DATA_FILE_TYPE_CODE_m12:
			break;
		case RECORD_INDICES_FILE_TYPE_CODE_m12:
			uh->maximum_entry_size = RECORD_INDEX_BYTES_m12;
			break;
		default:
			if (free_fps == TRUE_m12)
				FPS_free_processing_struct_m12(fps, TRUE_m12);
			G_error_message_m12("%s(): unrecognized type code (code = 0x%08x)\n", type_code, __FUNCTION__);
			return(NULL);
	}

	return(fps);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	FPS_close_m12(FILE_PROCESSING_STRUCT_m12 *fps) {
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (fps != NULL) {
		if (fps->parameters.fp != NULL) {
			if (fps->parameters.fd > 2) { // fclose() can crash under some circumstances (e.g. if file is already closed)  (fd < 0 == closed, 0-2 == standard streams)
				fclose(fps->parameters.fp);

				// below was from some Linux fclose/flushing issue - but not sure it's needed anymore - close() alone causes problem with Matlab
				// fflush(fps->parameters.fp);  // close() alone doesn't flush internal file buffers
				// #if defined MACOS_m12 || defined LINUX_m12
				// close(fps->parameters.fd);
				// #endif
				// #ifdef WINDOWS_m12
				// _close(fps->parameters.fd);
				// #endif
				
				fps->parameters.fp = NULL;
				fps->parameters.fd = FPS_FD_CLOSED_m12;
				fps->parameters.fpos = 0;
				// leave fps->flen intact
			}
		}
	}


	return;
}


si4	FPS_compare_start_times_m12(const void *a, const void *b)
{
	si8				a_start_time, b_start_time;
	FILE_PROCESSING_STRUCT_m12	*fps;
	
	
	fps = (FILE_PROCESSING_STRUCT_m12 *) *((FILE_PROCESSING_STRUCT_m12 **) a);
	a_start_time = fps->universal_header->segment_start_time;

	fps = (FILE_PROCESSING_STRUCT_m12 *)  *((FILE_PROCESSING_STRUCT_m12 **) a);
	b_start_time = fps->universal_header->segment_start_time;

	// qsort() requires an si4 return value, so can't just subtract
	if (a_start_time > b_start_time)
		return((si4) 1);
	if (a_start_time < b_start_time)
		return((si4) -1);
	return((si4) 0);
}


void	FPS_free_processing_struct_m12(FILE_PROCESSING_STRUCT_m12 *fps, TERN_m12 free_fps_structure)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (fps == NULL) {
		G_warning_message_m12("%s(): trying to free a NULL FILE_PROCESSING_STRUCT_m12 => returning with no action\n", __FUNCTION__);
		return;
	}
	
	if (fps->universal_header != NULL) {
		if (fps->universal_header->type_code == TIME_SERIES_DATA_FILE_TYPE_CODE_m12)  // CPS requires special freeing
			if (fps->parameters.cps != NULL)
				if (fps->directives.free_CMP_processing_struct == TRUE_m12)
					CMP_free_processing_struct_m12(fps->parameters.cps, TRUE_m12);
	}
	
	if (fps->parameters.raw_data != NULL)
		free_m12((void *) fps->parameters.raw_data, __FUNCTION__);
	
	if (fps->directives.free_password_data == TRUE_m12)
		if (fps->parameters.password_data != &globals_m12->password_data && fps->parameters.password_data != NULL)
			free_m12((void *) fps->parameters.password_data, __FUNCTION__);
	
	if (fps->parameters.mmap_block_bitmap != NULL)
		free_m12((void *) fps->parameters.mmap_block_bitmap, __FUNCTION__);
	
	// Note: always close when freeing; close_file directives used in reading / writing functions
	FPS_close_m12(fps);  // if already closed, this fails silently
	
	if (free_fps_structure == TRUE_m12) {
		free_m12((void *) fps, __FUNCTION__);
	} else {
		// leave full_file_name intact
		fps->parameters.last_access_time = UUTC_NO_ENTRY_m12;
		fps->parameters.cps = NULL;
		if (fps->parameters.password_data != &globals_m12->password_data)  // if points to global password data, leave intact for re-use
			fps->parameters.password_data = NULL;
		fps->universal_header = NULL;
		fps->data_pointers = NULL;  // Note: if free_CMP_processing_struct == FALSE_m12, this pointer is still set to NULL => assumes cps address is also stored elsewhere
		fps->parameters.raw_data_bytes = 0;
		fps->parameters.raw_data = NULL;
		fps->parameters.mmap_block_bytes = 0;
		fps->parameters.mmap_number_of_blocks = 0;
		fps->parameters.mmap_block_bitmap = NULL;
	}

	return;
}


FPS_DIRECTIVES_m12	*FPS_initialize_directives_m12(FPS_DIRECTIVES_m12 *directives)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (directives == NULL)
		directives = (FPS_DIRECTIVES_m12 *) calloc_m12((size_t) 1, sizeof(FPS_DIRECTIVES_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	// set directives to defaults
	directives->close_file = FPS_DIRECTIVES_CLOSE_FILE_DEFAULT_m12;
	directives->flush_after_write = FPS_DIRECTIVES_FLUSH_AFTER_WRITE_DEFAULT_m12;
	directives->update_universal_header = FPS_DIRECTIVES_UPDATE_UNIVERSAL_HEADER_DEFAULT_m12;
	directives->leave_decrypted = FPS_DIRECTIVES_LEAVE_DECRYPTED_DEFAULT_m12;
	directives->free_password_data = FPS_DIRECTIVES_FREE_PASSWORD_DATA_DEFAULT_m12;
	directives->free_CMP_processing_struct = FPS_DIRECTIVES_FREE_CMP_PROCESSING_STRUCT_DEFAULT_m12;
	directives->lock_mode = FPS_DIRECTIVES_LOCK_MODE_DEFAULT_m12;
	directives->open_mode = FPS_DIRECTIVES_OPEN_MODE_DEFAULT_m12;
	directives->memory_map = FPS_DIRECTIVES_MEMORY_MAP_DEFAULT_m12;

	
	return(directives);
}


FPS_PARAMETERS_m12	*FPS_initialize_parameters_m12(FPS_PARAMETERS_m12 *parameters)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (parameters == NULL)
		parameters = (FPS_PARAMETERS_m12 *) calloc_m12((size_t) 1, sizeof(FPS_PARAMETERS_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	// set parameters to defaults
	parameters->last_access_time = UUTC_NO_ENTRY_m12;
	parameters->full_file_read = FALSE_m12;
	parameters->raw_data_bytes = 0;
	parameters->raw_data = NULL;
	parameters->password_data = &globals_m12->password_data;
	parameters->cps = NULL;
	parameters->fd = FPS_FD_NO_ENTRY_m12;
	parameters->fp = NULL;
	parameters->fpos = 0;
	parameters->flen = 0;
	parameters->mmap_block_bytes = 0;
	parameters->mmap_number_of_blocks = 0;
	parameters->mmap_block_bitmap = NULL;
	PROC_pthread_mutex_init_m12(&parameters->mutex, NULL);

	return(parameters);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
TERN_m12	FPS_lock_m12(FILE_PROCESSING_STRUCT_m12 *fps, si4 lock_type, const si1 *function, ui4 behavior_on_fail)
{
	si4	err;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#if defined MACOS_m12 || defined LINUX_m12
	struct flock	fl;
	
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	errno_reset_m12();
	
	fl.l_type = lock_type;
	fl.l_whence = SEEK_SET;
	fl.l_start = 0;
	fl.l_len = 0;
	fl.l_pid = getpid();
	if (fcntl(fps->parameters.fd, F_SETLKW, &fl) == -1) {
		err = errno_m12();
		G_error_message_m12("%s(): fcntl() failed to lock file\n\tsystem error: %s (# %d)\n\tcalled from function %s()\n", __FUNCTION__, strerror(err), err, function);
		return(-1);
	}
#endif
	
	return(TRUE_m12);
}


si8	FPS_memory_map_read_m12(FILE_PROCESSING_STRUCT_m12 *fps, si8 file_offset, si8 bytes_to_read, const si1 *function, ui4 behavior_on_fail)
{
	ui1		mode;
	const ui1	SKIP_MODE = 0, READ_MODE = 1;
	ui4		start_block, end_block;
	ui8		bit_mask, *bit_word, read_start, read_bytes;
	si8		i, remaining_bytes, block_bytes;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (bytes_to_read == 0)
		return(TRUE_m12);  // didn't fail, just nothing to do
	file_offset = REMOVE_DISCONTINUITY_m12(file_offset);

	if (bytes_to_read == FPS_UNIVERSAL_HEADER_ONLY_m12) {
		bytes_to_read = UNIVERSAL_HEADER_BYTES_m12;
		file_offset = 0;
	}

	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	remaining_bytes = fps->parameters.flen - file_offset;
	if (bytes_to_read > remaining_bytes)
		bytes_to_read = remaining_bytes;
		
	block_bytes = (si8) fps->parameters.mmap_block_bytes;
	start_block = file_offset / block_bytes;
	end_block = (file_offset + bytes_to_read - 1) / block_bytes;
	bit_mask = 1 << (start_block % 64);
	bit_word = fps->parameters.mmap_block_bitmap + (start_block >> 6);
	file_offset = start_block * block_bytes;
	
	if (*bit_word & bit_mask) {
		mode = SKIP_MODE;
	} else {
		mode = READ_MODE;
		read_start = file_offset;
	}
	for (i = start_block; i < end_block; ++i) {
		if (*bit_word & bit_mask) {  // block already read
			if (mode) {  // switch READ_MODE to SKIP_MODE: read unread blocks up to here
				read_bytes = file_offset - read_start;
				FPS_seek_m12(fps, read_start);
				fread_m12((void *) (fps->parameters.raw_data + read_start), (size_t) 1, (size_t) read_bytes, fps->parameters.fp, fps->full_file_name, function, behavior_on_fail);
				mode = SKIP_MODE;
			}
		} else {  // block not yet read
			if (!mode) {  // switch SKIP_MODE to READ_MODE: mark read start
				read_start = file_offset;
				mode = READ_MODE;
			}
			*bit_word |= bit_mask;  // block will be read, mark now
		}
		file_offset += block_bytes;
		if (!(bit_mask <<= 1)) {
			++bit_word;
			bit_mask = 1;
		}
	}
	
	// final read
	if (*bit_word & bit_mask) {  // block already read
		if (mode)  // READ_MODE
			read_bytes = file_offset - read_start;
		else  // SKIP_MODE
			read_bytes = 0;
	} else {  // block not yet read
		if (mode) {  // READ_MODE
			read_bytes = fps->parameters.flen - read_start;
		} else {  // SKIP_MODE
			read_start = file_offset;
			read_bytes = fps->parameters.flen - file_offset;
		}
		*bit_word |= bit_mask;  // mark block as read
	}
	if (read_bytes) {
		FPS_seek_m12(fps, read_start);
		fread_m12((void *) (fps->parameters.raw_data + read_start), (size_t) 1, (size_t) read_bytes, fps->parameters.fp, fps->full_file_name, function, behavior_on_fail);
	}
	fps->parameters.fpos = read_start + read_bytes;

	return(bytes_to_read);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void FPS_mutex_off_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	PROC_pthread_mutex_unlock_m12(&fps->parameters.mutex);
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void FPS_mutex_on_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	PROC_pthread_mutex_lock_m12(&fps->parameters.mutex);

	return;
}


TERN_m12	FPS_open_m12(FILE_PROCESSING_STRUCT_m12 *fps, const si1 *function, ui4 behavior_on_fail)
{
	TERN_m12	create_file = FALSE_m12, create_path = FALSE_m12;
	si1		*mode, path[FULL_FILE_NAME_BYTES_m12], command[FULL_FILE_NAME_BYTES_m12 + 16];
	static ui4	create_modes = (ui4) (FPS_R_PLUS_OPEN_MODE_m12 | FPS_W_OPEN_MODE_m12 | FPS_W_PLUS_OPEN_MODE_m12 | FPS_A_OPEN_MODE_m12 | FPS_A_PLUS_OPEN_MODE_m12);
	si4		lock_type, err;
#if defined MACOS_m12 || defined LINUX_m12
	struct stat	sb;
#endif
#ifdef WINDOWS_m12
	struct _stat64	sb;
	HANDLE		file_h;
	DISK_GEOMETRY	disk_geom = { 0 };
	ui4		dg_result;
#endif

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	if (fps->directives.open_mode & create_modes)
		create_file = TRUE_m12;
	
	// open
	mode = NULL;
	switch (fps->directives.open_mode) {
		case FPS_R_OPEN_MODE_m12:
			mode = "r";
			break;
		case FPS_R_PLUS_OPEN_MODE_m12:
			mode = "r+";
			break;
		case FPS_W_OPEN_MODE_m12:
			mode = "w";
			break;
		case FPS_W_PLUS_OPEN_MODE_m12:
			mode = "w+";
			break;
		case FPS_A_OPEN_MODE_m12:
			mode = "a";
			break;
		case FPS_A_PLUS_OPEN_MODE_m12:
			mode = "a+";
			break;
		case FPS_NO_OPEN_MODE_m12:
		default:
			G_error_message_m12("%s(): invalid open mode (%u)\n\tcalled from function %s()\n", __FUNCTION__, fps->directives.open_mode, function);
			return(FALSE_m12);
	}
	
	errno_reset_m12();
	fps->parameters.fp = fopen_m12(fps->full_file_name, mode, function, RETURN_ON_FAIL_m12 | SUPPRESS_ERROR_OUTPUT_m12);
	if (fps->parameters.fp == NULL) {
		if (create_file == TRUE_m12) {
			err = errno_m12();
			if (err == ENOENT)
				create_path = TRUE_m12;
#ifdef WINDOWS_m12
			if (err == ERROR_PATH_NOT_FOUND)  // Windows can also return this code for same thing
				create_path = TRUE_m12;
#endif
			if (create_path == TRUE_m12) {
				G_extract_path_parts_m12(fps->full_file_name, path, NULL, NULL);
				if (G_file_exists_m12(path) != DIR_EXISTS_m12) {  // a component of the required directory tree does not exist - build it & try again
					
#if defined MACOS_m12 || defined LINUX_m12
					sprintf_m12(command, "mkdir -p \"%s\"", path);
#endif
#ifdef WINDOWS_m12
					sprintf_m12(command, "mkdir \"%s\"", path);
#endif
					system_m12(command, TRUE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
					fps->parameters.fp = fopen_m12(fps->full_file_name, mode, function, behavior_on_fail);
				}
			}
		}
		if (fps->parameters.fp == NULL) {
			G_error_message_m12("%s(): failed to open file \"%s\"\n\tcalled from function %s()\n", __FUNCTION__, fps->full_file_name, function);
			return(-1);
		}
	}
	
	// file descriptor & file length
#if defined MACOS_m12 || defined LINUX_m12
	fps->parameters.fd = fileno(fps->parameters.fp);
	fstat(fps->parameters.fd, &sb);
#endif
#ifdef WINDOWS_m12
	fps->parameters.fd = _fileno(fps->parameters.fp);
	_fstat64(fps->parameters.fd, &sb);
#endif
	fps->parameters.flen = sb.st_size;
	fps->parameters.fpos = 0;

	// memory mapping
	if (fps->directives.memory_map == TRUE_m12) {
		if (globals_m12->mmap_block_bytes == GLOBALS_MMAP_BLOCK_BYTES_NO_ENTRY_m12) {	// save value as global so don't do this for every mem_map open
#if defined MACOS_m12 || defined LINUX_m12							// (assumes session files all on same file system)
			fps->parameters.mmap_block_bytes = (ui4) sb.st_blksize;
#endif
#ifdef WINDOWS_m12
			if ((file_h = (HANDLE) _get_osfhandle(fps->parameters.fd)) != INVALID_HANDLE_VALUE) {
				dg_result = (ui4) DeviceIoControl(file_h, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &disk_geom, sizeof(DISK_GEOMETRY), &dg_result, (LPOVERLAPPED) NULL);
				if (dg_result == 1)
					fps->parameters.mmap_block_bytes = (ui4) disk_geom.BytesPerSector;
			}
#endif
			if (fps->parameters.mmap_block_bytes <= 0)
				fps->parameters.mmap_block_bytes = GLOBALS_MMAP_BLOCK_BYTES_DEFAULT_m12;
			globals_m12->mmap_block_bytes = fps->parameters.mmap_block_bytes;
			fps->parameters.mmap_number_of_blocks = (ui4) ((fps->parameters.flen + (si8) (fps->parameters.mmap_block_bytes - 1)) / (si8) fps->parameters.mmap_block_bytes);
			fps->parameters.mmap_block_bitmap = (ui8 *) calloc_m12((size_t) ((fps->parameters.mmap_number_of_blocks + 63) / 64), sizeof(ui8), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		} else {
			fps->parameters.mmap_block_bytes = globals_m12->mmap_block_bytes;
		}
	}
	
	// lock
#if defined MACOS_m12 || defined LINUX_m12
	if (fps->directives.lock_mode != FPS_NO_LOCK_MODE_m12) {
		lock_type = FPS_NO_LOCK_TYPE_m12;
		if (fps->directives.open_mode == FPS_R_OPEN_MODE_m12) {
			if (fps->directives.lock_mode & FPS_READ_LOCK_ON_READ_OPEN_m12)
				lock_type = F_RDLCK;
			else if (fps->directives.lock_mode & FPS_WRITE_LOCK_ON_READ_OPEN_m12)
				lock_type = F_WRLCK;
		} else if (fps->directives.lock_mode & (FPS_WRITE_LOCK_ON_WRITE_OPEN_m12 | FPS_WRITE_LOCK_ON_READ_WRITE_OPEN_m12)) {
			lock_type = F_WRLCK;
		} else {
			G_error_message_m12("%s(): incompatible lock (%u) and open (%u) modes\n\tcalled from function %s()\n", __FUNCTION__, fps->directives.lock_mode, fps->directives.open_mode, function);
			return(-1);
		}
		FPS_lock_m12(fps, lock_type, function, behavior_on_fail);
	}
#endif

	fps->parameters.last_access_time = G_current_uutc_m12();
	
	return(TRUE_m12);
}


si8	FPS_read_m12(FILE_PROCESSING_STRUCT_m12 *fps, si8 file_offset, si8 bytes_to_read, const si1 *function, ui4 behavior_on_fail)
{
	void	*data_ptr;
	si8	bytes_read, bytes_remaining;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// mutex on
	FPS_mutex_on_m12(fps);
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	file_offset = REMOVE_DISCONTINUITY_m12(file_offset);

#if defined MACOS_m12 || defined LINUX_m12
	// lock
	if (fps->directives.lock_mode & FPS_READ_LOCK_ON_READ_m12)
		FPS_lock_m12(fps, F_RDLCK, function, behavior_on_fail);
#endif
	// read
	if (file_offset == 0)
		data_ptr = (void *) fps->universal_header;
	else
		data_ptr = (void *) fps->data_pointers;
	
	bytes_remaining = fps->parameters.flen - file_offset;
	if (bytes_to_read > bytes_remaining)
		bytes_to_read = bytes_remaining;
	
	if (fps->directives.memory_map == TRUE_m12) {
		bytes_read = FPS_memory_map_read_m12(fps, file_offset, bytes_to_read, function, behavior_on_fail);
	} else {
		FPS_seek_m12(fps, file_offset);
		bytes_read = fread_m12(data_ptr, sizeof(ui1), (size_t) bytes_to_read, fps->parameters.fp, fps->full_file_name, function, behavior_on_fail);
	}

#if defined MACOS_m12 || defined LINUX_m12
	// unlock
	if (fps->directives.lock_mode & FPS_READ_LOCK_ON_READ_m12)
		FPS_unlock_m12(fps, function, behavior_on_fail);
#endif
	
	// update parameters
	fps->parameters.fpos = file_offset + bytes_read;
	fps->parameters.last_access_time = G_current_uutc_m12();
	
	// mutex on
	FPS_mutex_off_m12(fps);
			
	return(bytes_read);
}


TERN_m12	FPS_reallocate_processing_struct_m12(FILE_PROCESSING_STRUCT_m12 *fps, si8 new_raw_data_bytes)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (new_raw_data_bytes <= fps->parameters.raw_data_bytes)
		return(TRUE_m12);
		
	// reallocate
	fps->parameters.raw_data = (ui1 *) realloc_m12((void *) fps->parameters.raw_data, (size_t) new_raw_data_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

	// zero additional memory (realloc() copies existing memory if necessary, but does not zero additional memory allocated)
	if (new_raw_data_bytes > fps->parameters.raw_data_bytes)
		memset(fps->parameters.raw_data + fps->parameters.raw_data_bytes, 0, new_raw_data_bytes - fps->parameters.raw_data_bytes);
	fps->parameters.raw_data_bytes = new_raw_data_bytes;
		
	// reset fps pointers
	fps->universal_header = (UNIVERSAL_HEADER_m12 *) fps->parameters.raw_data; // all files start with universal header
	fps->data_pointers = fps->parameters.raw_data + UNIVERSAL_HEADER_BYTES_m12;
	if (fps->universal_header->type_code == TIME_SERIES_DATA_FILE_TYPE_CODE_m12 && fps->parameters.cps != NULL) {
		fps->parameters.cps->block_header = (CMP_BLOCK_FIXED_HEADER_m12 *) fps->data_pointers;
		fps->parameters.cps->parameters.allocated_compressed_bytes = new_raw_data_bytes - UNIVERSAL_HEADER_BYTES_m12;
	}
	
	return(TRUE_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	FPS_seek_m12(FILE_PROCESSING_STRUCT_m12 *fps, si8 file_offset)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	file_offset = REMOVE_DISCONTINUITY_m12(file_offset);
	if (fps->parameters.fpos == file_offset)
		return;
	
	fseek_m12(fps->parameters.fp, file_offset, SEEK_SET, fps->full_file_name, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	fps->parameters.fpos = file_offset;
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	FPS_set_pointers_m12(FILE_PROCESSING_STRUCT_m12 *fps, si8 file_offset)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (fps->parameters.full_file_read == TRUE_m12 || fps->directives.memory_map == TRUE_m12)
		fps->data_pointers = fps->parameters.raw_data + REMOVE_DISCONTINUITY_m12(file_offset);
	else
		fps->data_pointers = fps->parameters.raw_data + UNIVERSAL_HEADER_BYTES_m12;  // file_offset irrelevant

	if (fps->parameters.cps != NULL)
		fps->parameters.cps->block_header = (CMP_BLOCK_FIXED_HEADER_m12 *) fps->data_pointers;
	
	return;
}


void	FPS_show_processing_struct_m12(FILE_PROCESSING_STRUCT_m12 *fps)
{
	si1	hex_str[HEX_STRING_BYTES_m12(TYPE_STRLEN_m12)], time_str[TIME_STRING_BYTES_m12], *s;
	si4	i;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	printf_m12("----------- File Processing Structure - START ----------\n");
	UTF8_printf_m12("Full File Name: %s\n", fps->full_file_name);
	printf_m12("Full File Read: ");
	if (fps->parameters.full_file_read == TRUE_m12)
		printf_m12("true\n");
	else if (fps->parameters.full_file_read == FALSE_m12)
		printf_m12("false\n");
	else
		printf_m12("unknown\n");
	if (fps->parameters.last_access_time == UUTC_NO_ENTRY_m12) {
		printf_m12("Last Access Time: no entry\n");
	} else {
		STR_time_string_m12(fps->parameters.last_access_time, time_str, FALSE_m12, FALSE_m12, FALSE_m12);
		printf_m12("Last Access Time: %ld (¬µUTC), %s\n", fps->parameters.last_access_time, time_str);
	}
	if (fps->parameters.fd >= 3)
		printf_m12("File Descriptor: %d (open)\n", fps->parameters.fd);
	else if (fps->parameters.fd == -1)
		printf_m12("File Descriptor: %d (closed)\n", fps->parameters.fd);
	else if (fps->parameters.fd == FPS_FD_NO_ENTRY_m12)
		printf_m12("File Descriptor: %d (not yet opened)\n", fps->parameters.fd);
	else if (fps->parameters.fd == FPS_FD_EPHEMERAL_m12)
		printf_m12("File Descriptor: %d (ephemeral)\n", fps->parameters.fd);
	else    // stdin == 0, stdout == 1, stderr == 2
		printf_m12("File Descriptor: %d (standard stream: invalid)\n", fps->parameters.fd);
	printf_m12("File Length: ");
	if (fps->parameters.flen == FPS_FILE_LENGTH_UNKNOWN_m12)
		printf_m12("unknown\n");
	else
		printf_m12("%ld\n", fps->parameters.flen);
	s = (si1 *) &fps->universal_header->type_code;
	STR_generate_hex_string_m12((ui1 *) s, TYPE_STRLEN_m12, hex_str);
	printf_m12("File Type Code: %s    (", hex_str);
	for (i = 0; i < 4; ++i)
		printf_m12(" %c ", *s++);
	printf_m12(")\n");
	printf_m12("Raw Data Bytes: %ld\n", fps->parameters.raw_data_bytes);
	G_show_universal_header_m12(fps, NULL);
	if (fps->parameters.raw_data_bytes > UNIVERSAL_HEADER_BYTES_m12) {
		switch (fps->universal_header->type_code) {
			case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
			case VIDEO_METADATA_FILE_TYPE_CODE_m12:
				G_show_metadata_m12(fps, NULL, 0);
				break;
			case RECORD_DATA_FILE_TYPE_CODE_m12:
				G_show_records_m12(fps, NULL);
				break;
			default:
				break;
		}
	}
	if (fps->directives.memory_map == TRUE_m12) {
		printf_m12("Memory Mapping:\n");
		printf_m12("\tBlock Size: %u\n", fps->parameters.mmap_block_bytes);
		printf_m12("\tNumber of Blocks: %u\n", fps->parameters.mmap_number_of_blocks);
	}
	printf_m12("------------ File Processing Structure - END -----------\n\n");
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	FPS_sort_m12(FILE_PROCESSING_STRUCT_m12 **fps_array, si4 n_fps)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// input must be 2D FPS array, such as allocated by calloc_2D_m12()
	// sorts the pointers by FPS file start time, does not move the FPSs
	
	qsort((void *) fps_array, (size_t) n_fps, sizeof(FILE_PROCESSING_STRUCT_m12 *), FPS_compare_start_times_m12);

	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	FPS_unlock_m12(FILE_PROCESSING_STRUCT_m12 *fps, const si1 *function, ui4 behavior_on_fail)
{
	si4	err;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#if defined MACOS_m12 || defined LINUX_m12
	struct flock	fl;
	
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	errno_reset_m12();
	
	fl.l_type = F_UNLCK;
	fl.l_whence = SEEK_SET;
	fl.l_start = 0;
	fl.l_len = 0;
	fl.l_pid = getpid();
	if (fcntl(fps->parameters.fd, F_SETLKW, &fl) == -1) {
		err = errno_m12();
		G_error_message_m12("%s(): fcntl() failed to unlock file\n\tsystem error: %s (# %d)\n\tcalled from function %s()\n", __FUNCTION__, strerror(err), err, function);
		return(-1);
	}
#endif
	
	return(0);
}


si8	FPS_write_m12(FILE_PROCESSING_STRUCT_m12 *fps, si8 file_offset, si8 bytes_to_write, const si1 *function, ui4 behavior_on_fail)
{
	void			*data_ptr;
	si8			bytes_written, in_flen;
	UNIVERSAL_HEADER_m12	*uh;
#if defined MACOS_m12 || defined LINUX_m12
	struct stat		sb;
#endif
#ifdef WINDOWS_m12
	struct _stat64		sb;
#endif

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// mutex on
	FPS_mutex_on_m12(fps);
	
	in_flen = fps->parameters.flen;
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	// lock
#if defined MACOS_m12 || defined LINUX_m12
	if (fps->directives.lock_mode & FPS_WRITE_LOCK_ON_WRITE_m12)
		FPS_lock_m12(fps, F_WRLCK, function, behavior_on_fail);
#endif
	
	// write
	if (file_offset == 0)  // Note: this is not the same as update_universal_header directive (below)
		data_ptr = (void *) fps->universal_header;
	else
		data_ptr = (void *) fps->data_pointers;
	if (file_offset == FPS_APPEND_m12)
		file_offset = fps->parameters.flen;
	else
		file_offset = REMOVE_DISCONTINUITY_m12(file_offset);
	
	// update universal header, if requested
	if (fps->directives.update_universal_header == TRUE_m12) {
		uh = fps->universal_header;
		
		// update universal_header->body_CRC
		if (uh->body_CRC == CRC_NO_ENTRY_m12) {  // otherwise this is done with CRC_combine() in other functions
			if (file_offset == 0) {
				if (bytes_to_write > UNIVERSAL_HEADER_BYTES_m12)  // don't calculate if this is UNIVERSAL_HEADER_ONLY write
					uh->body_CRC = CRC_calculate_m12((ui1 *) fps->data_pointers, bytes_to_write - UNIVERSAL_HEADER_BYTES_m12);
			} else {
				uh->body_CRC = CRC_calculate_m12((ui1 *) fps->data_pointers, bytes_to_write);
			}
		}
		// update universal_header->header_CRC
		uh->header_CRC = CRC_calculate_m12((ui1 *) uh + UNIVERSAL_HEADER_HEADER_CRC_START_OFFSET_m12, UNIVERSAL_HEADER_BYTES_m12 - UNIVERSAL_HEADER_HEADER_CRC_START_OFFSET_m12);
		
		// write universal header
		FPS_seek_m12(fps, 0);
		fwrite_m12((void *) uh, sizeof(ui1), (size_t) UNIVERSAL_HEADER_BYTES_m12, fps->parameters.fp, fps->full_file_name, __FUNCTION__, behavior_on_fail);

		// return if all that was requested was universal header update
		if (file_offset == 0 && bytes_to_write == UNIVERSAL_HEADER_BYTES_m12) {
			if (fps->directives.flush_after_write == TRUE_m12)
				fflush(fps->parameters.fp);
			fps->parameters.fpos = UNIVERSAL_HEADER_BYTES_m12;
			fps->parameters.last_access_time = G_current_uutc_m12();
			if (fps->parameters.flen < UNIVERSAL_HEADER_BYTES_m12) {
				fps->parameters.flen = UNIVERSAL_HEADER_BYTES_m12;
				FPS_mutex_off_m12(fps);
				return(UNIVERSAL_HEADER_BYTES_m12);
			}
			FPS_mutex_off_m12(fps);
			return(0);  // return new bytes added to file, zero if overwrite
		}
	}

	FPS_seek_m12(fps, file_offset);
	bytes_written = fwrite_m12((void *) data_ptr, sizeof(ui1), (size_t) bytes_to_write, fps->parameters.fp, fps->full_file_name, __FUNCTION__, behavior_on_fail);
	if (bytes_written != bytes_to_write)
		G_warning_message_m12("%s(): write error\n");
	
	// flush
	if (fps->directives.flush_after_write == TRUE_m12 || fps->directives.update_universal_header == TRUE_m12)
		fflush(fps->parameters.fp);  // fflush() updates stat structure

	// update file length
	#if defined MACOS_m12 || defined LINUX_m12
	fstat(fps->parameters.fd, &sb);
	#endif
	#ifdef WINDOWS_m12
	_fstat64(fps->parameters.fd, &sb);
	#endif
	fps->parameters.flen = (si8) sb.st_size;
		
	// unlock
#if defined MACOS_m12 || defined LINUX_m12
	if (fps->directives.lock_mode & FPS_WRITE_LOCK_ON_WRITE_m12)
		FPS_unlock_m12(fps, function, behavior_on_fail);
#endif
	
	// update parameters
	fps->parameters.fpos = file_offset + bytes_written;
	fps->parameters.last_access_time = G_current_uutc_m12();

	// mutex off
	FPS_mutex_off_m12(fps);
	
	// return increment in file length (not bytes written)
	return(fps->parameters.flen - in_flen);
}



//*******************************//
// MARK: HARDWARE FUNCTIONS  (HW)
//*******************************//

#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	HW_get_core_info_m12()
{
	HW_PARAMS_m12	*hw_params;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	hw_params = &global_tables_m12->HW_params;
	
	if (hw_params->logical_cores)
		return;
	
	PROC_pthread_mutex_lock_m12(&global_tables_m12->HW_mutex);
	if (hw_params->logical_cores) {  // may have been set by another thread while waiting
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
		return;
	}

#ifdef LINUX_m12
	si1	*buf = NULL, *c;;
	si8	buf_len;

	buf_len = system_pipe_m12(&buf, 0, "lscpu", SP_DEFAULT_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	if (buf_len < 0) {
		hw_params->logical_cores = (si4) get_nprocs_conf();
	} else {
		si4	threads_per_core, cores_per_socket, sockets;
		sf8	scaling, min_mhz, max_mhz;
		
		threads_per_core = cores_per_socket = sockets = 0;
		scaling = min_mhz = max_mhz = (sf8) 0.0;
		
		c = STR_match_end_m12("Vendor ID:", buf);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m12(c, "%[^\r\n]s", hw_params->cpu_manufacturer);
		}
		c = STR_match_end_m12("Model name:", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m12(c, "%[^\r\n]s", hw_params->cpu_model);
		}
		c = STR_match_end_m12("Thread(s) per core:", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m12(c, "%d", &threads_per_core);
		}
		c = STR_match_end_m12("Core(s) per socket:", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m12(c, "%d", &cores_per_socket);
		}
		c = STR_match_end_m12("Socket(s):", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m12(c, "%d", &sockets);
		}
		c = STR_match_end_m12("CPU(s) scaling MHz:", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m12(c, "%lf", &scaling);
		}
		c = STR_match_end_m12("CPU max MHz:", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m12(c, "%lf", &max_mhz);
		}
		c = STR_match_end_m12("CPU min MHz:", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m12(c, "%lf", &min_mhz);
		}
		free(buf);
		
		hw_params->physical_cores = sockets * cores_per_socket;
		hw_params->logical_cores = hw_params->physical_cores * threads_per_core;
		if (threads_per_core)
			hw_params->hyperthreading = TRUE_m12;
		else
			hw_params->hyperthreading = FALSE_m12;
		
		hw_params->minimum_speed = min_mhz / (sf8) 1000.0;
		hw_params->maximum_speed = max_mhz / (sf8) 1000.0;
		hw_params->current_speed = hw_params->maximum_speed * (scaling / (sf8) 100.0);
	}
#endif  // LINUX_m12
	
#ifdef MACOS_m12
	size_t	len;
	si1	brand_string[128], *c;
	si8	max_speed;
	
	len = sizeof(si4);
	
	sysctlbyname("machdep.cpu.core_count", &hw_params->physical_cores, &len, NULL, 0);
	sysctlbyname("machdep.cpu.thread_count", &hw_params->logical_cores, &len, NULL, 0);
	if (hw_params->physical_cores < hw_params->logical_cores)
		hw_params->hyperthreading = TRUE_m12;
	else
		hw_params->hyperthreading = FALSE_m12;
	len = 128;
	sysctlbyname("machdep.cpu.brand_string", brand_string, &len, NULL, 0);
	c = STR_match_end_m12("(TM)", brand_string);
	if (c == NULL) {
		strncpy_m12(hw_params->cpu_manufacturer, brand_string, 64);
	} else {
		*c = 0;
		strcpy_m12(hw_params->cpu_manufacturer, brand_string);
		*c = ' ';
		while (*c == ' ')
			++c;
		strcpy_m12(hw_params->cpu_model, c);
	}
	len = sizeof(si8);
	sysctlbyname("hw.cpufrequency", &max_speed, &len, NULL, 0);
	hw_params->maximum_speed = (sf8) max_speed / (sf8) 1000000000.0;
#endif  // MACOS_m12
	
#ifdef WINDOWS_m12
	SYSTEM_INFO	sys_info;
	
	GetSystemInfo(&sys_info);  // returns logical cores
	hw_params->logical_cores = (si4) sys_info.dwNumberOfProcessors;
	hw_params->physical_cores = 0;  // unknown
	hw_params->hyperthreading = UNKNOWN_m12;
	
	switch((si4) sys_info.wProcessorArchitecture) {
		case PROCESSOR_ARCHITECTURE_AMD64:
			strcpy(hw_params->cpu_manufacturer, "Intel or AMD");
			strcpy(hw_params->cpu_model, "x64");
			break;
		case PROCESSOR_ARCHITECTURE_ARM:
			strcpy(hw_params->cpu_manufacturer, "ARM");
			*hw_params->cpu_model = 0;
			break;
		case PROCESSOR_ARCHITECTURE_ARM64:
			strcpy(hw_params->cpu_manufacturer, "ARM");
			strcpy(hw_params->cpu_model, "x64");
			break;
		case PROCESSOR_ARCHITECTURE_IA64:
			strcpy(hw_params->cpu_manufacturer, "Intel");
			strcpy(hw_params->cpu_model, "Itanium x64");
			break;
		case PROCESSOR_ARCHITECTURE_INTEL:
			strcpy(hw_params->cpu_manufacturer, "Intel");
			strcpy(hw_params->cpu_model, "x86");
			break;
		case PROCESSOR_ARCHITECTURE_UNKNOWN:
		default:
			break;
	}
#endif  // WINDOWS_m12

	PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);

	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	HW_get_endianness_m12(void)
{
	ui1		endianness;
	ui2		x;
	HW_PARAMS_m12	*hw_params;


#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	hw_params = &global_tables_m12->HW_params;
	if (hw_params->endianness == LITTLE_ENDIAN_m12)
		return;

	PROC_pthread_mutex_lock_m12(&global_tables_m12->HW_mutex);
	if (hw_params->endianness == LITTLE_ENDIAN_m12) {  // may have been set by another thread while waiting
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
		return;
	}

	x = 1;
	endianness = *((ui1 *) &x);

	hw_params->endianness = endianness;

	PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);

	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	HW_get_machine_code_m12(void)
{
	HW_PARAMS_m12	*hw_params;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	hw_params = &global_tables_m12->HW_params;
	if (hw_params->machine_code)
		return;

	// get machine serial number
	if (*hw_params->serial_number == 0)
		HW_get_machine_serial_m12();

	PROC_pthread_mutex_lock_m12(&global_tables_m12->HW_mutex);
	if (hw_params->machine_code) {  // may have been set by another thread while waiting
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
		return;
	}

	// get CRC of machine serial number
	hw_params->machine_code = CRC_calculate_m12((ui1 *) hw_params->serial_number, strlen(hw_params->serial_number));
	
	PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);

	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	HW_get_machine_serial_m12(void)
{
	HW_PARAMS_m12	*hw_params;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	hw_params = &global_tables_m12->HW_params;
	if (*hw_params->serial_number)
		return;

	PROC_pthread_mutex_lock_m12(&global_tables_m12->HW_mutex);
	if (*hw_params->serial_number) {  // may have been set by another thread while waiting
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
		return;
	}
	
	// get machine serial number
#ifdef LINUX_m12
	// Linux makes it impossible to get product serial from within program, even with sudo password. Use default interface MAC.
	if (*global_tables_m12->NET_params.MAC_address_string == 0)
		NET_get_mac_address_m12(NULL, &global_tables_m12->NET_params);
	strcpy(hw_params->serial_number, global_tables_m12->NET_params.MAC_address_string);
	STR_strip_character_m12(hw_params->serial_number, ':');
	PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
	return;
#endif
#if defined MACOS_m12 || defined WINDOWS_m12
	si1		*command, *buf, *machine_sn;
	si8		buf_len;

	#ifdef MACOS_m12
	// out example: "IOPlatformSerialNumber" = "C02XK4D2JGH6"  // quotes are part of output
	command = "ioreg -l | grep IOPlatformSerialNumber";
	#endif
	
	#ifdef WINDOWS_m12
	// out example: SerialNumber\nC02RP18FG8WM
	command = "wmic bios get serialnumber";
	#endif
	
	buf = NULL;
	buf_len = system_pipe_m12(&buf, 0, command, SP_DEFAULT_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	if (buf_len < 0)
		return;
	
#ifdef MACOS_m12
	machine_sn = STR_match_end_m12("IOPlatformSerialNumber\" = \"", buf);
	buf[buf_len - 3] = 0;  // <quote><lf>
#endif
	
#ifdef WINDOWS_m12
	buf[buf_len - 7] = buf[buf_len - 8] = 0;  // <cr><lf>
	STR_wchar2char_m12(buf, (wchar_t *) buf);
	machine_sn = STR_match_end_m12("SerialNumber  \r\n", buf);
#endif

	// copy machine serial number
	if (machine_sn != NULL)
		strcpy(hw_params->serial_number, machine_sn);

	free(buf);
	
	PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);

	return;
#endif
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	HW_get_memory_info_m12(void)
{
	si8		pages, page_size;
	HW_PARAMS_m12	*hw_params;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// gets system memory & page size in bytes

	hw_params = &global_tables_m12->HW_params;
	if (hw_params->system_memory_size)
		return;

	PROC_pthread_mutex_lock_m12(&global_tables_m12->HW_mutex);
	if (hw_params->system_memory_size) {  // may have been set by another thread while waiting
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
		return;
	}

#if defined MACOS_m12 || defined LINUX_m12
	pages = sysconf(_SC_PHYS_PAGES);
	page_size = sysconf(_SC_PAGE_SIZE);
	
	if (pages == -1 || page_size == -1) {
		fprintf_m12(stderr, "%s(): sysconf() error\n", __FUNCTION__);
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
		return;
	}

	hw_params->system_memory_size = (ui8) (pages * page_size);
	hw_params->system_page_size = (ui4) page_size;
#endif
	
#ifdef WINDOWS_m12
	MEMORYSTATUSEX	status;
	SYSTEM_INFO 	system_info;
	
	status.dwLength = sizeof(status);
	if (GlobalMemoryStatusEx(&status) == 0) {
		fprintf_m12(stderr, "%s(): GlobalMemoryStatusEx() error\n", __FUNCTION__);
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
		return;
	}
	hw_params->system_memory_size = (ui8) status.ullTotalPhys;
	
	GetNativeSystemInfo(&system_info);
	hw_params->system_page_size = (ui4) system_info.dwPageSize;
#endif
	
	hw_params->heap_base_address = (ui8) globals_list_m12;  // first thing allocated by initialize_medlib_m12()
	hw_params->heap_max_address = (hw_params->heap_base_address + hw_params->system_memory_size) - 1;
	// in all 64-bit OSs tested, stack addresses are > heap_max_address (even for child processes)
	
	PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
	
	return;
}


void	HW_get_performance_specs_m12(TERN_m12 get_current)
{
	si8				ROUNDS;
	clock_t				start_t, end_t, elapsed_time;
	si1				file[FULL_FILE_NAME_BYTES_m12];
	ui8				*p1, *p2, *p3;
	ui8				*test_arr1, *test_arr2, *test_arr3;
	si8				i;
	sf8				temp_sf8;
	FILE				*fp;
	HW_PARAMS_m12			*hw_params;
	HW_PERFORMANCE_SPECS_m12	*perf_specs;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	hw_params = &global_tables_m12->HW_params;
	perf_specs = &hw_params->performance_specs;

	if (perf_specs->integer_multiplications_per_sec != 0.0 && get_current != TRUE_m12)
		return;
		
	// see if they've been written out previously
	if (get_current != TRUE_m12)
		if (HW_get_performance_specs_from_file_m12() == TRUE_m12)
			return;
	
	PROC_pthread_mutex_lock_m12(&global_tables_m12->HW_mutex);
	// may have been done by another thread while waiting
	if (perf_specs->integer_multiplications_per_sec != 0.0)  {
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
		return;
	}
	
	// setup
	if (get_current == TRUE_m12)
		ROUNDS = 100000;  // 1e5
	else
		ROUNDS = 100000000;  // 1e8
	
	test_arr1 = (ui8 *) calloc((size_t) ROUNDS, sizeof(ui8));
	test_arr2 = (ui8 *) calloc((size_t) ROUNDS, sizeof(ui8));
	test_arr3 = (ui8 *) malloc((size_t) ROUNDS << 3);
	mlock_m12((void *) test_arr1, (size_t) (ROUNDS * sizeof(sf8)), FALSE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	mlock_m12((void *) test_arr2, (size_t) (ROUNDS * sizeof(sf8)), FALSE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	mlock_m12((void *) test_arr3, (size_t) (ROUNDS * sizeof(sf8)), FALSE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

	p1 = test_arr1;
	p2 = test_arr2;
	for (i = ROUNDS; i--; ++p1, ++p2) {
#if defined MACOS_m12 || defined LINUX_m12
		*p1 = ((ui8) random()) << 16;
		*p1 ^= (ui8) random();  // 48 bit number
		*p2 = ((ui8) random() >> 16) + 1;  // 16 bit non-zero number
#endif
#ifdef WINDOWS_m12
		*p1 = ((ui8) rand()) << 16;
		*p1 ^= (ui8) rand();  // 48 bit number
		*p2 = ((ui8) rand() >> 16) + 1;  // 16 bit non-zero number
#endif
	}

	// multiplication
	p1 = test_arr1;
	p2 = test_arr2;
	p3 = test_arr3;
	start_t = clock();
	for (i = ROUNDS; i--;)
		*p3++ = *p1++ * *p2++;
	end_t = clock();
	elapsed_time = end_t - start_t;
	temp_sf8 = (sf8) (CLOCKS_PER_SEC * ROUNDS) / (sf8) elapsed_time;
	perf_specs->integer_multiplications_per_sec = (si8) (temp_sf8 + (sf8) 0.5);
	perf_specs->nsecs_per_integer_multiplication = (sf8) 1e9 / temp_sf8;

	// division
	p1 = test_arr1;
	p2 = test_arr2;
	p3 = test_arr3;
	start_t = clock();
	for (i = ROUNDS; i--;)
		*p3++ = *p1++ / *p2++;
	end_t = clock();
	elapsed_time = end_t - start_t;
	temp_sf8 = (sf8) (CLOCKS_PER_SEC * ROUNDS) / (sf8) elapsed_time;
	perf_specs->integer_divisions_per_sec = (si8) (temp_sf8 + (sf8) 0.5);
	perf_specs->nsecs_per_integer_division = (sf8) 1e9 / temp_sf8;

	// clean up
	munlock_m12((void *) test_arr1, (size_t) (ROUNDS * sizeof(sf8)), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	munlock_m12((void *) test_arr2, (size_t) (ROUNDS * sizeof(sf8)), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	munlock_m12((void *) test_arr3, (size_t) (ROUNDS * sizeof(sf8)), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	free((void *) test_arr1);
	free((void *) test_arr2);
	free((void *) test_arr3);
	
	PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
	
	// write out (for future use)
	if (get_current != TRUE_m12) {
		if (HW_get_performance_specs_file_m12(file) == NULL)
			return;
		fp = fopen_m12(file, "w", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		fprintf_m12(fp, "machine code: 0x%08x\n", hw_params->machine_code);
		fprintf_m12(fp, "integer multiplications per sec: %ld\n", (si8) round(perf_specs->integer_multiplications_per_sec));
		fprintf_m12(fp, "integer divisions per sec: %ld\n", (si8) round(perf_specs->integer_divisions_per_sec));
		fprintf_m12(fp, "nsecs per integer multiplication: %0.6lf\n", perf_specs->nsecs_per_integer_multiplication);
		fprintf_m12(fp, "nsecs per integer division: %0.6lf\n", perf_specs->nsecs_per_integer_division);
		fclose(fp);
	}
	
	return;
}


si1	*HW_get_performance_specs_file_m12(si1 *file)
{
	TERN_m12	free_file;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	free_file = FALSE_m12;
	if (file == NULL) {  // caller responsible for freeing
		file = (si1 *) malloc_m12((size_t) FULL_FILE_NAME_BYTES_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free_file = TRUE_m12;
	}
	
#if defined MACOS_m12 || defined LINUX_m12
	si1		*env_var;

	env_var = getenv("HOME");
	if (env_var == NULL) {
		G_warning_message_m12("%s(): \"HOME\" is not defined in the environment\n", __FUNCTION__);
		if (free_file == TRUE_m12)
			free_m12((void *) file, __FUNCTION__);
		return(NULL);
	}
	sprintf_m12(file, "%s/.hw_performance_specs", env_var);
#endif
#ifdef WINDOWS_m12
	si1	*home_drive, *home_path;
	
	home_drive = getenv("HOMEDRIVE");
	home_path = getenv("HOMEPATH");
	if (home_path == NULL || home_drive == NULL) {
		G_warning_message_m12("%s(): either \"HOMEDRIVE\" or \"HOMEPATH\" is not defined in the environment\n", __FUNCTION__);
		if (free_file == TRUE_m12)
			free_m12((void *) file, __FUNCTION__);
		return(NULL);
	}
	sprintf_m12(file, "%s%s/.hw_performance_specs", home_drive, home_path);
#endif

	return(file);
}


TERN_m12	HW_get_performance_specs_from_file_m12(void)
{
	si1				file[FULL_FILE_NAME_BYTES_m12], *buffer, *c;
	ui4				file_machine_code;
	si8				flen, items;
	FILE				*fp;
	HW_PARAMS_m12			*hw_params;
	HW_PERFORMANCE_SPECS_m12	*perf_specs;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (HW_get_performance_specs_file_m12(file) == NULL)
		return(FALSE_m12);
		
	if (G_file_exists_m12(file) == DOES_NOT_EXIST_m12)
		return(FALSE_m12);
	
	hw_params = &global_tables_m12->HW_params;
	if (hw_params->machine_code == 0)
		HW_get_machine_code_m12();
	perf_specs = &hw_params->performance_specs;

	// get mutex
	PROC_pthread_mutex_lock_m12(&global_tables_m12->HW_mutex);  // delay getting mutex until machine code known
	if (perf_specs->integer_multiplications_per_sec != 0.0) {  // may have been done by another thread while waiting
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
		return(TRUE_m12);
	}

	// read in file
	fp = fopen_m12(file, "r", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	flen = G_file_length_m12(fp, NULL);
	buffer = (si1 *) malloc((size_t) (flen + 1));
	fread_m12((void *) buffer, sizeof(si1), (size_t) flen, fp, file, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	fclose(fp);
	buffer[flen] = 0;
	
	// parse file
	c = buffer;
	c = STR_match_end_m12("machine code: ", c);
	if (c == NULL)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m12;
	items = sscanf_m12(c, "%x", &file_machine_code);
	if (file_machine_code != hw_params->machine_code || items == 0)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m12;

	c = STR_match_end_m12("integer multiplications per sec: ", c);
	if (c == NULL)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m12;
	items = sscanf_m12(c, "%ld", &perf_specs->integer_multiplications_per_sec);
	if (items == 0)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m12;

	c = STR_match_end_m12("integer divisions per sec: ", c);
	if (c == NULL)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m12;
	items = sscanf_m12(c, "%ld", &perf_specs->integer_divisions_per_sec);
	if (items == 0)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m12;

	c = STR_match_end_m12("nsecs per integer multiplication: ", c);
	if (c == NULL)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m12;
	items = sscanf_m12(c, "%lf", &perf_specs->nsecs_per_integer_multiplication);
	if (items == 0)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m12;

	c = STR_match_end_m12("nsecs per integer division: ", c);
	if (c == NULL)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m12;
	items = sscanf_m12(c, "%lf", &perf_specs->nsecs_per_integer_division);
	if (items == 0)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m12;

	PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
	free((void *) buffer);
	
	return(TRUE_m12);

HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m12:
	
	PROC_pthread_mutex_unlock_m12(&global_tables_m12->HW_mutex);
	free((void *) buffer);
	return(FALSE_m12);
}



TERN_m12	HW_initialize_tables_m12(void)
{
	HW_PARAMS_m12	*hw_params;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// fill all unfilled fields in HW table
	
	hw_params = &global_tables_m12->HW_params;

	if (hw_params->endianness != LITTLE_ENDIAN_m12)
		HW_get_endianness_m12();

	if (hw_params->system_memory_size == 0)  // do this before anything is allocated
		HW_get_memory_info_m12();

	if (hw_params->logical_cores == 0)
		HW_get_core_info_m12();

	if (*hw_params->serial_number == 0)  // do this before getting machine code
		HW_get_machine_serial_m12();

	if (hw_params->machine_code == 0)  // do this before getting performance specs
		HW_get_machine_code_m12();

	if (hw_params->performance_specs.integer_multiplications_per_sec == 0)
		HW_get_performance_specs_m12(FALSE_m12);
	
	return(TRUE_m12);
}


void	HW_show_info_m12(void)
{
	si1		size_str[SIZE_STRING_BYTES_m12];
	HW_PARAMS_m12	*hw_params;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	hw_params = &global_tables_m12->HW_params;

	printf_m12("endianness = ");
	switch (hw_params->endianness) {
		case BIG_ENDIAN_m12:
			printf_m12("big endian\n");
			break;
		case LITTLE_ENDIAN_m12:
			printf_m12("little endian\n");
			break;
		default:
			printf_m12("invalid value (%hhu)\n", hw_params->endianness);
			break;
	}
	
	if (hw_params->logical_cores == 0)
		printf_m12("logical_cores = unknown\n");
	else
		printf_m12("logical_cores = %d\n", hw_params->logical_cores);

	if (hw_params->physical_cores == 0)
		printf_m12("physical_cores = unknown\n");
	else
		printf_m12("physical_cores = %d\n", hw_params->physical_cores);
	
	printf_m12("hyperthreading = ");
	switch (hw_params->hyperthreading) {
		case FALSE_m12:
			printf_m12("false\n");
			break;
		case TRUE_m12:
			printf_m12("true\n");
			break;
		case UNKNOWN_m12:
			printf_m12("unknown\n");
			break;
		default:
			printf_m12("invalid value (%hhd)\n", hw_params->hyperthreading);
			break;
	}
	
	if (hw_params->minimum_speed == 0.0)
		printf_m12("minimum_speed = unknown\n");
	else
		printf_m12("minimum_speed = %lf GHz\n", hw_params->minimum_speed);
	
	if (hw_params->maximum_speed == 0.0)
		printf_m12("maximum_speed = unknown\n");
	else
		printf_m12("maximum_speed = %lf GHz\n", hw_params->maximum_speed);
	
	if (hw_params->current_speed == 0.0)
		printf_m12("current_speed = unknown\n");
	else
		printf_m12("current_speed = %lf GHz  (average across logical cores)\n", hw_params->current_speed);
	
	if (hw_params->performance_specs.integer_multiplications_per_sec == 0.0)
		printf_m12("integer_multiplications_per_sec = unknown\n");
	else
		printf_m12("integer_multiplications_per_sec = %ld\n", (si8) hw_params->performance_specs.integer_multiplications_per_sec);
	if (hw_params->performance_specs.nsecs_per_integer_multiplication == 0.0)
		printf_m12("nsecs_per_integer_multiplication = unknown\n");
	else
		printf_m12("nsecs_per_integer_multiplication = %lf\n", hw_params->performance_specs.nsecs_per_integer_multiplication);
	if (hw_params->performance_specs.integer_divisions_per_sec == 0.0)
		printf_m12("integer_divisions_per_sec = unknown\n");
	else
		printf_m12("integer_divisions_per_sec = %ld\n", (si8) hw_params->performance_specs.integer_divisions_per_sec);
	if (hw_params->performance_specs.nsecs_per_integer_division == 0.0)
		printf_m12("nsecs_per_integer_division = unknown\n");
	else
		printf_m12("nsecs_per_integer_division = %lf\n", hw_params->performance_specs.nsecs_per_integer_division);

	if (hw_params->system_memory_size == 0) {
		printf_m12("system_memory_size = unknown\n");
	} else {
		STR_size_string_m12(size_str, hw_params->system_memory_size, TRUE_m12);
		printf_m12("system_memory_size = %s\n", size_str);
	}
	
	if (hw_params->system_page_size == 0) {
		printf_m12("system_page_size = unknown\n");
	} else {
		STR_size_string_m12(size_str, hw_params->system_page_size, TRUE_m12);
		printf_m12("system_page_size = %s\n", size_str);
	}
	
	if (hw_params->heap_base_address == 0)
		printf_m12("heap_base_address = unknown\n");
	else
		printf_m12("heap_base_address = %lu\n", hw_params->heap_base_address);
	
	if (hw_params->heap_max_address == 0)
		printf_m12("heap_max_address = unknown\n");
	else
		printf_m12("heap_max_address = %lu\n", hw_params->heap_max_address);
	
	if (*hw_params->cpu_manufacturer == 0)
		printf_m12("cpu_manufacturer = unknown\n");
	else
		printf_m12("cpu_manufacturer = \"%s\"\n", hw_params->cpu_manufacturer);
	
	if (*hw_params->cpu_model == 0)
		printf_m12("cpu_model = unknown\n");
	else
		printf_m12("cpu_model = \"%s\"\n", hw_params->cpu_model);
	
	if (*hw_params->serial_number == 0)
		printf_m12("serial_number = unknown\n");
	else
		printf_m12("serial_number = %s\n", hw_params->serial_number);
	
	if (hw_params->machine_code == 0)
		printf_m12("machine_code = unknown\n");
	else
		printf_m12("machine_code = 0x%08x\n", hw_params->machine_code);

	return;
}



//*******************************//
// MARK: NETWORK FUNCTIONS  (NET)
//*******************************//

TERN_m12	NET_check_internet_connection_m12(void)
{
	NET_PARAMS_m12	*np;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// if want to know if machine can reach internet, check == TRUE_m12
	// if want to know if network connected locally check != FALSE_m12

	np = &global_tables_m12->NET_params;
	
	PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
	*np->interface_name = 0;
	PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	G_push_behavior_m12(SUPPRESS_OUTPUT_m12);
	np = NET_get_default_interface_m12(np);
	G_pop_behavior_m12();
	if (np == NULL)
		return(FALSE_m12);
	
	// LAN can be up but WAN still down, so check wan IP
	PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
	*np->WAN_IPv4_address_string = 0;
	PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	G_push_behavior_m12(SUPPRESS_OUTPUT_m12);
	np = NET_get_wan_ipv4_address_m12(np);
	G_pop_behavior_m12();
	if (np == NULL)
		return(UNKNOWN_m12);  // UNKNOWN == LAN up, WAN down

	return(TRUE_m12);  // TRUE == LAN + WAN up (if machine has static ip, WAN == LAN)
}


TERN_m12	NET_domain_to_ip_m12(si1 *domain_name, si1 *ip)
{
	si4			rv;
	struct addrinfo		hints, *servinfo;
	struct sockaddr_in	*h;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	memset(&hints, 0, sizeof(struct addrinfo));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;

	if ((rv = getaddrinfo(domain_name, NULL, &hints , &servinfo)) != 0) {
		G_error_message_m12("%s(): getaddrinfo: %s (%d)\n", __FUNCTION__, gai_strerror(rv), rv);
		return(FALSE_m12);
	}
	
	// just use the first addrinfo
	if ((h = (struct sockaddr_in *) servinfo->ai_addr) == NULL) {
		*ip = 0;
		freeaddrinfo(servinfo);
		return(FALSE_m12);
	}

	strcpy(ip, inet_ntoa(h->sin_addr));
	freeaddrinfo(servinfo);  // done with this structure
	
	return(TRUE_m12);
}


NET_PARAMS_m12	*NET_get_active_m12(si1 *iface, NET_PARAMS_m12 *np)
{
	TERN_m12	copy_global, free_np;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	copy_global = NET_resolve_arguments_m12(iface, &np, &free_np);

	if (copy_global == TRUE_m12) {
		if (global_tables_m12->NET_params.active != UNKNOWN_m12)
			np->active = global_tables_m12->NET_params.active;
	}
	if (np->active != UNKNOWN_m12)
		return(np);
	
#if defined MACOS_m12 || defined LINUX_m12
	if (NET_get_config_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
#endif
#ifdef WINDOWS_m12
	if (NET_get_adapter_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
#endif
	
	return(np);
}


TERN_m12	NET_get_adapter_m12(NET_PARAMS_m12 *np, TERN_m12 copy_global)
{
#ifndef WINDOWS_m12
	return(UNKNOWN_m12);
#else
	TERN_m12		global_np;
	si1             	temp_str[256], *buffer, *iface_start, *c, *c2, *pattern;
	si4             	i, ret_val, attempts;
	DWORD 			dwSize, dwRetVal;
	ULONG			flags, family, outBufLen;
	LPVOID 			lpMsgBuf;
	PIP_ADAPTER_ADDRESSES	pAddresses, pCurrAddress;

	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// (get all info present in same buffers regardless of which was requested)
	//
	// called for mtu, duplex, link_speed, & active status in Windows

	global_np = FALSE_m12;
	if (copy_global == FALSE_m12)
		if (np == &global_tables_m12->NET_params)
			global_np = TRUE_m12;

	if (global_np == TRUE_m12) {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		if (*np->link_speed)  {  // may have been done by another thread while waiting
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
			return(TRUE_m12);
		}
	}
		
	// need MAC address
	if (NET_get_mac_address_m12(NULL, np) == NULL) {
		G_warning_message_m12("%s(): cannot get MAC address\n", __FUNCTION__);
		if (global_np == TRUE_m12)
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
		return(FALSE_m12);
	}

	// read GetAdapterAddresses() output
	flags = 0;
	family = AF_INET;  //IPv4
	lpMsgBuf = NULL;
	dwSize = 0;
	dwRetVal = 0;
	pAddresses = NULL;
	outBufLen = 0;
	pCurrAddress = NULL;
	outBufLen = 16384;

	attempts = 0; do {
		pAddresses = (IP_ADAPTER_ADDRESSES *) malloc_m12(outBufLen, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		dwRetVal = GetAdaptersAddresses(family, flags, NULL, pAddresses, &outBufLen);
		if (dwRetVal == ERROR_BUFFER_OVERFLOW) {
			free((void *) pAddresses);
			pAddresses = NULL;
		} else {
			break;
		}
		++attempts;
	} while ((dwRetVal == ERROR_BUFFER_OVERFLOW) && (attempts < 3));
	
	if (dwRetVal == NO_ERROR) {
		pCurrAddress = pAddresses;
		while (pCurrAddress != NULL) {
			// match MAC address to interface
			if (pCurrAddress->PhysicalAddressLength != 0) {
				for (i = 0; i < pCurrAddress->PhysicalAddressLength; ++i)
					if (pCurrAddress->PhysicalAddress[i] != np->MAC_address_bytes[i])
						break;
				if (i != pCurrAddress->PhysicalAddressLength) {
					pCurrAddress = pCurrAddress->Next;
					continue;
				}
			}
			np->MTU = (si4) pCurrAddress->Mtu;
			if (pCurrAddress->Flags & IP_ADAPTER_RECEIVE_ONLY)
				strcpy_m12(np->duplex, "false");
			else
				strcpy_m12(np->duplex, "true");
			if (pCurrAddress->ReceiveLinkSpeed >= 1000000000)
				sprintf_m12(np->link_speed, "1 Gbps");
			else if (pCurrAddress->ReceiveLinkSpeed >= 100000000)
				sprintf_m12(np->link_speed, "100 Mbps");
			else if (pCurrAddress->ReceiveLinkSpeed >= 10000000)
				sprintf_m12(np->link_speed, "10 Mbps");
			else
				strcpy(np->link_speed, "unknown");
			if (pCurrAddress->OperStatus == 1)
				np->active = TRUE_m12;
			else if
				(pCurrAddress->OperStatus == 2)
				np->active = TRUE_m12;
			else
				np->active = UNKNOWN_m12;
			break;  // found correct entry - exit loop
		}
	}

	// clean up
	if (pAddresses != NULL)
		free((void *) pAddresses);

	// called for mtu, duplex, link_speed, & active status in Windows
	if (copy_global == TRUE_m12) {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		global_tables_m12->NET_params.MTU = np->MTU;
		global_tables_m12->NET_params.active = np->active;
		strcpy(global_tables_m12->NET_params.link_speed, np->link_speed);
		strcpy(global_tables_m12->NET_params.duplex, np->duplex);
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	} else if (global_np == TRUE_m12) {
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	}

	return(TRUE_m12);
#endif
}


#ifdef LINUX_m12
TERN_m12	NET_get_config_m12(NET_PARAMS_m12 *np, TERN_m12 copy_global)
{
	TERN_m12	global_np;
	si1		temp_str[256], *buffer, *c, *pattern;
	si4		ret_val;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// (get all info present in same buffers regardless of which was requested)
	//
	// called for mtu, MAC_address, LAN_IPv4, plugged_in, & active in Linux

	global_np = FALSE_m12;
	if (copy_global == FALSE_m12)
		if (np == &global_tables_m12->NET_params)
			global_np = TRUE_m12;

	if (global_np == TRUE_m12) {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		if (*np->MAC_address_string)  {  // may have been done by another thread while waiting
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
			return(TRUE_m12);
		}
	}
	
	// get ifconfig() output
	sprintf_m12(temp_str, "/usr/sbin/ifconfig %s", np->interface_name);
	buffer = NULL;
	ret_val = system_pipe_m12(&buffer, 0, temp_str, SP_DEFAULT_m12, __FUNCTION__,  USE_GLOBAL_BEHAVIOR_m12);
	if (ret_val < 0) {
		if (global_np == TRUE_m12)
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
		return(FALSE_m12);
	}

	// mtu
	pattern = "mtu ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL) {
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->MTU = 0;
	} else {
		sscanf(c, "%d", &np->MTU);
	}
	
	// MAC address
	pattern = "ether ";
	np->MAC_address_num = 0;
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL) {
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		strcpy(np->MAC_address_string, "unknown");
	} else {
		sscanf(c, "%s", np->MAC_address_string);
		STR_to_upper_m12(np->MAC_address_string);
		sscanf(np->MAC_address_string, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", np->MAC_address_bytes, np->MAC_address_bytes + 1, np->MAC_address_bytes + 2, np->MAC_address_bytes + 3, np->MAC_address_bytes + 4, np->MAC_address_bytes + 5);  // network byte order
	}

	// LAN_IPv4
	if (*np->LAN_IPv4_address_string == 0) {
		pattern = "inet ";
		if ((c = STR_match_end_m12(pattern, buffer)) == NULL) {
			G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
			np->LAN_IPv4_address_num = 0;
			strcpy(np->LAN_IPv4_address_string, "unknown");
		} else {
			sscanf(c, "%s", np->LAN_IPv4_address_string);
			sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_address_bytes, np->LAN_IPv4_address_bytes + 1, np->LAN_IPv4_address_bytes + 2, np->LAN_IPv4_address_bytes + 3);  // network byte order
		}
	}

	pattern = "netmask ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL) {
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->LAN_IPv4_subnet_mask_num = 0;
		strcpy(np->LAN_IPv4_subnet_mask_string, "unknown");
	} else {
		sscanf(c, "%s", np->LAN_IPv4_subnet_mask_string);
		sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_subnet_mask_bytes, np->LAN_IPv4_subnet_mask_bytes + 1, np->LAN_IPv4_subnet_mask_bytes + 2, np->LAN_IPv4_subnet_mask_bytes + 3);
	}

	// status
	pattern = "UP";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL)
		np->active = FALSE_m12;
	else
		np->active = TRUE_m12;
 
	pattern = "RUNNING";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL)
		np->plugged_in = FALSE_m12;
	else
		np->plugged_in = TRUE_m12;

	// clean up
	free(buffer);

	if (copy_global == TRUE_m12) {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		global_tables_m12->NET_params.MTU = np->MTU;
		strcpy(global_tables_m12->NET_params.MAC_address_string, np->MAC_address_string);
		global_tables_m12->NET_params.MAC_address_num = np->MAC_address_num;
		strcpy(global_tables_m12->NET_params.LAN_IPv4_address_string, np->LAN_IPv4_address_string);
		global_tables_m12->NET_params.LAN_IPv4_address_num = np->LAN_IPv4_address_num;
		strcpy(global_tables_m12->NET_params.LAN_IPv4_subnet_mask_string, np->LAN_IPv4_subnet_mask_string);
		global_tables_m12->NET_params.LAN_IPv4_subnet_mask_num = np->LAN_IPv4_subnet_mask_num;
		global_tables_m12->NET_params.plugged_in = np->plugged_in;
		global_tables_m12->NET_params.active = np->active;
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	} else if (global_np == TRUE_m12) {
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	}

	return(TRUE_m12);
}
#endif  // LINUX_m12


#ifdef MACOS_m12
TERN_m12	NET_get_config_m12(NET_PARAMS_m12 *np, TERN_m12 copy_global)
{
	TERN_m12	global_np;
	si1		temp_str[256], *buffer, *c, *pattern;
	si4		ret_val;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// (get all info present in same buffer regardless of which was requested)
	//
	// called for mtu, MAC_address, LAN_IPv4, plugged_in, active, link_speed, & duplex fields in MacOS

	global_np = FALSE_m12;
	if (copy_global == FALSE_m12)
		if (np == &global_tables_m12->NET_params)
			global_np = TRUE_m12;

	if (global_np == TRUE_m12) {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		if (*np->MAC_address_string)  {  // may have been done by another thread while waiting
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
			return(TRUE_m12);
		}
	}
	
	// get ifconfig() output
	sprintf_m12(temp_str, "/sbin/ifconfig %s", np->interface_name);
	buffer = NULL;
	ret_val = system_pipe_m12(&buffer, 0, temp_str, SP_DEFAULT_m12, __FUNCTION__,  USE_GLOBAL_BEHAVIOR_m12);
	if (ret_val < 0) {
		if (global_np == TRUE_m12)
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
		return(FALSE_m12);
	}

	// parse ifconfig() output
	pattern = "mtu ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL) {
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->MTU = 0;
	} else {
		sscanf(c, "%d", &np->MTU);
	}
	
	pattern = "ether ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL) {
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->MAC_address_num = 0;
		strcpy(np->MAC_address_string, "unknown");
	} else {
		sscanf(c, "%s", np->MAC_address_string);
		STR_to_upper_m12(np->MAC_address_string);
		sscanf(np->MAC_address_string, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", np->MAC_address_bytes, np->MAC_address_bytes + 1, np->MAC_address_bytes + 2, np->MAC_address_bytes + 3, np->MAC_address_bytes + 4, np->MAC_address_bytes + 5);  // network byte order
	}

	if (*np->LAN_IPv4_address_string == 0) {  // may have been filled in by NET_get_lan_ipv4_address_m12()
		pattern = "inet ";
		if ((c = STR_match_end_m12(pattern, buffer)) == NULL) {
			G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\".\nCheck that cable is plugged in\n", __FUNCTION__, pattern, np->interface_name);
			np->LAN_IPv4_address_num = 0;
			strcpy(np->LAN_IPv4_address_string, "unknown");
		} else {
			sscanf(c, "%s", np->LAN_IPv4_address_string);
			sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_address_bytes, np->LAN_IPv4_address_bytes + 1, np->LAN_IPv4_address_bytes + 2, np->LAN_IPv4_address_bytes + 3);  // network byte order
		}
	}

	pattern = "netmask 0x";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL) {
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->LAN_IPv4_subnet_mask_num = 0;
		strcpy(np->LAN_IPv4_subnet_mask_string, "unknown");
	} else {
		sscanf(c, "%02hhx%02hhx%02hhx%02hhx", np->LAN_IPv4_subnet_mask_bytes, np->LAN_IPv4_subnet_mask_bytes + 1, np->LAN_IPv4_subnet_mask_bytes + 2, np->LAN_IPv4_subnet_mask_bytes + 3);  // network byte order
		sprintf_m12(np->LAN_IPv4_subnet_mask_string, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_subnet_mask_bytes[0], np->LAN_IPv4_subnet_mask_bytes[1], np->LAN_IPv4_subnet_mask_bytes[2], np->LAN_IPv4_subnet_mask_bytes[3]);
	}

	pattern = "media: ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL) {
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		strcpy(np->link_speed, "unknown");
		strcpy(np->duplex, "unknown");
	} else {
		sscanf(c, "%s %s", np->link_speed, np->duplex);
	}

	pattern = "status: ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL) {
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->active = UNKNOWN_m12;
	} else {
		sscanf(c, "%s", temp_str);
		if (strcmp(temp_str, "active") == 0)
			np->active = TRUE_m12;
		else if (strcmp(temp_str, "inactive") == 0)
			np->active = FALSE_m12;
		else {
			G_warning_message_m12("%s(): Unrecognized value (\"%s\") for field \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, temp_str, pattern, np->interface_name);
			np->active = UNKNOWN_m12;
		}
	}
	
	// clean up
	free(buffer);

	if (copy_global == TRUE_m12) {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		global_tables_m12->NET_params.MTU = np->MTU;
		strcpy(global_tables_m12->NET_params.MAC_address_string, np->MAC_address_string);
		global_tables_m12->NET_params.MAC_address_num = np->MAC_address_num;
		strcpy(global_tables_m12->NET_params.LAN_IPv4_address_string, np->LAN_IPv4_address_string);
		global_tables_m12->NET_params.LAN_IPv4_address_num = np->LAN_IPv4_address_num;
		strcpy(global_tables_m12->NET_params.LAN_IPv4_subnet_mask_string, np->LAN_IPv4_subnet_mask_string);
		global_tables_m12->NET_params.LAN_IPv4_subnet_mask_num = np->LAN_IPv4_subnet_mask_num;
		global_tables_m12->NET_params.plugged_in = np->plugged_in;
		global_tables_m12->NET_params.active = np->active;
		strcpy(global_tables_m12->NET_params.link_speed, np->link_speed);
		strcpy(global_tables_m12->NET_params.duplex, np->duplex);
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	} else if (global_np == TRUE_m12) {
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	}

	return(TRUE_m12);
}
#endif  // MACOS_m12


#ifdef WINDOWS_m12
TERN_m12	NET_get_config_m12(NET_PARAMS_m12 *np, TERN_m12 copy_global)
{
	TERN_m12		global_np;
	si1             	temp_str[256], *buffer, *iface_start, *c, *c2, *pattern;
	si4             	i, ret_val, attempts;
	DWORD 			dwSize, dwRetVal;
	ULONG			flags, family, outBufLen;
	LPVOID 			lpMsgBuf;
	PIP_ADAPTER_ADDRESSES	pAddresses, pCurrAddress;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// (get all info present in same buffers regardless of which was requested)
	//
	// called for host_name, MAC_address, LAN_IPv4, & plugged_in fields in Windows

	global_np = FALSE_m12;
	if (copy_global == FALSE_m12)
		if (np == &global_tables_m12->NET_params)
			global_np = TRUE_m12;

	if (global_np == TRUE_m12) {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		if (*np->MAC_address_string)  {  // may have been done by another thread while waiting
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
			return(TRUE_m12);
		}
	}
		
	// get ipconfig() output
	buffer = NULL;
	ret_val = system_pipe_m12(&buffer, 0, "ipconfig /all", SP_DEFAULT_m12, __FUNCTION__,  USE_GLOBAL_BEHAVIOR_m12);
	if (ret_val < 0) {
		if (global_np == TRUE_m12)
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
		return(FALSE_m12);
	}

	// parse ipconfig() output
	if (*np->host_name == 0) {
		pattern = "Host Name";
		if ((c = STR_match_end_m12(pattern, buffer)) == NULL) {
			if (gethostname(np->host_name, sizeof(np->host_name)) == -1) {
				G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ipconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
				strcpy(np->host_name, "unknown");
			}
		} else {
			while (*c++ != ':');
			++c;
			c2 = np->host_name;
			while (*c != '\r' && *c != '\n')
				*c2++ = *c++;
			*c2 = 0;
		}
	}
	
	// search for interface entry
	sprintf_m12(temp_str, "LAN adapter %s:", np->interface_name);  // pattern
	if ((c = STR_match_end_m12(temp_str, buffer)) == NULL) {
		G_warning_message_m12("%s(): Could not find interface \"%s\" in output of ipconfig()\n", __FUNCTION__, np->interface_name);
		if (global_np == TRUE_m12)
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
		return(FALSE_m12);
	}
	iface_start = c;  // start all subsequent searches fro this point

	// find next network adapter
	pattern = "adapter";
	if ((c = STR_match_start_m12(pattern, iface_start)) != NULL)
		*c = 0;  // terminate all subsequent searches here

	np->plugged_in = TRUE_m12;
	pattern = "Media disconnected";
	if ((c = STR_match_end_m12(pattern, iface_start)) != NULL)
		np->plugged_in = FALSE_m12;

	pattern = "Physical Address";
	if ((c = STR_match_end_m12(pattern, iface_start)) == NULL) {
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ipconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->MAC_address_num = 0;
		strcpy(np->MAC_address_string, "unknown");
	} else {
		while (*c++ != ':');
		++c;
		c2 = np->MAC_address_string;
		while (*c != '\r' && *c != '\n')
			*c2++ = *c++;
		*c2 = 0;
		STR_replace_char_m12('-', ':', np->MAC_address_string);
		STR_to_upper_m12(np->MAC_address_string);
		sscanf(np->MAC_address_string, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", np->MAC_address_bytes, np->MAC_address_bytes + 1, np->MAC_address_bytes + 2, np->MAC_address_bytes + 3, np->MAC_address_bytes + 4, np->MAC_address_bytes + 5);  // network byte order
	}

	if (*np->LAN_IPv4_address_string == 0) {  // may have been filled in above
		pattern = "IPv4 Address";
		if ((c = STR_match_end_m12(pattern, iface_start)) == NULL) {
			G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ipconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
			np->LAN_IPv4_address_num = 0;
			strcpy(np->LAN_IPv4_address_string, "unknown");
		} else {
			while (*c++ != ':');
			++c;
			c2 = np->LAN_IPv4_address_string;
			while (*c != '\r' && *c != '\n' && *c != '(')  // MS attaches "(Preferred)" with no space to default interface
				*c2++ = *c++;
			*c2 = 0;
			sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_address_bytes, np->LAN_IPv4_address_bytes + 1, np->LAN_IPv4_address_bytes + 2, np->LAN_IPv4_address_bytes + 3);  // network byte order
		}
	}

	pattern = "Subnet Mask";
	if ((c = STR_match_end_m12(pattern, iface_start)) == NULL) {
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of ipconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->LAN_IPv4_subnet_mask_num = 0;
		strcpy(np->LAN_IPv4_subnet_mask_string, "unknown");
	} else {
		while (*c++ != ':');
		++c;
		c2 = np->LAN_IPv4_subnet_mask_string;
		while (*c != '\r' && *c != '\n')
			*c2++ = *c++;
		*c2 = 0;
		sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_subnet_mask_bytes, np->LAN_IPv4_subnet_mask_bytes + 1, np->LAN_IPv4_subnet_mask_bytes + 2, np->LAN_IPv4_subnet_mask_bytes + 3);
	}
	free((void *) buffer);

	if (copy_global == TRUE_m12) {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		strcpy(global_tables_m12->NET_params.host_name, np->host_name);
		strcpy(global_tables_m12->NET_params.MAC_address_string, np->MAC_address_string);
		global_tables_m12->NET_params.MAC_address_num = np->MAC_address_num;
		strcpy(global_tables_m12->NET_params.LAN_IPv4_address_string, np->LAN_IPv4_address_string);
		global_tables_m12->NET_params.LAN_IPv4_address_num = np->LAN_IPv4_address_num;
		strcpy(global_tables_m12->NET_params.LAN_IPv4_subnet_mask_string, np->LAN_IPv4_subnet_mask_string);
		global_tables_m12->NET_params.LAN_IPv4_subnet_mask_num = np->LAN_IPv4_subnet_mask_num;
		global_tables_m12->NET_params.plugged_in = np->plugged_in;
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	} else if (global_np == TRUE_m12) {
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	}

	return(TRUE_m12);
}
#endif  // WINDOWS_m12


NET_PARAMS_m12	*NET_get_default_interface_m12(NET_PARAMS_m12 *np)
{
	TERN_m12	global_np, free_np;
	si1		*command, *buffer, *c;
	si4		ret_val;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	free_np = global_np = FALSE_m12;
	if (np == &global_tables_m12->NET_params) {
		global_np = TRUE_m12;
	} else if (np == NULL) {
		np = (NET_PARAMS_m12 *) calloc_m12((size_t) 1, sizeof(NET_PARAMS_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free_np = TRUE_m12;
	}

	if (*global_tables_m12->NET_params.interface_name) {
		if (global_np == FALSE_m12)
			strcpy(np->interface_name, global_tables_m12->NET_params.interface_name);
		return(np);
	}

	if (global_np == TRUE_m12) {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		if (*np->interface_name)  {  // may have been done by another thread while waiting
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
			return(np);
		}
	}
			
	#ifdef MACOS_m12
	command = "/sbin/route -n get default";
	#endif
	#ifdef LINUX_m12
	command = "/usr/sbin/ip route get 8.8.8.8";
	#endif
	#ifdef WINDOWS_m12
	command = "route PRINT -4 0.0.0.0";
	#endif
	buffer = NULL;
	ret_val = system_pipe_m12(&buffer, 0, command, SP_DEFAULT_m12, __FUNCTION__,  RETURN_ON_FAIL_m12);
	if (ret_val < 0) {  // probably no internet connection, otherwise route() error
		if (global_np == TRUE_m12)
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
		if (free_np == TRUE_m12)
			free((void *) np);
		return(NULL);
	}

	#ifdef MACOS_m12
	// parse route() output to get internet interface name
	if ((c = STR_match_end_m12("interface: ", buffer)) != NULL)
		sscanf(c, "%s", np->interface_name);
	#endif  // MACOS_m12
	
	#ifdef LINUX_m12
	// parse route() output to get internet interface name
	if ((c = STR_match_end_m12("dev ", buffer)) != NULL)
		sscanf(c, "%s", np->interface_name);
	// parse route() output to get internet ip address
	if ((c = STR_match_end_m12("src ", buffer)) != NULL) {
		sscanf(c, "%s", np->LAN_IPv4_address_string);
		sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_address_bytes, np->LAN_IPv4_address_bytes + 1, np->LAN_IPv4_address_bytes + 2, np->LAN_IPv4_address_bytes + 3);
	}
	#endif  // LINUX_m12

	#ifdef WINDOWS_m12
	si1	tmp_str[128];

	// parse route() output to get default ip address
	if ((c = STR_match_end_m12("0.0.0.0", buffer)) != NULL) {
		sscanf(c, "%s%s%s", tmp_str, tmp_str, np->LAN_IPv4_address_string);
		sscanf(np->LAN_IPv4_address_string, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_address_bytes, np->LAN_IPv4_address_bytes + 1, np->LAN_IPv4_address_bytes + 2, np->LAN_IPv4_address_bytes + 3);
		NET_iface_name_for_addr_m12(np->interface_name, np->LAN_IPv4_address_string);
	}
	#endif
	
	free((void *) buffer);
	
	if (*np->interface_name) {
		if (global_np == FALSE_m12) {
			strcpy(global_tables_m12->NET_params.interface_name, np->interface_name);
			#if defined LINUX_m12 || defined WINDOWS_m12
			strcpy(global_tables_m12->NET_params.LAN_IPv4_address_string, np->LAN_IPv4_address_string);
			global_tables_m12->NET_params.LAN_IPv4_address_num = np->LAN_IPv4_address_num;
			#endif
		}
	} else {
		G_set_error_m12(E_NO_INET_m12, __FUNCTION__, __LINE__);
		*np->LAN_IPv4_address_string = 0;
		np->LAN_IPv4_address_num = 0;
		if (free_np == TRUE_m12)
			free((void *) np);
		np = NULL;
	}
	
	if (global_np == TRUE_m12)
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);

	return(np);
}


NET_PARAMS_m12	*NET_get_duplex_m12(si1 *iface, NET_PARAMS_m12 *np)
{
	TERN_m12	copy_global, free_np;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	copy_global = NET_resolve_arguments_m12(iface, &np, &free_np);

	if (copy_global == TRUE_m12) {
		if (*global_tables_m12->NET_params.duplex)
			strcpy(np->duplex, global_tables_m12->NET_params.duplex);
	}
	if (*np->duplex)
		return(np);
	
#ifdef LINUX_m12
	if (NET_get_ethtool_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
#endif
#ifdef MACOS_m12
	if (NET_get_config_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
#endif
#ifdef WINDOWS_m12
	if (NET_get_adapter_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
#endif
	
	return(np);
}


TERN_m12	NET_get_ethtool_m12(NET_PARAMS_m12 *np, TERN_m12 copy_global)
{
#ifndef LINUX_m12
	return(UNKNOWN_m12);
#else

	TERN_m12	global_np;
	si1		temp_str[256], *buffer, *c, *pattern;
	si4		ret_val;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// (get all info present in same buffers regardless of which was requested)
	//
	// called for link speed & duplex in Linux

	global_np = FALSE_m12;
	if (copy_global == FALSE_m12)
		if (np == &global_tables_m12->NET_params)
			global_np = TRUE_m12;

	if (global_np == TRUE_m12) {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		if (*np->link_speed)  {  // may have been done by another thread while waiting
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
			return(TRUE_m12);
		}
	}
	
	// Note: ethtool() doesn't seem to work on WiFi networks
	buffer = NULL;
	sprintf_m12(temp_str, "/usr/sbin/ethtool %s", np->interface_name);
	ret_val = system_pipe_m12(&buffer, 0, temp_str, SP_DEFAULT_m12, __FUNCTION__,  RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12);
	if (ret_val < 0) {  // don't return false => this is typically superfluous info
		G_warning_message_m12("%s(): ethtool is not installed.\nCannot get link speed or duplex settings.\nInstall with \"sudo apt install ethtool\"\n", __FUNCTION__);
	} else {
		pattern = "Speed: ";
		if ((c = STR_match_end_m12(pattern, buffer)) != NULL)  // not present for wireless connections
			sscanf(c, "%s", np->link_speed);
		pattern = "Duplex: ";
		if ((c = STR_match_end_m12(pattern, buffer)) != NULL)  // not present for wireless connections
			sscanf(c, "%s", np->duplex);
		free(buffer);
	}
	if (*np->link_speed == 0)
		strcpy(np->link_speed, "unknown");
	if (*np->duplex == 0)
		strcpy(np->duplex, "unknown");

	if (copy_global == TRUE_m12) {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		strcpy(global_tables_m12->NET_params.link_speed, np->link_speed);
		strcpy(global_tables_m12->NET_params.duplex, np->duplex);
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	} else if (global_np == TRUE_m12) {
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	}

	return(TRUE_m12);
#endif
}


NET_PARAMS_m12	*NET_get_host_name_m12(NET_PARAMS_m12 *np)
{
	TERN_m12	global_np, free_np;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	free_np = FALSE_m12;
	if (np == NULL) {
		np = (NET_PARAMS_m12 *) calloc_m12((size_t) 1, sizeof(NET_PARAMS_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free_np = TRUE_m12;
	} else if (*np->host_name) {
		return(np);
	}
	
	global_np = FALSE_m12;
	if (np == &global_tables_m12->NET_params)
		global_np = TRUE_m12;

	if (*global_tables_m12->NET_params.host_name) {
		if (global_np == FALSE_m12)
			strcpy(np->host_name, global_tables_m12->NET_params.host_name);
		return(np);
	}
	
	if (global_np == TRUE_m12) {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		if (*np->host_name)  {  // may have been done by another thread while waiting
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
			return(np);
		}
	}
	
	if (gethostname(np->host_name, sizeof(np->host_name)) == -1) {
		G_warning_message_m12("%s(): cannot get host_name\n", __FUNCTION__);
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		else
			strcpy(np->host_name, "unknown");
		return(NULL);
	}
	
	if (global_np == TRUE_m12) {
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	} else {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		strcpy(global_tables_m12->NET_params.host_name, np->host_name);
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	}

	return(np);
}


void	*NET_get_in_addr_m12(struct sockaddr *sa)	// get sockaddr, IPv4 or IPv6
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (sa->sa_family == AF_INET)
		return(&(((struct sockaddr_in *) sa)->sin_addr));

	return(&(((struct sockaddr_in6 *) sa)->sin6_addr));
}


NET_PARAMS_m12	*NET_get_lan_ipv4_address_m12(si1 *iface, NET_PARAMS_m12 *np)
{
	TERN_m12	copy_global, free_np;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	copy_global = NET_resolve_arguments_m12(iface, &np, &free_np);

	if (copy_global == TRUE_m12) {
		if (*global_tables_m12->NET_params.LAN_IPv4_address_string) {
			strcpy(np->LAN_IPv4_address_string, global_tables_m12->NET_params.LAN_IPv4_address_string);
			np->LAN_IPv4_address_num = global_tables_m12->NET_params.LAN_IPv4_address_num;
		}
	}
	if (*np->LAN_IPv4_address_string)
		return(np);
		
	if (NET_get_config_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
	
	return(np);
}


NET_PARAMS_m12	*NET_get_link_speed_m12(si1 *iface, NET_PARAMS_m12 *np)
{
	TERN_m12	copy_global, free_np;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	copy_global = NET_resolve_arguments_m12(iface, &np, &free_np);

	if (copy_global == TRUE_m12) {
		if (*global_tables_m12->NET_params.link_speed)
			strcpy(np->link_speed, global_tables_m12->NET_params.link_speed);
	}
	if (*np->link_speed)
		return(np);
	
#ifdef LINUX_m12
	if (NET_get_ethtool_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
#endif
#ifdef MACOS_m12
	if (NET_get_config_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
#endif
#ifdef WINDOWS_m12
	if (NET_get_adapter_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
#endif
	
	return(np);
}


NET_PARAMS_m12	*NET_get_mac_address_m12(si1 *iface, NET_PARAMS_m12 *np)
{
	TERN_m12	copy_global, free_np;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	copy_global = NET_resolve_arguments_m12(iface, &np, &free_np);

	if (copy_global == TRUE_m12) {
		if (*global_tables_m12->NET_params.MAC_address_string) {
			strcpy(np->MAC_address_string, global_tables_m12->NET_params.MAC_address_string);
			np->MAC_address_num = global_tables_m12->NET_params.MAC_address_num;
		}
	}
	if (*np->MAC_address_string)
		return(np);
	
	if (NET_get_config_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
	
	return(np);
}


NET_PARAMS_m12	*NET_get_mtu_m12(si1 *iface, NET_PARAMS_m12 *np)
{
	TERN_m12	copy_global, free_np;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	copy_global = NET_resolve_arguments_m12(iface, &np, &free_np);

	if (copy_global == TRUE_m12) {
		if (global_tables_m12->NET_params.MTU > 0)
			np->MTU = global_tables_m12->NET_params.MTU;
	}
	if (np->MTU > 0)
		return(np);

#if defined MACOS_m12 || defined LINUX_m12
	if (NET_get_config_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
#endif
#ifdef WINDOWS_m12
	if (NET_get_adapter_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
#endif
	
	return(np);
}


NET_PARAMS_m12	*NET_get_parameters_m12(si1 *iface, NET_PARAMS_m12 *np)
{
	TERN_m12	copy_global, free_np;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// fill all fields of NET_PARAMS_m12 structure

	copy_global = NET_resolve_arguments_m12(iface, &np, &free_np);

	if (copy_global == TRUE_m12) {
		if (global_tables_m12->NET_params.plugged_in != UNKNOWN_m12)
			np->plugged_in = global_tables_m12->NET_params.plugged_in;
	}
	
	if (NET_get_config_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}

#ifdef LINUX_m12
	if (NET_get_host_name_m12(np) == NULL) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}

	if (NET_get_ethtool_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
#endif
#ifdef MACOS_m12
	if (NET_get_host_name_m12(np) == NULL) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
#endif
#ifdef WINDOWS_m12
	if (NET_get_adapter_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
#endif

	return(np);
}


NET_PARAMS_m12	*NET_get_plugged_in_m12(si1 *iface, NET_PARAMS_m12 *np)
{
	TERN_m12	copy_global, free_np;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	copy_global = NET_resolve_arguments_m12(iface, &np, &free_np);

	if (copy_global == TRUE_m12) {
		if (global_tables_m12->NET_params.plugged_in != UNKNOWN_m12)
			np->plugged_in = global_tables_m12->NET_params.plugged_in;
	}
	if (np->plugged_in != UNKNOWN_m12)
		return(np);
	
	if (NET_get_config_m12(np, copy_global) == FALSE_m12) {
		if (free_np == TRUE_m12)
			free_m12((void *) np, __FUNCTION__);
		return(NULL);
	}
	
	return(np);
}


NET_PARAMS_m12 *NET_get_wan_ipv4_address_m12(NET_PARAMS_m12 *np)
{
	TERN_m12	global_np;
	si1		*command, *buffer, *pattern, *c;
	si4		ret_val;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (np == NULL)
		np = (NET_PARAMS_m12 *) calloc_m12((size_t) 1, sizeof(NET_PARAMS_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	else if (*np->WAN_IPv4_address_string)
		return(np);
	
	global_np = FALSE_m12;
	if (np == &global_tables_m12->NET_params)
		global_np = TRUE_m12;
	
	if (*global_tables_m12->NET_params.WAN_IPv4_address_string) {
		if (global_np == FALSE_m12) {
			strcpy(np->WAN_IPv4_address_string, global_tables_m12->NET_params.WAN_IPv4_address_string);
			np->WAN_IPv4_address_num = global_tables_m12->NET_params.WAN_IPv4_address_num;
		}
		return(np);
	}
	
	if (global_np == TRUE_m12) {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		if (*np->WAN_IPv4_address_string)  {  // may have been done by another thread while waiting
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
			return(np);
		}
	}

	// get WAN IPV4 address (this server can take some time)
#if defined MACOS_m12 || defined LINUX_m12
	command = "/usr/bin/curl --connect-timeout 7.0 -s checkip.dyndns.org";
#endif
#ifdef WINDOWS_m12
	command = "curl.exe --connect-timeout 7.0 -s checkip.dyndns.org";
#endif
	
	buffer = NULL;
	ret_val = system_pipe_m12(&buffer, 0, command, SP_DEFAULT_m12, __FUNCTION__, RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12 | RETRY_ONCE_m12);
	if (ret_val < 0) {
		if (NET_get_lan_ipv4_address_m12(NULL, np) == NULL)
			G_warning_message_m12("%s(): no internet connection\n", __FUNCTION__);
		else
			G_warning_message_m12("%s(): cannot connect to checkip.dyndns.org\n", __FUNCTION__);
		if (global_np == TRUE_m12)
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
		return(NULL);
	}

	// parse output
	pattern = "Current IP Address: ";
	if ((c = STR_match_end_m12(pattern, buffer)) == NULL) {
		G_warning_message_m12("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
		if (global_np == TRUE_m12)
			PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
		free((void *) buffer);
		return(NULL);
	}
	sscanf(c, "%[^< ]s", np->WAN_IPv4_address_string);
	sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->WAN_IPv4_address_bytes, np->WAN_IPv4_address_bytes + 1, np->WAN_IPv4_address_bytes + 2, np->WAN_IPv4_address_bytes + 3);
	
	free((void *) buffer);

	if (global_np == TRUE_m12) {
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	} else {
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
		strcpy(global_tables_m12->NET_params.WAN_IPv4_address_string, np->WAN_IPv4_address_string);
		global_tables_m12->NET_params.WAN_IPv4_address_num = np->WAN_IPv4_address_num;
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);
	}

	return(np);
}


#if defined MACOS_m12 || defined LINUX_m12
si1	*NET_iface_name_for_addr_m12(si1 *iface_name, si1 *iface_addr)
{
	si1 			local_iface_name[NI_MAXHOST], tmp_addr[INET6_ADDRSTRLEN];
	si4 			fam;
	struct ifaddrs		*if_addr_list, *ifa;
	socklen_t		si_len;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (getifaddrs(&if_addr_list)) {
		G_warning_message_m12("%s(): getifaddrs() error\n", __FUNCTION__);
		return(NULL);
	}
	
	if (iface_name == NULL)
		iface_name = local_iface_name;  // not thread safe

	for (ifa = if_addr_list; ifa != NULL; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr == NULL)
			continue;
		
		fam = ifa->ifa_addr->sa_family;
		if (fam == AF_INET)
			si_len = sizeof(struct sockaddr_in);
		else if (fam == AF_INET6)
			si_len = sizeof(struct sockaddr_in6);
		else
			continue;
		
		// get ip address of interface
		if (getnameinfo(ifa->ifa_addr, si_len, tmp_addr, NI_MAXHOST, NULL, 0, NI_NUMERICHOST)) {
			G_warning_message_m12("%s(): getnameinfo() error\n", __FUNCTION__);
			freeifaddrs(if_addr_list);
			return(NULL);
		}
		
		// compare to target address
		if (strcmp(tmp_addr, iface_addr) == 0)
			break;
	}
	if (ifa == NULL) {
		G_warning_message_m12("%s(): could not match ip address to interface\n", __FUNCTION__);
		freeifaddrs(if_addr_list);
		return(NULL);
	}
	
	strcpy(iface_name, ifa->ifa_name);
	freeifaddrs(if_addr_list);
	
	return(iface_name);
}
#endif


#ifdef WINDOWS_m12
si1	*NET_iface_name_for_addr_m12(si1 *iface_name, si1 *iface_addr)
{
	si1			local_iface_name[64], *buffer, *c, *c2;
	si4			ret_val;
	si8			sz;
	FILE			*fp;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (iface_name == NULL)
		iface_name = local_iface_name;  // not thread safe

	// get interface name (aka connection name in Windows)
	buffer = NULL;
	ret_val = system_pipe_m12(&buffer, 0, "ipconfig", SP_DEFAULT_m12, __FUNCTION__,  RETURN_ON_FAIL_m12);
	*iface_name = 0;
	if (ret_val > 0) {  // parse ipconfig() output to find internet ip address
		if ((c = STR_match_start_m12(iface_addr, buffer)) != NULL) {
			// find "LAN adapter" backwards fromm here
			while (c >= buffer) {
				if (*c == 'L')
					if (strncmp(c, "LAN adapter ", 12) == 0)
						break;
				--c;
			}
			if (c >= buffer) {
				c += 12;
				c2 = iface_name;
				while (*c != ':')
					*c2++ = *c++;
				*c2 = 0;
			}
		}
		free((void *) buffer);
	}

	return(iface_name);
}
#endif


TERN_m12	NET_initialize_tables_m12(void)
{
	TERN_m12	copy_global;
	NET_PARAMS_m12	*np;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	np = &global_tables_m12->NET_params;
	NET_reset_parameters_m12(np);
	NET_get_default_interface_m12(np);
	copy_global = FALSE_m12;
	
	if (NET_get_config_m12(np, copy_global) == FALSE_m12)
		return(FALSE_m12);
	
	// this can is problematic and is rarely needed
//	if (NET_get_wan_ipv4_address_m12(np) == NULL)
//		return(FALSE_m12);

#ifdef LINUX_m12
	if (NET_get_host_name_m12(np) == NULL)
		return(FALSE_m12);

	if (NET_get_ethtool_m12(np, copy_global) == FALSE_m12)
		return(FALSE_m12);
#endif
#ifdef MACOS_m12
	if (NET_get_host_name_m12(np) == NULL)
		return(FALSE_m12);
#endif
#ifdef WINDOWS_m12
	if (NET_get_adapter_m12(np, copy_global) == FALSE_m12)
		return(FALSE_m12);
#endif

	return(TRUE_m12);
}


void	NET_reset_parameters_m12(NET_PARAMS_m12 *np)
{
	TERN_m12	global_np;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// call to clear NET_PARAMS_m12 structure (e.g. to obtain current values)
	// can call with NULL to reset global parameters)
	
	if (np == NULL)
		np = &global_tables_m12->NET_params;
	
	global_np = FALSE_m12;
	if (np == &global_tables_m12->NET_params)
		global_np = TRUE_m12;

	if (global_np == TRUE_m12)
		PROC_pthread_mutex_lock_m12(&global_tables_m12->NET_mutex);
	
	memset((void *) np, 0, sizeof(NET_PARAMS_m12));
	
	if (global_np == TRUE_m12)
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->NET_mutex);

	return;
}


TERN_m12	NET_resolve_arguments_m12(si1 *iface, NET_PARAMS_m12 **params_ptr, TERN_m12 *free_params)
{
	TERN_m12	interface_is_global, params_are_global;
	si1		tmp_str[64];
	NET_PARAMS_m12	*params;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns "copy global" (if global value known, just copy to np, else get & copy to global)
	
	if (iface != NULL) {
		if (*iface == 0)
			iface = NULL;
	}
	if (params_ptr == NULL)
		params = NULL;
	else
		params = *params_ptr;
	
	*free_params = FALSE_m12;
	
	params_are_global = FALSE_m12;
	if (params != NULL) {
		if (params == &global_tables_m12->NET_params)
			params_are_global = TRUE_m12;
		if (iface == NULL)
			if (*params->interface_name)
				iface = params->interface_name;
	}
	
	if (*global_tables_m12->NET_params.interface_name == 0)
		NET_get_default_interface_m12(&global_tables_m12->NET_params);

	interface_is_global = FALSE_m12;
	if (iface != NULL) {
		if (*iface >= '0' && *iface <= '9') {  // caller passed interface ip for interface name
			strcpy_m12(tmp_str, iface);
			NET_iface_name_for_addr_m12(iface, tmp_str);
		}
		if (strcmp(global_tables_m12->NET_params.interface_name, iface) == 0)
			interface_is_global = TRUE_m12;
	}
	
	if (iface != NULL) {
		// case: +iface, +params
		if (params != NULL) {
			if (iface != params->interface_name) {
				if (strcmp(iface, params->interface_name)) {  // interface changed, zero other params
					memset((void *) params, 0, sizeof(NET_PARAMS_m12));
					strcpy(params->interface_name, iface);
				}
			}
		}
		// case: +iface, -params
		else {
			params = (NET_PARAMS_m12 *) calloc_m12((size_t) 1, sizeof(NET_PARAMS_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			*free_params = TRUE_m12;
			strcpy(params->interface_name, iface);
		}
	} else { // iface == NULL
		interface_is_global = TRUE_m12;  // true for both cases because if params->interface_name exists, iface != NULL
		iface = global_tables_m12->NET_params.interface_name;
		 // case: -iface, +params
		if (params != NULL) {
			if (params_are_global == FALSE_m12)
				strcpy(iface, params->interface_name);
		}
		// case: -iface, -params
		else {
			params = (NET_PARAMS_m12 *) calloc_m12((size_t) 1, sizeof(NET_PARAMS_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			*free_params = TRUE_m12;
			strcpy(iface, params->interface_name);
		}
	}

	*params_ptr = params;

	if (interface_is_global == TRUE_m12 && params_are_global == FALSE_m12)
		return(TRUE_m12);

	return(FALSE_m12);
}


void    NET_show_parameters_m12(NET_PARAMS_m12 *np)
{
	si1        hex_str[HEX_STRING_BYTES_m12(NET_MAC_ADDRESS_BYTES_m12)];
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (np == NULL)
		np = &global_tables_m12->NET_params;

	printf_m12("interface_name: ");
	if (*np->interface_name)
		printf_m12("%s\n", np->interface_name);
	else
		printf_m12("unknown\n");
	printf_m12("host_name: ", np->host_name);
	if (*np->host_name)
		printf_m12("%s\n", np->host_name);
	else
		printf_m12("unknown\n");
	if (np->MAC_address_num) {
		STR_generate_hex_string_m12(np->MAC_address_bytes, NET_MAC_ADDRESS_BYTES_m12, hex_str);
		printf_m12("MAC_address_bytes: %s\n", hex_str);
		printf_m12("MAC_address_string: %s\n", np->MAC_address_string);
	} else {
		printf_m12("MAC_address_bytes: unknown\n");
		printf_m12("MAC_address_string: unknown\n");
	}
	if (np->LAN_IPv4_address_num) {
		STR_generate_hex_string_m12(np->LAN_IPv4_address_bytes, NET_IPV4_ADDRESS_BYTES_m12, hex_str);
		printf_m12("LAN_IPv4_address_bytes: %s\n", hex_str);
		printf_m12("LAN_IPv4_address_string: %s\n", np->LAN_IPv4_address_string);
	} else {
		printf_m12("LAN_IPv4_address_bytes: unknown\n");
		printf_m12("LAN_IPv4_address_string: unknown\n");
	}
	if (np->LAN_IPv4_subnet_mask_num) {
		STR_generate_hex_string_m12(np->LAN_IPv4_subnet_mask_bytes, NET_IPV4_ADDRESS_BYTES_m12, hex_str);
		printf_m12("LAN_IPv4_subnet_mask_bytes: %s\n", hex_str);
		printf_m12("LAN_IPv4_subnet_mask_string: %s\n", np->LAN_IPv4_subnet_mask_string);
	} else {
		printf_m12("LAN_IPv4_subnet_mask_bytes: unknown\n");
		printf_m12("LAN_IPv4_subnet_mask_string: unknown\n");
	}
	if (np->WAN_IPv4_address_num) {
		STR_generate_hex_string_m12(np->WAN_IPv4_address_bytes, NET_IPV4_ADDRESS_BYTES_m12, hex_str);
		printf_m12("WAN_IPv4_address_bytes: %s\n", hex_str);
		printf_m12("WAN_IPv4_address_string: %s\n", np->WAN_IPv4_address_string);
	} else {
		printf_m12("WAN_IPv4_address_bytes: unknown\n");
		printf_m12("WAN_IPv4_address_string: unknown\n");
	}
	if (np->MTU)
		printf_m12("MTU: %d\n", np->MTU);
	else
		printf_m12("MTU: unknown\n");
	if (*np->link_speed)
		printf_m12("link speed: %s\n", np->link_speed);
	else
		printf_m12("link speed: unknown\n");
	if (np->active == TRUE_m12)
		printf_m12("active: true\n");
	else if (np->active == FALSE_m12)
		printf_m12("active: false\n");
	else
		printf_m12("active: unknown\n");
#ifdef LINUX_m12
	if (*np->duplex)
		printf_m12("duplex: %s\n", np->duplex);
	else
		printf_m12("duplex: unknown\n");
	if (np->plugged_in == TRUE_m12)
		printf_m12("plugged_in: true\n");
	else if (np->plugged_in == FALSE_m12)
		printf_m12("plugged_in: false\n");
	else
		printf_m12("plugged_in: unknown\n");
#endif

	return;
}


void	NET_trim_address_m12(si1 *address)
{
	size_t	len;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// trim ipv6 version of ipv4 address to standard ipv4 address
	
	if (strncmp(address, "::ffff:", 7) == 0) {
		len = strlen(address);
		memmove(address, address + 7, len - 6);
	}
	
	return;
}



//********************************//
// MARK: PARALLEL FUNCTIONS  (PAR)
//********************************//

void	PAR_free_m12(PAR_INFO_m12 **par_info_ptr)  // frees thread globals & par itself - sets par pointer to NULL
{
	extern GLOBALS_m12		**globals_list_m12;
	extern volatile si4		globals_list_len_m12;
	extern pthread_mutex_t_m12	globals_list_mutex_m12;
	TERN_m12			main_globals_exist;
	si4				i;
	pid_t_m12			main_pid;
	PAR_INFO_m12			*par_info;
	
	
	par_info = *par_info_ptr;
	if (par_info->status == PAR_RUNNING_m12) {
		G_warning_message_m12("%s() process is running => returning\n", __FUNCTION__);
		return;
	}
	if (par_info->tid == 0) {
		G_warning_message_m12("%s() process has no thread ID => returning\n", __FUNCTION__);
		return;
	}

	// lock list
	PROC_pthread_mutex_lock_m12(&globals_list_mutex_m12);

	// find main globals
	main_pid = PROC_getpid_m12();
	for (i = 0; i < globals_list_len_m12; ++i)
		if (globals_list_m12[i]->_id == main_pid)
			break;
	
	// temporarily set to zero
	main_globals_exist = FALSE_m12;
	if (i < globals_list_len_m12) {
		globals_list_m12[i]->_id = 0;
		main_globals_exist = TRUE_m12;
	}
	
	// set thread global to thread tid & free them
	if (i < globals_list_len_m12) {
		globals_list_m12[i]->_id = main_pid;
		PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12);  // free_globals() will want the mutex
		if (globals_list_len_m12 == 1)
			G_free_globals_m12(TRUE_m12);  // clean up for exit
		else
			G_free_globals_m12(FALSE_m12);  // other threads have globals
		PROC_pthread_mutex_lock_m12(&globals_list_mutex_m12);  // reclaim mutex
	}
	
	// reset main globals
	if (main_globals_exist == TRUE_m12) {
		for (i = 0; i < globals_list_len_m12; ++i)
			if (globals_list_m12[i]->_id == 0)
				break;
		globals_list_m12[i]->_id = main_pid;
	}
	
	// unlock list
	PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12);

	// free par & set to NULL
	free((void *) par_info);  // caller responsible for disposing of anything in par_info->ret_val, if neceessary
	*par_info_ptr = NULL;

	return;
}


PAR_INFO_m12	*PAR_init_m12(PAR_INFO_m12 *par_info, si1 *function, si1 *label, ...) // varagrgs(label == PAR_DEFAULTS_m12): si4 priority, si1 *affinity, si4 detached
{
	TERN_m12	defaults;
	si1 		*affinity;
	si4 		priority, detached;
	va_list		args;
	

	if (function == NULL)
		G_warning_message_m12("%s() function must be passed => returning\n", __FUNCTION__);
	else if (*function == 0)
		G_warning_message_m12("%s() function must be passed => returning\n", __FUNCTION__);

	if (par_info == NULL)
		par_info = (PAR_INFO_m12 *) calloc_m12((size_t) 1, sizeof(PAR_INFO_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

	strcpy(par_info->function, function);

	defaults = FALSE_m12;
	if (label != NULL)
		if (strcmp(label, PAR_DEFAULTS_m12) == 0)
			defaults = TRUE_m12;
	
	if (defaults == TRUE_m12) {
			label = affinity = NULL;
			priority = detached = 0;
	} else {
		va_start(args, label);
		priority = va_arg(args, si4);
		affinity = va_arg(args, si1 *);
		detached = va_arg(args, si4);
		va_end(args);
	}

	if (label == NULL)
		label = "unlabeled thread";
	else if (*label == 0)
		label = "unlabeled thread";
	strcpy(par_info->label, label);
	
	if (priority == 0)
		priority = PROC_DEFAULT_PRIORITY_m12;
	par_info->priority = priority;
	
	if (affinity == NULL)
		affinity = "~0";
	strcpy(par_info->affinity, affinity);

	if (detached == 0)
		detached = TRUE_m12;
	par_info->detached = detached;
	
	return(par_info);
}


PAR_INFO_m12	*PAR_launch_m12(PAR_INFO_m12 *par_info, ...)  // varargs (par_info == NULL): si1 *function, si1 *label, si4 priority, si1 *affinity, , si4 detached, <function arguments>
							      // varargs (par_info != NULL): <function arguments>
{
	TERN_m12		unthreaded;
	PAR_THREAD_INFO_m12	par_t_info;

	// function() must return a pointer
	
	// get varags
	va_start(par_t_info.args, par_info);
	
	// initialize par_info
	if (par_info == NULL) {
		si1			*function, *label, *affinity;
		si4			priority, detached;
 
		par_info = (PAR_INFO_m12 *) calloc_m12((size_t) 1, sizeof(PAR_INFO_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		function = va_arg(par_t_info.args, si1 *);
		label = va_arg(par_t_info.args, si1 *);
		if (strcmp(label, PAR_DEFAULTS_m12) == 0) {
			PAR_init_m12(par_info, function, label);
		} else {
			priority = va_arg(par_t_info.args, si4);
			affinity = va_arg(par_t_info.args, si1 *);
			detached = va_arg(par_t_info.args, si4);
			PAR_init_m12(par_info, function, label, priority, affinity, detached);
		}
	}
		
	// "unthreaded" mechanism => just want seperate globals
	if (par_info->detached == PAR_UNTHREADED_m12) {
		unthreaded = TRUE_m12;
		par_info->detached = FALSE_m12;  // launch as attached thread
	} else {
		unthreaded = FALSE_m12;
	}
	
	// set up thread info
	par_t_info.par_info = par_info;
	
	// launch thread
	par_info->status = PAR_LAUNCHING_m12;
	PROC_launch_thread_m12(&par_info->thread_id, PAR_thread_m12, (void *) &par_t_info, par_info->priority, par_info->affinity, NULL, par_info->detached, par_info->label);

	// wait for argument capture
	while (par_info->status == PAR_LAUNCHING_m12)
		G_nap_m12("10 us");
	va_end(par_t_info.args);
	
	if (unthreaded == TRUE_m12) {
		PAR_wait_m12(par_info, NULL);
		par_info->detached = PAR_UNTHREADED_m12;  // restore for next call
	}
	
	return(par_info);
}

void	PAR_show_info_m12(PAR_INFO_m12 *par_info)
{
	printf_m12("\nlabel: \"%s\"\n", par_info->label);
	printf_m12("function: \"%s\"\n", par_info->function);
	if (par_info->ret_val == NULL)
		printf_m12("ret_val: not set\n");
	else
		printf_m12("ret_val: set\n");
	printf_m12("tid: %d\n", par_info->tid);
	printf_m12("priority: 0x%08x\n", par_info->priority);
	printf_m12("affinity: \"%s\"\n", par_info->affinity);
	printf_m12("detached: %d\n", par_info->detached);
	printf_m12("status: %d\n\n", par_info->status);

	return;
}


pthread_rval_m12	PAR_thread_m12(void *arg)
{
	extern GLOBALS_m12		**globals_list_m12;
	extern volatile si4		globals_list_len_m12;
	extern pthread_mutex_t_m12	globals_list_mutex_m12;
	si1				*function, *path, *password;
	si4				i, fn, list_len, varargs;
	ui8				flags;
	si8 				sample_count;
	sf8 				sampling_frequency, scale, fc1, fc2;
	void				*file_list;
	PAR_THREAD_INFO_m12		*par_t_info;
	PAR_INFO_m12 			*par_info;
	pid_t_m12			tid;
	SESSION_m12			*sess;
	CHANNEL_m12			*chan;
	SEGMENT_m12			*seg;
	TIME_SLICE_m12			*slice;
	DATA_MATRIX_m12 		*mat;


	par_t_info = (PAR_THREAD_INFO_m12 *) arg;
	par_info = par_t_info->par_info;
	function = par_info->function;
	
	// set globals
	tid = PROC_gettid_m12();
	if (par_info->tid && globals_list_m12 != NULL && globals_list_m12 != NULL) {  // find prior thread globals and change to this tid
		// medlib globals
		PROC_pthread_mutex_lock_m12(&globals_list_mutex_m12);
		for (i = 0; i < globals_list_len_m12; ++i)
			if (globals_list_m12[i]->_id == par_info->tid)
				break;
		if (i == globals_list_len_m12) {
			PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12);
			G_warning_message_m12("%s() can't match preexisting medlib globals => returning\n", __FUNCTION__);
			par_info->status = PAR_FINISHED_m12;
			return((pthread_rval_m12) 0);
		}
		globals_list_m12[i]->_id = tid;
		PROC_pthread_mutex_unlock_m12(&globals_list_mutex_m12);
	} else {
		G_initialize_globals_m12(TRUE_m12);
	}
	par_info->tid = tid;

	// get function
	if (strcmp(function, "G_open_session_m12") == 0)
		fn = PAR_OPEN_SESSION_m12;
	else if (strcmp(function, "G_read_session_m12") == 0)
		fn = PAR_READ_SESSION_m12;
	else if (strcmp(function, "G_open_channel_m12") == 0)
		fn = PAR_OPEN_CHANNEL_m12;
	else if (strcmp(function, "G_read_channel_m12") == 0)
		fn = PAR_READ_CHANNEL_m12;
	else if (strcmp(function, "G_open_segment_m12") == 0)
		fn = PAR_OPEN_SEGMENT_m12;
	else if (strcmp(function, "G_read_segment_m12") == 0)
		fn = PAR_READ_SEGMENT_m12;
	else if (strcmp(function, "DM_get_matrix_m12") == 0)
		fn = PAR_GET_MATRIX_m12;
	else {
		G_warning_message_m12("%s() can't match function => returning\n", __FUNCTION__);
		par_info->status = PAR_FINISHED_m12;
		return((pthread_rval_m12) 0);
	}

	// launch function
	switch (fn) {
		case PAR_OPEN_SESSION_m12:
		case PAR_READ_SESSION_m12:
			sess = va_arg(par_t_info->args, SESSION_m12 *);
			slice = va_arg(par_t_info->args, TIME_SLICE_m12 *);
			if (fn == PAR_READ_SESSION_m12 && sess != NULL) {
				par_info->status = PAR_RUNNING_m12;
				par_info->ret_val = (void *) G_read_session_m12(sess, slice);
			} else {
				file_list = va_arg(par_t_info->args, void *);
				list_len = va_arg(par_t_info->args, si4);
				flags = va_arg(par_t_info->args, ui8);
				password = va_arg(par_t_info->args, si1 *);
				par_info->status = PAR_RUNNING_m12;
				switch (fn) {
					case PAR_OPEN_SESSION_m12:
						par_info->ret_val = (void *) G_open_session_m12(sess, slice, file_list, list_len, flags, password);
						break;
					case PAR_READ_SESSION_m12:
						par_info->ret_val = (void *) G_read_session_m12(sess, slice, file_list, list_len, flags, password);
						break;
				}
			}
			break;
		case PAR_OPEN_CHANNEL_m12:
		case PAR_READ_CHANNEL_m12:
		case PAR_OPEN_SEGMENT_m12:
		case PAR_READ_SEGMENT_m12:
			if (fn == PAR_OPEN_SEGMENT_m12 || fn == PAR_READ_SEGMENT_m12)
				seg = va_arg(par_t_info->args, SEGMENT_m12 *);
			else
				chan = va_arg(par_t_info->args, CHANNEL_m12 *);
			slice = va_arg(par_t_info->args, TIME_SLICE_m12 *);
			if (fn == PAR_READ_CHANNEL_m12 && chan != NULL) {
				par_info->status = PAR_RUNNING_m12;
				par_info->ret_val = (void *) G_read_channel_m12(chan, slice);
			} else if (fn == PAR_READ_SEGMENT_m12 && seg != NULL) {
				par_info->status = PAR_RUNNING_m12;
				par_info->ret_val = (void *) G_read_segment_m12(seg, slice);
			} else {
				path = va_arg(par_t_info->args, void *);
				flags = va_arg(par_t_info->args, ui8);
				password = va_arg(par_t_info->args, si1 *);
				par_info->status = PAR_RUNNING_m12;
				switch (fn) {
					case PAR_OPEN_CHANNEL_m12:
						par_info->ret_val = (void *) G_open_channel_m12(chan, slice, path, flags, password);
						break;
					case PAR_READ_CHANNEL_m12:
						par_info->ret_val = (void *) G_read_channel_m12(chan, slice, path, flags, password);
						break;
					case PAR_OPEN_SEGMENT_m12:
						par_info->ret_val = (void *) G_open_segment_m12(seg, slice, path, flags, password);
						break;
					case PAR_READ_SEGMENT_m12:
						par_info->ret_val = (void *) G_read_segment_m12(seg, slice, path, flags, password);
						break;
				}
			}
			break;
		case PAR_GET_MATRIX_m12:
			mat = va_arg(par_t_info->args, DATA_MATRIX_m12 *);
			sess = va_arg(par_t_info->args, SESSION_m12 *);
			slice = va_arg(par_t_info->args, TIME_SLICE_m12 *);
			varargs = va_arg(par_t_info->args, si4);
			if (varargs == FALSE_m12) {
				par_info->status = PAR_RUNNING_m12;
				par_info->ret_val = (void *) DM_get_matrix_m12(mat, sess, slice, varargs);
			} else {
				sample_count = va_arg(par_t_info->args, si8);
				sampling_frequency = va_arg(par_t_info->args, sf8);
				flags = va_arg(par_t_info->args, ui8);
				scale = va_arg(par_t_info->args, sf8);
				fc1 = va_arg(par_t_info->args, sf8);
				fc2 = va_arg(par_t_info->args, sf8);
				par_info->status = PAR_RUNNING_m12;
				par_info->ret_val = (void *) DM_get_matrix_m12(mat, sess, slice, varargs, sample_count, sampling_frequency, flags, scale, fc1, fc2);
			}
			break;
	}
	
	par_info->status = PAR_FINISHED_m12;

	return((pthread_rval_m12) 0);
}


void	PAR_wait_m12(PAR_INFO_m12 *par_info, si1 *interval)
{
	if (par_info->detached == FALSE_m12) {
		PROC_pthread_join_m12(par_info->thread_id, NULL);
		return;
	}
	
	if (G_empty_string_m12(interval) == TRUE_m12)
		interval = "1 ms";
	
	// poll detached thread at interval
	while (par_info->status == PAR_RUNNING_m12)
		G_nap_m12(interval);
	
	return;
}



//********************************//
// MARK: PROCESS FUNCTIONS  (PROC)
//********************************//

TERN_m12	PROC_adjust_open_file_limit_m12(si4 new_limit, TERN_m12 verbose_flag)
{
	TERN_m12	ret_val = TRUE_m12;
#if defined MACOS_m12 || defined LINUX_m12
	struct rlimit	resource_limit;
#endif

	// verbose_flag passed because this function is usually called before the MED libraries are initialized
	
	#if defined MACOS_m12 || defined LINUX_m12
	// change resource limits (note: must change before calling any functions that use system resources)
	getrlimit(RLIMIT_NOFILE, &resource_limit);  // get existing limit set
	resource_limit.rlim_cur = (rlim_t) new_limit;  // change open file limit
	if (setrlimit(RLIMIT_NOFILE, &resource_limit) == -1)  // set limit set
		ret_val = FALSE_m12;
	#endif
	
	#ifdef WINDOWS_m12
	if (_setmaxstdio(new_limit) == -1)  // change open file limit
		ret_val = FALSE_m12;
	#endif

#ifdef FN_DEBUG_m12  // don't print until resources changed
	#ifdef MATLAB_m12
	mexPrintf("%s()\n", __FUNCTION__);
	#else
	printf("%s()\n", __FUNCTION__);
	#endif
#endif

	if (ret_val == FALSE_m12) {
		if (verbose_flag == TRUE_m12) {
			#ifdef MATLAB_m12
			mexPrintf("%s(): could not adjust process open file limit\n", __FUNCTION__);
			#else
			fprintf(stderr, "%s(): could not adjust process open file limit\n", __FUNCTION__);
			#endif
		}
	}

	return(ret_val);
}


TERN_m12	PROC_distribute_jobs_m12(PROC_THREAD_INFO_m12 *jobs, si4 n_jobs, si4 n_reserved_cores, TERN_m12 wait_jobs)
{
	si4			i, n_logical_cores, n_concurrent_jobs, new_job_idx;
	cpu_set_t_m12		cpu_set;
	HW_PARAMS_m12		*hw_params;
	PROC_THREAD_INFO_m12	*job, *new_job;
	#if defined LINUX_m12 || defined WINDOWS_m12
	si1			affinity[8];
	si4			start_core, end_core;
	#endif
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// calling function sets up thread_info structures
	// n_reserved_cores = number of cores to leave unassigned (typically zero). When needed this will be adjusted for the task & OS
	// if reserving cores for system n_reserved_cores typically == 1-2
	// if wait_jobs == TRUE_m12 wait for jobs in this function
	// returns FALSE_m12 on error, UNKNOWN_m12 if jobs still running, TRUE_m12 if all jobs finished
	
	// get logical cores
	hw_params = &global_tables_m12->HW_params;
	if (hw_params->logical_cores == 0)
		HW_get_core_info_m12();
	n_logical_cores = hw_params->logical_cores;
	
	// set reserved cores & concurrent jobs
	#ifdef WINDOWS_m12
	// Windows performs better with at least 1 reserved core (if possible)
	if (n_logical_cores <= 3)
		n_reserved_cores = n_logical_cores - 1;
	else if (n_reserved_cores < 3)
		n_reserved_cores = 3;
	#endif
	
	if (n_reserved_cores >= n_logical_cores)
		n_reserved_cores = n_logical_cores - 1;
	n_concurrent_jobs = n_logical_cores - n_reserved_cores;
	if (n_concurrent_jobs > n_jobs)
		n_concurrent_jobs = n_jobs;

	// build cpu set
#if defined LINUX_m12 || defined WINDOWS_m12  // MacOS does not allow affinity assignment
	

	#ifdef LINUX_m12
	start_core = n_reserved_cores;
	#endif
	#ifdef WINDOWS_m12  // Windows prefers first and terminal cores
	start_core = 1;
	#endif
	end_core = start_core + (n_concurrent_jobs - 1);
	
	sprintf(affinity, "%d-%d", start_core, end_core);
	PROC_generate_cpu_set_m12(affinity, &cpu_set);
#endif  // LINUX_m12 || WINDOWS_m12
#ifdef MACOS_m12
	cpu_set = ~((cpu_set_t_m12) 0);  // not used at current time
#endif
	
	// set all jobs to waiting state
	for (i = 0; i < n_jobs; ++i)
		jobs[i].status = PROC_THREAD_WAITING_m12;

	#ifdef MATLAB_m12
	G_push_behavior_m12(SUPPRESS_OUTPUT_m12);  // can't have output from threads in mex functions
	#endif

	// launch initial job set (all jobs detached)
	for (i = 0, job = jobs; i < n_concurrent_jobs; ++i, ++job)
		PROC_launch_thread_m12(&job->thread_id, job->thread_f, (void *) job, job->priority, NULL, &cpu_set, TRUE_m12, job->thread_label);

	// make sure status set in threads (volatile)
	for (i = 0, job = jobs; i < n_concurrent_jobs; ++i, ++job)
		while (job->status == PROC_THREAD_WAITING_m12);
	
	// launch rest of jobs as others finish
	new_job_idx = n_concurrent_jobs;
	while (new_job_idx < n_jobs) {
		for (i = 0, job = jobs; i < n_jobs; ++i, ++job) {
			if (job->status == PROC_THREAD_FINISHED_m12) {
				
				new_job = jobs + new_job_idx;

				// launch new job
				PROC_launch_thread_m12(&new_job->thread_id, new_job->thread_f, (void *) new_job, new_job->priority, NULL, &cpu_set, TRUE_m12, new_job->thread_label);
				
				// check if done
				if (++new_job_idx == n_jobs)
					break;
				
				// make sure status set in thread (volatile)
				while (new_job->status == PROC_THREAD_WAITING_m12);
			}
		}
		// don't peg this cpu
		G_nap_m12("100 us");
	}
	
	if (wait_jobs == TRUE_m12)
		return(PROC_wait_jobs_m12(jobs, n_jobs));
	else
		return(UNKNOWN_m12);
}


cpu_set_t_m12	*PROC_generate_cpu_set_m12(si1 *affinity_str, cpu_set_t_m12 *passed_cpu_set_p)
{
	TERN_m12        	not_flag, lessthan_flag, greaterthan_flag;
	si1             	*aff_str;
	si4             	i, n_cpus, start_num, end_num, cpus_set;
	cpu_set_t_m12 		*cpu_set_p;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	/* affinity string examples
	"a" or "all" set to all logical cpus  // same as not specifying a cpu set on most OS's
	"0" set to cpu 0  (read: "0")
	"~0" set to any cpu except 0  (read: "not 0")  // this is the default setting if no cpus are specified
	"<2" set to any cpu less than 2  (read: "less than 2")
	"~<2" set to any cpu greater than or equal to 2  (read: "not less than 2")
	">2" set to any cpu greater than 2  (read: "greater than 2")
	"~>2" set to any cpu less than or equal to 2  (read: "not greater than 2")
	"2-5" set to cpus 2 through 5  (read: "2 through 5")
	"~2-5" set to any cpu except 2 through 5  (read: "not 2 through 5")
	*/
	
	if (passed_cpu_set_p == NULL)  // up to caller to receive & free
		cpu_set_p = (cpu_set_t_m12 *) malloc_m12(sizeof(cpu_set_t_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	else
		cpu_set_p = passed_cpu_set_p;

	// get logical cpus
	if (global_tables_m12->HW_params.logical_cores == 0)
		HW_get_core_info_m12();
	n_cpus = global_tables_m12->HW_params.logical_cores;
	if (n_cpus == 1) {
	#ifdef LINUX_m12
		CPU_ZERO(cpu_set_p);
		CPU_SET(0, cpu_set_p);
	#endif
	#if defined MACOS_m12 || defined WINDOWS_m12
		*cpu_set_p = 1;
	#endif
		return(cpu_set_p);
	}

	// set default
	if (G_empty_string_m12(affinity_str) == TRUE_m12)
		affinity_str = "~0";  // reserve first cpu for os
#ifdef WINDOWS_m12
	si1	tmp_aff_str[16];

	// NOTE: in Windows, if all cpus are made available, OS will put all threads on CPU 0
	if (strcmp(affinity_str, "~0") == 0) {
		affinity_str = tmp_aff_str;
		sprintf(affinity_str, "~%d", n_cpus - 1);  // switch to last cpu for Windows
	}
#endif

	// parse affinity string
	aff_str = affinity_str;
	not_flag = FALSE_m12;
	if (*aff_str == '~') {
		not_flag = TRUE_m12;
		++aff_str;
	}
	if (*aff_str == 'a')
		end_num = n_cpus - 1;
	lessthan_flag = greaterthan_flag = FALSE_m12;
	if (*aff_str == '<') {
		lessthan_flag = TRUE_m12;
		++aff_str;
	} else if (*aff_str == '>') {
		greaterthan_flag = TRUE_m12;
		++aff_str;
	}
	start_num = 0;
	while (*aff_str >= '0' && *aff_str <= '9') {
		start_num *= 10;
		start_num += *aff_str - '0';
		++aff_str;
	}
	if (*aff_str == '-') {
		++aff_str;
		end_num = 0;
		while (*aff_str >= '0' && *aff_str <= '9') {
			end_num *= 10;
			end_num += *aff_str - '0';
			++aff_str;
		}
	} else {
		if (lessthan_flag == TRUE_m12) {
			end_num = start_num;
			start_num = 0;
		} else if (greaterthan_flag == TRUE_m12) {
			++start_num;
			end_num = n_cpus - 1;
		} else {
			end_num = start_num;
		}
	}
	if (start_num > (n_cpus - 1))
		start_num = (n_cpus - 1);
	if (end_num > (n_cpus - 1))
		end_num = (n_cpus - 1);
#ifdef WINDOWS_m12
	// NOTE: in Windows, if all cpus are made available, OS will put all threads on CPU zero
	if (start_num == 0 && end_num == (n_cpus - 1))
		if (--end_num < start_num)
			end_num = start_num;
#endif

	// build affinity set
#ifdef LINUX_m12
	if (not_flag == TRUE_m12) {
		for (i = 0; i < n_cpus; ++i)  // set all bits
			CPU_SET(i, cpu_set_p);
		for (cpus_set = n_cpus, i = start_num; i <= end_num; ++i, --cpus_set)
			CPU_CLR(i, cpu_set_p);
	} else {
		CPU_ZERO(cpu_set_p);
		for (cpus_set = 0, i = start_num; i <= end_num; ++i, ++cpus_set)
			CPU_SET(i, cpu_set_p);
	}
#endif

#if defined MACOS_m12 || defined WINDOWS_m12
	cpu_set_t_m12	mask;

	mask = 1 << start_num;
	*cpu_set_p = 0;
	for (cpus_set = 0, i = start_num; i <= end_num; ++i, mask <<= 1, ++cpus_set)
		*cpu_set_p |= mask;
	if (not_flag == TRUE_m12) {
		*cpu_set_p = ~*cpu_set_p;
		cpus_set = n_cpus - cpus_set;
	}
#endif
	
	if (cpus_set == 0) {
		G_warning_message_m12("%s(): no cpus specified => setting to ~0\n");
#ifdef LINUX_m12
		CPU_CLR(0, cpu_set_p);  // leave first cpu open for Linux
		for (i = 1; i < n_cpus; ++i)  // set all remaining bits
			CPU_SET(i, cpu_set_p);
#endif
#ifdef MACOS_m12
		*cpu_set_p = ~((cpu_set_t_m12) 1);  // leave first cpu open for MacOS
#endif
#ifdef WINDOWS_m12
		*cpu_set_p = (cpu_set_t_m12) (((ui8) 1 << (n_cpus - 1)) - 1);  // leave last cpu open for Windows
#endif

	}

	return(cpu_set_p);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
pid_t_m12	PROC_getpid_m12(void)
{
#if defined MACOS_m12 || defined LINUX_m12
	return(getpid());
#endif
#ifdef WINDOWS_m12
	return(GetCurrentProcessId());
#endif
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
pid_t_m12	PROC_gettid_m12(void)
{
#ifdef LINUX_m12
	return(gettid());
#endif
	
#ifdef MACOS_m12
	pid_t_m12	tid;
	
	pthread_threadid_np(NULL, &tid);  // NULL for thread returns current thread id
	return(tid);
#endif
	
#ifdef WINDOWS_m12
	return(GetCurrentThreadId());
#endif
}


TERN_m12	PROC_increase_process_priority_m12(TERN_m12 verbose_flag, si4 sudo_prompt_flag, ...)  // varargs (sudo_prompt_flag == TRUE_m12): si1 *exec_name, sf8 timeout_secs;
{
	TERN_m12	ret_val;
	
#ifdef FN_DEBUG_m12  // don't use MED print functions until medlib is initialized
	#ifdef MATLAB_m12
	mexPrintf("%s()\n", __FUNCTION__);
	#else
	printf("%s()\n", __FUNCTION__);
	#endif
#endif

	// verbose_flag passed because this function is usually called before the MED libraries are initialized
	// no printf_m12() calls for the same reason
	
	#if (defined MACOS_m12 || defined LINUX_m12) && !defined MATLAB_m12
	if (sudo_prompt_flag == TRUE_m12) {
		
		uid_t	effective_user = geteuid();
		
		if (effective_user == 0) {  // just reset sudo timeout if necessary (root UID == 0 so this should not prompt)
			system("sudo -l > /dev/null");
		} else {
			si1			pw[MAX_ASCII_PASSWORD_STRING_BYTES_m12], command[1024], *exec_name;
			sf8			timeout_secs;
			va_list			arg_p;
			pid_t			pid;
			
			
			// check that medlib initialized (required for G_enter_ascii_password_m12)
			if (globals_m12 == NULL) {
				#ifdef MATLAB_m12
				sprintf((char *) command, "\n%s(): initialize medlib before calling with sudo_prompt_flag\n\n", __FUNCTION__);
				mexErrMsgTxt(command);
				#else
				fprintf(stderr, "\n%s(): initialize medlib before calling with sudo_prompt_flag => exiting\n\n", __FUNCTION__);
				exit(-1);
				#endif
			}

			// get varargs
			va_start(arg_p, sudo_prompt_flag);
			exec_name = va_arg(arg_p, si1 *);
			timeout_secs = va_arg(arg_p, sf8);
			va_end(arg_p);
			
			if (G_enter_ascii_password_m12(pw, "Enter sudo password", FALSE_m12, (sf8) timeout_secs, FALSE_m12) == TRUE_m12) {
				if (*pw) {
					// change executable's permissions (for subsequent runs)
					// (changing permissions may fail silently if executable is on a network file system, or NOSUID bit set on volume)
					G_push_behavior_m12(SUPPRESS_OUTPUT_m12 | RETURN_ON_FAIL_m12);
					sprintf_m12(command, "echo %s | sudo -S chown root %s", pw, exec_name);  // in case owner wasn't root
					if (system_m12(command, TRUE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12)) {  // just check for password failure once
						G_pop_behavior_m12();
						G_warning_message_m12("%s(): Invalid sudo password\n", __FUNCTION__);
						return(FALSE_m12);
					}
					sprintf_m12(command, "echo %s | sudo -S chmod g+x %s", pw, exec_name);  // in case group didn't have execute permissions
					system_m12(command, TRUE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
					sprintf_m12(command, "echo %s | sudo -S chmod ug+s %s", pw, exec_name);  // set the "set-user" bits (must do owner and group)
					system_m12(command, TRUE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
					// renice in shell with sudo password (can't change current process priority from within process unless UID is root, or change kernel CAP_SETUID to true)
					pid = getpid();
					sprintf_m12(command, "echo %s | sudo -S renice %d -p %d", pw, PRIO_MIN, pid);
					if (system_m12(command, TRUE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12)) {
						G_pop_behavior_m12();
						return(FALSE_m12);
					}
					G_pop_behavior_m12();
					return(TRUE_m12);
				} else {
					return(FALSE_m12);  // no password entered
				}
			} else {
				return(FALSE_m12);
			}
		}
	}
	#endif

	ret_val = TRUE_m12;
	#if defined MACOS_m12 || defined LINUX_m12
	if (setpriority(PRIO_PROCESS, 0, PRIO_MIN))
		ret_val = FALSE_m12;
	#endif

	#ifdef WINDOWS_m12
	if ((ret_val = SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS)) == 0)  // zero indicates failure in Windows
		ret_val = FALSE_m12;
	#endif
	
	if (ret_val == FALSE_m12 && verbose_flag == TRUE_m12) {
	#if defined MACOS_m12 || defined LINUX_m12
		#ifdef MATLAB_m12
		mexPrintf("%s(): could not increase priority\nTo run with high priority, in a terminal type: \"sudo chown root <mex file>; sudo chmod ug+s <mex file>\"\n", __FUNCTION__);
		#else
		fprintf(stderr, "%s(): could not increase priority\nTo run with high priority, run with sudo or as root.\nOr: \"sudo chown root <program name>; sudo chmod ug+s <program name>\"\n", __FUNCTION__);
		#endif
	#endif
		
	#ifdef WINDOWS_m12
		#ifdef MATLAB_m12
		mexPrintf("%s(): could not increase priority\n", __FUNCTION__);
		#else
		fprintf(stderr, "%s(): could not increase priority\n", __FUNCTION__);
		#endif
	#endif
	}
	
	return(ret_val);
}


#if defined MACOS_m12 || defined LINUX_m12
ui4    PROC_launch_thread_m12(pthread_t_m12 *thread_id_ptr, pthread_fn_m12 thread_f, void *arg, si4 priority, si1 *affinity_str, cpu_set_t_m12 *cpu_set_p, TERN_m12 detached, si1 *thread_name)
{
	sf8              	f_min_priority, f_max_priority;
	pthread_t		*thread_id_p, local_thread_id_p;
	pthread_attr_t          thread_attributes;
	struct sched_param      scheduling_parameters;
	static si4		min_priority = PROC_UNDEFINED_PRIORITY_m12, low_priority, medium_priority, high_priority, max_priority;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (thread_id_ptr == NULL)  // caller doesn't need thread_id - detached thread
		thread_id_p = &local_thread_id_p;
	else
		thread_id_p = (pthread_t *) thread_id_ptr;
	
	pthread_attr_init(&thread_attributes);
	
	if (priority != PROC_DEFAULT_PRIORITY_m12) {
		pthread_attr_getschedparam(&thread_attributes, &scheduling_parameters);
		if (min_priority == PROC_UNDEFINED_PRIORITY_m12) {  // only do this once
			f_max_priority = (sf8) sched_get_priority_max(SCHED_OTHER);
			f_min_priority = (sf8) sched_get_priority_min(SCHED_OTHER);
			low_priority = (si4) round((0.75 * f_min_priority) + (0.25 * f_max_priority));
			medium_priority = (si4) round(0.5 * (f_min_priority + f_max_priority));
			high_priority = (si4) round((0.25 * f_min_priority) + (0.75 * f_max_priority));
			max_priority = (si4) f_max_priority;
			min_priority = (si4) f_min_priority;
		}
		switch (priority) {
			case PROC_MIN_PRIORITY_m12:
				scheduling_parameters.sched_priority = min_priority;
				break;
			case PROC_LOW_PRIORITY_m12:
				scheduling_parameters.sched_priority = low_priority;
				break;
			case PROC_MEDIUM_PRIORITY_m12:
				scheduling_parameters.sched_priority = medium_priority;
				break;
			case PROC_HIGH_PRIORITY_m12:
				scheduling_parameters.sched_priority = high_priority;
				break;
			case PROC_MAX_PRIORITY_m12:
				scheduling_parameters.sched_priority = max_priority;
				break;
			default: // caller passed priority value
				scheduling_parameters.sched_priority = priority;
				break;
		}
		pthread_attr_setschedparam(&thread_attributes, &scheduling_parameters);
	}

	if (detached == TRUE_m12)
		pthread_attr_setdetachstate(&thread_attributes, PTHREAD_CREATE_DETACHED);

# ifdef LINUX_m12
	TERN_m12	free_cpu_set = FALSE_m12;
	
	// generate affinity
	if (G_empty_string_m12(affinity_str) == FALSE_m12) {
		if (cpu_set_p == NULL)  // PROC_generate_cpu_set_m12() will allocate
			free_cpu_set = TRUE_m12;
		cpu_set_p = PROC_generate_cpu_set_m12(affinity_str, cpu_set_p);
	}
	// set affinity
	if (cpu_set_p != NULL) {
		PROC_set_thread_affinity_m12(NULL, &thread_attributes, cpu_set_p, TRUE_m12);
		if (free_cpu_set == TRUE_m12)
			free((void *) cpu_set_p);
	}
# endif  // LINUX_m12

	// start thread
	pthread_create(thread_id_p, &thread_attributes, thread_f, arg);

	// finished with attributes (destroy, or get memory leak)
	pthread_attr_destroy(&thread_attributes);

	// set thread name
# ifdef LINUX_m12
	if (G_empty_string_m12(thread_name) == FALSE_m12)
		pthread_setname_np(*thread_id_p, thread_name);  // _np is for "not portable"
# endif  // LINUX_m12
	
	return(1);  // zero indicates failure (for compatibility with Windows version)
}
#endif  // MACOS_m12 || LINUX_m12


#ifdef WINDOWS_m12
ui4    PROC_launch_thread_m12(pthread_t_m12 *thread_handle_p, pthread_fn_m12 thread_f, void *arg, si4 priority, si1 *affinity_str, cpu_set_t_m12 *cpu_set_p, TERN_m12 detached, si1 *thread_name)
{
	TERN_m12	free_cpu_set;
	HANDLE		*thread_hp, local_thread_h;
	ui4		thread_id;
	wchar_t		w_thread_name[THREAD_NAME_BYTES_m12];

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// returns thread id
	if (thread_handle_p == NULL)  // caller doesn't need thread_id - detached thread
		thread_hp = &local_thread_h;
	else
		thread_hp = thread_handle_p;

	// Create thread in suspended state so can set attributes
	thread_id = 0;  // zero indicates failure
	*thread_hp = (HANDLE) _beginthreadex(NULL, 0, (LPTHREAD_START_ROUTINE) thread_f, arg, CREATE_SUSPENDED, &thread_id);
	// _beginthreadex() is supposed to be better than CreateThread() for memory leaks & cleanup - called identically

	// Set Priority
	if (priority != PROC_DEFAULT_PRIORITY_m12) {
		switch (priority) {
			case PROC_MIN_PRIORITY_m12:
				priority = THREAD_PRIORITY_LOWEST;
				break;
			case PROC_LOW_PRIORITY_m12:
				priority = THREAD_PRIORITY_BELOW_NORMAL;
				break;
			case PROC_MEDIUM_PRIORITY_m12:
				priority = THREAD_PRIORITY_NORMAL;
				break;
			case PROC_HIGH_PRIORITY_m12:
				priority = THREAD_PRIORITY_ABOVE_NORMAL;
				break;
			case PROC_MAX_PRIORITY_m12:
				priority = THREAD_PRIORITY_HIGHEST;
				break;
			default: // caller passed priority value
				break;
		}
		SetThreadPriority(*thread_hp, priority);
	}
	
	// Set Affinity
	free_cpu_set = FALSE_m12;
	if (G_empty_string_m12(affinity_str) == FALSE_m12) {
		if (cpu_set_p == NULL)
			free_cpu_set = TRUE_m12;  // PROC_generate_cpu_set_m12() will allocate
		cpu_set_p = PROC_generate_cpu_set_m12(affinity_str, cpu_set_p);
	}
	if (cpu_set_p != NULL) {
		PROC_set_thread_affinity_m12(thread_hp, NULL, cpu_set_p, TRUE_m12);
		if (free_cpu_set == TRUE_m12)
			free((void *) cpu_set_p);
	}
	
	// set thread name
	if (G_empty_string_m12(thread_name) == FALSE_m12) {
		STR_char2wchar_m12(w_thread_name, thread_name);
		SetThreadDescription(*thread_hp, w_thread_name);
	}
	
	// start thread
	ResumeThread(*thread_hp);

	// detach thread
	if (detached == TRUE_m12)
		CloseHandle(*thread_hp);
	
	return(thread_id);  // zero indicates failure
}
#endif  // WINDOWS_m12


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	PROC_pthread_join_m12(pthread_t_m12 thread_id, void **value_ptr)
{
	si4	ret_val;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

#if defined MACOS_m12 || defined LINUX_m12
	ret_val = pthread_join(thread_id, value_ptr);
#endif
#ifdef WINDOWS_m12
	if (WaitForSingleObject(thread_id, INFINITE) == WAIT_OBJECT_0)
		ret_val = 0;
	else
		ret_val = -1;
#endif

	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	PROC_pthread_mutex_destroy_m12(pthread_mutex_t_m12 *mutex)
{
	si4	ret_val;
		
#if defined MACOS_m12 || defined LINUX_m12
	ret_val = pthread_mutex_destroy(mutex);
#endif
#ifdef WINDOWS_m12
	ret_val = (si4) CloseHandle(*mutex) - (si4) 1;  // CloseHandle returns zero on fail
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	PROC_pthread_mutex_init_m12(pthread_mutex_t_m12 *mutex, pthread_mutexattr_t_m12 *attr)
{
	si4	ret_val;
	
#if defined MACOS_m12 || defined LINUX_m12
	ret_val = pthread_mutex_init(mutex, attr);
#endif
#ifdef WINDOWS_m12
	if ((*mutex = CreateMutex(attr, 0, NULL)) == NULL)
		ret_val = -1;
	else
		ret_val = 0;
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	PROC_pthread_mutex_lock_m12(pthread_mutex_t_m12 *mutex)
{
	si4	ret_val;
	
#if defined MACOS_m12 || defined LINUX_m12
	ret_val = pthread_mutex_lock(mutex);
#endif
#ifdef WINDOWS_m12
	if (WaitForSingleObject(*mutex, INFINITE) == WAIT_OBJECT_0)
		ret_val = 0;
	else
		ret_val = -1;
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	PROC_pthread_mutex_unlock_m12(pthread_mutex_t_m12 *mutex)
{
	si4	ret_val;
	
#if defined MACOS_m12 || defined LINUX_m12
	ret_val = pthread_mutex_unlock(mutex);
#endif
#ifdef WINDOWS_m12
	if (ReleaseMutex(*mutex) == 0)
		ret_val = -1;
	else
		ret_val = 0;
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
pthread_t_m12	PROC_pthread_self_m12(void)
{
#if defined MACOS_m12 || defined LINUX_m12
	return(pthread_self());
#endif
	
#ifdef WINDOWS_m12
	return(GetCurrentThread());
#endif
}


#ifdef LINUX_m12
TERN_m12    PROC_set_thread_affinity_m12(pthread_t_m12 *thread_id_p, pthread_attr_t_m12 *attributes, cpu_set_t_m12 *cpu_set_p, TERN_m12 wait_for_lauch)
{
	const si4	MAX_ATTEMPTS = 10;
	TERN_m12	use_attributes;
	si1		thread_name[THREAD_NAME_BYTES_m12];
	si4		err, attempts;
	pthread_t	thread_id;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// if thread_id_p is passed, it is used
	// if thread_id_p is NULL & attributes is passed, it is used
	// attributes allow affinity to be set before thread is launched
	// thread_id can be used to change affinity while thread is running
	
	if (thread_id_p == NULL) {
		if (attributes == NULL)
			return(FALSE_m12);
		err = pthread_attr_setaffinity_np((pthread_attr_t *) attributes, sizeof(cpu_set_t), cpu_set_p);  // _np is for "not portable"
		use_attributes = TRUE_m12;
	} else {
		thread_id = *((pthread_t *) thread_id_p);
		err = pthread_setaffinity_np(thread_id, sizeof(cpu_set_t), cpu_set_p);  // _np is for "not portable"
		use_attributes = FALSE_m12;
	}
	
	if (wait_for_lauch == TRUE_m12) {
		for (attempts = MAX_ATTEMPTS; err == ESRCH && attempts--;) {  // ESRCH == "thread not found" => threads can take a beat to launch
			G_nap_m12("10 ms");
			if (use_attributes == TRUE_m12)
				err = pthread_attr_setaffinity_np((pthread_attr_t *) attributes, sizeof(cpu_set_t), cpu_set_p);  // _np is for "not portable"
			else
				err = pthread_setaffinity_np(thread_id, sizeof(cpu_set_t), cpu_set_p);  // _np is for "not portable"
		}
	}
	
	if (err) {
		*thread_name = 0;
		if (thread_id_p != NULL)
			pthread_getname_np(thread_id, thread_name, (size_t) THREAD_NAME_BYTES_m12);  // _np is for "not portable"
		if (*thread_name)
			G_warning_message_m12("%s(): error setting affinity for thread \"%s\" => not set", __FUNCTION__, thread_name);
		else
			G_warning_message_m12("%s(): error setting thread affinity => not set", __FUNCTION__);
		return(FALSE_m12);
	}
	
	return(TRUE_m12);
}
#endif  // LINUX_m12


#ifdef WINDOWS_m12
TERN_m12    PROC_set_thread_affinity_m12(pthread_t_m12 *thread_handle_p, pthread_attr_t_m12 *attributes, cpu_set_t_m12 *cpu_set_p, TERN_m12 wait_for_lauch)
{
	const si4	MAX_ATTEMPTS = 100;
	si1		thread_name[THREAD_NAME_BYTES_m12];
	wchar_t		*w_thread_name;
	si4		err, attempts;
	HANDLE		thread_h;
	HRESULT		hr;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// no correlate of attributes in Windows (argument ignored)
	
	thread_h = *((HANDLE *) thread_handle_p);
	err = SetThreadAffinityMask(thread_h, (DWORD_PTR) *cpu_set_p);  // Note Windows uses DWORD_PTR to ensure a ui8 - not used as pointer to ui4
	
	if (wait_for_lauch == TRUE_m12) {
		for (attempts = MAX_ATTEMPTS; err == 0 && attempts--;) {  // zero == unspecified error => can take a bit to launch
			G_nap_m12("10 ms");
			err = SetThreadAffinityMask(thread_h, (DWORD_PTR) *cpu_set_p);  // Note Windows uses DWORD_PTR to ensure a ui8 - not used as pointer to ui4
		}
	}
    
	if (err == 0) {
		*thread_name = 0;
		hr = GetThreadDescription(thread_h, (PWSTR *) &w_thread_name);
		if (SUCCEEDED(hr)) {
			STR_wchar2char_m12(thread_name, w_thread_name);
			free((void *) w_thread_name);
		}
		if (*thread_name)
			G_warning_message_m12("%s(): error setting affinity for thread \"%s\" => not set", __FUNCTION__, thread_name);
		else
			G_warning_message_m12("%s(): error setting thread affinity => not set", __FUNCTION__);
		return(FALSE_m12);
	}

	return(TRUE_m12);
}
#endif  // WINDOWS_m12


#ifdef MACOS_m12
TERN_m12    PROC_set_thread_affinity_m12(pthread_t_m12 *thread_id_p, pthread_attr_t_m12 *attributes, cpu_set_t_m12 *cpu_set_p, TERN_m12 wait_for_lauch)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// setting processor affinities can be done in MacOS but takes some work (see http://www.hybridkernel.com/2015/01/18/binding_threads_to_cores_osx.html)
	// this site suggests that it must be one core to one thread, not a range, which could be ok, but probably better to do some more reading
	
	*cpu_set_p = 0xFFFFFFFE;
	
	return(TRUE_m12);
}
#endif


#ifdef MACOS_m12
void    PROC_show_thread_affinity_m12(pthread_t_m12 *thread_id_p)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	return;  // thread affinity can be done in MacOS, but it takes some work
}
#endif  // MACOS_m12


#ifdef LINUX_m12
void    PROC_show_thread_affinity_m12(pthread_t_m12 *thread_id_p)
{
	si1		thread_name[THREAD_NAME_BYTES_m12];
	si4             i, n_cpus;
	cpu_set_t       cpu_set;
	pthread_t 	thread_id;
    
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	thread_id = *thread_id_p;

	*thread_name = 0;
	pthread_getname_np(thread_id, thread_name, (size_t) THREAD_NAME_BYTES_m12);  // _np is for "not portable"
	if (*thread_name)
		printf_m12("thread \"%s()\": ", thread_name);
	
	pthread_getaffinity_np(thread_id, sizeof(cpu_set_t), &cpu_set);  // _np is for "not portable"
	
	if (global_tables_m12->HW_params.logical_cores == 0)
		HW_get_core_info_m12();
	n_cpus = global_tables_m12->HW_params.logical_cores;
	for (i = 0; i < n_cpus; ++i) {
		if (CPU_ISSET(i, &cpu_set))
			printf_m12("1 ");
		else
			printf_m12("0 ");
	}
	printf_m12("\n\n");

	return;
}
#endif  // LINUX_m12


#ifdef WINDOWS_m12
void    PROC_show_thread_affinity_m12(pthread_t_m12 *thread_id_p)
{
	si1		thread_name[THREAD_NAME_BYTES_m12];
	wchar_t		*w_thread_name;
	si4             i, n_cpus;
	cpu_set_t_m12	cpu_set, tmp_cpu_set, mask;
	HANDLE 		thread_h;
	HRESULT		hr;
    
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	thread_h = *thread_id_p;

	SuspendThread(thread_h);  // suspend thread to get current cpu set
	tmp_cpu_set = ~((cpu_set_t_m12) 0);
	cpu_set = (cpu_set_t_m12) SetThreadAffinityMask(thread_h, (DWORD_PTR) tmp_cpu_set);  // use SetThreadAffinityMask() to return existing cpu set
	tmp_cpu_set = (cpu_set_t_m12) SetThreadAffinityMask(thread_h, (DWORD_PTR) cpu_set);  // reset to existing cpu set
	ResumeThread(thread_h);

	if (tmp_cpu_set == 0) {
		G_warning_message_m12("%s(): error %d from SetThreadAffinityMask()\n", __FUNCTION__, GetLastError());
		return;
	}

	*thread_name = 0;
	hr = GetThreadDescription(thread_h, (PWSTR *) &w_thread_name);
	if (SUCCEEDED(hr)) {
		STR_wchar2char_m12(thread_name, w_thread_name);
		free((void *) w_thread_name);
	}
	if (*thread_name)
		printf_m12("thread \"%s()\": ", thread_name);
	else
		printf_m12("thread: ");
	
	if (global_tables_m12->HW_params.logical_cores == 0)
		HW_get_core_info_m12();
	n_cpus = global_tables_m12->HW_params.logical_cores;
	
	for (mask = 1, i = 0; i < n_cpus; ++i, mask <<= 1) {
		if (cpu_set & mask)
			printf_m12("1 ");
		else
			printf_m12("0 ");
	}
	printf_m12("\n\n");

	return;
}
#endif  // WINDOWS


TERN_m12	PROC_wait_jobs_m12(PROC_THREAD_INFO_m12 *jobs, si4 n_jobs)
{
	si4	i, finished_jobs;
	
	
	while (1) {
		for (i = finished_jobs = 0; i < n_jobs; ++i) {
			if (jobs[i].status == PROC_THREAD_FINISHED_m12)
				++finished_jobs;
		}
		if (finished_jobs == n_jobs)
			break;
		
		// don't peg this cpu
		G_nap_m12("100 us");
	}
	
	#ifdef MATLAB_m12
	G_pop_behavior_m12();  // set in PROC_distribute_jobs_m12()
	#endif
	
	return(TRUE_m12);
}



//********************************************//
// MARK: PARITY FUNCTIONS  (PRTY)
//********************************************//


TERN_m12	PRTY_build_m12(PRTY_m12 *parity_ps)
{
	TERN_m12		video_data;
	ui1			*parity, *data, MED_version_major, MED_version_minor, byte_order_code;
	si1			*parity_path, session_name[BASE_FILE_NAME_BYTES_m12], channel_name[BASE_FILE_NAME_BYTES_m12];
	si1			tmp_str[FULL_FILE_NAME_BYTES_m12], command[FULL_FILE_NAME_BYTES_m12 + 32], type_string[TYPE_BYTES_m12];
	ui4			type_code;
	si4			i, j, n_files, segment_number;
	ui8			session_UID, channel_UID, segment_UID, *target_ptr, *source_ptr;
	si8			nr, nw, mem_block_bytes, bytes_read, bytes_written, bytes_remaining, bytes_to_read, bytes_to_write, target_len;
	PRTY_FILE_m12		*files, *target_file, *source_file;
	FILE			*parity_fp;
	UNIVERSAL_HEADER_m12	*uh;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// break out ps
	files = parity_ps->files;
	n_files = parity_ps->n_files;
	parity = parity_ps->parity;
	data = parity_ps->data;
	mem_block_bytes = parity_ps->mem_block_bytes;
	parity_path = parity_ps->path;
	
	// copy single files (they're their own parity)
	if (n_files == 1) {
		if (G_file_exists_m12(files[0].path) == FILE_EXISTS_m12) {
			#if defined MACOS_m12 || defined LINUX_m12
			sprintf_m12(command, "cp \"%s\" \"%s\"", files[0].path, parity_path);
			#endif
			#ifdef WINDOWS_m12
			sprintf_m12(command, "copy \"%s\" \"%s\"", files[0].path, parity_path);
			#endif
			system_m12(command, TRUE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		}
		return(TRUE_m12);
	}

	// zero arrays
	memset((void *) parity, (si4) 0, (size_t) mem_block_bytes);
	memset((void *) data, (si4) 0, (size_t) mem_block_bytes);

	// open files
	for (i = 0; i < n_files; ++i) {
		if (G_file_exists_m12(files[i].path) == FILE_EXISTS_m12) {
			files[i].fp = fopen_m12(files[i].path, "r", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			files[i].len = G_file_length_m12(files[i].fp, NULL);
		}
	}

	// sort by length
	qsort((void *) files, (size_t) n_files, sizeof(PRTY_FILE_m12), PRTY_file_compare_m12);
	
	// open parity file
	--n_files;  // longest (last) file is starting data for parity
	
	// make path
	G_extract_path_parts_m12(parity_path, tmp_str, NULL, NULL);
	if (G_file_exists_m12(tmp_str) != DIR_EXISTS_m12) {
		#if defined MACOS_m12 || defined LINUX_m12
		sprintf_m12(command, "mkdir -p \"%s\"", tmp_str);
		#endif
		#ifdef WINDOWS_m12
		sprintf_m12(command, "mkdir \"%s\"", tmp_str);
		#endif
		system_m12(command, TRUE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	}
	parity_fp = fopen_m12(parity_path, "w+", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	// check if video_data
	G_extract_path_parts_m12(files[0].path, NULL, tmp_str, NULL);
	type_code = G_MED_type_code_from_string_m12(tmp_str);
	video_data = FALSE_m12;
	if (type_code == VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12) {
		type_code = G_MED_type_code_from_string_m12(files[0].path);
		if (type_code == NO_TYPE_CODE_m12)  //  non-MED extension
			video_data = TRUE_m12;
	}

	// build parity
	bytes_read = bytes_written = 0;
	target_file = files + n_files;
	target_len = target_file->len;
	while (bytes_read < target_len) {
		// read basis file (longest)
		bytes_remaining = target_len - bytes_read;
		bytes_to_read = mem_block_bytes;
		if (bytes_remaining < mem_block_bytes)
			bytes_to_read = bytes_remaining;
		bytes_to_write = bytes_to_read;
		nr = fread((void *) parity, sizeof(ui1), (size_t) bytes_to_read, target_file->fp);
		if (nr != bytes_to_read) {
			G_error_message_m12("%s(): error reading file \"%s\" => exiting\n", __FUNCTION__, target_file->path);
			exit(-1);
		}
		bytes_read += nr;
		// preserve non-paritied universal header fields
		if (bytes_read == 0 && video_data == FALSE_m12) {
			uh = (UNIVERSAL_HEADER_m12 *) parity;
			strncpy_m12(type_string, uh->type_string, TYPE_BYTES_m12);
			MED_version_major = uh->MED_version_major;
			MED_version_minor = uh->MED_version_minor;
			byte_order_code = uh->byte_order_code;
			segment_number = uh->segment_number;
			strncpy_m12(session_name, uh->session_name, BASE_FILE_NAME_BYTES_m12);
			strncpy_m12(channel_name, uh->channel_name, BASE_FILE_NAME_BYTES_m12);
			session_UID = uh->session_UID;
			channel_UID = uh->channel_UID;
			segment_UID = uh->segment_UID;
		}
		
		for (i = 0; i < n_files; ++i) {
			// read source file
			source_file = files + i;
			if (source_file->finished == TRUE_m12)
				continue;
			bytes_to_read = source_file->len - bytes_written;
			if (bytes_to_read > mem_block_bytes)
				bytes_to_read = mem_block_bytes;
			else
				source_file->finished = TRUE_m12;
			nr = fread((void *) data, sizeof(ui1), (size_t) bytes_to_read, source_file->fp);
			if (nr != bytes_to_read) {
				G_error_message_m12("%s(): error reading file \"%s\" => exiting\n", __FUNCTION__, source_file->path);
				exit(-1);
			}

			// add to parity array
			target_ptr = (ui8 *) parity;
			source_ptr = (ui8 *) data;
			for (j = bytes_to_read >> 3; j--;)
				*target_ptr++ ^= *source_ptr++;
		}

		// write out new parity
		nw = fwrite((void *) parity, sizeof(ui1), (size_t) bytes_to_write, parity_fp);
		if (nw != bytes_to_write) {
			G_error_message_m12("%s(): error writing file \"%s\" => exiting\n", __FUNCTION__, parity_path);
			exit(-1);
		}
		bytes_written += nw;
	}
	for (i = 0; i < n_files; ++i)
		fclose(files[i].fp);
	
	if (video_data == FALSE_m12) {
		// read in parity universal header region
		fseek_m12(parity_fp, (si8) 0, SEEK_SET, parity_path, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		nr = fread((void *) parity, sizeof(ui1), (size_t) UNIVERSAL_HEADER_BYTES_m12, parity_fp);
		if (nr != UNIVERSAL_HEADER_BYTES_m12) {
			G_error_message_m12("%s(): error reading file \"%s\" => exiting\n", __FUNCTION__, parity_path);
			exit(-1);
		}
		
		// copy preserved fields into parity universal header
		strncpy_m12(uh->type_string, type_string, TYPE_BYTES_m12);
		uh->MED_version_major = MED_version_major;
		uh->MED_version_minor = MED_version_minor;
		uh->byte_order_code = byte_order_code;
		uh->segment_number = segment_number;
		strncpy_m12(uh->session_name, session_name, BASE_FILE_NAME_BYTES_m12);
		strncpy_m12(uh->channel_name, channel_name, BASE_FILE_NAME_BYTES_m12);
		uh->session_UID = session_UID;
		uh->channel_UID = channel_UID;
		uh->segment_UID = segment_UID;
		
		// write out modified universal header
		fseek_m12(parity_fp, (si8) 0, SEEK_SET, parity_path, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		nw = fwrite((void *) parity, sizeof(ui1), (size_t) UNIVERSAL_HEADER_BYTES_m12, parity_fp);
		if (nw != UNIVERSAL_HEADER_BYTES_m12) {
			G_error_message_m12("%s(): error writing file \"%s\" => exiting\n", __FUNCTION__, parity_path);
			exit(-1);
		}
		fseek_m12(parity_fp, (si8) 0, SEEK_END, parity_path, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);  // paranoia
	}
	fclose(parity_fp);

	return(TRUE_m12);
}


si4	PRTY_file_compare_m12(const void *a, const void *b)
{
	PRTY_FILE_m12	*as, *bs;
	
	
	as = (PRTY_FILE_m12 *) a;
	bs = (PRTY_FILE_m12 *) b;
	
	if (as->len < bs->len)
		return((si4) -1);
	if (as->len > bs->len)
		return((si4) 1);
	
	return((si4) 0);
}


si1	**PRTY_file_list_m12(si1 *MED_path, si4 *n_files)  // MED_path is MED file or directory
{
	TERN_m12	sess_files, ssr_files, chan_files, all_segs;
	si1		sess_path[FULL_FILE_NAME_BYTES_m12] = { 0 };
	si1		sess_name[BASE_FILE_NAME_BYTES_m12] = { 0 };
	si1		ssr_path[FULL_FILE_NAME_BYTES_m12] = { 0 };
	si1		chan_path[FULL_FILE_NAME_BYTES_m12] = { 0 };
	si1		seg_path[FULL_FILE_NAME_BYTES_m12] = { 0 };
	si1		tmp_path[FULL_FILE_NAME_BYTES_m12] = { 0 };
	si1		tmp_str[SEGMENT_BASE_FILE_NAME_BYTES_m12] = { 0 };
	si1		**file_list, **tmp_list, **ssr_list, **chan_list, **seg_list, **vid_list;
	ui4		type_code;
	si4		i, j, k, tmp_files;
	si4		n_ssrs, n_chans, n_segs, n_vids;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// returns a list of file paths that exist at or below the passed path level
	
	G_path_from_root_m12(MED_path, tmp_path);
	
	file_list = NULL;
	*n_files = 0;

	n_chans = n_segs = 0;
	sess_files = ssr_files = chan_files = all_segs = FALSE_m12;
	type_code = G_MED_type_code_from_string_m12(tmp_path);
	ssr_list = chan_list = NULL;
	switch (type_code) {
		case SESSION_DIRECTORY_TYPE_CODE_m12:
			strcpy(sess_path, tmp_path);
			G_extract_path_parts_m12(sess_path, NULL, sess_name, NULL);
			sprintf_m12(ssr_path, "%s/%s.%s", sess_path, sess_name, RECORD_DIRECTORY_TYPE_STRING_m12);
			if (G_file_exists_m12(ssr_path) == DIR_EXISTS_m12)
				ssr_list = G_generate_file_list_m12(NULL, &n_ssrs, ssr_path, NULL, "r*", GFL_FULL_PATH_m12);
			chan_list = G_generate_file_list_m12(NULL, &n_chans, sess_path, NULL, "?icd", GFL_FULL_PATH_m12);
			sess_files = ssr_files = chan_files = all_segs = TRUE_m12;
			break;
		case RECORD_DIRECTORY_TYPE_CODE_m12:
			strcpy(ssr_path, tmp_path);
			G_extract_path_parts_m12(ssr_path, sess_path, sess_name, NULL);
			ssr_list = G_generate_file_list_m12(NULL, &n_ssrs, ssr_path, NULL, "r*", GFL_FULL_PATH_m12);
			ssr_files = TRUE_m12;
			break;
		case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:
			strcpy(chan_path, tmp_path);
			G_extract_path_parts_m12(chan_path, sess_path, NULL, NULL);
			sess_files = ssr_files = FALSE_m12;
			chan_list = (si1 **) calloc_2D_m12((size_t) 1, (size_t) FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			strcpy(chan_list[0], chan_path);
			chan_files = all_segs = TRUE_m12;
			n_chans = 1;
			break;
		case TIME_SERIES_SEGMENT_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_SEGMENT_DIRECTORY_TYPE_CODE_m12:
			strcpy(seg_path, tmp_path);
			G_extract_path_parts_m12(seg_path, chan_path, NULL, NULL);
			G_extract_path_parts_m12(chan_path, sess_path, NULL, NULL);
			n_chans = 1;
			chan_list = (si1 **) calloc_2D_m12((size_t) n_chans, (size_t) FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			strcpy(chan_list[0], chan_path);
			n_segs = 1;
			seg_list = (si1 **) calloc_2D_m12((size_t) n_segs, (size_t) FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			strcpy(seg_list[0], seg_path);
			all_segs = FALSE_m12;
			break;
		case RECORD_DATA_FILE_TYPE_CODE_m12:
		case RECORD_INDICES_FILE_TYPE_CODE_m12:
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
		case VIDEO_INDICES_FILE_TYPE_CODE_m12:
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
		case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
		case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
			if (G_file_exists_m12(tmp_path) == FILE_EXISTS_m12) {
				file_list = (si1 **) calloc_2D_m12((size_t) 1, (size_t) FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
				strcpy(file_list[0], tmp_path);
				*n_files = 1;
			}
			return(file_list);
		case NO_FILE_TYPE_CODE_m12:
			return(NULL);
	}
		
	tmp_files = MAX_OPEN_FILES_m12(2048, 1);  // max channels 2048
	tmp_list = (si1 **) calloc_2D_m12((size_t) tmp_files, (size_t) FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	tmp_files = 0;
	
	// session records
	if (sess_files == TRUE_m12) {
		sprintf_m12(tmp_path, "%s/%s.%s", sess_path, sess_name, RECORD_DATA_FILE_TYPE_STRING_m12);
		if (G_file_exists_m12(tmp_path) == FILE_EXISTS_m12)
			strcpy(tmp_list[tmp_files++], tmp_path);
		sprintf_m12(tmp_path, "%s/%s.%s", sess_path, sess_name, RECORD_INDICES_FILE_TYPE_STRING_m12);
		if (G_file_exists_m12(tmp_path) == FILE_EXISTS_m12)
			strcpy(tmp_list[tmp_files++], tmp_path);
	}

	if (ssr_files == TRUE_m12) {
		ssr_list = G_generate_file_list_m12(NULL, &n_ssrs, ssr_path, NULL, "r*", GFL_FULL_PATH_m12);
		for (i = 0; i < n_ssrs; ++i) {
			if (G_file_exists_m12(ssr_list[i]) == FILE_EXISTS_m12)
				strcpy(tmp_list[tmp_files++], ssr_list[i]);
		}
		free_m12((void *) ssr_list, __FUNCTION__);
	}
	
	for (i = 0; i < n_chans; ++i) {
		if (chan_files == TRUE_m12) {
			G_extract_path_parts_m12(chan_list[i], NULL, tmp_str, NULL);
			sprintf_m12(tmp_path, "%s/%s.%s", chan_list[i], tmp_str, RECORD_DATA_FILE_TYPE_STRING_m12);
			if (G_file_exists_m12(tmp_path) == FILE_EXISTS_m12)
				strcpy(tmp_list[tmp_files++], tmp_path);
			sprintf_m12(tmp_path, "%s/%s.%s", chan_list[i], tmp_str, RECORD_INDICES_FILE_TYPE_STRING_m12);
			if (G_file_exists_m12(tmp_path) == FILE_EXISTS_m12)
				strcpy(tmp_list[tmp_files++], tmp_path);
		}
		if (all_segs == TRUE_m12)
			seg_list = G_generate_file_list_m12(NULL, &n_segs, chan_list[i], NULL, "?isd", GFL_FULL_PATH_m12);
		
		type_code = G_MED_type_code_from_string_m12(chan_list[i]);
		for (j = 0; j < n_segs; ++j) {
			G_extract_path_parts_m12(seg_list[j], NULL, tmp_str, NULL);

			if (type_code == TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12) {
				sprintf_m12(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, TIME_SERIES_DATA_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_path) == FILE_EXISTS_m12)
					strcpy(tmp_list[tmp_files++], tmp_path);
				sprintf_m12(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, TIME_SERIES_INDICES_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_path) == FILE_EXISTS_m12)
					strcpy(tmp_list[tmp_files++], tmp_path);
				sprintf_m12(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, TIME_SERIES_METADATA_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_path) == FILE_EXISTS_m12)
					strcpy(tmp_list[tmp_files++], tmp_path);
			} else if (type_code == VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12) {
				vid_list = G_generate_file_list_m12(NULL, &n_vids, chan_list[i], "*_s????_n????", NULL, GFL_FULL_PATH_m12);
				for (k = 0; k < n_vids; ++k)
					strcpy(tmp_list[tmp_files++], vid_list[k]);
				free_m12((void *) vid_list, __FUNCTION__);
				sprintf_m12(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, VIDEO_INDICES_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_path) == FILE_EXISTS_m12)
					strcpy(tmp_list[tmp_files++], tmp_path);
				sprintf_m12(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, VIDEO_METADATA_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(tmp_path) == FILE_EXISTS_m12)
					strcpy(tmp_list[tmp_files++], tmp_path);
			}
			sprintf_m12(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, RECORD_DATA_FILE_TYPE_STRING_m12);
			if (G_file_exists_m12(tmp_path) == FILE_EXISTS_m12)
				strcpy(tmp_list[tmp_files], tmp_path);
			sprintf_m12(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, RECORD_INDICES_FILE_TYPE_STRING_m12);
			if (G_file_exists_m12(tmp_path) == FILE_EXISTS_m12)
				strcpy(tmp_list[tmp_files++], tmp_path);
		}
		free_m12((void *) seg_list, __FUNCTION__);  // free for next channel
	}
	free_m12((void *) chan_list, __FUNCTION__);

	file_list = (si1 **) calloc_2D_m12((size_t) tmp_files, (size_t) FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	for (i = 0; i < tmp_files; ++i)
		strcpy(file_list[i], tmp_list[i]);
	free_m12((void *) tmp_list, __FUNCTION__);

	*n_files = tmp_files;
	
	return(file_list);
}


TERN_m12	PRTY_repair_file_m12(PRTY_m12 *parity_ps)
{
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// internal function called from PRTY_restore_m12()
	
	// check that parity is at least as recent as rest of files
	// FILE_TIMES_m12	*G_file_times_m12(FILE *fp, si1 *path, FILE_TIMES_m12 *ft, TERN_m12 set_time)

	// check valid code for body vs uh & block offsets
	
	return(TRUE_m12);
}


TERN_m12	PRTY_restore_m12(si1 *MED_path)
{
	TERN_m12	success, video_type;
	ui1		validity_code;
	si1		sess_path[FULL_FILE_NAME_BYTES_m12], sess_name[BASE_FILE_NAME_BYTES_m12], base_name[SEGMENT_BASE_FILE_NAME_BYTES_m12];
	si1		tmp_path[FULL_FILE_NAME_BYTES_m12], **input_file_list, **ts_chan_names, **vid_chan_names, **ssr_names, **list;
	si1		parity_path[FULL_FILE_NAME_BYTES_m12];
	ui4		level_code;
	si4		i, j, k, fd, n_ts_chans, n_vid_chans, n_segs, n_input_files, n_parity_files, n_bad_blocks;
	si4		allocated_parity_files, n_repaired, n_attempted, n_skipped;
	si8		len, mmap_block_bytes, mem_block_bytes, mem_blocks;
	FILE		*fp;
	PRTY_FILE_m12	*parity_files;
	PRTY_BLOCK_m12	*bad_blocks;
	PRTY_m12	parity_ps;
	EXT_CODE_m12 	type;
	#if defined MACOS_m12 || defined LINUX_m12
	struct stat	sb;
	#endif
	#ifdef WINDOWS_m12
	HANDLE		file_h;
	DISK_GEOMETRY	disk_geom = { 0 };
	ui4		dg_result;
	#endif

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// get file list
	input_file_list = PRTY_file_list_m12(MED_path, &n_input_files);
	if (n_input_files == 0) {
		G_warning_message_m12("\n%s(): no MED files found at or below \"%s\"\n", __FUNCTION__, MED_path);
		return(FALSE_m12);
	}
	
	// get session path & name
	strcpy(sess_path, input_file_list[0]);
	G_extract_path_parts_m12(sess_path, tmp_path, NULL, type.ext);
	while (type.code != SESSION_DIRECTORY_TYPE_CODE_m12) {
		strcpy(sess_path, tmp_path);
		G_extract_path_parts_m12(sess_path, tmp_path, NULL, type.ext);
	}
	G_extract_path_parts_m12(sess_path, NULL, sess_name, NULL);
	printf_m12("%s(%d): sess_path = %s\n", __FUNCTION__, __LINE__, sess_path);
	printf_m12("%s(%d): sess_name = %s\n", __FUNCTION__, __LINE__, sess_name);

	// get volume block size
	if (globals_m12->mmap_block_bytes == GLOBALS_MMAP_BLOCK_BYTES_NO_ENTRY_m12) {
		fp = fopen_m12(input_file_list[0], "r", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);

		#if defined MACOS_m12 || defined LINUX_m12
		fd = fileno(fp);
		fstat(fd, &sb);
		mmap_block_bytes = (si8) sb.st_blksize;
		#endif
		#ifdef WINDOWS_m12
		fd = _fileno(fp);
		if ((file_h = (HANDLE) _get_osfhandle(fd)) != INVALID_HANDLE_VALUE) {
			dg_result = (ui4) DeviceIoControl(file_h, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &disk_geom, sizeof(DISK_GEOMETRY), &dg_result, (LPOVERLAPPED) NULL);
			if (dg_result == 1)
				mmap_block_bytes = (si8) disk_geom.BytesPerSector;
		}
		#endif
		fclose(fp);

		if (mmap_block_bytes <= 0)
			mmap_block_bytes = GLOBALS_MMAP_BLOCK_BYTES_DEFAULT_m12;
		globals_m12->mmap_block_bytes = mmap_block_bytes;
	} else {
		mmap_block_bytes = globals_m12->mmap_block_bytes;
	}
	
	// get parity & data arrays
	mem_block_bytes = (si8) (1 << 29);  // 500 MiB
	mem_blocks = mem_block_bytes / mmap_block_bytes;
	parity_ps.mem_block_bytes = mem_blocks * mmap_block_bytes;
	parity_ps.parity = (ui1 *) calloc((size_t) mem_block_bytes, sizeof(ui1));
	mlock_m12((void *) parity_ps.parity, (size_t) mem_block_bytes, FALSE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	parity_ps.data = (ui1 *) calloc((size_t) mem_block_bytes, sizeof(ui1));
	mlock_m12((void *) parity_ps.data, (size_t) mem_block_bytes, FALSE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	n_parity_files = allocated_parity_files = 0;
	parity_files = NULL;

	// validate & restore files
	n_repaired = n_attempted = n_skipped = 0;
	ts_chan_names = vid_chan_names = ssr_names = NULL;
	n_ts_chans = n_vid_chans = n_segs = 0;
	for (i = 0; i < n_input_files; ++i) {
		validity_code = PRTY_validate_m12(NULL, input_file_list[i], &bad_blocks, &n_bad_blocks);
		if (validity_code == PRTY_VALID_m12)
			continue;
		if (validity_code & PRTY_E_UNSPEC_m12) {
			++n_skipped;
			G_warning_message_m12("%s(): unspecified error processing file \"%s\" => skipping\n", __FUNCTION__, input_file_list[i]);
			continue;
		}
		++n_attempted;

		printf_m12("%s(%d)\n", __FUNCTION__, __LINE__);
		// get channel names, channel count, & segment count, if needed
		level_code = G_get_level_m12(input_file_list[i], &type.code);
		switch (level_code) {
			case LH_SESSION_m12:
				n_parity_files = 2;
				break;
			case LH_SEGMENTED_SESS_RECS_m12:
				if (ssr_names == NULL) {
					sprintf_m12(tmp_path, "%s/%s.%s", sess_path, sess_name, RECORD_DIRECTORY_TYPE_STRING_m12);
					ssr_names = G_generate_file_list_m12(NULL, &n_segs, tmp_path, NULL, RECORD_DATA_FILE_TYPE_STRING_m12, GFL_NAME_m12);
				}
				n_parity_files = n_segs + 1;
				list = ssr_names;
				break;
			case LH_TIME_SERIES_CHANNEL_m12:
			case LH_TIME_SERIES_SEGMENT_m12:
				if (ts_chan_names == NULL)
					ts_chan_names = G_generate_file_list_m12(NULL, &n_ts_chans, sess_path, NULL, TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12, GFL_NAME_m12);
				n_parity_files = n_ts_chans + 1;
				list = ts_chan_names;
				break;
			case LH_VIDEO_CHANNEL_m12:
			case LH_VIDEO_SEGMENT_m12:
				if (vid_chan_names == NULL)
					vid_chan_names = G_generate_file_list_m12(NULL, &n_vid_chans, sess_path, NULL, VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12, GFL_NAME_m12);
				n_parity_files = n_vid_chans + 1;
				list = vid_chan_names;
				break;
		}
		// realloc, if needed
		printf_m12("%s(%d)\n", __FUNCTION__, __LINE__);
		if (n_parity_files > allocated_parity_files) {
			parity_files = (PRTY_FILE_m12 *) realloc((void *) parity_files, (size_t) n_parity_files * sizeof(PRTY_FILE_m12));
			allocated_parity_files = n_parity_files;
		}
				
		printf_m12("%s(%d)\n", __FUNCTION__, __LINE__);
		// build parity path
		video_type = TRUE_m12;
		switch (type.code) {
			case RECORD_DATA_FILE_TYPE_CODE_m12:
			case RECORD_INDICES_FILE_TYPE_CODE_m12:
				printf_m12("%s(%d)\n", __FUNCTION__, __LINE__);
				if (level_code == LH_SESSION_m12 || level_code == LH_SEGMENTED_SESS_RECS_m12) {
					if (level_code == LH_SESSION_m12)
						sprintf_m12(parity_path, "%s/parity.%s", sess_path, type.ext);
					else  // LH_SEGMENTED_SESS_RECS_CODE_m12
						sprintf_m12(parity_path, "%s/%s.%s/parity.%s", sess_path, sess_name, RECORD_DIRECTORY_TYPE_STRING_m12, type.ext);
				} else {  // channel or segment level records
					if (level_code == LH_TIME_SERIES_SEGMENT_m12 || level_code == LH_VIDEO_SEGMENT_m12) {  // strip off segment tag
						len = strlen(base_name);
						base_name[len - 6] = 0;
					}
					STR_replace_pattern_m12(base_name, "parity", input_file_list[i], parity_path);
				}
				break;
			case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
			case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
			case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
			case VIDEO_METADATA_FILE_TYPE_CODE_m12:
			case VIDEO_INDICES_FILE_TYPE_CODE_m12:
				video_type = FALSE_m12;
			default:
				printf_m12("%s(%d)\n", __FUNCTION__, __LINE__);
				G_extract_path_parts_m12(input_file_list[i], NULL, base_name, type.ext);
				len = strlen(base_name);
				if (video_type == TRUE_m12)
					base_name[len - 12] = 0;
				else
					base_name[len - 6] = 0;
				printf_m12("%s(%d): base_name = %s\n", __FUNCTION__, __LINE__, base_name);
				printf_m12("%s(%d): init_file = %s\n", __FUNCTION__, __LINE__, input_file_list[i]);
				STR_replace_pattern_m12(base_name, "parity", input_file_list[i], parity_path);
				break;
		}
		printf_m12("%s(%d): parity_path = %s\n", __FUNCTION__, __LINE__, parity_path);
		if (G_file_exists_m12(parity_path) == DOES_NOT_EXIST_m12) {
			++n_skipped;
			G_warning_message_m12("%s(): no parity data for file \"%s\" => skipping\n", __FUNCTION__, input_file_list[i]);
			continue;
		}

		// build file list
		strcpy(parity_files[PRTY_FILE_PARITY_IDX_m12].path, parity_path);
		printf_m12("%s(%d)\n", __FUNCTION__, __LINE__);
		strcpy(parity_files[PRTY_FILE_DAMAGED_IDX_m12].path, input_file_list[i]);
		printf_m12("%s(%d)\n", __FUNCTION__, __LINE__);
		G_extract_path_parts_m12(input_file_list[i], NULL, base_name, NULL);  // damaged file name
		printf_m12("%s(%d)\n", __FUNCTION__, __LINE__);
		for (j = 2, k = 0; j < n_parity_files; ++k) {
			if (strcmp(list[k], base_name)) {
				STR_replace_pattern_m12("parity", list[k], parity_path, tmp_path);
				strcpy(parity_files[j++].path, tmp_path);
			}
		}
		for (j = 0; j < n_parity_files; ++j)
			printf_m12("%s(%d): parity_file_path = %s\n", __FUNCTION__, __LINE__, parity_files[j].path);

		// repair
		parity_ps.files = parity_files;
		parity_ps.n_files = n_parity_files;
		parity_ps.n_bad_blocks = n_bad_blocks;
		parity_ps.bad_blocks = bad_blocks;
		parity_ps.validity_code = validity_code;
		
		G_warning_message_m12("%s(): repairing file \"%s\"\n", __FUNCTION__, input_file_list[i]);
		success = PRTY_repair_file_m12(&parity_ps);
		if (success == TRUE_m12)
			++n_repaired;
		else
			G_warning_message_m12("%s(): error restoring file \"%s\"\n", __FUNCTION__, input_file_list[i]);
		
		if (n_bad_blocks) {
			n_bad_blocks = 0;
			free_m12((void *) bad_blocks, __FUNCTION__);
		}
	}
	
	munlock_m12((void *) parity_ps.parity, (size_t) parity_ps.mem_block_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	free((void *) parity_ps.parity);
	munlock_m12((void *) parity_ps.data, (size_t) parity_ps.mem_block_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	free((void *) parity_ps.data);
	munlock_m12((void *) parity_ps.files, (size_t) allocated_parity_files * sizeof(PRTY_FILE_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	free((void *) parity_ps.files);

	free_m12((void *) ts_chan_names, __FUNCTION__);
	free_m12((void *) vid_chan_names, __FUNCTION__);
	free_m12((void *) ssr_names, __FUNCTION__);

	if (n_attempted == 0) {
		if (n_skipped) {
			G_message_m12("No damaged files detected  (%d files skipped)\n\n", n_skipped);
			success = UNKNOWN_m12;
		} else {
			G_message_m12("No damaged files detected\n\n");
			success = TRUE_m12;
		}
	} else {
		if (n_attempted == n_repaired) {
			if (n_skipped) {
				G_message_m12("All damaged files restored  (%d files skipped)\n\n", n_skipped);
				success = UNKNOWN_m12;
			} else {
				G_message_m12("All damaged files restored\n\n");
				success = TRUE_m12;
			}
		} else {
			if (n_skipped) {
				G_message_m12("%d of %d damaged files restored  (%d files skipped)\n\n", n_repaired, n_attempted, n_skipped);
				success = UNKNOWN_m12;
			} else {
				G_message_m12("%d of %d damaged files restored\n\n", n_repaired, n_attempted);
				success = FALSE_m12;
			}
		}
	}

	return(success);
}


ui1        PRTY_validate_m12(si1 *MED_file, ...)  // varargs(MED_file == NULL): si1 *MED_file, PRTY_BLOCK_m12 **bad_blocks, si4 *n_bad_blocks)
{
	TERN_m12			valid, return_bb;
	ui1				*bytes, *idx_bytes, valid_code;
	si1				idx_path[FULL_FILE_NAME_BYTES_m12];
	ui4				type_code;
	si4				n_bb, bb_size, *n_bad_blocks, BAD_BLOCK_INCREMENT;
	si8				i, len, nr, offset, record_bytes, block_bytes;
	va_list				v_args;
	FILE				*fp, *idx_fp;
	UNIVERSAL_HEADER_m12		*uh;
	RECORD_HEADER_m12		*rh;
	RECORD_INDEX_m12		*r_ind;
	CMP_BLOCK_FIXED_HEADER_m12	*bh;
	TIME_SERIES_INDEX_m12		*ts_ind;
	PRTY_BLOCK_m12			*bb, **bad_blocks;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// function validates MED file CRCs
	
	// get varargs
	return_bb = FALSE_m12;
	if (MED_file == NULL) {
		va_start(v_args, MED_file);
		MED_file = (si1 *) va_arg(v_args, si1 *);
		bad_blocks = (PRTY_BLOCK_m12 **) va_arg(v_args, PRTY_BLOCK_m12 **);
		n_bad_blocks = (si4 *) va_arg(v_args, si4 *);
		va_end(v_args);
		
		return_bb = TRUE_m12;
		*bad_blocks = bb = NULL;
		n_bb = bb_size = *n_bad_blocks = 0;
		BAD_BLOCK_INCREMENT = 5;
	}
	
	G_message_m12("Validating \"%s\" ... ", MED_file);

	if (G_file_exists_m12(MED_file) == DOES_NOT_EXIST_m12) {
		G_warning_message_m12("\n%s(): file \"%s\" does not exist\n", __FUNCTION__, MED_file);
		return(PRTY_E_UNSPEC_m12);
	}

	type_code = G_MED_type_code_from_string_m12(MED_file);
	switch (type_code) {
		case SESSION_DIRECTORY_TYPE_CODE_m12:
		case RECORD_DIRECTORY_TYPE_CODE_m12:
		case TIME_SERIES_CHANNEL_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_CHANNEL_DIRECTORY_TYPE_CODE_m12:
		case TIME_SERIES_SEGMENT_DIRECTORY_TYPE_CODE_m12:
		case VIDEO_SEGMENT_DIRECTORY_TYPE_CODE_m12:
			G_warning_message_m12("\n%s(): \"%s\" is a MED directory, not file\n", __FUNCTION__, MED_file);
			return(UNKNOWN_m12);
		case RECORD_DATA_FILE_TYPE_CODE_m12:
		case RECORD_INDICES_FILE_TYPE_CODE_m12:
		case VIDEO_METADATA_FILE_TYPE_CODE_m12:
		case VIDEO_INDICES_FILE_TYPE_CODE_m12:
		case TIME_SERIES_METADATA_FILE_TYPE_CODE_m12:
		case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
		case TIME_SERIES_INDICES_FILE_TYPE_CODE_m12:
			break;
		default:
			G_warning_message_m12("\n%s(): \"%s\" is not a MED file\n", __FUNCTION__, MED_file);
			return(PRTY_E_UNSPEC_m12);
	}
	
	fp = fopen_m12(MED_file, "r", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	if (fp == NULL)
		return(PRTY_E_UNSPEC_m12);
	len = G_file_length_m12(fp, NULL);
	bytes = (ui1 *) malloc((size_t) len);
	if (bytes == NULL) {
		G_warning_message_m12("\n%s(): allocation error\n", __FUNCTION__);
		return(PRTY_E_UNSPEC_m12);
	}
	nr = fread_m12((void *) bytes, sizeof(ui1), (size_t) len, fp, MED_file, __FUNCTION__,USE_GLOBAL_BEHAVIOR_m12);
	fclose(fp);
	if (nr !=len) {
		free((void *) bytes);
		return(PRTY_E_UNSPEC_m12);
	}

	valid_code = PRTY_VALID_m12;
	
	// check universal header CRC
	uh = (UNIVERSAL_HEADER_m12 *) bytes;
	valid = CRC_validate_m12(bytes + UNIVERSAL_HEADER_HEADER_CRC_START_OFFSET_m12, UNIVERSAL_HEADER_BYTES_m12 - UNIVERSAL_HEADER_HEADER_CRC_START_OFFSET_m12, uh->header_CRC);
	if (valid == FALSE_m12) {
		G_warning_message_m12("%sheader CRC invalid%s\n", TC_RED_m12, TC_RESET_m12);
		valid_code |= PRTY_E_HEADER_m12;
	}

	// check body CRC
	valid = CRC_validate_m12(bytes + UNIVERSAL_HEADER_BODY_CRC_START_OFFSET_m12, len - UNIVERSAL_HEADER_BODY_CRC_START_OFFSET_m12, uh->body_CRC);
	if (valid == FALSE_m12) {
		G_warning_message_m12("%sbody CRC invalid%s\n", TC_RED_m12, TC_RESET_m12);
		valid_code |= PRTY_E_BODY_m12;
	}

	// if total_record_bytes or total_block_bytes is damaged looping using these won't work - use indices (chances both damaged low)
	if (valid_code & PRTY_E_BODY_m12) {
		switch (type_code) {
			case RECORD_DATA_FILE_TYPE_CODE_m12:
				len = strcpy_m12(idx_path, MED_file);
				strcpy(idx_path + (len - 4), RECORD_INDICES_FILE_TYPE_STRING_m12);
				idx_fp = fopen_m12(idx_path, "r", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
				if (idx_fp == NULL) {
					free((void *) bytes);
					return(PRTY_E_UNSPEC_m12);
				}
				len = G_file_length_m12(idx_fp, NULL);
				idx_bytes = (ui1 *) malloc((size_t) len);
				if (idx_bytes == NULL) {
					G_warning_message_m12("\n%s(): allocation error\n", __FUNCTION__);
					fclose(idx_fp);
					return(PRTY_E_UNSPEC_m12);
				}
				nr = fread_m12((void *) idx_bytes, sizeof(ui1), (size_t) len, idx_fp, idx_path, __FUNCTION__,USE_GLOBAL_BEHAVIOR_m12);
				fclose(idx_fp);
				if (nr != len) {
					free((void *) bytes);
					free((void *) idx_bytes);
					G_warning_message_m12("\n%s(): index file read error\n", __FUNCTION__);
					return(PRTY_E_UNSPEC_m12);
				}
				printf_m12("%s(%d)\n", __FUNCTION__, __LINE__);
				r_ind = (RECORD_INDEX_m12 *) (idx_bytes + UNIVERSAL_HEADER_BYTES_m12);
				for (i = 0; i < uh->number_of_entries; ++i, ++r_ind) {
					offset = r_ind->file_offset;
					rh = (RECORD_HEADER_m12 *) (bytes + offset);
					record_bytes = (r_ind + 1)->file_offset - offset;
					valid = CRC_validate_m12((ui1 *) rh + RECORD_HEADER_CRC_START_OFFSET_m12, record_bytes - RECORD_HEADER_CRC_START_OFFSET_m12, rh->record_CRC);
					if (valid == FALSE_m12) {
						G_warning_message_m12("record #%ld: %sinvalid starting at offset %ld%s\n", TC_RED_m12, i + 1, offset, TC_RESET_m12);
						if (return_bb == TRUE_m12) {
							if (n_bb == bb_size) {
								bb_size += BAD_BLOCK_INCREMENT;
								bb = (PRTY_BLOCK_m12 *) realloc((void *) bb, (size_t) bb_size * sizeof(PRTY_BLOCK_m12));
							}
							bb[n_bb].index = (ui4) i;
							bb[n_bb].length = rh->total_record_bytes;
							bb[n_bb].offset = offset;
							++n_bb;
						}
					}
				}
				free((void *) idx_bytes);
				printf_m12("%s(%d)\n", __FUNCTION__, __LINE__);
 				break;
			case TIME_SERIES_DATA_FILE_TYPE_CODE_m12:
				printf_m12("%s(%d)\n", __FUNCTION__, __LINE__);
				len = strcpy_m12(idx_path, MED_file);
				strcpy(idx_path + (len - 4), TIME_SERIES_INDICES_FILE_TYPE_STRING_m12);
				idx_fp = fopen_m12(idx_path, "r", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
				if (idx_fp == NULL) {
					free((void *) bytes);
					return(PRTY_E_UNSPEC_m12);
				}
				len = G_file_length_m12(idx_fp, NULL);
				idx_bytes = (ui1 *) malloc((size_t) len);
				if (idx_bytes == NULL) {
					G_warning_message_m12("\n%s(): allocation error\n", __FUNCTION__);
					fclose(idx_fp);
					return(PRTY_E_UNSPEC_m12);
				}
				nr = fread_m12((void *) idx_bytes, sizeof(ui1), (size_t) len, idx_fp, idx_path, __FUNCTION__,USE_GLOBAL_BEHAVIOR_m12);
				fclose(idx_fp);
				if (nr != len) {
					free((void *) bytes);
					free((void *) idx_bytes);
					G_warning_message_m12("\n%s(): index file read error\n", __FUNCTION__);
					return(PRTY_E_UNSPEC_m12);
				}
				ts_ind = (TIME_SERIES_INDEX_m12 *) (idx_bytes + UNIVERSAL_HEADER_BYTES_m12);
				printf_m12("%s(%d)\n", __FUNCTION__, __LINE__);
				for (i = 0; i < uh->number_of_entries; ++i, ++ts_ind) {
					offset = REMOVE_DISCONTINUITY_m12(ts_ind->file_offset);
					bh = (CMP_BLOCK_FIXED_HEADER_m12 *) (bytes + offset);
					block_bytes = REMOVE_DISCONTINUITY_m12((ts_ind + 1)->file_offset) - offset;
					valid = CRC_validate_m12((ui1 *) bh + CMP_BLOCK_CRC_START_OFFSET_m12, block_bytes - CMP_BLOCK_CRC_START_OFFSET_m12, bh->block_CRC);
					if (valid == FALSE_m12) {
						G_warning_message_m12("block #%ld: %sinvalid starting at offset %ld\n", TC_RED_m12, i + 1, offset, TC_RESET_m12);
						if (return_bb == TRUE_m12) {
							if (n_bb == bb_size) {
								bb_size += BAD_BLOCK_INCREMENT;
								bb = (PRTY_BLOCK_m12 *) realloc((void *) bb, (size_t) bb_size * sizeof(PRTY_BLOCK_m12));
							}
							bb[n_bb].index = (ui4) i;
							bb[n_bb].length = bh->total_block_bytes;
							bb[n_bb].offset = offset;
							++n_bb;
						}
					}
					bh = (CMP_BLOCK_FIXED_HEADER_m12 *) ((ui1 *) bh + bh->total_block_bytes);
				}
				printf_m12("%s(%d)\n", __FUNCTION__, __LINE__);
				break;
		}
	}

	free((void *) bytes);
	
	if (return_bb == TRUE_m12) {
		if (n_bb) {
			*bad_blocks = (PRTY_BLOCK_m12 *) malloc_m12((size_t) n_bb * sizeof(PRTY_BLOCK_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			memcpy((void *) *bad_blocks, (void *) bb, (size_t) n_bb * sizeof(PRTY_BLOCK_m12));
			free((void *) bb);
			*n_bad_blocks = n_bb;
			valid_code |= PRTY_BLOCKS_m12;
		}
	}
	
	if (valid_code == PRTY_VALID_m12)  // invalid already mentioned above
		G_message_m12("%svalid%s\n", TC_GREEN_m12, TC_RESET_m12);

	return(valid_code);
}


TERN_m12	PRTY_write_m12(si1 *session_path, ui4 flags, si4 segment_number)
{
	si1		sess_path[FULL_FILE_NAME_BYTES_m12], md_path[FULL_FILE_NAME_BYTES_m12];
	si1		sess_name[BASE_FILE_NAME_BYTES_m12], tmp_str[FULL_FILE_NAME_BYTES_m12];
	si1		num_str[FILE_NUMBERING_DIGITS_m12 + 1], type_string[TYPE_BYTES_m12];
	si1		**chan_names, **vid_paths, **seg_names, **base_paths;
	si4		i, j, k, start_seg, end_seg, fd, n_chans, n_vids, n_segs, n_files, new_files;
	si8		mmap_block_bytes, mem_block_bytes, mem_blocks;
	FILE		*md_fp;
	PRTY_FILE_m12	*files;
	PRTY_m12	parity_ps;
	#if defined MACOS_m12 || defined LINUX_m12
	struct stat	sb;
	#endif
	#ifdef WINDOWS_m12
	HANDLE		file_h;
	DISK_GEOMETRY	disk_geom = { 0 };
	ui4		dg_result;
	#endif
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// get volume block size
	if (globals_m12->mmap_block_bytes == GLOBALS_MMAP_BLOCK_BYTES_NO_ENTRY_m12) {
		G_path_from_root_m12(session_path, sess_path);
		G_extract_path_parts_m12(sess_path, NULL, sess_name, NULL);
		G_find_metadata_file_m12(sess_path, md_path);  // just find any file - metadata should always be there
		md_fp = fopen_m12(md_path, "r", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		
		#if defined MACOS_m12 || defined LINUX_m12
		fd = fileno(md_fp);
		fstat(fd, &sb);
		mmap_block_bytes = (si8) sb.st_blksize;
		#endif
		#ifdef WINDOWS_m12
		fd = _fileno(md_fp);
		if ((file_h = (HANDLE) _get_osfhandle(fd)) != INVALID_HANDLE_VALUE) {
			dg_result = (ui4) DeviceIoControl(file_h, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &disk_geom, sizeof(DISK_GEOMETRY), &dg_result, (LPOVERLAPPED) NULL);
			if (dg_result == 1)
				mmap_block_bytes = (si8) disk_geom.BytesPerSector;
		}
		#endif
		fclose(md_fp);
		
		if (mmap_block_bytes <= 0)
			mmap_block_bytes = GLOBALS_MMAP_BLOCK_BYTES_DEFAULT_m12;
		globals_m12->mmap_block_bytes = mmap_block_bytes;
	} else {
		mmap_block_bytes = globals_m12->mmap_block_bytes;
	}
	
	// get time series channel names
	n_chans = n_segs = 0;
	chan_names = NULL;
	if (flags & PRTY_TS_MASK_m12) {
		chan_names = G_generate_file_list_m12(NULL, &n_chans, sess_path, NULL, TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12, GFL_NAME_m12);
		if (n_chans) {
			// get segment count
			if (segment_number == PRTY_ALL_SEGS_m12) {
				sprintf_m12(tmp_str, "%s/%s.%s", sess_path, chan_names[0], TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12);
				seg_names = G_generate_file_list_m12(NULL, &n_segs, tmp_str, NULL, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12, GFL_NAME_m12);
				free_m12((void *) seg_names, __FUNCTION__);
				start_seg = 1;
				end_seg = n_segs;
			} else {
				start_seg = end_seg = segment_number;
				n_segs = 1;
			}
		}
	}

	// fill parity ps
	mem_block_bytes = (si8) (1 << 29);  // 500 MiB
	mem_blocks = mem_block_bytes / mmap_block_bytes;
	parity_ps.mem_block_bytes = mem_block_bytes = mem_blocks * mmap_block_bytes;
	
	parity_ps.parity = (ui1 *) calloc((size_t) mem_block_bytes, sizeof(ui1));
	mlock_m12((void *) parity_ps.parity, (size_t) mem_block_bytes, FALSE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	parity_ps.data = (ui1 *) calloc((size_t) mem_block_bytes, sizeof(ui1));
	mlock_m12((void *) parity_ps.data, (size_t) mem_block_bytes, FALSE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	n_files = (n_chans > n_segs) ? n_chans : n_segs;
	parity_ps.files = files = (PRTY_FILE_m12 *) malloc((size_t) n_files * sizeof(PRTY_FILE_m12));
	mlock_m12((void *) parity_ps.files, (size_t) n_files * sizeof(PRTY_FILE_m12), FALSE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	base_paths = (si1 **) calloc_2D_m12(n_files, FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	// build time series segment parity
	if (n_chans) {
		for (i = start_seg; i <= end_seg; ++i) {
			// build segment base paths
			G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, i);
			for (j = 0; j < n_chans; ++j) {
				sprintf_m12(tmp_str, "%s_s%s", chan_names[j], num_str);
				sprintf_m12(base_paths[j], "%s/%s.%s/%s.%s/%s", sess_path, chan_names[j], TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12, tmp_str, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12, tmp_str);
			}
			
			// time series data
			if (flags & PRTY_TS_SEG_DAT_DATA_m12) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m12(files[k].path, "%s.%s", base_paths[j], TIME_SERIES_DATA_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(files[k].path) == FILE_EXISTS_m12)
						++k;
				}
				if (k) {
					sprintf_m12(tmp_str, "parity_s%s", num_str);
					sprintf_m12(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12, tmp_str, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12, tmp_str, TIME_SERIES_DATA_FILE_TYPE_STRING_m12);
					parity_ps.n_files = k;
					G_message_m12("Building segment %d time series data parity ...\n", i);
					PRTY_build_m12(&parity_ps);
				}
			}
			
			// time series indices
			if (flags & PRTY_TS_SEG_DAT_IDX_m12) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m12(files[k].path, "%s.%s", base_paths[j], TIME_SERIES_INDICES_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(files[k].path) == FILE_EXISTS_m12)
						++k;
				}
				if (k) {
					sprintf_m12(tmp_str, "parity_s%s", num_str);
					sprintf_m12(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12, tmp_str, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12, tmp_str, TIME_SERIES_INDICES_FILE_TYPE_STRING_m12);
					parity_ps.n_files = k;
					G_message_m12("Building segment %d time series indices parity ...\n", i);
					PRTY_build_m12(&parity_ps);
				}
			}
			
			// time series metadata
			if (flags & PRTY_TS_SEG_META_m12) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m12(files[k].path, "%s.%s", base_paths[j], TIME_SERIES_METADATA_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(files[k].path) == FILE_EXISTS_m12)
						++k;
				}
				if (k) {
					sprintf_m12(tmp_str, "parity_s%s", num_str);
					sprintf_m12(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12, tmp_str, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12, tmp_str, TIME_SERIES_METADATA_FILE_TYPE_STRING_m12);
					parity_ps.n_files = k;
					G_message_m12("Building segment %d time series metadata parity ...\n", i);
					PRTY_build_m12(&parity_ps);
				}
			}
			
			// time series segment record data
			if (flags & PRTY_TS_SEG_REC_DATA_m12) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m12(files[k].path, "%s.%s", base_paths[j], RECORD_DATA_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(files[k].path) == FILE_EXISTS_m12)
						++k;
				}
				if (k) {
					sprintf_m12(tmp_str, "parity_s%s", num_str);
					sprintf_m12(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12, tmp_str, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12, tmp_str, RECORD_DATA_FILE_TYPE_STRING_m12);
					parity_ps.n_files = k;
					G_message_m12("Building time series segment record data parity ...\n");
					PRTY_build_m12(&parity_ps);
				}
			}
			
			// time series segment record indices
			if (flags & PRTY_TS_SEG_REC_IDX_m12) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m12(files[k].path, "%s.%s", base_paths[j], RECORD_INDICES_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(files[k].path) == FILE_EXISTS_m12)
						++k;
				}
				if (k) {
					sprintf_m12(tmp_str, "parity_s%s", num_str);
					sprintf_m12(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12, tmp_str, TIME_SERIES_SEGMENT_DIRECTORY_TYPE_STRING_m12, tmp_str, RECORD_INDICES_FILE_TYPE_STRING_m12);
					parity_ps.n_files = k;
					G_message_m12("Building time series segment record indices parity ...\n");
					PRTY_build_m12(&parity_ps);
				}
			}
		}
		
		// build time series channel record base paths
		if (flags & PRTY_TS_CHAN_RECS_m12) {
			for (i = 0; i < n_chans; ++i)
				sprintf_m12(base_paths[i], "%s/%s.%s/%s", sess_path, chan_names[i], TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12, chan_names[i]);
			
			// time series channel record data
			if (flags & PRTY_TS_CHAN_REC_DATA_m12) {
				for (i = j = 0; i < n_chans; ++i) {
					sprintf_m12(files[j].path, "%s.%s", base_paths[i], RECORD_DATA_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(files[j].path) == FILE_EXISTS_m12)
						++j;
				}
				if (j) {
					sprintf_m12(parity_ps.path, "%s/parity.%s/parity.%s", sess_path, TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12, RECORD_DATA_FILE_TYPE_STRING_m12);
					parity_ps.n_files = j;
					G_message_m12("Building channel record data parity ...\n");
					PRTY_build_m12(&parity_ps);
				}
			}
			
			// time series channel record indices
			if (flags & PRTY_TS_CHAN_REC_IDX_m12) {
				for (i = j = 0; i < n_chans; ++i) {
					sprintf_m12(files[j].path, "%s.%s", base_paths[i], RECORD_INDICES_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(files[j].path) == FILE_EXISTS_m12)
						++j;
				}
				if (j) {
					sprintf_m12(parity_ps.path, "%s/parity.%s/parity.%s", sess_path, TIME_SERIES_CHANNEL_DIRECTORY_TYPE_STRING_m12, RECORD_INDICES_FILE_TYPE_STRING_m12);
					parity_ps.n_files = j;
					G_message_m12("Building channel record indices parity ...\n");
					PRTY_build_m12(&parity_ps);
				}
			}
		}
	}  // end time series channels
	free_m12((void *) chan_names, __FUNCTION__);
	
	// get video channel names
	n_chans = 0;
	chan_names = NULL;
	if (flags & PRTY_VID_MASK_m12) {
		chan_names = G_generate_file_list_m12(NULL, &n_chans, sess_path, NULL, VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12, GFL_NAME_m12);
		if (n_chans && n_segs == 0) {  // segment count should be same for time series & video channels
			// get segment count
			if (segment_number == PRTY_ALL_SEGS_m12) {
				sprintf_m12(tmp_str, "%s/%s.%s", sess_path, chan_names[0], VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12);
				seg_names = G_generate_file_list_m12(NULL, &n_segs, tmp_str, NULL, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12, GFL_NAME_m12);
				free_m12((void *) seg_names, __FUNCTION__);
				start_seg = 1;
				end_seg = n_segs;
			} else {
				start_seg = end_seg = segment_number;
				n_segs = 1;
			}
		}
	}
	
	new_files = (n_chans > n_segs) ? n_chans : n_segs;
	if (new_files > n_files) {
		munlock_m12((void *) parity_ps.files, (size_t) n_files * sizeof(PRTY_FILE_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free((void *) parity_ps.files);
		free_m12((void *) base_paths, __FUNCTION__);

		n_files = new_files;
		parity_ps.files = files = (PRTY_FILE_m12 *) malloc((size_t) n_files * sizeof(PRTY_FILE_m12));
		mlock_m12((void *) parity_ps.files, (size_t) n_files * sizeof(PRTY_FILE_m12), FALSE_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		base_paths = (si1 **) calloc_2D_m12(n_files, FULL_FILE_NAME_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	}
	
	if (n_chans) {
		
		// build video segment parity
		for (i = start_seg; i <= end_seg; ++i) {
			
			G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, i);
			
			// video data (these are done across video data files within a segment)
			if (flags & PRTY_VID_SEG_DAT_DATA_m12) {
				sprintf_m12(tmp_str, "%s_s%s", chan_names[j], num_str);
				sprintf_m12(base_paths[0], "%s/%s.%s/%s.%s", sess_path, chan_names[j], VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12, tmp_str, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12);
				strcat(tmp_str, "_n????");
				vid_paths = G_generate_file_list_m12(NULL, &n_vids, base_paths[0], tmp_str, NULL, GFL_FULL_PATH_m12);
				if (n_vids) {
					G_extract_path_parts_m12(vid_paths[0], NULL, NULL, type_string);  // get video extension
					sprintf_m12(tmp_str, "parity_s%s", num_str);
					sprintf_m12(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12, tmp_str, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12, tmp_str, type_string);
					G_message_m12("Building segment %d video data parity ...\n", i);
					for (j = 0; j < n_vids; ++j)
						strcpy_m12(files[j].path, vid_paths[j]);
					parity_ps.n_files = n_vids;
					PRTY_build_m12(&parity_ps);
					free_m12((void *) vid_paths, __FUNCTION__);
				}
			}
			
			// build segment base paths
			for (j = 0; j < n_chans; ++j) {
				sprintf_m12(tmp_str, "%s_s%s", chan_names[j], num_str);
				sprintf_m12(base_paths[j], "%s/%s.%s/%s.%s/%s", sess_path, chan_names[j], VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12, tmp_str, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12, tmp_str);
			}
			
			// video indices
			if (flags & PRTY_VID_SEG_DAT_IDX_m12) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m12(files[k].path, "%s.%s", base_paths[j], VIDEO_INDICES_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(files[k].path) == FILE_EXISTS_m12)
						++k;
				}
				if (k) {
					sprintf_m12(tmp_str, "parity_s%s", num_str);
					sprintf_m12(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12, tmp_str, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12, tmp_str, VIDEO_INDICES_FILE_TYPE_STRING_m12);
					G_message_m12("Building segment %d video indices parity ...\n", i);
					parity_ps.n_files = k;
					PRTY_build_m12(&parity_ps);
				}
			}
			
			// video metadata
			if (flags & PRTY_VID_SEG_META_m12) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m12(files[k].path, "%s.%s", base_paths[j], VIDEO_METADATA_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(files[k].path) == FILE_EXISTS_m12)
						++k;
				}
				if (k) {
					sprintf_m12(tmp_str, "parity_s%s", num_str);
					sprintf_m12(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12, tmp_str, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12, tmp_str, VIDEO_METADATA_FILE_TYPE_STRING_m12);
					parity_ps.n_files = k;
					G_message_m12("Building segment %d video metadata parity ...\n", i);
					PRTY_build_m12(&parity_ps);
				}
			}
			
			// video segment record data
			if (flags & PRTY_VID_SEG_REC_DATA_m12) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m12(files[k].path, "%s.%s", base_paths[j], RECORD_DATA_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(files[k].path) == FILE_EXISTS_m12)
						++k;
				}
				if (k) {
					sprintf_m12(tmp_str, "parity_s%s", num_str);
					sprintf_m12(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12, tmp_str, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12, tmp_str, RECORD_DATA_FILE_TYPE_STRING_m12);
					parity_ps.n_files = k;
					G_message_m12("Building segment %d record data parity ...\n", i);
					PRTY_build_m12(&parity_ps);
				}
			}
			
			// video segment record indices
			if (flags & PRTY_VID_SEG_REC_IDX_m12) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m12(files[k].path, "%s.%s", base_paths[j], RECORD_INDICES_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(files[k].path) == FILE_EXISTS_m12)
						++k;
				}
				if (k) {
					sprintf_m12(tmp_str, "parity_s%s", num_str);
					sprintf_m12(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12, tmp_str, VIDEO_SEGMENT_DIRECTORY_TYPE_STRING_m12, tmp_str, RECORD_INDICES_FILE_TYPE_STRING_m12);
					parity_ps.n_files = k;
					G_message_m12("Building segment %d record indices parity ...\n", i);
					PRTY_build_m12(&parity_ps);
				}
			}
		}
		
		// build video channel record base paths
		if (flags & PRTY_VID_CHAN_RECS_m12) {
			for (i = 0; i < n_chans; ++i)
				sprintf_m12(base_paths[i], "%s/%s.%s/%s", sess_path, chan_names[i], VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12, chan_names[i]);
			
			// video record data
			if (flags & PRTY_VID_CHAN_REC_DATA_m12) {
				for (i = j = 0; i < n_chans; ++i) {
					sprintf_m12(files[j].path, "%s.%s", base_paths[i], RECORD_DATA_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(files[j].path) == FILE_EXISTS_m12)
						++j;
				}
				if (j) {
					sprintf_m12(parity_ps.path, "%s/parity.%s/parity.%s", sess_path, VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12, RECORD_DATA_FILE_TYPE_STRING_m12);
					parity_ps.n_files = j;
					G_message_m12("Building channel record data parity ...\n");
					PRTY_build_m12(&parity_ps);
				}
			}
			
			// video channel record indices
			if (flags & PRTY_VID_CHAN_REC_IDX_m12) {
				for (i = j = 0; i < n_chans; ++i) {
					sprintf_m12(files[j].path, "%s.%s", base_paths[i], RECORD_INDICES_FILE_TYPE_STRING_m12);
					if (G_file_exists_m12(files[j].path) == FILE_EXISTS_m12)
						++j;
				}
				if (j) {
					sprintf_m12(parity_ps.path, "%s/parity.%s/parity.%s", sess_path, VIDEO_CHANNEL_DIRECTORY_TYPE_STRING_m12, RECORD_INDICES_FILE_TYPE_STRING_m12);
					parity_ps.n_files = j;
					G_message_m12("Building channel record indices parity ...\n");
					PRTY_build_m12(&parity_ps);
				}
			}
		}
		
	}  // end video channels
	free_m12((void *) chan_names, __FUNCTION__);
	
	// segmented session records
	if (flags & PRTY_SEG_SESS_RECS_m12) {
		for (i = 0; i < n_segs; ++i) {
			G_numerical_fixed_width_string_m12(num_str, FILE_NUMBERING_DIGITS_m12, i + 1);
			sprintf_m12(base_paths[i], "%s/%s.%s/%s_s%s", sess_path, sess_name, RECORD_DIRECTORY_TYPE_STRING_m12, sess_name, num_str);
		}
		
		// segmented session record data
		if (flags & PRTY_SEG_SESS_REC_DATA_m12) {
			for (i = j = 0; i < n_segs; ++i) {
				sprintf_m12(files[j].path, "%s.%s", base_paths[i], RECORD_DATA_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(files[j].path) == FILE_EXISTS_m12)
					++j;
			}
			if (j) {
				sprintf_m12(parity_ps.path, "%s/%s.%s/parity.%s", sess_path, sess_name, RECORD_DIRECTORY_TYPE_STRING_m12, RECORD_DATA_FILE_TYPE_STRING_m12);
				parity_ps.n_files = j;
				G_message_m12("Building segmented session record data parity ...\n");
				PRTY_build_m12(&parity_ps);
			}
		}
		
		// segmented session record indices
		if (flags & PRTY_SEG_SESS_REC_IDX_m12) {
			for (i = j = 0; i < n_segs; ++i) {
				sprintf_m12(files[j].path, "%s.%s", base_paths[i], RECORD_INDICES_FILE_TYPE_STRING_m12);
				if (G_file_exists_m12(files[j].path) == FILE_EXISTS_m12)
					++j;
			}
			if (j) {
				sprintf_m12(parity_ps.path, "%s/%s.%s/parity.%s", sess_path, sess_name, RECORD_DIRECTORY_TYPE_STRING_m12, RECORD_INDICES_FILE_TYPE_STRING_m12);
				parity_ps.n_files = j;
				G_message_m12("Building segmented session record indices parity ...\n");
				PRTY_build_m12(&parity_ps);
			}
		}
	}

	// session records
	if (flags & PRTY_SESS_RECS_m12) {
		// session records data
		if (flags & PRTY_GLB_SESS_REC_DATA_m12) {
			sprintf_m12(files[0].path, "%s/%s.%s", sess_path, sess_name, RECORD_DATA_FILE_TYPE_STRING_m12);
			if (G_file_exists_m12(files[0].path) == FILE_EXISTS_m12) {
				sprintf_m12(parity_ps.path, "%s/parity.%s", sess_path, RECORD_DATA_FILE_TYPE_STRING_m12);
				parity_ps.n_files = 1;
				G_message_m12("Building session record data parity ...\n");
				PRTY_build_m12(&parity_ps);
			}
		}
		
		// session records indices
		if (flags & PRTY_GLB_SESS_REC_IDX_m12) {
			sprintf_m12(files[0].path, "%s/%s.%s", sess_path, sess_name, RECORD_INDICES_FILE_TYPE_STRING_m12);
			if (G_file_exists_m12(files[0].path) == FILE_EXISTS_m12) {
				sprintf_m12(parity_ps.path, "%s/parity.%s", sess_path, RECORD_INDICES_FILE_TYPE_STRING_m12);
				parity_ps.n_files = 1;
				G_message_m12("Building session record indices parity ...\n");
				PRTY_build_m12(&parity_ps);
			}
		}
	}

	munlock_m12((void *) parity_ps.parity, (size_t) mem_block_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	free((void *) parity_ps.parity);
	munlock_m12((void *) parity_ps.data, (size_t) mem_block_bytes, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	free((void *) parity_ps.data);
	munlock_m12((void *) parity_ps.files, (size_t) n_chans * sizeof(PRTY_FILE_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	free((void *) files);
	free_m12((void *) base_paths, __FUNCTION__);

	G_message_m12("Parity data built\n\n");

	return(0);
}



//********************************************//
// MARK: RUNTIME CONFIGURATION FUNCTIONS  (RC)
//********************************************//

si4     RC_read_field_m12(si1 *field_name, si1 **buffer, TERN_m12 update_buffer_ptr, si1 *field_value_str, sf8 *float_val, si8 *int_val, TERN_m12 *TERN_val)
{
	TERN_m12        option_selected, free_field_value_str, local_TERN_val, options_only;
	si1             *c, temp_str[256], *temp_si1_ptr, *field_title_ptr;
	si1             *type_ptr, type_str[256];
	si1             *options_ptr, options_str[256];
	si1             *default_value_ptr, default_value_str[256];
	si1             *field_value_ptr;
	si4             type, option_number;
	si8             item, default_item, local_int_val;
	sf8             local_float_val;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// If update_buffer_ptr == TRUE_m12, caller can use it to progress serially through the RC file instead of starting at beginning each time.
	// Requires that caller knows that order of entries will stay the same. It is more efficient, but less flexible.
	// IMPORTANT: Caller responsible for saving a copy of *buffer for freeing, if it will be modified.
	
	// setup
	free_field_value_str = FALSE_m12;
	if (field_value_str == NULL) {  // need this string regardless of types
		field_value_str = (si1 *) malloc((size_t) 256);
		free_field_value_str = TRUE_m12;
	}
	// prevent error if user passes NULL to expected type (value will still be in field_value_str)
	if (float_val == NULL)
		float_val = &local_float_val;
	if (int_val == NULL)
		int_val = &local_int_val;
	if (TERN_val == NULL)
		TERN_val = &local_TERN_val;
	// zero strings
	*type_str = *options_str = *default_value_str = *field_value_str = 0;
	
	// find requested field entry
	c = *buffer;
	sprintf_m12(temp_str, "%%%% FIELD: %s", field_name);
	if ((field_title_ptr = STR_match_end_m12(temp_str, c)) == NULL)
		G_error_message_m12("%s(): Could not match field label \"%s\" in rc file\n", __FUNCTION__, temp_str);
	
	// get type
	c = field_title_ptr;
	if ((type_ptr = STR_match_end_m12("%% TYPE:", c)) == NULL)
		G_error_message_m12("%s(): Could not match TYPE subfield in field \"%s\" of rc file\n", __FUNCTION__, field_name);
	while (*type_ptr == (si1) 32)  // space
		++type_ptr;
	item = sscanf(type_ptr, "%[^\r\n]", type_str);
	if (item) {
		temp_si1_ptr = type_str + strlen(type_str);
		while (*--temp_si1_ptr == (si1) 32);
		*++temp_si1_ptr = 0;
	} else {
		G_error_message_m12("%s(): No TYPE subfield specified in field \"%s\" of rc file\n", __FUNCTION__, field_name);
	}

	type = 0;
	if (strcmp(type_str, "string") == 0)
		type = RC_STRING_TYPE_m12;
	else if (strcmp(type_str, "float") == 0)
		type = RC_FLOAT_TYPE_m12;
	else if (strcmp(type_str, "integer") == 0)
		type = RC_INTEGER_TYPE_m12;
	else if (strcmp(type_str, "ternary") == 0)
		type = RC_TERNARY_TYPE_m12;
	else
	       G_error_message_m12("%s(): Could not match TYPE subfield in field \"%s\" of rc file\n", __FUNCTION__, field_name);

	// get options pointer
	c = type_ptr;
	options_only = FALSE_m12;
	if ((options_ptr = STR_match_end_m12("%% OPTIONS", c)) == NULL)
		G_error_message_m12("%s(): Could not match OPTIONS subfield in field \"%s\" of rc file\n", __FUNCTION__, field_name);
	if (*options_ptr == ':') {
		++options_ptr;
	} else if (strncmp(options_ptr, " ONLY:", 6) == 0) {
		options_ptr += 6;
		options_only = TRUE_m12;
	} else {
		G_error_message_m12("%s(): Could not match OPTIONS subfield in field \"%s\" of rc file\n", __FUNCTION__, field_name);
	}
	while (*options_ptr == (si1) 32)  // space
		++options_ptr;
	item = sscanf(options_ptr, "%[^\r\n]", options_str);
	if (item) {
		temp_si1_ptr = options_str + strlen(options_str);
		while (*--temp_si1_ptr == (si1) 32);
		*++temp_si1_ptr = 0;
	}

	// get default value pointer
	c = options_ptr;
	if ((default_value_ptr = STR_match_end_m12("%% DEFAULT:", c)) == NULL)
		G_error_message_m12("%s(): Could not match DEFAULT subfield in field \"%s\" of rc file\n", __FUNCTION__, field_name);
	while (*default_value_ptr == (si1) 32)  // space
		++default_value_ptr;
	
	default_item = sscanf(default_value_ptr, "%[^\r\n]", default_value_str);
	if (default_item) {
		temp_si1_ptr = default_value_str + strlen(default_value_str);
		while (*--temp_si1_ptr == (si1) 32);  // space
		*++temp_si1_ptr = 0;
	}

	// get field value as string
	c = default_value_ptr;
	if ((field_value_ptr = STR_match_end_m12("%% VALUE:", c)) == NULL)
		G_error_message_m12("%s(): Could not match value field label \"%s\" in rc file\n", __FUNCTION__, temp_str);
	while (*field_value_ptr == (si1) 32)  // space
		++field_value_ptr;
	item = sscanf(field_value_ptr, "%[^\r\n]", field_value_str);
	temp_si1_ptr = field_value_str + strlen(field_value_str);
	if (update_buffer_ptr == TRUE_m12)
		*buffer = temp_si1_ptr;
	if (item) {
		while (*--temp_si1_ptr == (si1) 32);  // space
		*++temp_si1_ptr = 0;
	} else {
		strcpy(field_value_str, "DEFAULT");
	}
	
READ_RC_HANDLE_DEFAULT_m12:
	
	// VALUE field is "DEFAULT", and default may be "PROMPT"
	if (strcmp(field_value_str, "DEFAULT") == 0) {
		if (default_item)
			strcpy(field_value_str, default_value_str);
		else
			G_error_message_m12("%s(): No DEFAULT value to enter in field \"%s\" of rc file\n", __FUNCTION__, field_name);
	}

	// PROMPT (Note: user can enter "DEFAULT", "NO ENTRY", or any of the recognized OPTIONS here if desired)
	if (strcmp(field_value_str, "PROMPT") == 0) {
		if (options_only == TRUE_m12)
			printf_m12("RC FIELD: \033[31m%s\033[0m\nOPTIONS: \033[31m%s\033[0m\nDEFAULT: \033[31m%s\033[0m\nEnter an option: ", field_name, options_str, default_value_str);
		else
			printf_m12("RC FIELD: \033[31m%s\033[0m\nOPTIONS: \033[31m%s\033[0m\nDEFAULT: \033[31m%s\033[0m\nEnter a value: ", field_name, options_str, default_value_str);
		item = scanf("%[^\r\n]", field_value_str); fgetc(stdin); putchar_m12('\n');
		if (item) {
			temp_si1_ptr = field_value_str + strlen(field_value_str);
			while (*--temp_si1_ptr == (si1) 32);  // space
			*++temp_si1_ptr = 0;
		}
	}

	// no entry
	option_selected = RC_NO_OPTION_m12;
	if ((strcmp(field_value_str, "NO ENTRY") == 0)) {
		if (options_only == TRUE_m12) {
			G_error_message_m12("%s(): \"NO ENTRY\" is not an option in field \"%s\" of rc file => using default\n", __FUNCTION__, field_name);
			strcpy(field_value_str, "DEFAULT");
			goto READ_RC_HANDLE_DEFAULT_m12;
		} else
			option_selected = RC_NO_ENTRY_m12;
	}

	// options
	if (option_selected == RC_NO_OPTION_m12) {
		option_number = 0;
		options_ptr = options_str;
		while (1) {
			while (*options_ptr == 32 || *options_ptr == ',')  // space or comma
				++options_ptr;
			if (*options_ptr == 0)
				break;
			++option_number;
			item = sscanf(options_ptr, "%[^,\r\n]", temp_str);
			if (item) {
				if (strcmp(temp_str, field_value_str) == 0) {
					option_selected = option_number;
					strcpy(field_value_str, temp_str);
					break;
				}
				options_ptr += strlen(temp_str);
			} else {
				break;
			}
		}
		if (option_selected == RC_NO_OPTION_m12) {
			if (options_only == TRUE_m12) {
				G_error_message_m12("%s(): String \"%s\" is not an option in field \"%s\" of rc file => using default\n", __FUNCTION__, field_value_str, field_name);
				strcpy(field_value_str, "DEFAULT");
				goto READ_RC_HANDLE_DEFAULT_m12;
			}
		}
	}
			
	// user entered value
	switch (type) {
		case RC_STRING_TYPE_m12:
			if (option_selected == RC_NO_ENTRY_m12)
				field_value_str[0] = 0;  // function default
			break;
		case RC_FLOAT_TYPE_m12:
			if (option_selected == RC_NO_ENTRY_m12)
				*float_val = 0.0;  // function default
			else {
				item = sscanf(field_value_str, "%lf", float_val);
				if (item != 1 && option_selected == RC_NO_OPTION_m12)
					G_error_message_m12("%s(): Could not convert string \"%s\" to type \"%s\" in field \"%s\" of rc file\n", __FUNCTION__, field_value_str, type_str, field_name);
			}
			break;
		case RC_INTEGER_TYPE_m12:
			if (option_selected == RC_NO_ENTRY_m12)
				*int_val = 0;  // function default
			else {
				// I have no idea why, but the Visual Studio linker can't find sscanf_m12() - just this function
				item = sscanf_m12(field_value_str, "%ld", int_val);
				if (item != 1 && option_selected == RC_NO_OPTION_m12)
					G_error_message_m12("%s(): Could not convert string \"%s\" to type \"%s\" in field \"%s\" of rc file\n", __FUNCTION__, field_value_str, type_str, field_name);
			}
			break;
		case RC_TERNARY_TYPE_m12:
			if (option_selected == RC_NO_ENTRY_m12) {
				*TERN_val = UNKNOWN_m12;  // function default
				break;
			}
			if (option_selected == RC_NO_OPTION_m12) {  // user entered value
				item = sscanf(field_value_str, "%hhd", TERN_val);
				if (item != 1) {
					G_error_message_m12("%s(): Could not convert string \"%s\" to type \"%s\" in field \"%s\" of rc file\n", __FUNCTION__, field_value_str, type_str, field_name);
					break;
				}
				if (*TERN_val < FALSE_m12 || *TERN_val > TRUE_m12)
					G_error_message_m12("%s(): Invalid value for type \"%s\" in field \"%s\" of rc file\n", __FUNCTION__, type_str, field_name);
			} else {  // user entered option
				if (strcmp(field_value_str, "YES") == 0 || strcmp(field_value_str, "TRUE") == 0) {
					*TERN_val = TRUE_m12;
				} else if (strcmp(field_value_str, "NO") == 0 || strcmp(field_value_str, "FALSE") == 0) {
					*TERN_val = FALSE_m12;
				} else if (strcmp(field_value_str, "UNKNOWN") == 0) {
					*TERN_val = UNKNOWN_m12;
				}
			}
			break;
		default:
			break;
	}

	if (free_field_value_str == TRUE_m12)
		free((void *) field_value_str);
	
	return(option_selected);
}


si4     RC_read_field_2_m12(si1 *field_name, si1 **buffer, TERN_m12 update_buffer_ptr, void *val, si4 val_type, ...)  // vararg (val_type == RC_UNKNOWN_m12): *returned_val_type
{
	TERN_m12        *tern_val, option_selected, options_only;
	si1             *str_val, *c, temp_str[RC_STRING_BYTES_m12], *temp_si1_ptr, *field_title_ptr, local_str_val[RC_STRING_BYTES_m12];
	si1             *type_ptr, type_str[RC_STRING_BYTES_m12];
	si1             *options_ptr, options_str[RC_STRING_BYTES_m12];
	si1             *default_value_ptr, default_value_str[RC_STRING_BYTES_m12];
	si1             *field_value_ptr;
	si4             type, option_number, *returned_val_type;
	si8             *int_val, item, default_item;
	sf8             *float_val;
	va_list		arg_p;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// If update_buffer_ptr == TRUE_m12, caller can use it to progress serially through the RC file instead of starting at beginning each time.
	// Requires that caller knows that order of entries will stay the same. It is more efficient, but less flexible.
	// IMPORTANT: Caller responsible for saving a copy of *buffer for freeing, if it will be modified.
	// if type unknown, caller should pass RC_STRING_BYTES_m12 byte block of memory in val, and pass the address of an si4 in returned_val_type vararg
	// Version 2 has fewer arguments, but does not return field value as a string unless the field type was a string
	// All strings are presumed to be < RC_STRING_BYTES_m12 bytes

	if (val == NULL) {
		G_error_message_m12("%s(): NULL value pointer passed \"%s\" in rc file\n", __FUNCTION__);
		return(-1);
	}

	// setup
	if (val_type != RC_STRING_TYPE_m12)  // need str_val regardless of type
		str_val = local_str_val;
	returned_val_type = NULL;
	switch (val_type) {
		case RC_STRING_TYPE_m12:
			str_val = (si1 *) val;
			break;
		case RC_FLOAT_TYPE_m12:
			float_val = (sf8 *) val;
			break;
		case RC_INTEGER_TYPE_m12:
			int_val = (si8 *) val;
			break;
		case RC_TERNARY_TYPE_m12:
			tern_val = (si1 *) val;
			break;
		case RC_UNKNOWN_TYPE_m12:
			va_start(arg_p, val_type);
			returned_val_type = va_arg(arg_p, si4 *);
			va_end(arg_p);
			break;
		default:
			G_error_message_m12("%s(): unrecognized type (%d) passed\n", __FUNCTION__, val_type);
			return(-1);
	}
	// zero strings
	*str_val = *type_str = *options_str = *default_value_str = 0;
	
	// find requested field entry
	c = *buffer;
	sprintf_m12(temp_str, "%%%% FIELD: %s", field_name);
	if ((field_title_ptr = STR_match_end_m12(temp_str, c)) == NULL)
		G_error_message_m12("%s(): Could not match field label \"%s\" in rc file\n", __FUNCTION__, temp_str);
	
	// get type
	c = field_title_ptr;
	if ((type_ptr = STR_match_end_m12("%% TYPE:", c)) == NULL)
		G_error_message_m12("%s(): Could not match TYPE subfield in field \"%s\" of rc file\n", __FUNCTION__, field_name);
	while (*type_ptr == (si1) 32)  // space
		++type_ptr;
	item = sscanf(type_ptr, "%[^\r\n]", type_str);
	if (item) {
		temp_si1_ptr = type_str + strlen(type_str);
		while (*--temp_si1_ptr == (si1) 32);
		*++temp_si1_ptr = 0;
	} else {
		G_error_message_m12("%s(): No TYPE subfield specified in field \"%s\" of rc file\n", __FUNCTION__, field_name);
	}

	type = 0;
	if (strcmp(type_str, "string") == 0)
		type = RC_STRING_TYPE_m12;
	else if (strcmp(type_str, "float") == 0)
		type = RC_FLOAT_TYPE_m12;
	else if (strcmp(type_str, "integer") == 0)
		type = RC_INTEGER_TYPE_m12;
	else if (strcmp(type_str, "ternary") == 0)
		type = RC_TERNARY_TYPE_m12;
	else
	       G_error_message_m12("%s(): Could not match TYPE subfield in field \"%s\" of rc file\n", __FUNCTION__, field_name);
	
	if (type != val_type) {
		if (val_type == RC_UNKNOWN_TYPE_m12) {
			*returned_val_type = type;
			switch (type) {
				case RC_STRING_TYPE_m12:
					str_val = (si1 *) val;
					break;
				case RC_FLOAT_TYPE_m12:
					float_val = (sf8 *) val;
					break;
				case RC_INTEGER_TYPE_m12:
					int_val = (si8 *) val;
					break;
				case RC_TERNARY_TYPE_m12:
					tern_val = (si1 *) val;
					break;
			}
		} else {
			G_error_message_m12("%s(): field type (%d) != passed type (%d) in field \"%s\" of rc file\n", __FUNCTION__, type, val_type, field_name);
		}
	}

	// get options pointer
	c = type_ptr;
	options_only = FALSE_m12;
	if ((options_ptr = STR_match_end_m12("%% OPTIONS", c)) == NULL)
		G_error_message_m12("%s(): Could not match OPTIONS subfield in field \"%s\" of rc file\n", __FUNCTION__, field_name);
	if (*options_ptr == ':') {
		++options_ptr;
	} else if (strncmp(options_ptr, " ONLY:", 6) == 0) {
		options_ptr += 6;
		options_only = TRUE_m12;
	} else {
		G_error_message_m12("%s(): Could not match OPTIONS subfield in field \"%s\" of rc file\n", __FUNCTION__, field_name);
	}
	while (*options_ptr == (si1) 32)  // space
		++options_ptr;
	item = sscanf(options_ptr, "%[^\r\n]", options_str);
	if (item) {
		temp_si1_ptr = options_str + strlen(options_str);
		while (*--temp_si1_ptr == (si1) 32);
		*++temp_si1_ptr = 0;
	}

	// get default value pointer
	c = options_ptr;
	if ((default_value_ptr = STR_match_end_m12("%% DEFAULT:", c)) == NULL)
		G_error_message_m12("%s(): Could not match DEFAULT subfield in field \"%s\" of rc file\n", __FUNCTION__, field_name);
	while (*default_value_ptr == (si1) 32)  // space
		++default_value_ptr;
	
	default_item = sscanf(default_value_ptr, "%[^\r\n]", default_value_str);
	if (default_item) {
		temp_si1_ptr = default_value_str + strlen(default_value_str);
		while (*--temp_si1_ptr == (si1) 32);  // space
		*++temp_si1_ptr = 0;
	}

	// get field value as string
	c = default_value_ptr;
	if ((field_value_ptr = STR_match_end_m12("%% VALUE:", c)) == NULL)
		G_error_message_m12("%s(): Could not match value field label \"%s\" in rc file\n", __FUNCTION__, temp_str);
	while (*field_value_ptr == (si1) 32)  // space
		++field_value_ptr;
	item = sscanf(field_value_ptr, "%[^\r\n]", str_val);
	temp_si1_ptr = str_val + strlen(str_val);
	if (update_buffer_ptr == TRUE_m12)
		*buffer = temp_si1_ptr;
	if (item) {
		while (*--temp_si1_ptr == (si1) 32);  // space
		*++temp_si1_ptr = 0;
	} else {
		strcpy(str_val, "DEFAULT");
	}
	
READ_RC_HANDLE_DEFAULT_m12:
	
	// VALUE field is "DEFAULT", and default may be "PROMPT"
	if (strcmp(str_val, "DEFAULT") == 0) {
		if (default_item)
			strcpy(str_val, default_value_str);
		else
			G_error_message_m12("%s(): No DEFAULT value to enter in field \"%s\" of rc file\n", __FUNCTION__, field_name);
	}

	// PROMPT (Note: user can enter "DEFAULT", "NO ENTRY", or any of the recognized OPTIONS here if desired)
	if (strcmp(str_val, "PROMPT") == 0) {
		if (options_only == TRUE_m12)
			printf_m12("RC FIELD: \033[31m%s\033[0m\nOPTIONS: \033[31m%s\033[0m\nDEFAULT: \033[31m%s\033[0m\nEnter an option: ", field_name, options_str, default_value_str);
		else
			printf_m12("RC FIELD: \033[31m%s\033[0m\nOPTIONS: \033[31m%s\033[0m\nDEFAULT: \033[31m%s\033[0m\nEnter a value: ", field_name, options_str, default_value_str);
		item = scanf("%[^\r\n]", str_val); fgetc(stdin); putchar_m12('\n');
		if (item) {
			temp_si1_ptr = str_val + strlen(str_val);
			while (*--temp_si1_ptr == (si1) 32);  // space
			*++temp_si1_ptr = 0;
		}
	}

	// no entry
	option_selected = RC_NO_OPTION_m12;
	if ((strcmp(str_val, "NO ENTRY") == 0)) {
		if (options_only == TRUE_m12) {
			G_error_message_m12("%s(): \"NO ENTRY\" is not an option in field \"%s\" of rc file => using default\n", __FUNCTION__, field_name);
			strcpy(str_val, "DEFAULT");
			goto READ_RC_HANDLE_DEFAULT_m12;
		} else
			option_selected = RC_NO_ENTRY_m12;
	}

	// options
	if (option_selected == RC_NO_OPTION_m12) {
		option_number = 0;
		options_ptr = options_str;
		while (1) {
			while (*options_ptr == 32 || *options_ptr == ',')  // space or comma
				++options_ptr;
			if (*options_ptr == 0)
				break;
			++option_number;
			item = sscanf(options_ptr, "%[^,\r\n]", temp_str);
			if (item) {
				if (strcmp(temp_str, str_val) == 0) {
					option_selected = option_number;
					strcpy(str_val, temp_str);
					break;
				}
				options_ptr += strlen(temp_str);
			} else {
				break;
			}
		}
		if (option_selected == RC_NO_OPTION_m12) {
			if (options_only == TRUE_m12) {
				G_error_message_m12("%s(): String \"%s\" is not an option in field \"%s\" of rc file => using default\n", __FUNCTION__, str_val, field_name);
				strcpy(str_val, "DEFAULT");
				goto READ_RC_HANDLE_DEFAULT_m12;
			}
		}
	}
			
	// user entered value
	switch (type) {
		case RC_STRING_TYPE_m12:
			if (option_selected == RC_NO_ENTRY_m12)
				str_val[0] = 0;  // function default
			break;
		case RC_FLOAT_TYPE_m12:
			if (option_selected == RC_NO_ENTRY_m12)
				*float_val = 0.0;  // function default
			else {
				item = sscanf(str_val, "%lf", float_val);
				if (item != 1 && option_selected == RC_NO_OPTION_m12)
					G_error_message_m12("%s(): Could not convert string \"%s\" to type \"%s\" in field \"%s\" of rc file\n", __FUNCTION__, str_val, type_str, field_name);
			}
			break;
		case RC_INTEGER_TYPE_m12:
			if (option_selected == RC_NO_ENTRY_m12)
				*int_val = 0;  // function default
			else {
				// I have no idea why, but the Visual Studio linker can't find sscanf_m12() - just this function
				item = sscanf_m12(str_val, "%ld", int_val);
				if (item != 1 && option_selected == RC_NO_OPTION_m12)
					G_error_message_m12("%s(): Could not convert string \"%s\" to type \"%s\" in field \"%s\" of rc file\n", __FUNCTION__, str_val, type_str, field_name);
			}
			break;
		case RC_TERNARY_TYPE_m12:
			if (option_selected == RC_NO_ENTRY_m12) {
				*tern_val = UNKNOWN_m12;  // function default
				break;
			}
			if (option_selected == RC_NO_OPTION_m12) {  // user entered value
				item = sscanf(str_val, "%hhd", tern_val);
				if (item != 1) {
					G_error_message_m12("%s(): Could not convert string \"%s\" to type \"%s\" in field \"%s\" of rc file\n", __FUNCTION__, str_val, type_str, field_name);
					break;
				}
				if (*tern_val < FALSE_m12 || *tern_val > TRUE_m12)
					G_error_message_m12("%s(): Invalid value for type \"%s\" in field \"%s\" of rc file\n", __FUNCTION__, type_str, field_name);
			} else {  // user entered option
				if (strcmp(str_val, "YES") == 0 || strcmp(str_val, "TRUE") == 0) {
					*tern_val = TRUE_m12;
				} else if (strcmp(str_val, "NO") == 0 || strcmp(str_val, "FALSE") == 0) {
					*tern_val = FALSE_m12;
				} else if (strcmp(str_val, "UNKNOWN") == 0) {
					*tern_val = UNKNOWN_m12;
				}
			}
			break;
		default:
			break;
	}
	
	return(option_selected);
}


//****************************//
// MARK: HASH FUNCTIONS  (SHA)
//****************************//

// ATTRIBUTION:
//
// Author:	Brad Conte (brad@bradconte.com)
// Disclaimer:	This code is presented "as is" without any guarantees.
// Details:	Implementation of the SHA-256 hashing algorithm.
//		Algorithm specification can be found here:
//	      	http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf
//		This implementation uses little endian byte order.
//
// Code:	https://github.com/B-Con/crypto-algorithms/blob/master/sha256.c
//
// Only SHA-256 functions are included in the MED library
// The version below contains minor modifications for compatibility with the MED Library.


void	SHA_finalize_m12(SHA_CTX_m12 *ctx, ui1 *hash)
{
	ui4	i;
	
	
	i = ctx->datalen;

	// pad whatever data is left in the buffer
	if (ctx->datalen < 56) {
		ctx->data[i++] = 0x80;
		while (i < 56)
			ctx->data[i++] = 0x00;
	}
	else {
		ctx->data[i++] = 0x80;
		while (i < 64)
			ctx->data[i++] = 0x00;
		SHA_transform_m12(ctx, ctx->data);
		memset(ctx->data, 0, 56);
	}

	// Append to the padding the total message's length in bits and transform.
	ctx->bitlen += ctx->datalen * 8;
	ctx->data[63] = ctx->bitlen;
	ctx->data[62] = ctx->bitlen >> 8;
	ctx->data[61] = ctx->bitlen >> 16;
	ctx->data[60] = ctx->bitlen >> 24;
	ctx->data[59] = ctx->bitlen >> 32;
	ctx->data[58] = ctx->bitlen >> 40;
	ctx->data[57] = ctx->bitlen >> 48;
	ctx->data[56] = ctx->bitlen >> 56;
	SHA_transform_m12(ctx, ctx->data);

	// Since this implementation uses little endian byte ordering and SHA uses big endian,
	// reverse all the bytes when copying the final state to the output hash.
	for (i = 0; i < 4; ++i) {
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m12;
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m12;
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m12;
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m12;
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m12;
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m12;
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m12;
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m12;
	}
	
	return;
}


ui1    *SHA_hash_m12(const ui1 *data, si8 len, ui1 *hash)
{
	SHA_CTX_m12         ctx;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (global_tables_m12->SHA_h0_table == NULL)  // all tables initialized together
		SHA_initialize_tables_m12();

	// if hash not passed, up to caller to free it
	if (hash == NULL)
		hash = (ui1 *) calloc_m12((size_t) SHA_HASH_BYTES_m12, sizeof(ui1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	SHA_initialize_m12(&ctx);
	SHA_update_m12(&ctx, data, len);
	SHA_finalize_m12(&ctx, hash);
	
	return(hash);
}


void	SHA_initialize_m12(SHA_CTX_m12 *ctx)
{
	ui4	*SHA_h0;
	
	
	ctx->datalen = 0;
	ctx->bitlen = 0;
	
	SHA_h0 = global_tables_m12->SHA_h0_table;
	ctx->state[0] = SHA_h0[0];
	ctx->state[1] = SHA_h0[1];
	ctx->state[2] = SHA_h0[2];
	ctx->state[3] = SHA_h0[3];
	ctx->state[4] = SHA_h0[4];
	ctx->state[5] = SHA_h0[5];
	ctx->state[6] = SHA_h0[6];
	ctx->state[7] = SHA_h0[7];
	
	return;
}


TERN_m12	SHA_initialize_tables_m12(void)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (global_tables_m12->SHA_h0_table != NULL)
		return(TRUE_m12);

	PROC_pthread_mutex_lock_m12(&global_tables_m12->SHA_mutex);
	if (global_tables_m12->SHA_h0_table != NULL) {  // may have been done by another thread while waiting
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->SHA_mutex);
		return(TRUE_m12);
	}

	// h0 table
	if (global_tables_m12->SHA_h0_table == NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		global_tables_m12->SHA_h0_table = (ui4 *) mxCalloc((mwSize) SHA_H0_ENTRIES_m12, (mwSize) sizeof(ui4));
	#else
		global_tables_m12->SHA_h0_table = (ui4 *) calloc((size_t) SHA_H0_ENTRIES_m12, sizeof(ui4));
	#endif
		{
			ui4 temp[SHA_H0_ENTRIES_m12] = SHA_H0_m12;
			memcpy(global_tables_m12->SHA_h0_table, temp, SHA_H0_ENTRIES_m12 * sizeof(ui4));
		}
	}

	// k table
	if (global_tables_m12->SHA_k_table == NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		global_tables_m12->SHA_k_table = (ui4 *) mxCalloc((mwSize) SHA_K_ENTRIES_m12, (mwSize) sizeof(ui4));
	#else
		global_tables_m12->SHA_k_table = (ui4 *) calloc((size_t) SHA_K_ENTRIES_m12, sizeof(ui4));
	#endif
		{
			ui4 temp[SHA_K_ENTRIES_m12] = SHA_K_m12;
			memcpy(global_tables_m12->SHA_k_table, temp, SHA_K_ENTRIES_m12 * sizeof(ui4));
		}
	}

	PROC_pthread_mutex_unlock_m12(&global_tables_m12->SHA_mutex);

	return(TRUE_m12);
}


void	SHA_transform_m12(SHA_CTX_m12 *ctx, const ui1 *data)
{
	ui4	a, b, c, d, e, f, g, h, i, j, t1, t2, m[64], *sha_k;

	
	for (i = 0, j = 0; i < 16; ++i, j += 4)
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
	for ( ; i < 64; ++i)
		m[i] = SHA_SIG1_m12(m[i - 2]) + m[i - 7] + SHA_SIG0_m12(m[i - 15]) + m[i - 16];

	a = ctx->state[0];
	b = ctx->state[1];
	c = ctx->state[2];
	d = ctx->state[3];
	e = ctx->state[4];
	f = ctx->state[5];
	g = ctx->state[6];
	h = ctx->state[7];
	
	sha_k = global_tables_m12->SHA_k_table;
	for (i = 0; i < 64; ++i) {
		t1 = h + SHA_EP1_m12(e) + SHA_CH_m12(e,f,g) + sha_k[i] + m[i];
		t2 = SHA_EP0_m12(a) + SHA_MAJ_m12(a,b,c);
		h = g;
		g = f;
		f = e;
		e = d + t1;
		d = c;
		c = b;
		b = a;
		a = t1 + t2;
	}

	ctx->state[0] += a;
	ctx->state[1] += b;
	ctx->state[2] += c;
	ctx->state[3] += d;
	ctx->state[4] += e;
	ctx->state[5] += f;
	ctx->state[6] += g;
	ctx->state[7] += h;
	
	return;
}


void	SHA_update_m12(SHA_CTX_m12 *ctx, const ui1 *data, si8 len)
{
	si8	i;
	
	
	for (i = 0; i < len; ++i) {
		ctx->data[ctx->datalen] = data[i];
		ctx->datalen++;
		if (ctx->datalen == 64) {
			SHA_transform_m12(ctx, ctx->data);
			ctx->bitlen += 512;
			ctx->datalen = 0;
		}
	}
	
	return;
}



//******************************//
// MARK: STRING FUNCTIONS  (STR)
//******************************//

#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
wchar_t	*STR_char2wchar_m12(wchar_t *target, si1 *source)
{
	si1	*c, *c2, *tmp_source = NULL;
	si8	len, wsz;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// if source == target, done in place
	// if not actually ascii, results may be weird
	// assumes target is big enough
	
	wsz = sizeof(wchar_t);  // 2 or 4 => varies by OS & compiler
	c = (si1 *) target - wsz;
	len = strlen(source);
	if ((void *) source == (void *) target) {
		tmp_source = (si1 *) malloc((size_t) len + 1);
		memcpy((void *) tmp_source, (void *)  source, (size_t)len + 1);
		c2 = tmp_source;
	} else {
		c2 = source;
	}
	memset((void *) target, 0, wsz * (len + 1));
	
	while (len--)
		*(c += wsz) = *c2++;  // little endian version
	
	if (tmp_source != NULL)
		free((void *) tmp_source);
	
	return(target);
}


ui4     STR_check_spaces_m12(si1 *string)
{
	ui4     spaces;
	si1     *c;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (string == NULL)
		return(NO_SPACES_m12);
	if (*string == 0)
		return(NO_SPACES_m12);
	
	c = string;
	spaces = NO_SPACES_m12;
	while (*++c) {
		if (*c == 0x20) {  // space
			if (*(c - 1) == 0x5c)  // backslash
				spaces |= ESCAPED_SPACES_m12;
			else
				spaces |= UNESCAPED_SPACES_m12;
		}
	}
			    
	return(spaces);
}


si4	STR_compare_m12(const void *a, const void *b)
{
	si1		*ap, *bp, ac, bc;
	
	
	// Sorting Rules:
	// ascii only
	// case insensitive, but in case of equivalence lower case precedes upper case (e.g. "abc.txt" before "Abc.txt"
	//  "." before <space> (e.g. "RawData.nrd" before "RawData 0001.nrd"
	
	ac = *(ap = *((si1 **) a));
	bc = *(bp = *((si1 **) b));

	while (ac && bc) {
		
		// letters
		if (ac >= 'A' && ac <= 'Z') {
			ac += ('a' - 'A');  // "promote" to lower case, so "_" precedes letters
		}
		if (bc >= 'A' && bc <= 'Z')
			bc += ('a' - 'A');  // "promote" to lower case, so "_" precedes letters
		
		// equal - go to next character
		if (ac == bc) {
			ac = *++ap;
			bc = *++bp;
			continue;
		}
		
		// change ascii <space> before "." to "." before <space>
		if (ac == 0x20 || bc == 0x20) {  // a or b is a space, not both (caught above) (0x20 == <space>)
			if (bc == '.')
				return(1);
			if (ac == '.')
				return(-1);
		}
		
		return((si4) ac - (si4) bc);
	}
	
	if (ac)  // b longer than a
		return(1);
	if (bc)  // a longer than b
		return(-1);
	
	// case-insensitive equal strings - sort by case
	--ap; --bp;
	while (*++ap && *++bp) {
		if (*ap != *bp)  // first case difference
			return((si4) *bp - (si4) *ap);  // lower before upper case
	}
	
	// identical strings
	return(0);
}


TERN_m12    STR_contains_formatting_m12(si1 *string, si1 *plain_string)
{
	TERN_m12	format_seq;
	si1		*c1, *c2, *c3;
	
	// if plain_string == NULL : return T/F on string, do not modify string
	// if plain_string == string : return T/F on string, do modify string (done in place)
	// if plain_string != string && plain_string != NULL : return T/F on path, return plain_string with formatting removed, leave string intact
	// assumes plain_string has adequate space for deformatted string if passed (length plain_string will always be <= length of string)
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	c1 = string;
	format_seq = FALSE_m12;
	while (*c1) {
		if (*c1 == 27) {  // escape
			if (*(c1 + 1) == 91) {  // '['
				c2 = c1 + 3;
				if (*c2++ == 109)  // 'm'
					format_seq = TRUE_m12;
				else if (*c2++ == 109)  // 'm'
					format_seq = TRUE_m12;
				else if (*c2++ == 109)  // 'm'
					format_seq = TRUE_m12;
				else if (*c2++ == 109)  // 'm'
					format_seq = TRUE_m12;
				if (format_seq == TRUE_m12)
					break;
			}
		}
		++c1;
	}
	
	if (plain_string == NULL)
		return(format_seq);
	
	if (format_seq == TRUE_m12) {
		if (plain_string != string) {
			c2 = plain_string;
			c3 = string;
			while (c3 != c1)  // copy string up to c1 into plain_string
				*c2++ = *c3++;
		} else {
			c2 = c1;  // same string - no copying needed
		}
	} else {
		if (plain_string != string)
			strcpy(plain_string, string);
		return(FALSE_m12);
	}
	
	// remove formatting
	while (*c1) {
		if (*c1 == 27) {  // escape
			if (*(c1 + 1) == 91) {  // '['
				c3 = c1 + 3;
				format_seq = FALSE_m12;
				if (*c3++ == 109)  // 'm'
					format_seq = TRUE_m12;
				else if (*c3++ == 109)  // 'm'
					format_seq = TRUE_m12;
				else if (*c3++ == 109)  // 'm'
					format_seq = TRUE_m12;
				else if (*c3++ == 109)  // 'm'
					format_seq = TRUE_m12;
				if (format_seq == TRUE_m12) {
					c1 = c3;
					if (*c1 == 0) // end of string
						break;
					if (*c1 == 27)  // possibly another escape sequence
						continue;
				}
			}
		}
		*c2++ = *c1++;
	}
	*c2 = 0;
	
	return(TRUE_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
TERN_m12	STR_contains_regex_m12(si1 *string)
{
	si1	c;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// NOT an exhaustive list of potential regex characters, just enough to know if regex is present
	
	if (string == NULL)
		return(FALSE_m12);
	
	while ((c = *string++)) {
		switch (c) {
			case '*':
			case '?':
			case '|':
			case '^':
			case '$':
			case '[':
			case '{':
				return(TRUE_m12);
		}
	}
	
	return(FALSE_m12);
}


si1     *STR_duration_string_m12(si1 *dur_str, si8 int_usecs, TERN_m12 abbreviated, TERN_m12 two_level)
{
	const si1	*full[9] = {"year", "month", "week", "day", "hour", "minute", "second", "millisecond", "microsecond"};
	const si1	*abbr[9] = {"yr", "mo", "wk", "day", "hr", "min", "sec", "ms", "us"};
	si1		*offset_dur_str;
	si4		level_idx, int_level_1, int_level_2;
	const sf8	divisors[9] = {31556926000000.0, 2629744000000.0, 604800000000.0, 86400000000.0, 3600000000.0, 60000000.0, 1000000.0, 1000.0, -1.0};
	sf8             usecs, level_1, level_2;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Note: if dur_str == NULL, it will be allocated & calling functio is responsible for freeing
	if (dur_str == NULL)
		dur_str = calloc_m12((size_t) TIME_STRING_BYTES_m12, sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	if (int_usecs < 0) {
		if (abbreviated == TRUE_m12) {
			strcpy(dur_str, "neg ");
			offset_dur_str = dur_str + 4;
		} else {
			strcpy(dur_str, "negative ");
			offset_dur_str = dur_str + 9;
		}
		int_usecs = -int_usecs;
	} else {
		offset_dur_str = dur_str;
	}
	
	level_1 = usecs = (sf8) int_usecs;
	for (level_idx = 0; usecs < divisors[level_idx]; ++level_idx);
	
	if (level_idx == 8)  // usecs
		two_level = FALSE_m12;
	else
		level_1 /= divisors[level_idx];
	
	if (two_level == TRUE_m12) {
		int_level_1 = (si4) level_1;  // rounnd down
		usecs = (level_1 - (sf8) int_level_1) * divisors[level_idx];
		level_2 = usecs / divisors[level_idx + 1];
		int_level_2 = (si4) level_2;  // rounnd down
		if (abbreviated == TRUE_m12)
			sprintf_m12(offset_dur_str, "%d %s, %d %s", int_level_1, abbr[level_idx], int_level_2, abbr[level_idx + 1]);
		else
			sprintf_m12(offset_dur_str, "%d %s%s, %d %s%s", int_level_1, full[level_idx], PLURAL_m12(int_level_1), int_level_2, full[level_idx + 1], PLURAL_m12(int_level_2));
	} else {
		if (abbreviated == TRUE_m12)
			sprintf_m12(offset_dur_str, "%0.2lf %s", level_1, abbr[level_idx]);
		else
			sprintf_m12(offset_dur_str, "%0.2lf %ss", level_1, full[level_idx]);
	}
	
	return(dur_str);
}


void    STR_escape_chars_m12(si1 *string, si1 target_char, si8 buffer_len)
{
	si1	*c1, *c2, *tmp_str, backslash;
	si8     n_target_chars, len;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	backslash = (si1) 0x5c;
	
	// count
	for (n_target_chars = 0, c1 = string; *c1++;)
		if (*c1 == target_char)
			if (*(c1 - 1) != backslash)
				++n_target_chars;
	len = (c1 - string) + n_target_chars;
	if (buffer_len != 0) {  // if zero, proceed at caller's peril
		if (buffer_len < len) {
			G_error_message_m12("%s(): string buffer too small\n", __FUNCTION__);
			return;
		}
	}
	
	tmp_str = (si1 *) malloc(len);
	
	c1 = string;
	c2 = tmp_str;
	while (*c1) {
		if (*c1 == target_char) {
			if (*(c1 - 1) != backslash)
				*c2++ = backslash;
		}
		*c2++ = *c1++;
	}
	*c2 = 0;
	strcpy(string, tmp_str);
	
	free((void *) tmp_str);
	
	return;
}


si1	*STR_generate_hex_string_m12(ui1 *bytes, si4 num_bytes, si1 *string)
{
	si4	i;
	si1	*s;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (string == NULL)  // up to caller to free
		string = (si1 *) calloc_m12((size_t)((num_bytes + 1) * 3), sizeof(si1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	s = string;
	*s++ = '0';
	*s++ = 'x';
	
	for (i = 0; i < num_bytes; ++i) {
		sprintf_m12(s, " %02x", bytes[i]);
		if (bytes[i] < 0x10)
			*(s + 1) = '0';
		s += 3;
	}
	*s = 0;
	
	return(string);
}


si1	*STR_match_end_m12(si1 *pattern, si1 *buffer)
{
	// returns pointer to the character after the first match in the buffer, NULL if no match (assumes both pattern & buffer are zero-terminated)
	si4	pat_len, buf_len;
	si1	*pat_p, *buf_p;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	pat_len = strlen(pattern);
	buf_len = strlen(buffer);
	if (pat_len >= buf_len)
		return(NULL);
	
	do {
		pat_p = pattern;
		buf_p = buffer++;
		while (*buf_p++ == *pat_p++) {
			if (!*pat_p) {
				if (*buf_p)
					return(buf_p);
				else
					return(NULL);
			}
		}
	} while (*buf_p);
	
	return(NULL);
}


si1	*STR_match_end_bin_m12(si1 *pattern, si1 *buffer, si8 buf_len)
{
	si1	*pat_p, *buf_p, *buf_end;
	si8	pat_len;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// returns pointer to the character after the first match in the buffer, NULL if no match (assumes pattern is zero-terminated)
	// "bin" version allows for binary data in buffer (zeros in buffer)
	// NOTE: if updating buffer pointer in sequential calls, adjust buf_len accordingly

	pat_len = (si8) strlen(pattern);
	if (pat_len >= buf_len)
		return(NULL);
	
	buf_end = (buffer + buf_len) - pat_len;
	do {
		pat_p = pattern;
		buf_p = buffer++;
		while (*buf_p++ == *pat_p++) {
			if (buf_p == buf_end)
				return(NULL);
			if (!*pat_p)
				return(buf_p);
		}
		if (!*pat_p) {
			if (buf_p < buf_end)
				return(buf_p);
			return(NULL);
		}
	} while (buffer < buf_end);
	
	return(NULL);
}


si1	*STR_match_line_end_m12(si1 *pattern, si1 *buffer)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns pointer to beginning of the line following the line with first match, NULL if no match (assumes both pattern & buffer are zero-terminated)
	
	buffer = STR_match_end_m12(pattern, buffer);
	if (buffer == NULL)
		return(NULL);
	
	while (*buffer != '\n' && *buffer != '\r' && *buffer != 0)
		++buffer;
	if (*buffer == 0)
		return(NULL);
	
	while (*buffer == '\n' || *buffer != '\r')
		++buffer;
	
	if (*buffer == 0)
		return(NULL);
	
	return(buffer);
}


si1	*STR_match_line_start_m12(si1 *pattern, si1 *buffer)
{
	si1	*buf_p;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns pointer to beginning of the line containing the first match, NULL if no match (assumes both pattern & buffer are zero-terminated)

	buf_p = STR_match_start_m12(pattern, buffer);
	if (buf_p == NULL)
		return(NULL);
	
	while (*buf_p != '\n' && buf_p != buffer)
		--buf_p;
	
	if (buf_p == buffer)
		return(buffer);
	
	return(++buf_p);
}


si1	*STR_match_start_m12(si1 *pattern, si1 *buffer)
{
	si4	pat_len, buf_len;
	si1	*pat_p, *buf_p;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns pointer to beginning of the first match in the buffer, NULL if no match (assumes both pattern & buffer are zero-terminated)

	pat_len = strlen(pattern);
	buf_len = strlen(buffer);
	if (pat_len > buf_len)
		return(NULL);
	
	do {
		pat_p = pattern;
		buf_p = buffer++;
		while (*buf_p++ == *pat_p++)
			if (!*pat_p)
				return(--buffer);
	} while (*buf_p);
	
	return(NULL);
}


si1	*STR_match_start_bin_m12(si1 *pattern, si1 *buffer, si8 buf_len)
{
	si1	*pat_p, *buf_p, *buf_end;
	si8	pat_len;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// returns pointer to beginning of the first match in the buffer, NULL if no match (assumes pattern is zero-terminated)
	// "bin" version allows for binary data in buffer (zeros in buffer)
	// NOTE: if updating buffer pointer in sequential calls, adjust buf_len accordingly

	pat_len = (si8) strlen(pattern);
	if (pat_len >= buf_len)
		return(NULL);
	
	buf_end = (buffer + buf_len) - pat_len;
	do {
		pat_p = pattern;
		buf_p = buffer++;
		while (*buf_p++ == *pat_p++) {
			if (!*pat_p)
				return(--buffer);
			if (buf_p == buf_end)
				return(NULL);
		}
		if (!*pat_p) {
			if (buf_p <= buf_end)
				return(--buffer);
			return(NULL);
		}
	} while (buffer < buf_end);
	
	return(NULL);
}


si1     *STR_re_escape_m12(si1 *str, si1 *esc_str)
{
	si8     len;
	si1     *c1, *c2;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	c1 = str;
	while (*c1++);
	len = c1 - str;
	if (esc_str == NULL)  // up to caller to free
		esc_str = (si1 *) calloc_m12((size_t) (len * 2), sizeof(si1), __FUNCTION__, __LINE__);
	strcpy(esc_str, str);
	c1 = esc_str;
	c2 = str - 1;
	while (*++c2) {
		switch (*c2) {
			case '\n':
				*c1++ = '\\'; *c1++ = 'n'; break;
			case '\r':
				*c1++ = '\\'; *c1++ = 'r'; break;
			case '\t':
				*c1++ = '\\'; *c1++ = 't'; break;
			case '\7':
				*c1++ = '\\'; *c1++ = '7'; break;
			case '\\':
				*c1++ = '\\'; *c1++ = '\\'; break;
			default:
				*c1++ = *c2; break;
		}
	}
	*c1 = 0;
	
	return(esc_str);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void    STR_replace_char_m12(si1 c, si1 new_c, si1 *buffer)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Note: does not handle UTF8 chars
	// Done in place
	
	if (buffer == NULL || c == 0)
		return;
	
	do {
		if (*buffer == c)
			*buffer = new_c;
	} while (*buffer++);
	
	return;
}


si1	*STR_replace_pattern_m12(si1 *pattern, si1 *new_pattern, si1 *buffer, si1 *new_buffer)
{
	TERN_m12	in_place = FALSE_m12;
	si1		*c, *last_c, *new_c, *c2;
	si4		char_diff, extra_chars, matches;
	si8		len, pat_len, new_pat_len;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// if buffer new_buffer == new_buffer, done in place (adequate space assumed)
	// if buffer new_buffer == NULL, it is allocated

	if (pattern == NULL || new_pattern == NULL || buffer == NULL)
		return(NULL);
	if (*pattern == 0 || *buffer == 0)
		return(NULL);
	
	pat_len = strlen(pattern);
	new_pat_len = strlen(new_pattern);
	char_diff = new_pat_len - pat_len;
	
	matches = 0;
	c = buffer;
	while (1) {
		c = STR_match_end_m12(pattern, c);
		if (c == NULL)
			break;
		++matches;
	}
	if (!matches)
		return(buffer);
	
	extra_chars = matches * char_diff;
	len = strlen(buffer) + extra_chars + 1;  // extra byte for terminal zero
	if (new_buffer == buffer) {
		in_place = TRUE_m12;
		new_buffer = NULL;
	}
	if (new_buffer == NULL)
		new_buffer = (si1 *) calloc_m12((size_t) len, sizeof(ui1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	if (new_buffer != buffer)
		strcpy(new_buffer, buffer);
	
	last_c = c = buffer;
	new_c = new_buffer;
	extra_chars = 0;
	while (1) {
		c = STR_match_start_m12(pattern, c);
		if (c == NULL)
			break;
		while (last_c < c)
			*new_c++ = *last_c++;
		c2 = new_pattern;
		while (*c2)
			*new_c++ = *c2++;
		last_c = (c += pat_len);
	}
	while (*last_c)
		*new_c++ = *last_c++;
	*new_c = 0;
	
	if (in_place == TRUE_m12) {
		memcpy((void *) buffer, (void *) new_buffer, (size_t) len);
		free_m12((void *) new_buffer, __FUNCTION__);
		new_buffer = buffer;
	}
	
	return(new_buffer);
}


si1     *STR_size_string_m12(si1 *size_str, si8 n_bytes, TERN_m12 base_2)
{
	static si1              private_size_str[SIZE_STRING_BYTES_m12];
	static const si1        units[6][8] = {"bytes", "KB", "MB", "GB", "TB", "PB"};
	static const si1        i_units[6][8] = {"bytes", "KiB", "MiB", "GiB", "TiB", "PiB"};
	ui8                     i, j, t;
	sf8                     size;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// Note: if size_str == NULL, this function is not thread safe
	if (size_str == NULL)
		size_str = private_size_str;
	
	if (base_2 == TRUE_m12) {
		for (i = 0, j = 1, t = n_bytes; t >>= 10; ++i, j <<= 10);
		size = (sf8) n_bytes / (sf8) j;
		sprintf_m12(size_str, "%0.2lf %s", size, i_units[i]);
	} else {
		for (i = 0, j = 1, t = n_bytes; t /= 1000; ++i, j *= 1000);
		size = (sf8) n_bytes / (sf8) j;
		sprintf_m12(size_str, "%0.2lf %s", size, units[i]);
	}

	return(size_str);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	STR_sort_m12(si1 **string_array, si8 n_strings)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// input must be 2D string array, such as allocated by calloc_2D_m12()
	// sorts the pointers, does not move the strings
	
	qsort((void *) string_array, (size_t) n_strings, sizeof(si1 *), STR_compare_m12);
	
	return;
}


void    STR_strip_character_m12(si1 *s, si1 character)
{
	si1	*c1, *c2;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	c1 = c2 = s;
	while (*c2) {
		if (*c2 == character) {
			++c2;
			continue;
		}
		*c1++ = *c2++;
	}
	*c1 = 0;
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
const si1	*STR_tern_m12(TERN_m12 val)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	switch(val) {
		case -1:
			return("false");
		case 1:
			return("true");
		case 0:
			return("unknown");
		default:
			return("invalid");
	}
}


si1	*STR_time_string_m12(si8 uutc, si1 *time_str, TERN_m12 fixed_width, TERN_m12 relative_days, si4 colored_text, ...)  // time_str buffer sould be of length TIME_STRING_BYTES_m12
{
	si1			*standard_timezone_acronym, *standard_timezone_string, *date_color, *time_color, *color_reset, *meridian;
	static si1      	private_time_str[TIME_STRING_BYTES_m12];
	const si1      		*mos[12] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
	const si1		*months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
	const si1		*wdays[7] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
	const si1		*mday_num_sufs[32] = {	"", "st", "nd", "rd", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", \
							"th", "th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th", "th", "st" };
	const si1		*weekdays[7] = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };
	TERN_m12		offset;
	si4             	microseconds, DST_offset, day_num;
	time_t             	local_time, test_time;
	sf8             	UTC_offset_hours;
	va_list         	arg_p;
	struct tm       	ti;
	LOCATION_INFO_m12	loc_info = {0};
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Note if NULL is passed for time_str, this function is not thread-safe
	if (time_str == NULL)
		time_str = private_time_str;
	
	switch (uutc) {
		case UUTC_NO_ENTRY_m12:
			strcpy(time_str, "no entry");
			return(time_str);
		case BEGINNING_OF_TIME_m12:
			strcpy(time_str, "beginning of time");
			return(time_str);
		case END_OF_TIME_m12:
			strcpy(time_str, "end of time");
			return(time_str);
		case CURRENT_TIME_m12:
			uutc = G_current_uutc_m12();
			if (globals_m12->time_constants_set == FALSE_m12)  // set global time constants to location of machine
				if (G_get_location_info_m12(&loc_info, TRUE_m12, FALSE_m12) == NULL)
					G_warning_message_m12("%s(): daylight change data not available\n", __FUNCTION__);
			break;
	}
	
	if (globals_m12->RTO_known == FALSE_m12) {  // FALSE_m12 used to mean unknown and relevant.
		relative_days = offset = TRUE_m12;  // force relative days if using oUTC - nobody needs to know the 1970 date
	} else {  // use UNKNOWN_m12 (0) for cases in which recording time offset is irrelevant (e.g. times not associated with MED files)
		test_time = uutc - globals_m12->recording_time_offset;
		if (test_time < 0)  // time is offset
			uutc += globals_m12->recording_time_offset;
		offset = FALSE_m12;
	}
	DST_offset = G_DST_offset_m12(uutc);
	
	standard_timezone_acronym = globals_m12->standard_timezone_acronym;
	standard_timezone_string = globals_m12->standard_timezone_string;
	if (offset == FALSE_m12) {
		if (strncmp(standard_timezone_string, "offset", 6) == 0) {
			standard_timezone_acronym = "UTC";
			standard_timezone_string = "Coordinated Universal Time";
		}
	}
	local_time = (si8) (uutc / (si8) 1000000) + (si8) (globals_m12->standard_UTC_offset + DST_offset);
	microseconds = (si4) (uutc % (si8) 1000000);
#if defined MACOS_m12 || defined LINUX_m12
	gmtime_r(&local_time, &ti);
#endif
#ifdef WINDOWS_m12
	ti = *(gmtime(&local_time));
#endif
	ti.tm_year += 1900;
	
	if (colored_text == TRUE_m12) {
		va_start(arg_p, colored_text);
		date_color = va_arg(arg_p, si1 *);
		time_color = va_arg(arg_p, si1 *);
		va_end(arg_p);
		color_reset = TC_RESET_m12;
	} else {
		date_color = time_color = color_reset = "";
	}
	if (relative_days == TRUE_m12) {
		uutc -= globals_m12->recording_time_offset;
		day_num = (si4)(uutc / TWENTY_FOURS_HOURS_m12) + 1;
	}
	
	if (fixed_width == TRUE_m12) {
		UTC_offset_hours = (sf8)(DST_offset + globals_m12->standard_UTC_offset) / (sf8)3600.0;
		if (relative_days == TRUE_m12)
			sprintf_m12(time_str, "%sDay %04d  %s%02d:%02d:%02d.%06d", date_color, day_num, time_color, ti.tm_hour, ti.tm_min, ti.tm_sec, microseconds);
		else
			sprintf_m12(time_str, "%s%s %02d %s %d  %s%02d:%02d:%02d.%06d", date_color, wdays[ti.tm_wday], ti.tm_mday, mos[ti.tm_mon], ti.tm_year, time_color, ti.tm_hour, ti.tm_min, ti.tm_sec, microseconds);
		if (DST_offset) {
			if (UTC_offset_hours >= 0.0)
				sprintf_m12(time_str, "%s %s (UTC +%0.2lf)%s", time_str, globals_m12->daylight_timezone_acronym, UTC_offset_hours, color_reset);
			else
				sprintf_m12(time_str, "%s %s (UTC %0.2lf)%s", time_str, globals_m12->daylight_timezone_acronym, UTC_offset_hours, color_reset);
		}
		else {
			if (offset == TRUE_m12)  // no UTC offset displayed
				sprintf_m12(time_str, "%s %s%s", time_str, standard_timezone_acronym, color_reset);
			else if (UTC_offset_hours >= 0.0)
				sprintf_m12(time_str, "%s %s (UTC +%0.2lf)%s", time_str, standard_timezone_acronym, UTC_offset_hours, color_reset);
			else
				sprintf_m12(time_str, "%s %s (UTC %0.2lf)%s", time_str, standard_timezone_acronym, UTC_offset_hours, color_reset);
		}
	}
	else {
		ti.tm_sec += ((microseconds + 5e5) / 1e6);  // round to nearest second
		if (ti.tm_hour < 12) {
			meridian = "AM";
			if (ti.tm_hour == 0)
				ti.tm_hour = 12;
		}
		else {
			meridian = "PM";
			if (ti.tm_hour > 12)
				ti.tm_hour -= 12;
		}
		if (relative_days == TRUE_m12)
			sprintf_m12(time_str, "%sDay %04d  %s%d:%02d:%02d %s,", date_color, day_num, time_color, ti.tm_hour, ti.tm_min, ti.tm_sec, meridian);
		else
			sprintf_m12(time_str, "%s%s, %s %d%s, %d  %s%d:%02d:%02d %s,", date_color, weekdays[ti.tm_wday], months[ti.tm_mon], ti.tm_mday, mday_num_sufs[ti.tm_mday], ti.tm_year, time_color, ti.tm_hour, ti.tm_min, ti.tm_sec, meridian);
		if (DST_offset)
			sprintf_m12(time_str, "%s %s%s", time_str, globals_m12->daylight_timezone_string, color_reset);
		else
				sprintf_m12(time_str, "%s %s%s", time_str, standard_timezone_string, color_reset);
	}
	
	return(time_str);
}


void	STR_to_lower_m12(si1 *s)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	--s;
	while (*++s) {
		if (*s > 64 && *s < 91)
			*s += 32;
	}
	
	return;
}


void	STR_to_title_m12(si1 *s)
{
	TERN_m12	cap_mode;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// make all lower case
	STR_to_lower_m12(s);
	
	// capitalize first letter regardless of word
	if (*s > 96 && *s < 123)
		*s -= 32;
	
	cap_mode = FALSE_m12;
	while (*++s) {
		if (*s < 97 || *s > 122) {  // not a lower case letter
			if (*s == 32)  // space
				cap_mode = TRUE_m12;
			continue;
		}
		if (cap_mode == TRUE_m12) {
			switch (*s) {  // not exhaustive, but covers most cases
				case 'a':
					if (strncmp(s, "a ", 2) == 0) {
						++s;
						continue;
					}
					if (strncmp(s, "an ", 3) == 0) {
						s += 2;
						continue;
					}
					if (strncmp(s, "and ", 4) == 0) {
						s += 3;
						continue;
					}
					break;
				case 'b':
					if (strncmp(s, "but ", 4) == 0) {
						s += 3;
						continue;
					}
					if (strncmp(s, "by ", 3) == 0) {
						s += 2;
						continue;
					}
					break;
				case 'f':
					if (strncmp(s, "for ", 4) == 0) {
						s += 3;
						continue;
					}
					if (strncmp(s, "from ", 5) == 0) {
						s += 4;
						continue;
					}
					break;
				case 'i':
					if (strncmp(s, "if ", 3) == 0) {
						s += 2;
						continue;
					}
					break;
				case 'o':
					if (strncmp(s, "of ", 3) == 0) {
						s += 2;
						continue;
					}
					break;
				case 't':
					if (strncmp(s, "the ", 4) == 0) {
						s += 3;
						continue;
					}
					if (strncmp(s, "to ", 3) == 0) {
						s += 2;
						continue;
					}
					break;
				case 'w':
					if (strncmp(s, "with ", 5) == 0) {
						s += 4;
						continue;
					}
					if (strncmp(s, "within ", 7) == 0) {
						s += 6;
						continue;
					}
					if (strncmp(s, "without ", 8) == 0) {
						s += 7;
						continue;
					}
					break;
			}
			*s -= 32;
			cap_mode = FALSE_m12;
		}
	}
	
	return;
}


void	STR_to_upper_m12(si1 *s)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	--s;
	while (*++s) {
		if (*s > 96 && *s < 123)
			*s -= 32;
	}
	
	return;
}


void    STR_unescape_chars_m12(si1 *string, si1 target_char)
{
	si1	*c1, *c2, backslash;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	backslash = (si1) 0x5c;
	c1 = c2 = string;
	while (*c1) {
		if (*c1 == backslash) {
			if (*(c1 + 1) == target_char) {
				++c1;
				continue;
			}
		}
		*c2++ = *c1++;
	}
	*c2 = 0;
	
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si1	*STR_wchar2char_m12(si1 *target, wchar_t *source)
{
	si1	*c, *c2;
	si8	len, wsz;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// if source == target, done in place
	// if not actually ascii, results may be weird
	
	wsz = sizeof(wchar_t);  // 2 or 4 => varies by OS & compiler
	c = target;
	c2 = (si1 *) source - wsz;
	len = wcslen(source);
	
	while (len--)
		*c++ = *(c2 += wsz);  // little endian version
	*c = 0;
	
	return(target);
}



//***********************************//
// MARK: TRANSMISSION FUNCTIONS  (TR)
//***********************************//

TR_INFO_m12	*TR_alloc_trans_info_m12(si8 buffer_bytes, ui4 ID_code, ui1 header_flags, sf4 timeout, si1 *password)
{
	TR_INFO_m12	*trans_info;
	TR_HEADER_m12	*header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// allocate
	trans_info = (TR_INFO_m12 *) calloc_m12((size_t) 1, sizeof(TR_INFO_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	trans_info->buffer_bytes = buffer_bytes;  // bytes available for data
	trans_info->buffer = (ui1 *) calloc_m12((size_t) (buffer_bytes + TR_HEADER_BYTES_m12), sizeof(ui1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);  // add room for header
	trans_info->data = trans_info->buffer + TR_HEADER_BYTES_m12;
	trans_info->mss = TR_INET_MSS_BYTES_m12;  // change to TR_LO_MSS_BYTES_m12 for backplane
	trans_info->sock_fd = -1;
	trans_info->timeout = timeout;
	trans_info->mode = TR_MODE_NONE_m12;
	header = trans_info->header;
	header->flags = header_flags;
	header->ID_code = ID_code;

	// set header defaults
	header->type = TR_TYPE_DEFAULT_m12;
	header->version = TR_VERSION_DEFAULT_m12;
	
	// password / expanded key only required for encrypted transissions
	trans_info->expanded_key_allocated = FALSE_m12;
	if (password != NULL) {
		if (*password) {
			trans_info->expanded_key = (ui1 *) malloc_m12((size_t) AES_EXPANDED_KEY_BYTES_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			AES_key_expansion_m12(trans_info->expanded_key, password);
			trans_info->expanded_key_allocated = TRUE_m12;
		}
	}
	
	// create socket (this function also sets timeout)
	TR_create_socket_m12(trans_info);

	return(trans_info);
}


TERN_m12	TR_bind_m12(TR_INFO_m12 *trans_info, si1 *iface_addr, ui2 iface_port)
{
	TERN_m12		sys_asgn_iface_addr, sys_asgn_iface_port;
	si4			sock_fd;
	si2			sock_fam = AF_INET;  // change to AF_UNSPEC to support IPv4 or IPv6
	NET_PARAMS_m12		np;
	struct sockaddr_in	sock_addr = { 0 };
	socklen_t		si_len;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	sys_asgn_iface_addr = sys_asgn_iface_port = FALSE_m12;
	
	if (iface_addr == TR_IFACE_ANY_m12) {
		*trans_info->iface_addr = 0;
		sys_asgn_iface_addr = TRUE_m12;
	} else if (*iface_addr == 0) {  // TR_IFACE_DFLT_m12
		if (*global_tables_m12->NET_params.LAN_IPv4_address_string == 0)
			NET_get_lan_ipv4_address_m12(NULL, &global_tables_m12->NET_params);
		strcpy(trans_info->iface_addr, global_tables_m12->NET_params.LAN_IPv4_address_string);
	} else if (*iface_addr >= 'A' && *iface_addr <= 'z') {  // user passed interface name, get ip
		NET_get_lan_ipv4_address_m12(NULL, &global_tables_m12->NET_params);
		if (NET_get_parameters_m12(iface_addr, &np) == NULL) {
			G_warning_message_m12("%s(): cannot get IP address for interface name \"%s\"\n", __FUNCTION__, iface_addr);
			return(FALSE_m12);
		} else {
			strcpy(trans_info->iface_addr, np.LAN_IPv4_address_string);
		}
	} else if (*iface_addr >= '0' && *iface_addr <= '9') {  // user passed ip
		if (trans_info->iface_addr != iface_addr)
			strcpy(trans_info->iface_addr, iface_addr);
	} else {
		G_warning_message_m12("%s(): improper IP address or interface name: \"%s\"\n", __FUNCTION__, iface_addr);
		return(FALSE_m12);
	}
	
	if (iface_port == TR_PORT_ANY_m12)
		sys_asgn_iface_port = TRUE_m12;
	trans_info->iface_port = iface_port;

	if (trans_info->sock_fd <= 0)
		TR_create_socket_m12(trans_info);
	sock_fd = trans_info->sock_fd;

	// set socket reuse address option
	#if defined MACOS_m12 || defined LINUX_m12
	si4	flags;
	#endif
	#ifdef WINDOWS_m12
	si1	flags;
	#endif
	flags = 1;
	if (setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, &flags, sizeof(flags)) == -1) {
		G_warning_message_m12("%s: socket option error\n", __FUNCTION__);
		return(FALSE_m12);
	}

	// set socket info
	si_len = sizeof(struct sockaddr_in);
	sock_addr.sin_family = sock_fam;
	sock_addr.sin_port = htons(trans_info->iface_port);  // set local port (in internet byte order)
	if (sys_asgn_iface_addr == TRUE_m12)
		sock_addr.sin_addr.s_addr = 0;  // htonl(INADDR_ANY)
	else
		inet_pton(sock_fam, trans_info->iface_addr, &sock_addr.sin_addr);  // set local address for bind()

	// bind socket to local interface
	if (bind(sock_fd, (struct sockaddr *) &sock_addr, sizeof(struct sockaddr_in))) {
		G_warning_message_m12("%s(): socket binding error\n", __FUNCTION__);
		#if defined MACOS_m12 || defined LINUX_m12
		close(sock_fd);
		#endif
		#ifdef WINDOWS_m12
		closesocket(sock_fd);
		#endif
		return(FALSE_m12);
	}

	// get system assigned interface values
	if (sys_asgn_iface_addr == TRUE_m12 || sys_asgn_iface_port == TRUE_m12) {
		getsockname(sock_fd, (struct sockaddr *) &sock_addr, &si_len);
		if (sys_asgn_iface_addr == TRUE_m12)
			inet_ntop(sock_fam, &sock_addr.sin_addr, trans_info->iface_addr, si_len);  // usually 0.0.0.0
		if (sys_asgn_iface_port == TRUE_m12)
			trans_info->iface_port = ntohs(sock_addr.sin_port);
	}

	return(TRUE_m12);
}



void	TR_build_message_m12(TR_MESSAGE_HEADER_m12 *msg, si1 *message_text)
{
	si4	encrpyption_blocks;
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	msg->time = G_current_uutc_m12();
	encrpyption_blocks = (strlen(message_text) + ENCRYPTION_BLOCK_BYTES_m12) / ENCRYPTION_BLOCK_BYTES_m12;  // include room for terminal zero
	msg->message_bytes = encrpyption_blocks * ENCRYPTION_BLOCK_BYTES_m12;
	strncpy_m12((si1 *) (msg + 1), message_text, msg->message_bytes);  // zero unused bytes
	
	return;
}


TERN_m12	TR_check_transmission_header_alignment_m12(ui1 *bytes)
{
	TR_HEADER_m12		*th;
	TERN_m12                free_flag = FALSE_m12;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// see if already checked
	if (globals_m12->transmission_header_aligned == UNKNOWN_m12)
		globals_m12->transmission_header_aligned = FALSE_m12;
	else
		return(globals_m12->transmission_header_aligned);
	
	// check overall size
	if (sizeof(TR_HEADER_m12) != TR_HEADER_BYTES_m12)
		goto TRANSMISSION_HEADER_NOT_ALIGNED_m12;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc_m12(TR_HEADER_BYTES_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free_flag = TRUE_m12;
	}
	th = (TR_HEADER_m12 *) bytes;
	if (&th->crc != (ui4 *) (bytes + TR_CRC_OFFSET_m12))
		goto TRANSMISSION_HEADER_NOT_ALIGNED_m12;
	if (&th->packet_bytes != (ui2 *) (bytes + TR_PACKET_BYTES_OFFSET_m12))
		goto TRANSMISSION_HEADER_NOT_ALIGNED_m12;
	if (&th->flags != (ui2 *) (bytes + TR_FLAGS_OFFSET_m12))
		goto TRANSMISSION_HEADER_NOT_ALIGNED_m12;
	if (th->ID_string != (si1 *) (bytes + TR_ID_STRING_OFFSET_m12))
		goto TRANSMISSION_HEADER_NOT_ALIGNED_m12;
	if (&th->ID_string_terminal_zero != (si1 *) (bytes + TR_ID_STRING_TERMINAL_ZERO_OFFSET_m12))
		goto TRANSMISSION_HEADER_NOT_ALIGNED_m12;
	if (&th->ID_code != (ui4 *) (bytes + TR_ID_CODE_OFFSET_m12))
		goto TRANSMISSION_HEADER_NOT_ALIGNED_m12;
	if (&th->type != (ui1 *) (bytes + TR_TYPE_OFFSET_m12))
		goto TRANSMISSION_HEADER_NOT_ALIGNED_m12;
	if (&th->subtype != (ui1 *) (bytes + TR_SUBTYPE_OFFSET_m12))
		goto TRANSMISSION_HEADER_NOT_ALIGNED_m12;
	if (&th->version != (ui1 *) (bytes + TR_VERSION_OFFSET_m12))
		goto TRANSMISSION_HEADER_NOT_ALIGNED_m12;
	if (&th->transmission_bytes != (si8 *) (bytes + TR_TRANSMISSION_BYTES_OFFSET_m12))
		goto TRANSMISSION_HEADER_NOT_ALIGNED_m12;
	if (&th->offset != (si8 *) (bytes + TR_OFFSET_OFFSET_m12))
		goto TRANSMISSION_HEADER_NOT_ALIGNED_m12;

	// aligned
	globals_m12->transmission_header_aligned = TRUE_m12;
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_message_m12("TR_HEADER_m12 structure is aligned");
	
	return(TRUE_m12);
	
	// not aligned
TRANSMISSION_HEADER_NOT_ALIGNED_m12:
	
	if (free_flag == TRUE_m12)
		free((void *) bytes);
	
	if (globals_m12->verbose == TRUE_m12)
		G_error_message_m12("%s(): TR_HEADER_m12 structure is NOT aligned", __FUNCTION__);
	
	return(FALSE_m12);
}


void	TR_close_transmission_m12(TR_INFO_m12 *trans_info)
{

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
// ??? shutdown screwing up TCP close, shutdown necessary?
	// TCP: receiver should initiate closure, send should wait for it
//	if ((trans_info->header->flags & TR_FLAGS_UDP_m12) == 0) {  // TCP bit == zero
//		if (trans_info->mode == TR_MODE_SEND_m12) {
//			ui1	buffer[8];
//			TR_set_socket_blocking_m12(trans_info, TRUE_m12);  // in case socket is non-blocking
//			// not expecting any further transmissions, so should block until socket closes
//			recv(trans_info->sock_fd, (void *) buffer, 8, 0);
//		}
//	}

#if defined MACOS_m12 || defined LINUX_m12
	if (trans_info->mode == TR_MODE_FORCE_CLOSE_m12)
		shutdown(trans_info->sock_fd, SHUT_RDWR);
	close(trans_info->sock_fd);
#endif
#ifdef WINDOWS_m12
	if (trans_info->mode == TR_MODE_FORCE_CLOSE_m12)
		shutdown(trans_info->sock_fd, SD_BOTH);
	closesocket(trans_info->sock_fd);
#endif
	trans_info->sock_fd = -1;
	trans_info->mode = TR_MODE_NONE_m12;
	
	return;
}


TERN_m12	TR_connect_m12(TR_INFO_m12 *trans_info, si1 *dest_addr, ui2 dest_port)
{
	TERN_m12		blocking, connected;
	si2			sock_fam = AF_INET;  // change to AF_UNSPEC to support IPv4 or IPv6
	si4			sock_fd, err, ret_val, timeout_ms;
	struct sockaddr_in	sock_addr = { 0 };
#if defined MACOS_m12 || defined LINUX_m12
	struct pollfd		fds;
#endif
#ifdef WINDOWS_m12
	WSAPOLLFD		fds;
#endif

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// connect() does not use the socket timeout value
	// this function uses poll() to accomplish that
	// the timeout value is read from the TR_INFO_m12 structure
	
	if (trans_info->sock_fd <= 0)
		TR_create_socket_m12(trans_info);
	sock_fd = trans_info->sock_fd;

	if (*dest_addr >= 'A' && *dest_addr <= 'z') {  // user passed domain, get ip
		if (NET_domain_to_ip_m12(dest_addr, trans_info->dest_addr) == FALSE_m12) {
			G_warning_message_m12("%s(): cannot get IP address for domain \"%s\"\n", __FUNCTION__, dest_addr);
			return(FALSE_m12);
		}
	} else if (*dest_addr >= '0' && *dest_addr <= '9') {  // user passed ip
		if (trans_info->dest_addr != dest_addr)
			strcpy(trans_info->dest_addr, dest_addr);
	} else if (*dest_addr == 0) {  // user passed no destination
		G_warning_message_m12("%s(): no destination address\n", __FUNCTION__);
		return(FALSE_m12);
	} else {
		G_warning_message_m12("%s(): improper IP address or domain: \"%s\"\n", __FUNCTION__, dest_addr);
		return(FALSE_m12);
	}
	trans_info->dest_port = dest_port;
	
	// connect socket to remote interface
	inet_pton(sock_fam, trans_info->dest_addr, &sock_addr.sin_addr);   // set remote address for connect()
	sock_addr.sin_port = htons(trans_info->dest_port);  // set local port (in internet byte order)
	sock_addr.sin_family = sock_fam;  // set socket family
	
	// set socket to non-blocking (if not already)
	blocking = TR_set_socket_blocking_m12(trans_info, UNKNOWN_m12);
	if (blocking == TRUE_m12)
		TR_set_socket_blocking_m12(trans_info, FALSE_m12);

	// try to connect
	connected = TRUE_m12;
	errno_reset_m12();
	ret_val = connect(sock_fd, (struct sockaddr *) &sock_addr, sizeof(struct sockaddr_in));
	if (ret_val == -1) {
		err = errno_m12();
		// see if just not connected yet
		if (errno == EINPROGRESS) {
			// wait for socket to be writable, or return after socket timeout
			if (trans_info->timeout > (sf4) 0.0)
				timeout_ms = (si4) (((sf8) trans_info->timeout * (sf8) 1000.0) + (sf8) 0.5);  // timeout in ms
			else
				timeout_ms = 5;  // default to 5 second timeout

			// use poll() because socket fd's often exceed set size limit (1024) of select()
#if defined MACOS_m12 || defined LINUX_m12
			memset((void *) &fds, 0, sizeof(struct pollfd));
#endif
#ifdef WINDOWS_m12
			memset((void *) &fds, 0, sizeof(WSAPOLLFD));
#endif
			fds.fd = sock_fd;
			fds.events = POLLOUT;
			errno_reset_m12();
#if defined MACOS_m12 || defined LINUX_m12
			ret_val = poll(&fds, (nfds_t) 1, timeout_ms);
#endif
#ifdef WINDOWS_m12
			ret_val = WSAPoll(&fds, (ULONG) 1, timeout_ms);
#endif
			if (ret_val == -1) {
				err = errno_m12();
			} else if (ret_val == 0) {
				err = ETIMEDOUT;  // timed out
				ret_val = -1;
			} else if (fds.revents != POLLOUT) {
				err = EACCES;  // socket not writable
				ret_val = -1;
			}
		}
		if (ret_val == -1) {
			connected = FALSE_m12;
			G_warning_message_m12("%s(): socket connect error: #%d: %s\n", __FUNCTION__, err, strerror(err));
			TR_close_transmission_m12(trans_info);
		}
	}

	// reset socket to blocking if necessary
	if (blocking == TRUE_m12)
		TR_set_socket_blocking_m12(trans_info, TRUE_m12);

	return(connected);
}


TERN_m12	TR_connect_to_server_m12(TR_INFO_m12 *trans_info, si1 *dest_addr, ui2 dest_port)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// binds to default route interface & then connects

	if (trans_info->sock_fd <= 0)
		TR_create_socket_m12(trans_info);
	
	// bind to default interface, any port
	if (TR_bind_m12(trans_info, TR_IFACE_DFLT_m12, TR_PORT_ANY_m12) == FALSE_m12)
		return(FALSE_m12);
	
	return(TR_connect_m12(trans_info, dest_addr, dest_port));
}


TERN_m12	TR_create_socket_m12(TR_INFO_m12 *trans_info)
{
	si2				sock_fam = AF_INET;
	si4				sock_type, sock_protocol;
	TR_HEADER_m12			*header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (trans_info->sock_fd > 0)
		TR_close_transmission_m12(trans_info);  // don't leave existing socket open
	
	// create socket
	header = trans_info->header;
	if (header->flags & TR_FLAGS_UDP_m12) {
		sock_type = SOCK_DGRAM;
		sock_protocol = IPPROTO_UDP;
	} else {  // TCP
		sock_type = SOCK_STREAM;
		sock_protocol = IPPROTO_TCP;
	}
	if ((trans_info->sock_fd = socket(sock_fam, sock_type, sock_protocol)) == -1) {
		G_warning_message_m12("%s(): socket creation error\n", __FUNCTION__);
		return(FALSE_m12);
	}

	// set socket timeout
	if (trans_info->timeout > (sf4) 0.0)
		TR_set_socket_timeout_m12(trans_info);
			
	return(TRUE_m12);
}


void	TR_free_transmission_info_m12(TR_INFO_m12 **trans_info_ptr, TERN_m12 free_structure)
{
	TR_INFO_m12 	*trans_info;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	trans_info = *trans_info_ptr;
	if (trans_info == NULL) {
		G_warning_message_m12("%s(): attempting to free NULL pointer", __FUNCTION__);
		return;
	}
	
	TR_close_transmission_m12(trans_info);

	if (trans_info->buffer != NULL)
		free_m12((void *) trans_info->buffer, __FUNCTION__);
	
	if (trans_info->expanded_key_allocated == TRUE_m12)  // don't free password itself - passed by caller
		free_m12((void *) trans_info->expanded_key, __FUNCTION__);
		
	if (free_structure == TRUE_m12) {
		free_m12((void *) trans_info, __FUNCTION__);
		*trans_info_ptr = NULL;
	} else {
		trans_info->buffer = NULL;
		trans_info->buffer_bytes = 0;
		trans_info->expanded_key = NULL;
		trans_info->expanded_key_allocated = FALSE_m12;
	}

	return;
}


void	TR_realloc_trans_info_m12(TR_INFO_m12 *trans_info, si8 buffer_bytes, TR_HEADER_m12 **caller_header)
{
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (buffer_bytes > trans_info->buffer_bytes) {
		trans_info->buffer = (ui1 *) realloc_m12((void *) trans_info->buffer, (size_t) (buffer_bytes + TR_HEADER_BYTES_m12), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		trans_info->buffer_bytes = buffer_bytes;
		trans_info->data = trans_info->buffer + TR_HEADER_BYTES_m12;
		if (caller_header != NULL)
			*caller_header = trans_info->header;
	}

	return;
}


si8	TR_recv_transmission_m12(TR_INFO_m12 *trans_info, TR_HEADER_m12 **caller_header)
{
	TERN_m12	password_passed, acknowledge;
	ui1		*buffer, *partial_pkt;
	ui2		max_pkt_bytes;
	ui4		ID_code;
	si4		sock_fd, attempts, err;
	sf4		curr_timeout;
	si8		data_bytes, data_bytes_received, ret_val, packet_bytes_remaining;
	TR_HEADER_m12	*header, *pkt_header, *ack_header, saved_data;
	TR_INFO_m12	*ack_trans_info;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	if (trans_info == NULL) {
		G_warning_message_m12("%s(): transmission info is NULL\n", __FUNCTION__);
		return((si8) FALSE_m12);
	}
	trans_info->mode = TR_MODE_NONE_m12;  // zero until transmission successful (not set for acknowlegements)
	if (trans_info->sock_fd == -1) {  // try to reopen socket
		if (TR_create_socket_m12(trans_info) == FALSE_m12)
			return((si8) FALSE_m12);
		if (TR_bind_m12(trans_info, trans_info->iface_addr, TR_PORT_ANY_m12) == FALSE_m12)
			return((si8) FALSE_m12);
		if (TR_connect_m12(trans_info, trans_info->dest_addr, trans_info->dest_port) == FALSE_m12)
			return((si8) FALSE_m12);
	}
	buffer = trans_info->buffer;
	header = trans_info->header;
	sock_fd = trans_info->sock_fd;
	ID_code = header->ID_code;
	max_pkt_bytes = trans_info->mss + TR_HEADER_BYTES_m12;

	// receive
	attempts = 0;
	data_bytes_received = 0;
	acknowledge = UNKNOWN_m12;
	do {
		pkt_header = (TR_HEADER_m12 *) (buffer + data_bytes_received);
		if (data_bytes_received)
			saved_data = *pkt_header;
			
		// recv
		errno_reset_m12();
		ret_val = recv(sock_fd, (void *) pkt_header, max_pkt_bytes, 0);
				
		// receive checks
		if (ret_val < TR_HEADER_BYTES_m12) {
			if (ret_val == 0) {
				data_bytes_received = TR_E_SOCK_CLOSED_m12;
				G_warning_message_m12("%s(%s:%hu <- %s:%hu): %s\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, TR_strerror(data_bytes_received));
			} else if (ret_val < 0) {
				err = errno_m12();
				if (TR_set_socket_blocking_m12(trans_info, UNKNOWN_m12) == FALSE_m12)
					if (err == EAGAIN || err == EWOULDBLOCK)  // no data available on non-blocking socket (on most OS implementations these are the same number)
						return(TR_E_NO_DATA_m12);
				if (err == ETIMEDOUT) {  // timeout
					data_bytes_received = TR_E_SOCK_TIMED_OUT_m12;
					G_warning_message_m12("%s(%s:%hu <- %s:%hu): %s\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, TR_strerror(data_bytes_received));
				} else {
					data_bytes_received = TR_E_SOCK_FAILED_m12;
					G_warning_message_m12("%s(%s:%hu <- %s:%hu): %s (sock errno %d)\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, TR_strerror(data_bytes_received), err);
				}
			} else {
				data_bytes_received = TR_E_UNSPEC_m12;
				G_warning_message_m12("%s(%s:%hu <- %s:%hu): receive too small for header (%ld bytes)\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, ret_val);
			}
			goto TR_RECV_FAIL_m12;
		}

		// check ID code
		if (pkt_header->ID_code != ID_code) {
			data_bytes_received = TR_E_ID_MISMATCH_m12;
			goto TR_RECV_FAIL_m12;
		}
				
		// keep alive
		if (pkt_header->packet_bytes == TR_HEADER_BYTES_m12 && pkt_header->type == TR_TYPE_KEEP_ALIVE_m12)
			break;
		
		// sender requested acknowledgment
		if (acknowledge == UNKNOWN_m12) {
			acknowledge = FALSE_m12;
			if (header->flags & TR_FLAGS_UDP_m12) {  // TCP has built in acknowledgment
				if (header->flags & TR_FLAGS_ACKNOWLEDGE_m12) {
					acknowledge = TRUE_m12;
					ack_trans_info = (TR_INFO_m12 *) calloc((size_t) 1, sizeof(TR_INFO_m12));
					ack_header = ack_trans_info->header;
					ack_header->ID_code = ID_code;
					ack_header->type = TR_TYPE_ACK_OK_m12;
					ack_trans_info->sock_fd = sock_fd;
				}
			}
		}

		if (ret_val < (si8) pkt_header->packet_bytes) {
			// first try to receive rest of packet (shouldn't happen often: inet mss chosen to avoid this)
			partial_pkt = (ui1 *) pkt_header;
			packet_bytes_remaining = (si8) pkt_header->packet_bytes - ret_val;
			curr_timeout = trans_info->timeout;
			trans_info->timeout = (sf4) 2.0;  // wait no more than 2 seconds for subsequent sends
			TR_set_socket_timeout_m12(trans_info);
			attempts = 0; do {
				partial_pkt += ret_val;
				ret_val = recv(sock_fd, (void *) partial_pkt, max_pkt_bytes, 0);
				if (ret_val <= 0)
					break;
				packet_bytes_remaining -= ret_val;
			} while (packet_bytes_remaining > 0 && attempts++ < 3);
			trans_info->timeout = curr_timeout;  // reset timeout
			TR_set_socket_timeout_m12(trans_info);

			// couldn't get full packet
			if (packet_bytes_remaining > 0) {
				if (acknowledge == TRUE_m12) {
					if (attempts++ < TR_RETRANSMIT_ATTEMPTS_m12) {
						ack_header->flags = TR_TYPE_ACK_RETRANSMIT_m12;
						TR_send_transmission_m12(ack_trans_info);
						data_bytes_received = 0;
						continue;
					}
				}
				data_bytes_received = TR_E_TRANS_FAILED_m12;
				G_warning_message_m12("%s(%s:%hu <- %s:%hu): packet size error\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port);
				goto TR_RECV_FAIL_m12;
			}
		}
		
		// CRC
		if (pkt_header->flags & TR_FLAGS_CRC_m12) {
			if (CRC_validate_m12((ui1 *) pkt_header + CRC_BYTES_m12, pkt_header->packet_bytes - CRC_BYTES_m12, pkt_header->crc) == FALSE_m12) {
				if (acknowledge == TRUE_m12) {
					if (attempts++ < TR_RETRANSMIT_ATTEMPTS_m12) {
						ack_header->type = TR_TYPE_ACK_RETRANSMIT_m12;
						TR_send_transmission_m12(ack_trans_info);
						continue;
					}
				}
				data_bytes_received = TR_E_CRC_MISMATCH_m12;
				G_warning_message_m12("%s(%s:%hu <- %s:%hu): %s\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, TR_strerror(data_bytes_received));
				goto TR_RECV_FAIL_m12;
			}
		}
		
		if (acknowledge == TRUE_m12)
			TR_send_transmission_m12(ack_trans_info);
		
		// realloc
		if (pkt_header->transmission_bytes > trans_info->buffer_bytes)
			TR_realloc_trans_info_m12(trans_info, pkt_header->transmission_bytes, &header);
		
		// move data into place
		data_bytes = (si8) (pkt_header->packet_bytes - (ui2) TR_HEADER_BYTES_m12);
		if (data_bytes_received)
			*pkt_header = saved_data;

		// update
		data_bytes_received += data_bytes;
		attempts = 0;  // reset counter
		
	} while (data_bytes_received < pkt_header->transmission_bytes);
	
	// get key
	if (pkt_header->flags & TR_FLAGS_INCLUDE_KEY_m12) {
		if (trans_info->expanded_key == NULL) {
			trans_info->expanded_key = malloc_m12(ENCRYPTION_KEY_BYTES_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			trans_info->expanded_key_allocated = TRUE_m12;
		}
		pkt_header->transmission_bytes -= ENCRYPTION_KEY_BYTES_m12;
		data_bytes_received -= ENCRYPTION_KEY_BYTES_m12;
		memcpy((void *) trans_info->expanded_key, (void *) (trans_info->data + pkt_header->transmission_bytes), (size_t) ENCRYPTION_KEY_BYTES_m12);
		AES_leftover_decrypt_m12(ENCRYPTION_KEY_BYTES_m12, trans_info->expanded_key);
	}

	// decrypt
	if (pkt_header->flags & TR_FLAGS_ENCRYPT_m12) {
		if (trans_info->expanded_key == NULL) {
			G_push_behavior_m12(SUPPRESS_OUTPUT_m12);
			password_passed = G_check_password_m12(trans_info->password);
			G_pop_behavior_m12();
			if (password_passed == FALSE_m12) {
				G_warning_message_m12("%s(): no password or expanded key => cannot decrypt transmission\n", __FUNCTION__);
				return(TR_E_UNSPEC_m12);
			}
			trans_info->expanded_key = (ui1 *) malloc_m12((size_t) ENCRYPTION_KEY_BYTES_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			trans_info->expanded_key_allocated = TRUE_m12;
			AES_key_expansion_m12(trans_info->expanded_key, trans_info->password);
		}
		AES_decrypt_m12(trans_info->data, data_bytes_received, NULL, trans_info->expanded_key);
	}

	trans_info->mode = TR_MODE_RECV_m12;  // set only if transmission successful

TR_RECV_FAIL_m12:
	
	// update & clean header
	*header = *pkt_header;
	header->crc = 0;
	header->packet_bytes = 0;
	header->offset = 0;

	// reset encryption flags
	header->flags &= ~(TR_FLAGS_ENCRYPT_m12 | TR_FLAGS_INCLUDE_KEY_m12);
	
	// close on request or error
	if (data_bytes_received < 0 || header->flags & TR_FLAGS_CLOSE_m12) {
		TR_close_transmission_m12(trans_info);
		header->flags &= ~TR_FLAGS_CLOSE_m12;  // reset close flag if set
	}
	
	// clean up
	if (acknowledge == TRUE_m12)
		free((void *) ack_trans_info);
	
	return(data_bytes_received);
}


TERN_m12	TR_send_message_m12(TR_INFO_m12 *trans_info, ui1 type, TERN_m12 encrypt, si1 *fmt, ...)
{
	si1			*message_text;
	si8			bytes_sent;
	va_list 		args;
	TR_HEADER_m12		*header;
	TR_MESSAGE_HEADER_m12	*msg;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	switch (type) {
		case TR_ERROR_TYPE_m12:
		case TR_WARNING_TYPE_m12:
		case TR_SUCCESS_TYPE_m12:
		case TR_MESSAGE_TYPE_m12:
			break;
		default:
			G_warning_message_m12("%s(): unrecognized message type\n", __FUNCTION__);
			return(FALSE_m12);
	}

	header = trans_info->header;
	msg = (TR_MESSAGE_HEADER_m12 *) (header + 1);
	message_text = (si1 *) (msg + 1);
	va_start(args, fmt);
	vsprintf_m12(message_text, fmt, args);
	va_end(args);
	TR_build_message_m12(msg, message_text);

	header->type = type;
	if (type == TR_ERROR_TYPE_m12)
		header->flags |= TR_FLAGS_CLOSE_m12;
	if (encrypt == TRUE_m12)
		header->flags |= TR_FLAGS_ENCRYPT_m12;
	header->transmission_bytes = TR_MESSAGE_HEADER_BYTES_m12 + msg->message_bytes;
	
	bytes_sent = TR_send_transmission_m12(trans_info);
	header = trans_info->header;
	if (bytes_sent != header->transmission_bytes)
		return(FALSE_m12);

	return(TRUE_m12);
}


si8	TR_send_transmission_m12(TR_INFO_m12 *trans_info)  // expanded_key can be NULL if not encypting
{
	TERN_m12	password_passed, acknowledge, no_destruct_flag;
	ui1		*buffer, *data;
	ui2		data_bytes, packet_bytes;
	ui4		ID_code;
	si4		sock_fd, attempts, err;
	si8		ret_val, data_bytes_sent, data_bytes_remaining, bytes_received, actual_data_bytes;
	TR_HEADER_m12	*header, *pkt_header, *ack_header, saved_data;
	TR_INFO_m12	*ack_trans_info;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (trans_info == NULL) {
		G_warning_message_m12("%s(): transmission info is NULL\n", __FUNCTION__);
		return((si8) FALSE_m12);
	}
	trans_info->mode = TR_MODE_NONE_m12;  // zero until transmission successful (not set for acknowlegements)
	if (trans_info->sock_fd == -1) {  // try to reopen socket
		if (TR_create_socket_m12(trans_info) == FALSE_m12)
			return((si8) FALSE_m12);
		if (TR_bind_m12(trans_info, trans_info->iface_addr, TR_PORT_ANY_m12) == FALSE_m12)
			return((si8) FALSE_m12);
		if (TR_connect_m12(trans_info, trans_info->dest_addr, trans_info->dest_port) == FALSE_m12)
			return((si8) FALSE_m12);
	}
	header = trans_info->header;
	ID_code = header->ID_code;
	buffer = trans_info->buffer;
	data = trans_info->data;
	sock_fd = trans_info->sock_fd;

	if (header->transmission_bytes > trans_info->buffer_bytes) {
		G_warning_message_m12("%s(): buffer too small for transmission\n", __FUNCTION__);
		return(TR_E_UNSPEC_m12);
	}
	
	// encryption
	if (header->flags & TR_FLAGS_ENCRYPT_m12) {
		if (trans_info->expanded_key == NULL) {
			G_push_behavior_m12(SUPPRESS_OUTPUT_m12);
			password_passed = G_check_password_m12(trans_info->password);
			G_pop_behavior_m12();
			if (password_passed == FALSE_m12) {
				G_warning_message_m12("%s(): no password or expanded key => cannot encrypt transmission\n", __FUNCTION__);
				return(TR_E_UNSPEC_m12);
			}
			trans_info->expanded_key = (ui1 *) malloc_m12((size_t) ENCRYPTION_KEY_BYTES_m12, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			trans_info->expanded_key_allocated = TRUE_m12;
			AES_key_expansion_m12(trans_info->expanded_key, trans_info->password);
		}
	}
	
	// no destruct flag - send side only
	no_destruct_flag = FALSE_m12;
	if (header->flags & TR_FLAGS_NO_DESTRUCT_m12) {
		no_destruct_flag = TRUE_m12;
		header->flags &= ~TR_FLAGS_NO_DESTRUCT_m12; // reset before transmission so receiver doesn't use it on subsequent send
	}
	
	// include key
	actual_data_bytes = header->transmission_bytes;  // save this value for encryption
	if (header->flags & TR_FLAGS_INCLUDE_KEY_m12) {
		TR_realloc_trans_info_m12(trans_info, header->transmission_bytes + ENCRYPTION_KEY_BYTES_m12, &header);
		memcpy((void *) (trans_info->data + header->transmission_bytes), (void *) trans_info->expanded_key, (size_t) ENCRYPTION_KEY_BYTES_m12);
		AES_leftover_encrypt_m12(ENCRYPTION_KEY_BYTES_m12, trans_info->data + header->transmission_bytes);
		header->transmission_bytes += ENCRYPTION_KEY_BYTES_m12;
	}
	
	// encrypt
	if (header->flags & TR_FLAGS_ENCRYPT_m12)
		AES_encrypt_m12(data, actual_data_bytes, NULL, trans_info->expanded_key);
	
	// acknowledge
	acknowledge = FALSE_m12;
	if (header->flags & TR_FLAGS_UDP_m12)  // TCP has built in acknowledgment
		if (header->flags & TR_FLAGS_ACKNOWLEDGE_m12)
			acknowledge = TRUE_m12;
	if (acknowledge == TRUE_m12) {
		ack_trans_info = (TR_INFO_m12 *) calloc((size_t) 1, sizeof(TR_INFO_m12));
		ack_header = ack_trans_info->header;
		ack_header->ID_code = header->ID_code;
		ack_trans_info->sock_fd = sock_fd;
		ack_trans_info->timeout = (sf4) 2.0;  // wait 2 seconds for acknowledgment
	}
		
	// transmit
	data_bytes_sent = 0;
	data_bytes_remaining = header->transmission_bytes;
	do {
		if (data_bytes_remaining > trans_info->mss)  // this is set so 8 byte alignment will be maintained
			data_bytes = trans_info->mss;
		else
			data_bytes = (ui2) data_bytes_remaining;
		packet_bytes = data_bytes + (ui2) TR_HEADER_BYTES_m12;

		// set packet header
		pkt_header = (TR_HEADER_m12 *) (buffer + data_bytes_sent);
		if (data_bytes_sent) {
			if (no_destruct_flag == TRUE_m12)  // preserve data in header region
				saved_data = *pkt_header;
			*pkt_header = *header;
		}
		pkt_header->packet_bytes = packet_bytes;
		pkt_header->offset = data_bytes_sent;
		
		// calculate CRC (does not include crc field of header)
		if (pkt_header->flags & TR_FLAGS_CRC_m12)
			header->crc = CRC_calculate_m12(buffer + CRC_BYTES_m12, packet_bytes - CRC_BYTES_m12);
		
		// send
	TR_SEND_RETRANSMIT_m12:
		errno_reset_m12();
		ret_val = send(sock_fd, (void *) pkt_header, packet_bytes, 0);
		if (ret_val <= 0) {
			if (ret_val == 0) {
				data_bytes_sent = TR_E_SOCK_CLOSED_m12;
				G_warning_message_m12("%s(%s:%hu -> %s:%hu): %s\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, TR_strerror(data_bytes_sent));
			} else {
				data_bytes_sent = TR_E_SOCK_FAILED_m12;
				err = errno_m12();
				G_warning_message_m12("%s(%s:%hu -> %s:%hu): %s (sock errno %d)\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, TR_strerror(data_bytes_sent), err);
			}
			header->flags |= TR_FLAGS_CLOSE_m12;
			goto TR_SEND_FAIL;
		}
		if (ret_val != (si8) packet_bytes) {
			G_warning_message_m12("%s(): packet size error\n", __FUNCTION__);
			header->flags |= TR_FLAGS_CLOSE_m12;
			data_bytes_sent = TR_E_TRANS_FAILED_m12;
			goto TR_SEND_FAIL;
		}

		// acknowledge
		if (acknowledge == TRUE_m12) {
			TR_set_socket_timeout_m12(ack_trans_info);
			attempts = 0; do {
				bytes_received = TR_recv_transmission_m12(ack_trans_info, NULL);
				if (bytes_received != 0)
					continue;
				if (pkt_header->ID_code != ID_code)  // check ID code
					continue;
				if (ack_header->type == TR_TYPE_ACK_RETRANSMIT_m12)
					goto TR_SEND_RETRANSMIT_m12;
			} while (header->type != TR_TYPE_ACK_OK_m12 && attempts++ < TR_RETRANSMIT_ATTEMPTS_m12);
			TR_set_socket_timeout_m12(trans_info);  // reset timeout
			
			if (ack_header->type != TR_TYPE_ACK_OK_m12) {
				data_bytes_sent = TR_E_NO_ACK_m12;
				G_warning_message_m12("%s(): %s\n", __FUNCTION__, TR_strerror(data_bytes_sent));
				header->flags |= TR_FLAGS_CLOSE_m12;
				goto TR_SEND_FAIL;
			}
		}
		
		// restore data in header region
		if (no_destruct_flag == TRUE_m12)
			if (data_bytes_sent)
				*pkt_header = saved_data;
				
		data_bytes_sent += (si8) data_bytes;
		data_bytes_remaining -= (si8) data_bytes;
		
	} while (data_bytes_remaining);
	
	trans_info->mode = TR_MODE_SEND_m12;  // set only if transmission successful
	
TR_SEND_FAIL:
	
	// clean up header
	header->crc = 0;
	header->packet_bytes = 0;
	header->offset = 0;

	// decrypt for non destructive mode
	// note: faster to copy & substitute buffer than decrypt after transmitting, but may cause memory issue for large transmissions & this mode is rarely necessary)
	if (header->flags & TR_FLAGS_ENCRYPT_m12) {
		if (no_destruct_flag == TRUE_m12)
			AES_decrypt_m12(data, actual_data_bytes, NULL, trans_info->expanded_key);
		// reset encryption flags
		header->flags &= ~(TR_FLAGS_ENCRYPT_m12 | TR_FLAGS_INCLUDE_KEY_m12);
	}
	
	// close
	if (header->flags & TR_FLAGS_CLOSE_m12) {
		TR_close_transmission_m12(trans_info);
		header->flags &= ~TR_FLAGS_CLOSE_m12;  // reset close flag
	}
	
	// clean up
	if (acknowledge == TRUE_m12)
		free((void *) ack_trans_info);
	
	return(data_bytes_sent);
}


TERN_m12	TR_set_socket_blocking_m12(TR_INFO_m12 *trans_info, TERN_m12 blocking)
{
#if defined MACOS_m12 || defined LINUX_m12
	TERN_m12	current_state;
	si4		socket_flags;

	
	socket_flags = fcntl(trans_info->sock_fd, F_GETFL, 0);  // get existing flags
	if (socket_flags == -1)
		return(UNKNOWN_m12);
	
	current_state = (socket_flags & O_NONBLOCK) ? FALSE_m12 : TRUE_m12;
	if (current_state == blocking || blocking == UNKNOWN_m12)
		return(current_state);

	// set socket to blocking
	if (blocking == TRUE_m12) {
		socket_flags &= ~O_NONBLOCK;
		if (fcntl(trans_info->sock_fd, F_SETFL, socket_flags) == -1) {
			G_warning_message_m12("%s(): could not set socket to blocking\n", __FUNCTION__);
			blocking = UNKNOWN_m12;
		}
	}

	// set socket to non-blocking
	else {
		socket_flags |= O_NONBLOCK;
		if (fcntl(trans_info->sock_fd, F_SETFL, socket_flags) == -1) {
			G_warning_message_m12("%s(): could not set socket to non-blocking\n", __FUNCTION__);
			blocking = UNKNOWN_m12;
		}
	}
#endif
	
#ifdef WINDOWS_m12
	ui4	enable;
	si4	err;
	
	
	// set socket to blocking
	if (blocking == TRUE_m12) {
		enable = 1;
		err = ioctlsocket(trans_info->sock_fd, FIONBIO, &enable);
		if (err != NO_ERROR) {
			G_warning_message_m12("%s(): could not set socket to blocking\n", __FUNCTION__);
			blocking = UNKNOWN_m12;
		}
	}

	// set socket to non-blocking
	else if (blocking == FALSE_m12) {
		enable = 0;
		err = ioctlsocket(trans_info->sock_fd, FIONBIO, &enable);
		if (err != NO_ERROR) {
			G_warning_message_m12("%s(): could not set socket to non-blocking\n", __FUNCTION__);
			blocking = UNKNOWN_m12;
		}
	}
	
	// blocking == UNKNOWN_m12 => just return current state
	else {
		enable = 1;  // set to blocking
		err = ioctlsocket(trans_info->sock_fd, FIONBIO, &enable);  // apparently this will fail if already set to blocking, with error code WSAEOPNOTSUPP
		
		if (err == NO_ERROR) {  // reset to non-blocking
			enable = 0;
			ioctlsocket(trans_info->sock_fd, FIONBIO, &enable);
			blocking = FALSE_m12;
		} else if (WSAGetLastError() == WSAEOPNOTSUPP) {
			blocking = TRUE_m12;
		}
	}
#endif

	return(blocking);
}


void	TR_set_socket_timeout_m12(TR_INFO_m12 *trans_info)
{
#if defined MACOS_m12 || defined LINUX_m12
	struct timeval	tv;
	
	tv.tv_sec = (time_t) trans_info->timeout;
	tv.tv_usec = (time_t) ((((sf8) trans_info->timeout - (sf8) tv.tv_sec) * (sf8) 1e6) + (sf8) 0.5);
	setsockopt(trans_info->sock_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(struct timeval));
#endif
#ifdef WINDOWS_m12
	si1	timeout_str[16];
	si8 	len, timeout_ms;
	
	timeout_ms = (si8) (((sf8) trans_info->timeout * (sf8) 1000.0) + (sf8) 0.5);
	len = sprintf_m12(timeout_str, "%ld", timeout_ms) + 1;  // leave room for terminal zero
	setsockopt(trans_info->sock_fd, SOL_SOCKET, SO_RCVTIMEO, timeout_str, len);
#endif
	return;
}


TERN_m12	TR_show_message_m12(TR_HEADER_m12 *header)
{
	ui1			type;
	si1			*msg;
	TR_MESSAGE_HEADER_m12	*msg_header;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	type = header->type;
	
	switch (type) {
		case TR_TYPE_OPERATION_SUCCEEDED_m12:
			G_message_m12("%s(): operation succeeded", __FUNCTION__);
			return(TRUE_m12);
		case TR_TYPE_OPERATION_FAILED_m12:
			G_warning_message_m12("%s(): operation failed", __FUNCTION__);
			return(TRUE_m12);
		case TR_TYPE_OPERATION_SUCCEEDED_WITH_MESSAGE_m12:
		case TR_TYPE_MESSAGE_m12:
		case TR_TYPE_OPERATION_FAILED_WITH_WARNING_MESSAGE_m12:
		case TR_TYPE_OPERATION_FAILED_WITH_ERROR_MESSAGE_m12:
			msg_header = (TR_MESSAGE_HEADER_m12 *) (header + 1);
			msg = (si1 *) (msg_header + 1);
			break;
		default:
			return(FALSE_m12);
	}

	switch (type) {
		case TR_TYPE_OPERATION_SUCCEEDED_WITH_MESSAGE_m12:
		case TR_TYPE_MESSAGE_m12:
			G_message_m12("%s", msg);
			return(TRUE_m12);
		case TR_TYPE_OPERATION_FAILED_WITH_WARNING_MESSAGE_m12:
			G_warning_message_m12("%s", msg);
			return(TRUE_m12);
		case TR_TYPE_OPERATION_FAILED_WITH_ERROR_MESSAGE_m12:
			G_error_message_m12("%s", msg);
			return(TRUE_m12);
	}
	
	return(FALSE_m12);  // never gets here - just to shut compiler up
}


void	TR_show_transmission_m12(TR_INFO_m12 *trans_info)
{
	TERN_m12		blocking;
	si1			hex_str[HEX_STRING_BYTES_m12(sizeof(ui4))];
	TR_HEADER_m12		*header;
		
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	// transmission info
	printf_m12("-------------- Transmission Info - START ------------\n");
	if (trans_info->buffer == NULL)
		printf_m12("Buffer: NULL\n");
	else
		printf_m12("Buffer: allocated\n");
	printf_m12("Buffer Bytes: %ld\n", trans_info->buffer_bytes);
	if (trans_info->data == trans_info->buffer + TR_HEADER_BYTES_m12)
		printf_m12("Data: set\n");
	else
		printf_m12("Data: not set\n");
	if (trans_info->password == NULL)
		printf_m12("Password: NULL\n");
	else if (*trans_info->password == 0)
		printf_m12("Password: empty\n");
	else
		printf_m12("Password: %s\n", trans_info->password);
	if (trans_info->expanded_key == NULL)
		printf_m12("Expanded Key: NULL\n");
	else
		printf_m12("Expanded Key: set\n");
	if (trans_info->expanded_key_allocated == TRUE_m12)
		printf_m12("Expanded Key Allocated: true\n");
	if (trans_info->expanded_key_allocated == FALSE_m12)
		printf_m12("Expanded Key Allocated: false\n");
	else
		printf_m12("Expanded Key Allocated: not set\n");
	if (trans_info->mode == TR_MODE_SEND_m12)
		printf_m12("Mode: send\n");
	else if (trans_info->mode == TR_MODE_RECV_m12)
		printf_m12("Mode: receive\n");
	else if (trans_info->mode == TR_MODE_NONE_m12)
		printf_m12("Mode: not set\n");
	else if (trans_info->mode == TR_MODE_FORCE_CLOSE_m12)
		printf_m12("Mode: force close\n");
	else
		printf_m12("Mode: invalid value (%hhu)\n", trans_info->mode);
	printf_m12("Socket File Descriptor: %d\n", trans_info->sock_fd);
	if (*trans_info->dest_addr == 0)
		printf_m12("Destination Address: any\n");
	else
		printf_m12("Destination Address: %s\n", trans_info->dest_addr);
	if (trans_info->dest_port == 0)
		printf_m12("Destination Port: any\n");
	else
		printf_m12("Destination Port: %hu\n", trans_info->dest_port);
	if (*trans_info->iface_addr == 0)
		printf_m12("Interface Address: any\n");
	else
		printf_m12("Interface Address: %s\n", trans_info->iface_addr);
	if (trans_info->iface_port == 0)
		printf_m12("Interface Port: any\n");
	else
		printf_m12("Interface Port: %hu\n", trans_info->iface_port);
	if (trans_info->timeout == (sf4) 0.0)
		printf_m12("Timeout (seconds): never\n");
	else
		printf_m12("Timeout (seconds): %0.2f\n", trans_info->timeout);
	if (trans_info->mss == 0)
		printf_m12("Maximum Segment Size (bytes): not set\n");
	else
		printf_m12("Maximum Segment Size (bytes): %hu\n", trans_info->mss);
	printf_m12("--------------- Transmission Info - END -------------\n");
	
	// header
	printf_m12("-------------- Transmission Header - START ------------\n");
	header = trans_info->header;
	if (header == NULL) {
		printf_m12("Header not set\n--------------- Transmission Header - END -------------\n");
		return;
	}
	if (header->crc == CRC_NO_ENTRY_m12) {
		printf_m12("CRC: no entry\n");
	} else {
		STR_generate_hex_string_m12((ui1 *) &header->crc, sizeof(ui4), hex_str);
		printf_m12("CRC: %s (%s)\n", header->crc, hex_str);
	}
	printf_m12("Packet Bytes: %hu\n", header->packet_bytes);
	printf_m12("Flags (%hu): ", header->flags);
	if (header->flags & TR_FLAGS_BIG_ENDIAN_m12)
		printf_m12("BIG_ENDIAN");
	else
		printf_m12("LITTLE_ENDIAN");
	if (header->flags & TR_FLAGS_UDP_m12)
		printf_m12(", UDP");
	else
		printf_m12(", TCP");
	if (header->flags & TR_FLAGS_ENCRYPT_m12)
		printf_m12(", ENCRYPT");
	if (header->flags & TR_FLAGS_INCLUDE_KEY_m12)
		printf_m12(", INCLUDE_KEY");
	if (header->flags & TR_FLAGS_CLOSE_m12)
		printf_m12(", CLOSE");
	if (header->flags & TR_FLAGS_ACKNOWLEDGE_m12)
		printf_m12(", ACKNOWLEDGE");
	if (header->flags & TR_FLAGS_CRC_m12)
		printf_m12(", CRC");
	if (header->flags & TR_FLAGS_NO_DESTRUCT_m12)
		printf_m12(", NO_DESTRUCT");
	if (header->flags & TR_FLAGS_TO_FILE_m12)
		printf_m12(", TO_FILE");
	
	// socket flags not included in header flags
	blocking = TR_set_socket_blocking_m12(trans_info, UNKNOWN_m12);
	if (blocking == TRUE_m12)
		printf_m12(", BLOCKING");
	else if (blocking == FALSE_m12)
		printf_m12(", NON_BLOCKING");
	printf_m12("\n");
	if (header->ID_code == TR_ID_CODE_NO_ENTRY_m12) {
		printf_m12("ID String: no entry\n");
	} else {
		STR_generate_hex_string_m12((ui1 *) &header->ID_code, sizeof(ui4), hex_str);
		printf_m12("ID String: %s (%s)\n", header->ID_string, hex_str);
	}
	if (header->type == TR_TYPE_NO_ENTRY_m12)
		printf_m12("Type: %hhu (no entry)\n", header->type);
	else
		printf_m12("Type: %hhu\n", header->type);
	if (header->subtype == TR_TYPE_NO_ENTRY_m12)
		printf_m12("Subtype: %hhu (no entry)\n", header->subtype);
	else
		printf_m12("Subtype: %hhu\n", header->subtype);
	if (header->version == TR_VERSION_NO_ENTRY_m12)
		printf_m12("Version: %hhu (no entry)\n", header->version);
	else
		printf_m12("Version: %hhu\n", header->version);
	printf_m12("Transmission Bytes: %ld\n", header->transmission_bytes);
	printf_m12("Offset: %ld\n", header->offset);
	printf_m12("--------------- Transmission Header - END -------------\n");

	// body
	printf_m12("--------------- Transmission Body - START -------------\n");
	if (header->type <= TR_TYPE_GENERIC_MAX_m12) {  // generic type codes
		switch (header->type) {
			case TR_TYPE_NO_ENTRY_m12:
				printf_m12("Type: TR_TYPE_NO_ENTRY_m12\nBody: none\n");
				break;
			case TR_TYPE_KEEP_ALIVE_m12:
				printf_m12("Type: TR_TYPE_KEEP_ALIVE_m12\nBody: none\n");
				break;
			case TR_TYPE_ACK_OK_m12:
				printf_m12("Type: TR_TYPE_ACK_OK_m12\nBody: none\n");
				break;
			case TR_TYPE_MESSAGE_m12:
				printf_m12("Type: TR_TYPE_MESSAGE_m12\nBody: none\n");
				break;
			case TR_TYPE_OPERATION_SUCCEEDED_m12:
				printf_m12("Type: TR_TYPE_OPERATION_SUCCEEDED_m12\nBody: none\n");
				break;
			case TR_TYPE_OPERATION_SUCCEEDED_WITH_MESSAGE_m12:
				printf_m12("Type: TR_TYPE_OPERATION_SUCCEEDED_WITH_MESSAGE_m12\nBody: ");
				TR_show_message_m12(header);
				putchar_m12('\n');
				break;
			case TR_TYPE_OPERATION_FAILED_m12:
				printf_m12("Type: TR_TYPE_OPERATION_FAILED_m12\nBody: none\n");
				break;
			case TR_TYPE_OPERATION_FAILED_WITH_WARNING_MESSAGE_m12:
				printf_m12("Type: TR_TYPE_OPERATION_FAILED_m12\nBody: ");
				TR_show_message_m12(header);
				putchar_m12('\n');
				break;
			case TR_TYPE_OPERATION_FAILED_WITH_ERROR_MESSAGE_m12:
				printf_m12("Type: TR_TYPE_OPERATION_FAILED_WITH_ERROR_MESSAGE_m12\nBody: ");
				TR_show_message_m12(header);
				putchar_m12('\n');
				break;
			default:
				break;
		}
	} else {  // app-specific type codes (not done)
//		switch (header->ID_code) {
//			case XXXX:
//				switch (header->type) {
//					case YYYY:
//						break;
//					default:
//						break;
//				}
//				break;
//			default:
//				break;
//		}
	}
	printf_m12("---------------- Transmission Body - END --------------\n\n");

	return;
}


si1	*TR_strerror(si4 err_num)
{
	switch(err_num) {
		case TR_E_NO_ERR_m12:
			return(TR_E_NO_ERR_STR_m12);
		case TR_E_UNSPEC_m12:
			return(TR_E_UNSPEC_STR_m12);
		case TR_E_SOCK_FAILED_m12:
			return(TR_E_SOCK_FAILED_STR_m12);
		case TR_E_SOCK_NO_OPEN_m12:
			return(TR_E_SOCK_NO_OPEN_STR_m12);
		case TR_E_SOCK_CLOSED_m12:
			return(TR_E_SOCK_CLOSED_STR_m12);
		case TR_E_SOCK_TIMED_OUT_m12:
			return(TR_E_SOCK_TIMED_OUT_STR_m12);
		case TR_E_NO_DATA_m12:
			return(TR_E_NO_DATA_STR_m12);
		case TR_E_ID_MISMATCH_m12:
			return(TR_E_ID_MISMATCH_STR_m12);
		case TR_E_TRANS_FAILED_m12:
			return(TR_E_TRANS_FAILED_STR_m12);
		case TR_E_CRC_MISMATCH_m12:
			return(TR_E_CRC_MISMATCH_STR_m12);
		case TR_E_NO_ACK_m12:
			return(TR_E_NO_ACK_STR_m12);
		default:
			return("unknown error code");
	}
}
	


//********************************//
// MARK: UNICODE FUNCTIONS  (UTF8)
//********************************//

// ATTRIBUTION
//
// Basic UTF-8 manipulation routines
// by Jeff Bezanson
// placed in the public domain Fall 2005

// "This code is designed to provide the utilities you need to manipulate
// UTF-8 as an internal string encoding. These functions do not perform the
// error checking normally needed when handling UTF-8 data, so if you happen
// to be from the Unicode Consortium you will want to flay me alive.
// I do this because error checking can be performed at the boundaries (I/O),
// with these routines reserved for higher performance on data known to be
// valid."
//
// downloaded from http://www.cprogramming.com
//
// Minor modifications for compatibility with the MED Library.


// byte offset => char_num
#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	UTF8_char_num_m12(si1 *s, si4 offset)
{
	si4	char_num = 0, offs = 0;
	
	
	while (offs < offset && s[offs]) {
		(void) (UTF8_ISUTF_m12(s[++offs]) || UTF8_ISUTF_m12(s[++offs]) || UTF8_ISUTF_m12(s[++offs]) || ++offs);
		char_num++;
	}
	
	return(char_num);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	UTF8_dec_m12(si1 *s, si4 *i)
{
	(void) (UTF8_ISUTF_m12(s[--(*i)]) || UTF8_ISUTF_m12(s[--(*i)]) || UTF8_ISUTF_m12(s[--(*i)]) || --(*i));
	
	return;
}


si4	UTF8_escape_m12(si1 *buf, si4 sz, si1 *src, si4 escape_quotes)
{
	si4	c = 0, i = 0, amt;
	
	
	while (src[i] && c < sz) {
		if (escape_quotes && src[i] == '"') {
			amt = snprintf_m12(buf, sz - c, "\\\"");
			i++;
		} else {
			amt = UTF8_escape_wchar_m12(buf, sz - c, UTF8_next_char_m12(src, &i));
		}
		c += amt;
		buf += amt;
	}
	if (c < sz)
		*buf = '\0';
	
	return(c);
}


si4	UTF8_escape_wchar_m12(si1 *buf, si4 sz, ui4 ch)
{
	if (ch == L'\n')
		return(snprintf(buf, sz, "\\n"));
	else if (ch == L'\t')
		return(snprintf(buf, sz, "\\t"));
	else if (ch == L'\r')
		return(snprintf(buf, sz, "\\r"));
	else if (ch == L'\b')
		return(snprintf(buf, sz, "\\b"));
	else if (ch == L'\f')
		return(snprintf(buf, sz, "\\f"));
	else if (ch == L'\v')
		return(snprintf(buf, sz, "\\v"));
	else if (ch == L'\a')
		return(snprintf(buf, sz, "\\a"));
	else if (ch == L'\\')
		return(snprintf(buf, sz, "\\\\"));
	else if (ch < 32 || ch == 0x7f)
		return(snprintf(buf, sz, "\\x%hhX", (ui1) ch));
	else if (ch > 0xFFFF)
		return(snprintf(buf, sz, "\\U%.8X", (ui4) ch));
	else if (ch >= 0x80 && ch <= 0xFFFF)
		return(snprintf(buf, sz, "\\u%.4hX", (ui2) ch));
	
	return(snprintf(buf, sz, "%c", (si1) ch));
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     UTF8_fprintf_m12(FILE *stream, si1 *fmt, ...)
{
	si4		sz;
	si1		*src;
	ui4		*w_cs;
	va_list		args;
	

	va_start(args, fmt);
	sz = vasprintf_m12(&src, fmt, args);
	va_end(args);
	
#ifdef MATLAB_m12
if (stream == stderr || stream == stdout)
		mexPrintf("%s", src);
	else
		fprintf(stream, "%s", src);
	free((void *) src);
	return(sz);
#endif
	
#ifdef WINDOWS_m12
	fprintf(stream, "%s", src);
	free((void *) src);
	return(sz);
#endif

	w_cs = (ui4 *) calloc(sz + 1, sizeof(ui4));
	UTF8_to_ucs_m12(w_cs, sz + 1, src, sz);
	fprintf(stream, "%ls", (wchar_t *) w_cs);
	
	free((void *) src);
	free((void *) w_cs);
	
	return(sz);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	UTF8_hex_digit_m12(si1 c)
{
	return((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'));
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	UTF8_inc_m12(si1 *s, si4 *i)
{
	(void) (UTF8_ISUTF_m12(s[++(*i)]) || UTF8_ISUTF_m12(s[++(*i)]) || UTF8_ISUTF_m12(s[++(*i)]) || ++(*i));
}


TERN_m12	UTF8_initialize_tables_m12(void)
{
#ifdef FN_DEBUG_m12
	printf_m12("%s()\n", __FUNCTION__);
#endif

	if (global_tables_m12->UTF8_offsets_table != NULL)
		return(TRUE_m12);

	PROC_pthread_mutex_lock_m12(&global_tables_m12->UTF8_mutex);
	if (global_tables_m12->UTF8_offsets_table != NULL) {  // may have been done by another thread while waiting
		PROC_pthread_mutex_unlock_m12(&global_tables_m12->UTF8_mutex);
		return(TRUE_m12);
	}

	// offsets table
	if (global_tables_m12->UTF8_offsets_table == NULL) {
	#ifdef MATLAB_PERSISTENT_m12
		global_tables_m12->UTF8_offsets_table = (ui4 *) mxMalloc((mwSize) (UTF8_OFFSETS_TABLE_ENTRIES_m12 << 2));
	#else
		global_tables_m12->UTF8_offsets_table = (ui4 *) malloc((size_t) (UTF8_OFFSETS_TABLE_ENTRIES_m12 << 2));
	#endif
		{
			ui4 temp[UTF8_OFFSETS_TABLE_ENTRIES_m12] = UTF8_OFFSETS_TABLE_m12;
			memcpy((void *) global_tables_m12->UTF8_offsets_table, (void *) temp, (size_t) (UTF8_OFFSETS_TABLE_ENTRIES_m12 << 2));
		}
	}

	// trailing bytes table
	if (global_tables_m12->UTF8_trailing_bytes_table == NULL) {
#ifdef MATLAB_PERSISTENT_m12
		global_tables_m12->UTF8_trailing_bytes_table = (si1 *) mxMalloc((mwSize) UTF8_TRAILING_BYTES_TABLE_ENTRIES_m12);
#else
		global_tables_m12->UTF8_trailing_bytes_table = (si1 *) malloc((size_t) UTF8_TRAILING_BYTES_TABLE_ENTRIES_m12);
#endif
		{
			si1 temp[UTF8_TRAILING_BYTES_TABLE_ENTRIES_m12] = UTF8_TRAILING_BYTES_TABLE_m12;
			memcpy((void *) global_tables_m12->UTF8_trailing_bytes_table, (void *) temp, (size_t) UTF8_TRAILING_BYTES_TABLE_ENTRIES_m12);
		}
	}

	PROC_pthread_mutex_unlock_m12(&global_tables_m12->UTF8_mutex);

	return(TRUE_m12);
}


si4     UTF8_is_locale_utf8_m12(si1 *locale)
{
	// this code based on libutf8
	const si1	*cp = locale;
	

	for (; *cp != '\0' && *cp != '@' && *cp != '+' && *cp != ','; cp++) {
		if (*cp == '.') {
			const si1 *encoding = ++cp;
			for (; *cp != '\0' && *cp != '@' && *cp != '+' && *cp != ','; cp++);
			if ((cp - encoding == 5 && !strncmp(encoding, "UTF-8", 5)) || (cp - encoding == 4 && !strncmp(encoding, "utf8", 4)))
				return(1); // it's UTF-8
			break;
		}
	}
	
	return(0);
}


// medlib addition
TERN_m12 UTF8_is_valid_m12(si1 *string, TERN_m12 zero_invalid, si1 *field_name)
{
	TERN_m12	valid, warn_invalid;
	si4		i, cnt;
	ui1		x;

	
	if (*string == 0)  // common occurrence in MED fields
		return(TRUE_m12);
	
	// if field name passed, warning will be displayed
	warn_invalid = FALSE_m12;
	if (field_name != NULL)
		if (*field_name)
			warn_invalid = TRUE_m12;
	
	valid = TRUE_m12;
	for (cnt = 0, i = (si4) strlen(string); i--;) {
		x = (ui1) *string++;
		if (cnt) {
			if ((x & 0xC0) != 0x80) {  // 0bxx000000 & 0b11000000 == 0b10000000
				valid = FALSE_m12;
				break;
			}
			--cnt;
		} else {
			if ((x & 0xE0) == 0xC0)  // 0bxxx00000 & 0b11100000 == 0b11000000
				cnt = 1;
			else if ((x & 0xF0) == 0xE0)  // 0bxxxx0000 & 0b11110000 == 0b11100000
				cnt = 2;
			else if ((x & 0xF8) == 0xF0)  // 0bxxxxx000 & 0b11111000 == 0b11110000
				cnt = 3;
			else if (x & 0x80) {  // 0bx0000000 & 0b10000000 == 0b10000000
				valid = FALSE_m12;
				break;
			}
		}
	}
	if (cnt)
		valid = FALSE_m12;
	
	if (valid == FALSE_m12) {
		if (zero_invalid == TRUE_m12)
			*string = 0;
		if (warn_invalid == TRUE_m12) {
			if (zero_invalid == TRUE_m12)
				G_warning_message_m12("%s(): field \"%s\" is invalid UTF-8 and was zeroed\n", __FUNCTION__, field_name);
			else
				G_warning_message_m12("%s(): field \"%s\" is invalid UTF-8\n", __FUNCTION__, field_name);
		}
		return(FALSE_m12);
	}

	return(TRUE_m12);
}


si1	*UTF8_memchr_m12(si1 *s, ui4 ch, si4 sz, si4 *char_num)
{
	si8	i = 0, last_i = 0;
	ui4	c, *offsets_table;
	si4	csz;
	

	if (global_tables_m12->UTF8_offsets_table == NULL)
		UTF8_initialize_tables_m12();
	offsets_table = global_tables_m12->UTF8_offsets_table;
	
	*char_num = 0;
	while (i < sz) {
		c = csz = 0;
		do {
			c <<= 6;
			c += (ui1) s[i++];
			csz++;
		} while (i < sz && !UTF8_ISUTF_m12(s[i]));
		c -= offsets_table[csz - 1];
		
		if (c == ch) {
			return(&s[last_i]);
		}
		last_i = i;
		(*char_num)++;
	}
	
	return(NULL);
}


// reads the next utf-8 sequence out of a string, updating an index
#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
ui4     UTF8_next_char_m12(si1 *s, si4 *i)
{
	ui4	ch = 0;
	si4	sz = 0;
	

	if (s[*i] == 0)
		return(0);
	
	if (global_tables_m12->UTF8_offsets_table == NULL)
		UTF8_initialize_tables_m12();
	
	do {
		ch <<= 6;
		ch += (ui1) s[(*i)++];
		sz++;
	} while (s[*i] && !UTF8_ISUTF_m12(s[*i]));
	
	ch -= global_tables_m12->UTF8_offsets_table[sz - 1];

	return(ch);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	UTF8_octal_digit_m12(si1 c)
{
	return(c >= '0' && c <= '7');
}


// char_num => byte offset
#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     UTF8_offset_m12(si1 *str, si4 char_num)
{
	si4	offs = 0;
	
	
	while (char_num > 0 && str[offs]) {
		(void) (UTF8_ISUTF_m12(str[++offs]) || UTF8_ISUTF_m12(str[++offs]) || UTF8_ISUTF_m12(str[++offs]) || ++offs);
		char_num--;
	}
	
	return(offs);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     UTF8_printf_m12(si1 *fmt, ...)
{
	si4		sz;
	si1		*src;
	ui4		*w_cs;
	va_list 	args;
	
	
	va_start(args, fmt);
	sz = vasprintf_m12(&src, fmt, args);
	va_end(args);
	
#ifdef MATLAB_m12
	mexPrintf("%s", src);
	free((void *) src);
	return(sz);
#endif
	
#ifdef WINDOWS_m12
	printf("%s", src);
	free((void *) src);
	return(sz);
#endif

	w_cs = (ui4 *) calloc(sz + 1, sizeof(ui4));
	UTF8_to_ucs_m12(w_cs, sz + 1, src, sz);
	printf("%ls", (wchar_t *) w_cs);
	
	free((void *) src);
	free((void *) w_cs);
	
	return(sz);
}


// str points to a backslash or character after a backslash
// returns number of input characters processed
si4     UTF8_read_escape_sequence_m12(si1 *str, ui4 *dest)
{
	ui4	ch;
	si1	digs[9] = "\0\0\0\0\0\0\0\0";
	si4	dno = 0, i = 1;
	
	
	if (*str == '\\')
		++str;
	
	ch = (ui4)str[0];    // take literal character
	if (str[0] == 'n')
		ch = L'\n';
	else if (str[0] == 't')
		ch = L'\t';
	else if (str[0] == 'r')
		ch = L'\r';
	else if (str[0] == 'b')
		ch = L'\b';
	else if (str[0] == 'f')
		ch = L'\f';
	else if (str[0] == 'v')
		ch = L'\v';
	else if (str[0] == 'a')
		ch = L'\a';
	else if (UTF8_octal_digit_m12(str[0])) {
		i = 0;
		do {
			digs[dno++] = str[i++];
		} while (UTF8_octal_digit_m12(str[i]) && dno < 3);
		ch = strtol(digs, NULL, 8);
	}
	else if (str[0] == 'x') {
		while (UTF8_hex_digit_m12(str[i]) && dno < 2) {
			digs[dno++] = str[i++];
		}
		if (dno > 0)
			ch = strtol(digs, NULL, 16);
	}
	else if (str[0] == 'u') {
		while (UTF8_hex_digit_m12(str[i]) && dno < 4) {
			digs[dno++] = str[i++];
		}
		if (dno > 0)
			ch = strtol(digs, NULL, 16);
	}
	else if (str[0] == 'U') {
		while (UTF8_hex_digit_m12(str[i]) && dno < 8) {
			digs[dno++] = str[i++];
		}
		if (dno > 0)
			ch = strtol(digs, NULL, 16);
	}
	*dest = ch;
	
	return(i);
}


// returns length of next utf-8 sequence
#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4      UTF8_seqlen_m12(si1 *s)
{
	if (global_tables_m12->UTF8_offsets_table == NULL)
		UTF8_initialize_tables_m12();
	
	return(global_tables_m12->UTF8_trailing_bytes_table[(si4) ((ui1) s[0])] + 1);
}


si1	*UTF8_strchr_m12(si1 *s, ui4 ch, si4 *char_num)
{
	si4	i = 0, last_i = 0;
	ui4	c;
	
	
	*char_num = 0;
	while (s[i]) {
		c = UTF8_next_char_m12(s, &i);
		if (c == ch)
			return(&s[last_i]);
		last_i = i;
		(*char_num)++;
	}
	
	return(NULL);
}


// number of characters
si4     UTF8_strlen_m12(si1 *s)
{
	si4	count = 0;
	si4	i = 0;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	while (UTF8_next_char_m12(s, &i))
		count++;
	
	return(count);
}


// conversions without error checking
// only works for valid UTF-8, i.e. no 5- or 6-byte sequences
// srcsz == source size in bytes, or -1 if 0-terminated
// sz = dest size in # of wide characters

// returns # characters converted
// dest will always be 0-terminated, even if there isn't enough room
// for all the characters.
// if sz == srcsz + 1 (i.e. 4 * srcsz + 4 bytes), there will always be enough space
si4     UTF8_to_ucs_m12(ui4 *dest, si4 sz, si1 *src, si4 srcsz)
{
	si1	*trailing_bytes_table, *src_end = src + srcsz;
	ui4	*offsets_table, ch;
	si4	nb, i = 0;
	
	
	if (global_tables_m12->UTF8_offsets_table == NULL)
		UTF8_initialize_tables_m12();
	offsets_table = global_tables_m12->UTF8_offsets_table;
	trailing_bytes_table = global_tables_m12->UTF8_trailing_bytes_table;
	
	while (i < sz - 1) {
		nb = trailing_bytes_table[(ui1) *src];
		if (srcsz == -1 && *src == 0)
			goto UTF8_DONE_TOUCS_m12;
		else if (src + nb >= src_end)
			goto UTF8_DONE_TOUCS_m12;

		ch = 0;
		switch (nb) {
			// these fall through deliberately
			case 3: ch += (ui1) *src++; ch <<= 6;
			case 2: ch += (ui1) *src++; ch <<= 6;
			case 1: ch += (ui1) *src++; ch <<= 6;
			case 0: ch += (ui1) *src++;
		}
		ch -= offsets_table[nb];
		dest[i++] = ch;
	}
	
UTF8_DONE_TOUCS_m12:
	
	dest[i] = 0;
	
	return(i);
}


// srcsz == number of source characters, or -1 if 0-terminated
// sz == size of dest buffer in bytes

// returns # characters converted
// dest will only be 0-terminated if there is enough space. this is
// for consistency; imagine there are 2 bytes of space left, but the next
// character requires 3 bytes. in this case we could NUL-terminate, but in
// general we can't when there's insufficient space. therefore this function
// only NULL-terminates if all the characters fit, and there's space for
// the NULL as well.
// the destination string will never be bigger than the source string
si4     UTF8_to_utf8_m12(si1 *dest, si4 sz, ui4 *src, si4 srcsz)
{
	ui4	ch;
	si4	i = 0;
	si1	*dest_end = dest + sz;
	
	
	while (srcsz < 0 ? src[i] != 0 : i < srcsz) {
		ch = src[i];
		if (ch < 0x80) {
			if (dest >= dest_end)
				return(i);
			*dest++ = (si1) ch;
		}
		else if (ch < 0x800) {
			if (dest >= dest_end - 1)
				return(i);
			*dest++ = (ch >> 6) | 0xC0;
			*dest++ = (ch & 0x3F) | 0x80;
		}
		else if (ch < 0x10000) {
			if (dest >= dest_end - 2)
				return(i);
			*dest++ = (ch >> 12) | 0xE0;
			*dest++ = ((ch >> 6) & 0x3F) | 0x80;
			*dest++ = (ch & 0x3F) | 0x80;
		}
		else if (ch < 0x110000) {
			if (dest >= dest_end - 3)
				return(i);
			*dest++ = (ch >> 18) | 0xF0;
			*dest++ = ((ch >> 12) & 0x3F) | 0x80;
			*dest++ = ((ch >> 6) & 0x3F) | 0x80;
			*dest++ = (ch & 0x3F) | 0x80;
		}
		i++;
	}
	if (dest < dest_end)
		*dest = '\0';
	
	return(i);
}


// convert a string with literal \uxxxx or \Uxxxxxxxx characters to UTF-8
// example: UTF8_unescape(mybuf, 256, "hello\\u220e")
// note the double backslash is needed if called on a C string literal
si4     UTF8_unescape_m12(si1 *buf, si4 sz, si1 *src)
{
	si4	c = 0, amt;
	ui4	ch;
	si1	temp[4];
	
	
	while (*src && c < sz) {
		if (*src == '\\') {
			src++;
			amt = UTF8_read_escape_sequence_m12(src, &ch);
		} else {
			ch = (si4)*src;
			amt = 1;
		}
		src += amt;
		amt = UTF8_wc_to_utf8_m12(temp, ch);
		if (amt > sz - c)
			break;
		memcpy(&buf[c], temp, amt);
		c += amt;
	}
	if (c < sz)
		buf[c] = '\0';
	
	return(c);
}


si4     UTF8_vfprintf_m12(FILE *stream, si1 *fmt, va_list args)
{
	si4	sz;
	si1	*src;
	ui4	*w_cs;
	
	
	sz = vasprintf_m12(&src, fmt, args);

#ifdef MATLAB_m12
	if (stream == stderr || stream == stdout)
		mexPrintf("%s", src);
	else
		fprintf(stream, "%s", src);
	free((void *) src);
	return(sz);
#endif
	
#ifdef WINDOWS_m12
	fprintf(stream, "%s", src);
	free((void *) src);
	return(sz);
#endif
	w_cs = (ui4 *) calloc(sz + 1, sizeof(ui4));
	UTF8_to_ucs_m12(w_cs, sz + 1, src, sz);

	fprintf(stream, "%ls", (wchar_t *) w_cs);
	
	free((void *) src);
	free((void *) w_cs);
	
	return(sz);
}


si4     UTF8_vprintf_m12(si1 *fmt, va_list args)
{
	si4	sz;
	si1	*src;
	ui4	*w_cs;
	
	
	sz = vasprintf_m12(&src, fmt, args);
	
#ifdef MATLAB_m12
	mexPrintf("%s", src);
	free((void *) src);
	return(sz);
#endif
	
#ifdef WINDOWS_m12
	printf("%s", src);
	free((void *) src);
	return(sz);
#endif
	
	w_cs = (ui4 *) calloc(sz + 1, sizeof(ui4));
	UTF8_to_ucs_m12(w_cs, sz + 1, src, sz);
	printf("%ls", (wchar_t *) w_cs);
	
	free((void *) src);
	free((void *) w_cs);
	
	return(sz);
}


si4     UTF8_wc_to_utf8_m12(si1 *dest, ui4 ch)
{
	if (ch < 0x80) {
		dest[0] = (char)ch;
		return(1);
	}
	if (ch < 0x800) {
		dest[0] = (ch >> 6) | 0xC0;
		dest[1] = (ch & 0x3F) | 0x80;
		return(2);
	}
	if (ch < 0x10000) {
		dest[0] = (ch >> 12) | 0xE0;
		dest[1] = ((ch >> 6) & 0x3F) | 0x80;
		dest[2] = (ch & 0x3F) | 0x80;
		return(3);
	}
	if (ch < 0x110000) {
		dest[0] = (ch >> 18) | 0xF0;
		dest[1] = ((ch >> 12) & 0x3F) | 0x80;
		dest[2] = ((ch >> 6) & 0x3F) | 0x80;
		dest[3] = (ch & 0x3F) | 0x80;
		return(4);
	}
	
	return(0);
}



//******************************//
// MARK: WINDOWS FUNCTIONS  (WN)
//******************************//

void    WN_cleanup_m12(void)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef WINDOWS_m12
	#ifdef NEED_WIN_SOCKETS_m12
		WSACleanup();
	#endif
	
	#ifndef MATLAB_m12
		WN_reset_terminal_m12();
	#endif
#endif
	return;
}
	

void WN_clear_m12(void)
{
#ifdef WINDOWS_m12
	HANDLE				hStdout;
	CONSOLE_SCREEN_BUFFER_INFO	csbi;
	SMALL_RECT			scrollRect;
	COORD				scrollTarget;
	CHAR_INFO			fill;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	hStdout = GetStdHandle(STD_OUTPUT_HANDLE);

	// get the number of character cells in the current buffer
	if (!GetConsoleScreenBufferInfo(hStdout, &csbi))
		return;
	
	// scroll the rectangle of the entire buffer
	scrollRect.Left = 0;
	scrollRect.Top = 0;
	scrollRect.Right = csbi.dwSize.X;
	scrollRect.Bottom = csbi.dwSize.Y;
	
	// scroll upwards off the top of the buffer with a magnitude of the entire height
	scrollTarget.X = 0;
	scrollTarget.Y = (SHORT) (0 - csbi.dwSize.Y);
	
	// fill with empty spaces with the buffer's default text attribute
	fill.Char.UnicodeChar = TEXT(' ');
	fill.Attributes = csbi.wAttributes;
	
	// scroll
	ScrollConsoleScreenBuffer(hStdout, &scrollRect, NULL, scrollTarget, &fill);
	
	// move the cursor to the top left corner too
	csbi.dwCursorPosition.X = 0;
	csbi.dwCursorPosition.Y = 0;
	
	SetConsoleCursorPosition(hStdout, csbi.dwCursorPosition);
#endif
	return;
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si8	WN_DATE_to_uutc_m12(sf8 date)
{
	sf8	secs, uutc;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// DATE == days since 29 Dec 1899 00:00:00 UTC
	secs = (date * (sf8) 86400.0) - (sf8) 2209161600.0;
	uutc = (si8) round(secs * (sf8) 1e6);
	
	return(uutc);
}


// for conversion of windows file time to uutc on any platform
si8	WN_filetime_to_uutc_m12(ui1 *win_filetime)  // pass pointer to beginning of FILETIME structure as ui1 pointer
{
	ui1	*ui1_p;
	si8	uutc, leftovers;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// A Windows file time is the number of 100-nanosecond intervals since 12:00 AM January 1, 1601 UTC (excluding leap seconds).
	ui1_p = (ui1 *) &uutc;  // can't guarantee alignment so copy bytewise to uutc variable (not worth memcpy function call overhead for 8 bytes)
	*ui1_p++ = *win_filetime++; *ui1_p++ = *win_filetime++; *ui1_p++ = *win_filetime++; *ui1_p++ = *win_filetime++;
	*ui1_p++ = *win_filetime++; *ui1_p++ = *win_filetime++; *ui1_p++ = *win_filetime++; *ui1_p = *win_filetime;
	leftovers = uutc % (si8) WIN_TICKS_PER_USEC_m12;
	leftovers = ((leftovers << 1) + WIN_TICKS_PER_USEC_m12) / (WIN_TICKS_PER_USEC_m12 << 1);
	uutc /= (si8) WIN_TICKS_PER_USEC_m12;
	uutc -= (WIN_USECS_TO_EPOCH_m12 - leftovers);
	
	return(uutc);
}


TERN_m12	WN_initialize_terminal_m12(void)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef  WINDOWS_m12
	HANDLE	hOut;
	DWORD	dwOriginalOutMode, dwRequestedOutModes, dwOutMode;
	
	
	// Set output mode to handle virtual terminal sequences
	hOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if (hOut == INVALID_HANDLE_VALUE)
		return(FALSE_m12);

	dwOriginalOutMode = 0;
	if (!GetConsoleMode(hOut, &dwOriginalOutMode))
		return(FALSE_m12);

	dwRequestedOutModes = ENABLE_VIRTUAL_TERMINAL_PROCESSING | DISABLE_NEWLINE_AUTO_RETURN;

	dwOutMode = dwOriginalOutMode | dwRequestedOutModes;
	if (!SetConsoleMode(hOut, dwOutMode)) {  // failed to set both modes, try to step down mode gracefully.
	    dwRequestedOutModes = ENABLE_VIRTUAL_TERMINAL_PROCESSING;
	    dwOutMode = dwOriginalOutMode | dwRequestedOutModes;
	    if (!SetConsoleMode(hOut, dwOutMode))  // Failed to set any VT mode, can't do anything here.
		    return(FALSE_m12);
	}
#endif
	return(TRUE_m12);
}


si4    WN_ls_1d_to_buf_m12(si1 **dir_strs, si4 n_dirs, TERN_m12 full_path, si1 **buffer)  // replacement for unix "ls -1d (on a directory list)"
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef WINDOWS_m12
	si1			*file_name, *dir_name, enclosing_directory[FULL_FILE_NAME_BYTES_m12];
	si1			tmp_dir[FULL_FILE_NAME_BYTES_m12];
	ui4			fe;
	si4			i, n_files, file_name_size;
	WIN32_FIND_DATAA 	ffd;
	HANDLE 		        find_h;
	FILE			*fp;
	
	
	// returns number of files or -1 for error
	// dir_strs can include "*" & "?" regex characters
	// right now, *buffer should not be allocated
	
	if (dir_strs == NULL)
		return(-1);
	if (dir_strs[0] == NULL)
		return(-1);
	if (n_dirs < 1)
		return(-1);
	
	if (buffer == NULL) {
		G_warning_message_m12("%s(): buffer is NULL\n");
		return(-1);
	}

	if (full_path == TRUE_m12)
		file_name_size = FULL_FILE_NAME_BYTES_m12;
	else
		file_name_size = SEGMENT_BASE_FILE_NAME_BYTES_m12;
		
	if (*buffer == NULL) {
		*buffer = (si1 *) malloc_m12((size_t) file_name_size, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	} else if (freeable_m12((void *) *buffer) == FALSE_m12) {
		G_warning_message_m12("%s(): *buffer cannot be statically allocated\n");
		return(-1);
	}
	**buffer = 0;
	
	find_h = INVALID_HANDLE_VALUE;
	n_files = 0;
	for (i = 0; i < n_dirs; ++i) {
		dir_name = dir_strs[i];
		if (STR_contains_regex_m12(dir_name) == FALSE_m12) {
			fe = G_file_exists_m12(dir_name);
			// a plain directory name will not list it's contents => must append "\*"
			if (fe == DIR_EXISTS_m12) {
				sprintf(tmp_dir, "%s\\*", dir_name);
				dir_name = tmp_dir;
			} else if (fe == DOES_NOT_EXIST_m12) {
				continue;
			}
			// regular files will list
		}
		find_h = FindFirstFileA((LPCSTR) dir_name, &ffd);
		if (find_h == INVALID_HANDLE_VALUE)
			continue;
		if (full_path == TRUE_m12) {
			G_path_from_root_m12(dir_name, dir_name);
			G_extract_path_parts_m12(dir_name, enclosing_directory, NULL, NULL);
		}
		do {
			file_name = ffd.cFileName;
			// exclude files/directories starting with "$"
			if (*file_name == '$')
				continue;
			// exclude ".", "..", & files/directories starting with "._"
			// invisible files (".<file_name>") are not excluded
			if (*file_name == '.') {
				if (file_name[1] == 0 || file_name[1] == '.' || file_name[1] == '_')
					continue;
			}
			++n_files;
			*buffer = (si1 *) realloc_m12(*buffer, (size_t) (n_files * file_name_size), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
			if (full_path == TRUE_m12)
				sprintf_m12(*buffer, "%s%s\\%s\n", *buffer, enclosing_directory, file_name);
			else
				sprintf_m12(*buffer, "%s%s\n", *buffer, file_name);
		} while (FindNextFileA(find_h, &ffd));
		
		FindClose(find_h);
	}
		
	if (find_h == INVALID_HANDLE_VALUE && n_files == 0)
		return(-1);
	
	return(n_files);
#endif
	
	return(-1);
}


si4    WN_ls_1d_to_tmp_m12(si1 **dir_strs, si4 n_dirs, TERN_m12 full_path, si1 *temp_file)  // replacement for unix "ls -1d > temp_file (on a directory list)"
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef WINDOWS_m12
	si1			*file_name, *dir_name, enclosing_directory[FULL_FILE_NAME_BYTES_m12];
	si1			tmp_dir[FULL_FILE_NAME_BYTES_m12];
	ui4			fe;
	si4			i, n_files;
	WIN32_FIND_DATAA 	ffd;
	HANDLE 		        find_h;
	FILE			*fp;
	
	
	// returns number of files or -1 for error
	// dir_strs can include "*" & "?" regex characters
	
	if (dir_strs == NULL)
		return(-1);
	if (dir_strs[0] == NULL)
		return(-1);
	if (n_dirs < 1)
		return(-1);
	
	if (temp_file == NULL)
		temp_file = globals_m12->temp_file;  // not thread safe
	else if (*temp_file == 0)  // generate a unique temp file
		G_unique_temp_file_m12(temp_file);
	// else caller passed temp file name
	
	// open temp file
	fp = fopen_m12(temp_file, "w", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	
	find_h = INVALID_HANDLE_VALUE;
	n_files = 0;
	for (i = 0; i < n_dirs; ++i) {
		dir_name = dir_strs[i];
		if (STR_contains_regex_m12(dir_name) == FALSE_m12) {
			fe = G_file_exists_m12(dir_name);
			// a plain directory name will not list it's contents => must append "\*"
			if (fe == DIR_EXISTS_m12) {
				sprintf(tmp_dir, "%s\\*", dir_name);
				dir_name = tmp_dir;
			} else if (fe == DOES_NOT_EXIST_m12) {
				continue;
			}
			// regular files will list
		}
		find_h = FindFirstFileA((LPCSTR) dir_name, &ffd);
		if (find_h == INVALID_HANDLE_VALUE)
			continue;
		if (full_path == TRUE_m12)
			G_extract_path_parts_m12(dir_name, enclosing_directory, NULL, NULL);
		do {
			file_name = ffd.cFileName;
			// exclude files/directories starting with "$"
			if (*file_name == '$')
				continue;
			// exclude ".", "..", & files/directories starting with "._"
			// invisible files (".<file_name>") are not excluded
			if (*file_name == '.') {
				if (file_name[1] == 0 || file_name[1] == '.' || file_name[1] == '_')
					continue;
			}
			++n_files;
			if (full_path == TRUE_m12)
				fprintf_m12(fp, "%s\\%s\n", enclosing_directory, file_name);
			else
				fprintf_m12(fp, "%s\n", file_name);
		} while (FindNextFileA(find_h, &ffd));
		
		FindClose(find_h);
	}
	fclose(fp);
		
	if (find_h == INVALID_HANDLE_VALUE && n_files == 0)
		return(-1);
	
	return(n_files);
#endif
	
	return(-1);
}


void	WN_nap_m12(struct timespec *nap)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef WINDOWS_m12
	static TERN_m12		use_ms = FALSE_m12;
	si8			hns, ms;
	LARGE_INTEGER		interval;
	static NTDELAYEXECTYPE	NtDelayExecution;  // pointer higher resolution sleep function

		
	// circumvent Windows' Sleep() 1 millisecond resolution
		
	if (use_ms == TRUE_m12)
		goto G_WN_SLEEP_USE_MS;
	
	if (!(nap->tv_nsec % (si8) 10000))  // duration can be expressed in ms
		goto G_WN_SLEEP_USE_MS;

	// load the needed NT dylib functions
	if (global_tables_m12->hNTdll == NULL) {
		ULONG			actual_resolution;
		ZWSETTIMERRESTYPE 	ZwSetTimerResolution;  // pointer to set timer resolution function
		
		global_tables_m12->hNTdll = LoadLibraryA("ntdll");
		if (global_tables_m12->hNTdll == NULL) {
			G_warning_message_m12("%s(): error loading NTdll library => using millisecond resolution\n", __FUNCTION__);
			use_ms = TRUE_m12;
			goto G_WN_SLEEP_USE_MS;
		} else {
			ZwSetTimerResolution = (ZWSETTIMERRESTYPE) GetProcAddress(global_tables_m12->hNTdll, "ZwSetTimerResolution");
			if (ZwSetTimerResolution != NULL) {
				ZwSetTimerResolution(1, 1, &actual_resolution);  // call the set timer resolution function (only done once)
			} else {
				G_warning_message_m12("%s(): error loading ZwSetTimerResolution() from NTdll library => using millisecond resolution\n", __FUNCTION__);
				use_ms = TRUE_m12;
				FreeLibrary(global_tables_m12->hNTdll);
				global_tables_m12->hNTdll = NULL;
				goto G_WN_SLEEP_USE_MS;
			}
			// load the sleep function (static)
			NtDelayExecution = (NTDELAYEXECTYPE) GetProcAddress(global_tables_m12->hNTdll, "NtDelayExecution");
			if (NtDelayExecution == NULL) {
				G_warning_message_m12("%s(): error loading NtDelayExecution() from NTdll library => using millisecond resolution\n", __FUNCTION__);
				use_ms = TRUE_m12;
				FreeLibrary(global_tables_m12->hNTdll);
				global_tables_m12->hNTdll = NULL;
				goto G_WN_SLEEP_USE_MS;
			}
		}
	}
	
	// convert to 100 ns resolution
	hns = (si8) nap->tv_sec * (si8) 10000000;
	hns += (si8) round((sf8) nap->tv_nsec / (sf8) 100.0);
	interval.QuadPart = (LONGLONG) -hns;  // compiler complains without this cast & assignment
	NtDelayExecution(0, &interval);

	return;

	G_WN_SLEEP_USE_MS:
	
	ms = nap->tv_sec * (si8) 1000;
	ms += (si8) round((sf8) nap->tv_nsec / (sf8) 1e6);
	if (ms == (si8) 0) {
		ms = (si8) 1;  // limited to 1 ms rseolution
	} else if (ms > (si8) 0x7FFFFFFF) {
		G_warning_message_m12("%s(): millisecond overflow\n", __FUNCTION__);
		ms = (si8) 0x7FFFFFFF;
	}
	Sleep((si4) ms);  // standard Windows sleep function
	
	return;
#endif
	
	return;
}


TERN_m12	WN_reset_terminal_m12(void)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef  WINDOWS_m12
	HANDLE	hOut;
	DWORD	dwOriginalOutMode;
	
	
	// set output mode to handle virtual terminal sequences
	hOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if (hOut == INVALID_HANDLE_VALUE)
		return(FALSE_m12);

	dwOriginalOutMode = 3;
	if (!SetConsoleMode(hOut, dwOriginalOutMode))
		return(FALSE_m12);
#endif
	return(TRUE_m12);
}


TERN_m12	WN_socket_startup_m12(void)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef WINDOWS_m12
	WORD		wVersionRequested;
	WSADATA		wsaData;
	si4		err;
	
	
	wVersionRequested = MAKEWORD(2, 2);
	err = WSAStartup(wVersionRequested, &wsaData);
	if (err) {
		G_error_message_m12("%s(): WSAStartup failed with error: %d\n", __FUNCTION__, err);
		return(FALSE_m12);
	}
	
	// confirm that the WinSock DLL supports 2.2
	if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
		G_error_message_m12("%s(): Could not find a usable version of Winsock.dll\n", __FUNCTION__);
		WSACleanup();
		return(FALSE_m12);
	}
	
#endif
	return(TRUE_m12);
}


si4	WN_system_m12(si1 *command)  // Windows has a system() function which works fine, but it opens a command prompt window.
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef WINDOWS_m12
	si1			*tmp_command;
	si1			*cmd_exe_path;
	si4			ret_val;
	si8			len;
	PROCESS_INFORMATION	process_info = {0};
	STARTUPINFOA		startup_info = {0};

	
	if (command == NULL)
		return(-1);
	if (*command == 0)
		return(-1);

	len = strlen(command);
	tmp_command = malloc(len + 6);
	tmp_command[0] = 0x2F;  // '/'
	tmp_command[1] = 0x63;  // 'c'
	tmp_command[2] = 0x20;  // <space>
	
	
	if (command[0] == 0x22) {  // if first character is a double quote, surround the whole command in another set of double quotes (e.g. if path to utility contains a space [e.g. "Program Files"])
		tmp_command[3] = 0x22;  // <double quote>
		memcpy(tmp_command + 4, command, len);
		tmp_command[len + 4] = 0x22;  // <double quote>
		tmp_command[len + 5] = 0;  // <terminal zero>
	} else {
		memcpy(tmp_command + 3, command, len + 1);
	}

	startup_info.cb = sizeof(STARTUPINFOA);
	cmd_exe_path = getenv("COMSPEC");
	_flushall();  // required for Windows system() calls, probably a good idea here too

	if (CreateProcessA(cmd_exe_path, tmp_command, NULL, NULL, 0, CREATE_NO_WINDOW, NULL, NULL, &startup_info, &process_info)) {
		WaitForSingleObject(process_info.hProcess, INFINITE);
		GetExitCodeProcess(process_info.hProcess, &ret_val);
		CloseHandle(process_info.hProcess);
		CloseHandle(process_info.hThread);
	}
	
	free((void *) tmp_command);
	
	return(ret_val);
#endif
	
#if defined MACOS_m12 || defined LINUX_m12
	return(-1);
#endif
}


#ifdef WINDOWS_m12
si8	WN_time_to_uutc_m12(FILETIME win_time)
{
	si8	uutc, leftovers;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// A Windows time is the number of 100-nanosecond intervals since 12:00 AM January 1, 1601 UTC (excluding leap seconds).
	uutc = ((si8) win_time.dwHighDateTime << 32) + (si8) win_time.dwLowDateTime;
	leftovers = uutc % (si8) WIN_TICKS_PER_USEC_m12;
	leftovers = ((leftovers << 1) + WIN_TICKS_PER_USEC_m12) / (WIN_TICKS_PER_USEC_m12 << 1);
	uutc /= (si8) WIN_TICKS_PER_USEC_m12;
	uutc -= (WIN_USECS_TO_EPOCH_m12 - leftovers);
	
	return(uutc);
}
#endif


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
sf8	WN_uutc_to_date_m12(si8 uutc)
{
	sf8	secs, days;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// DATE == days since 29 Dec 1899 00:00:00 UTC
	secs = ((sf8) uutc / (sf8) 1e6) + (sf8) 2209161600.0;
	days = secs / (sf8) 86400.0;
	
	return(days);
}


#ifdef WINDOWS_m12
FILETIME	WN_uutc_to_win_time_m12(si8 uutc)
{
	FILETIME ft;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	uutc += WIN_USECS_TO_EPOCH_m12;
	uutc *= WIN_TICKS_PER_USEC_m12;
	
	ft.dwLowDateTime = (ui4) ((ui8) uutc & 0x00000000ffffffff);
	ft.dwHighDateTime = (ui4) ((ui8) uutc >> 32);
	
	return(ft);
}
#endif


void	WN_windify_file_paths_m12(si1 *target, si1 *source)
{
	si1		*c1, *c2;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// if target == source, or target == NULL, conversion done in place
	if (source == NULL)
		return;
	if (target == NULL)
		target = source;
	else if (target != source)
		strcpy(target, source);

	// Replace all '/' in string except if escaped ("\/" -> note if in string literal, you have to escape the escape "\\/"), or part of "://"

	c1 = c2 = target;
	while (*c2) {
		if (*c2 == '\\') {
			if (*(c2 + 1) == '/') {  // unescape forward slash
				*c1++ = '/';
				c2 += 2;
				continue;
			}
		} else if (*c2 == ':') {
			if (*(c2 + 1) == '/') {  // leave "http://" etc. alone
				if (*(c2 + 2) == '/') {
					while (*c2 && *c2 != ' ')
						*c1++ = *c2++;
					continue;
				}
			}
		} else if (*c2 == '/') {  // replace all other '/' with '\'
			*c1++ = '\\';
			++c2;
			continue;
		}
		*c1++ = *c2++;
	}
	*c1 = 0;

	return;
}


si1	*WN_windify_format_string_m12(si1 *fmt)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef WINDOWS_m12
	// changes ld, li, lo, lu, lx, lX to "ll" versions of the same
	si1	*c, *new_c, *new_fmt;
	si4	matches;
	si8	len;
	
	
	if (fmt == NULL)
		return(NULL);
	
	matches = 0;
	c = fmt;
	while (*c) {
		if (*c++ == '%') {
			// skip over numbers & periods
			while ((*c >= '0' && *c <= '9') || *c == '.')
				++c;
			if (*c == 'l') {
				switch (*++c) {
					case 'd':
					case 'i':
					case 'o':
					case 'u':
					case 'x':
					case 'X':
						++matches;
						break;
				}
			}
		}
	}
	if (!matches)
		return(fmt);
	
	len = (si8) (c - fmt) + matches + 1;  // extra byte for terminal zero
	new_fmt = (si1 *) calloc((size_t) len, sizeof(ui1));  // freed by printf functions
	
	c = fmt;
	new_c = new_fmt;
	while (*c) {
		if (*c == '%') {
			*new_c++ = *c++;
			// copy numbers & periods
			while ((*c >= '0' && *c <= '9') || *c == '.')
				*new_c++ = *c++;
			if (*c == 'l') {
				*new_c++ = *c++;
				switch (*c) {
					case 'd':
					case 'i':
					case 'o':
					case 'u':
					case 'x':
					case 'X':
						*new_c++ = 'l';
						break;
				}
			}
		}
		*new_c++ = *c++;
	}
		
	return(new_fmt);
#endif
	return(fmt);
}


//**********************************************//
// MARK: STANDARD LIBRARY FUNCTIONS  (no prefix)
//**********************************************//

#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4    asprintf_m12(si1 **target, si1 *fmt, ...)
{
	si4		ret_val;
	va_list		args;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	va_start(args, fmt);
	ret_val = vasprintf_m12(target, fmt, args);
	va_end(args);
	
	// this function returns the allocated string, so add it to the AT list
#ifdef AT_DEBUG_m12
	size_t	len;
	
	len = strlen(*target);
	AT_add_entry_m12(*target, len + 1, __FUNCTION__);
#endif

	return(ret_val);
}


void	*calloc_m12(size_t n_members, size_t el_size, const si1 *function, ui4 behavior_on_fail)
{
	void	*ptr;
	si4	err;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (n_members == 0 || el_size == 0)
		return((void *) NULL);
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	errno_reset_m12();
	
#ifdef MATLAB_PERSISTENT_m12
	ptr = mxCalloc((mwSize) n_members, (mwSize) el_size);
#else
	ptr = calloc(n_members, el_size);
#endif
	if (ptr == NULL) {
		if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
			(void) fprintf_m12(stderr, "%c\n\t%s() failed to allocate the requested array (%ld members of size %ld)\n", 7, __FUNCTION__, n_members, el_size);
			err = errno_m12();
			(void) fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
			if (function != NULL)
				(void)fprintf_m12(stderr, "\tcalled from function %s()\n", function);
			if (behavior_on_fail & RETURN_ON_FAIL_m12)
				(void)fprintf_m12(stderr, "\t=> returning NULL\n\n");
			else if (behavior_on_fail & EXIT_ON_FAIL_m12)
				(void)fprintf_m12(stderr, "\t=> exiting program\n\n");
			fflush(stderr);
		}
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			return(NULL);
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(-1);
	}
	
	// alloc tracking
#ifdef AT_DEBUG_m12
	AT_add_entry_m12(ptr, (size_t) (n_members * el_size), function);
#endif

#ifdef MATLAB_PERSISTENT_m12
	mexMakeMemoryPersistent(ptr);
#endif

	return(ptr);
}


// not a standard function, but closely related
void	**calloc_2D_m12(size_t dim1, size_t dim2, size_t el_size, const si1 *function, ui4 behavior_on_fail)
{
	ui1	**ptr;
	size_t  i, dim1_bytes, dim2_bytes, content_bytes, total_bytes;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Returns pointer to 2 dimensional zeroed array of dim1 by dim2 elements of size el_size
	// ptr[0] points to a one dimensional array of size (dim1 * dim2)
	// The whole block can be freed with free(ptr)
	
	if (dim1 == 0 || dim2 == 0 || el_size == 0)
		return((void **) NULL);
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	dim1_bytes = dim1 * sizeof(void *) ;
	dim2_bytes = dim2 * el_size;
	content_bytes = dim1 * dim2_bytes;
	total_bytes = dim1_bytes + content_bytes;
	ptr = (ui1 **) calloc_m12(total_bytes, sizeof(ui1), function, behavior_on_fail);
	ptr[0] = (ui1 *) (ptr + dim1);
	for (i = 1; i < dim1; ++i)
		ptr[i] = ptr[i - 1] + dim2_bytes;
		
	return((void **) ptr);
}


size_t	calloc_size_m12(void *address, size_t element_size)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	return(malloc_size_m12(address) / element_size);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	errno_m12(void)
{
	// Note: zero errno with errno_reset_m12() before running the function you may need it in
	// Note: Windows errno.h defines almost all the same error codes as Macos & Linux, but the numbers may differ, so use defined names rather than numbers
	
#if defined MACOS_m12 || defined LINUX_m12
	extern si4	errno;
	
	return(errno);
#endif

#ifdef WINDOWS_m12
	si4	err;
	
	err = (si4) _get_errno(&err);  // Windows runtime
	if (err == 0)
		err = (si4) GetLastError();  // WinAPI
	
	#ifdef NEED_WIN_SOCKETS_m12
	if (err == 0)
		err = WSAGetLastError();  // Windows sockets
	#endif
	
	return(err);
#endif
	
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void	errno_reset_m12(void)
{
	// use this function to zero errno before function call that may set it

#if defined MACOS_m12 || defined LINUX_m12
	extern si4	errno;
	
	errno = 0;
#endif
	
#ifdef WINDOWS_m12
	_set_errno((si4) 0);  // Windows runtime
	SetLastError((DWORD) 0);  // WinAPI
	#ifdef NEED_WIN_SOCKETS_m12
		WSASetLastError((si4) 0);  // Windows sockets
	#endif
#endif
	
	return;
}


void	exit_m12(si4 status)
{
#ifdef FN_DEBUG_m12
	printf_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef WINDOWS_m12
	WN_cleanup_m12();
#endif

#ifdef MATLAB_m12
	const si1	tmp_str[32];
	
	sprintf((char *) tmp_str, "Exit status: %d\n", status);
	mexErrMsgTxt(tmp_str);
#else
	exit(status);
#endif
}


FILE	*fopen_m12(si1 *path, si1 *mode, const si1 *function, ui4 behavior_on_fail)
{
	FILE	*fp;
	si4	err;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;

	errno_reset_m12();
	
#if defined MACOS_m12 || defined LINUX_m12
	fp = fopen(path, mode);
#endif
	
#ifdef WINDOWS_m12
	TERN_m12	binary_set = FALSE_m12;
	TERN_m12	write_mode = FALSE_m12;
	si1		tmp_mode[8], *c, *tc;

	
	// MED requires binary mode
	c = mode;
	tc = tmp_mode;
	while (*c) {
		if (*c == 't') {
			*tc++ = 'b';
			binary_set = TRUE_m12;
		} else {
			if (*c == 'w' || *c == 'a' || *c == '+')
				write_mode = TRUE_m12;
			*tc++ = *c++;
		}
	}
	if (binary_set == FALSE_m12)
		*tc++ = 'b';
	*tc = 0;
	
	if (write_mode == TRUE_m12)
		fp = _fsopen(path, tmp_mode, _SH_DENYNO);
	else
		fp = fopen(path, tmp_mode);
#endif
	
	if (fp == NULL) {
		if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
			UTF8_fprintf_m12(stderr, "%c\n\t%s() failed to open file \"%s\"\n", 7, __FUNCTION__, path);
			err = errno_m12();
			fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
			if (function != NULL)
				fprintf_m12(stderr, "\tcalled from function %s()\n", function);
			if (behavior_on_fail & RETURN_ON_FAIL_m12)
				fprintf_m12(stderr, "\t=> returning NULL\n\n");
			else if (behavior_on_fail & EXIT_ON_FAIL_m12)
				fprintf_m12(stderr, "\t=> exiting program\n\n");
			fflush(stderr);
		}
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			return(NULL);
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(-1);
	}

	return(fp);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     fprintf_m12(FILE *stream, si1 *fmt, ...)
{
	si1		*temp_str;
	si4		ret_val;
	va_list		args;
	
	
	va_start(args, fmt);
	ret_val = vasprintf_m12(&temp_str, fmt, args);  // could just call vfprintf_m12() here & be done, but it's hardly any extra code, so duplicate & skip extra function call
	va_end(args);
	
	if (ret_val >= 0) {
#ifdef MATLAB_m12
		if (stream == stderr || stream == stdout)
			ret_val = mexPrintf("%s", temp_str);
		else
#endif
		ret_val = fprintf(stream, "%s", temp_str);
		free((void *) temp_str);
	}

	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	fputc_m12(si4 c, FILE *stream)
{
	si4	ret_val;

	
#ifdef MATLAB_m12
	if (stream == stderr || stream == stdout)
		ret_val = mexPrintf("%c", c);
	else
#endif
	ret_val = fputc(c, stream);
	
	return(ret_val);
}


size_t	fread_m12(void *ptr, size_t el_size, size_t n_members, FILE *stream, si1 *path, const si1 *function, ui4 behavior_on_fail)
{
	size_t	nr;
	si4	err;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	errno_reset_m12();
	if ((nr = fread(ptr, el_size, n_members, stream)) != n_members) {
		if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
			err = errno_m12();
			UTF8_fprintf_m12(stderr, "%c\n\t%s() failed to read file \"%s\"\n", 7, __FUNCTION__, path);
			fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
			if (function != NULL)
				fprintf_m12(stderr, "\tcalled from function %s()\n", function);
			if (behavior_on_fail & RETURN_ON_FAIL_m12)
				fprintf_m12(stderr, "\t=> returning number of items read\n\n");
			else if (behavior_on_fail & EXIT_ON_FAIL_m12)
				fprintf_m12(stderr, "\t=> exiting program\n\n");
			fflush(stderr);
		}
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			return(nr);
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(-1);
	}

	return(nr);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
void    free_m12(void *ptr, const si1 *function)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef AT_DEBUG_m12
	if (AT_remove_entry_m12(ptr, function) == FALSE_m12)
		return;
#endif
	#ifdef MATLAB_PERSISTENT_m12
	mxFree(ptr);
	#else
	free(ptr);
	#endif
	
	return;
}


// not a standard function, but closely related
void    free_2D_m12(void **ptr, size_t dim1, const si1 *function)
{
	size_t	i;
	void	*base_address;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
		
	// dim1 == 0 indicates allocated en block per caller (caller could just use free_m12() in this case, as here)
	if (dim1 == 0) {
		free_m12((void *) ptr, function);
		return;
	}
		
	// allocated en block  (check all addresses because pointers may have been sorted)
	base_address = (void *) ((ui1 *) ptr + (dim1 * sizeof(void *)));
	for (i = 0; i < dim1; ++i) {
		if (ptr[i] == base_address) {
			free_m12((void *) ptr, function);
			return;
		}
	}

	// allocated separately
	for (i = 0; i < dim1; ++i)
		free_m12((void *) ptr[i], function);
	free_m12((void *) ptr, function);

	return;
}


// not a standard function, but closely related
#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
TERN_m12	freeable_m12(void *address)
{
	ui8			address_val;
	HW_PARAMS_m12		*hw_params;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns whether address is freeable
	// heap starts at heap base & grows upward
	// MacOS & Linux stack base > heap_max_address & grows downward
	// Windows stack base < heap base & generally grows toward heap base (per internet this may not always be true, but I have never seen it happen)
	// if getting unexpected results, consider compiling with AT_DEBUG_m12 to track down where errors occur
	// NOTE: not tested under 32-bit hardware or compilation

	if (address == NULL)
		return(FALSE_m12);

#ifdef AT_DEBUG_m12
	return(AT_freeable_m12(address));
#endif

	// all allocated heap addresses are at least divisible by 8
	address_val = (ui8) address;
	if (address_val & (ui8) 7)
		return(FALSE_m12);

	hw_params = &global_tables_m12->HW_params;
	if (address_val > hw_params->heap_max_address)
		return(FALSE_m12);
#ifndef MATLAB_m12  // true heap base in Matlab is from Matlab itself and so far below first allocated medlib variable
	if (address_val < hw_params->heap_base_address)  // covers NULL address case & Windows stack
		return(FALSE_m12);
#endif

#ifdef MACOS_m12
	// check if address in allocation table
	if (malloc_size(address))
		return(TRUE_m12);
	return(FALSE_m12);
#endif
	
	// Can't use malloc_size_m13() if address not allocated:
	// LINUX_m13: malloc_usable_size() generates unrecoverable segmentation fault
	// WINDOWS_m13: _msize() terminates process without signal

#ifdef LINUX_m13
	si4	err;
	
	// check that current protection can be changed
	err = mprotect(address, (size_t) 1, PROT_READ | PROT_WRITE);
	if (err)  // errno set: EACCES (not permitted), EINVAL (not page aligned), or ENOMEM (outside process address range)
		return(FALSE_m12);
#endif

#ifdef WINDOWS_m13
	DWORD	err, curr_protection;

	// check that current protection can be changed
	err = VirtualProtect(address, (size_t) 1, (DWORD) PAGE_READONLY, &curr_protection);
	if (err == 0)  // errno set: probably ERROR_INVALID_ADDRESS
		return(FALSE_m12);
	
	// reset protection if successful
	VirtualProtect(address, (size_t) 1, curr_protection, &err);  // second protection parameter cannot be NULL
#endif

	// checked all that we can check, possibly still false though
	return(TRUE_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     fscanf_m12(FILE *stream, si1 *fmt, ...)
{
	si4		ret_val;
	va_list		args;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef WINDOWS_m12
	si1	*new_fmt = NULL;
	
	// convert format string
	new_fmt = WN_windify_format_string_m12(fmt);
	
	va_start(args, fmt);
	ret_val = vfscanf(stream, new_fmt, args);
	va_end(args);
	
	if (new_fmt != fmt)
		free((void *) new_fmt);
#endif
	
#if defined MACOS_m12 || defined LINUX_m12
	va_start(args, fmt);
	ret_val = vfscanf(stream, fmt, args);
	va_end(args);
#endif
	
	return(ret_val);
}


si4	fseek_m12(FILE *stream, si8 offset, si4 whence, si1 *path, const si1 *function, ui4 behavior_on_fail)
{
	si4	err;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	errno_reset_m12();
	
#if defined MACOS_m12 || defined LINUX_m12
	if ((fseek(stream, offset, whence)) == -1) {
		if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
			(void) fprintf_m12(stderr, "%c\n\t%s() failed to move the file pointer to requested location (offset %ld, whence %d)\n", 7, __FUNCTION__, offset, whence);
			(void) UTF8_fprintf_m12(stderr, "%\tin file \"%s\"\n", path);
			err = errno_m12();
			(void) fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
			if (function != NULL)
				(void) fprintf_m12(stderr, "\tcalled from function %s()\n", function);
			if (behavior_on_fail & RETURN_ON_FAIL_m12)
				(void) fprintf_m12(stderr, "\t=> returning -1\n\n");
			else if (behavior_on_fail & EXIT_ON_FAIL_m12)
				(void) fprintf_m12(stderr, "\t=> exiting program\n\n");
			fflush(stderr);
		}
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			return(-1);
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(-1);
	}
#endif

#ifdef WINDOWS_m12
	if ((_fseeki64(stream, offset, whence)) == -1) {
		if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
			(void) fprintf_m12(stderr, "%c\n\t%s() failed to move the file pointer to requested location (offset %ld, whence %d)\n", 7, __FUNCTION__, offset, whence);
			(void) UTF8_fprintf_m12(stderr, "%\tin file \"%s\"\n", path);
			err = errno_m12();
			(void) fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
			if (function != NULL)
				(void) fprintf_m12(stderr, "\tcalled from function %s()\n", function);
			if (behavior_on_fail & RETURN_ON_FAIL_m12)
				(void) fprintf_m12(stderr, "\t=> returning -1\n\n");
			else if (behavior_on_fail & EXIT_ON_FAIL_m12)
				(void) fprintf_m12(stderr, "\t=> exiting program\n\n");
			fflush(stderr);
		}
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			return(-1);
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(-1);
	}
#endif

	return(0);
}
		
		
si8	ftell_m12(FILE *stream, const si1 *function, ui4 behavior_on_fail)
{
	si4	err;
	si8	pos;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;

	errno_reset_m12();

#if defined MACOS_m12 || defined LINUX_m12
	if ((pos = ftell(stream)) == -1) {
		if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
			(void) fprintf_m12(stderr, "%c\n\t%s() failed obtain the current location\n", 7, __FUNCTION__);
			err = errno_m12();
			(void) fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
			if (function != NULL)
				(void)fprintf_m12(stderr, "\tcalled from function %s()\n", function);
			if (behavior_on_fail & RETURN_ON_FAIL_m12)
				(void)fprintf_m12(stderr, "\t=> returning -1\n\n");
			else if (behavior_on_fail & EXIT_ON_FAIL_m12)
				(void)fprintf_m12(stderr, "\t=> exiting program\n\n");
			fflush(stderr);
		}
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			return(-1);
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(-1);
	}
#endif
#ifdef WINDOWS_m12
	if ((pos = _ftelli64(stream)) == -1) {
		if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
			(void) fprintf_m12(stderr, "%c\n\t%s() failed obtain the current location\n", 7, __FUNCTION__);
			err = errno_m12();
			(void) fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
			if (function != NULL)
				(void) fprintf_m12(stderr, "\tcalled from function %s()\n", function);
			if (behavior_on_fail & RETURN_ON_FAIL_m12)
				(void) fprintf_m12(stderr, "\t=> returning -1\n\n");
			else if (behavior_on_fail & EXIT_ON_FAIL_m12)
				(void) fprintf_m12(stderr, "\t=> exiting program\n\n");
			fflush(stderr);
		}
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			return(-1);
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(-1);
	}
#endif

	return(pos);
}
		
		
size_t	fwrite_m12(void *ptr, size_t el_size, size_t n_members, FILE *stream, si1 *path, const si1 *function, ui4 behavior_on_fail)
{
	si4	err;
	size_t	nw;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	errno_reset_m12();
	
	if ((nw = fwrite(ptr, el_size, n_members, stream)) != n_members) {
		if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
			(void) UTF8_fprintf_m12(stderr, "%c\n\t%s() failed to write file \"%s\"\n", 7, __FUNCTION__, path);
			err = errno_m12();
			(void) fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
			if (function != NULL)
				(void) fprintf_m12(stderr, "\tcalled from function %s()\n", function);
			if (behavior_on_fail & RETURN_ON_FAIL_m12)
				(void) fprintf_m12(stderr, "\t=> returning number of items written\n\n");
			else if (behavior_on_fail & EXIT_ON_FAIL_m12)
				(void) fprintf_m12(stderr, "\t=> exiting program\n\n");
			fflush(stderr);
		}
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			return(nw);
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(-1);
	}
	
	return(nw);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
char	*getcwd_m12(char *buf, size_t size)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef MATLAB_m12
	G_error_message_m12("%s(): the current working directory is not defined for Matlab mex files => pass full path\n", __FUNCTION__);
	return(NULL);
#endif

#if defined MACOS_m12 || defined LINUX_m12
	return(getcwd(buf, size));
#endif
#ifdef WINDOWS_m12
	return(_getcwd(buf, size));
#endif
}


void	*malloc_m12(size_t n_bytes, const si1 *function, ui4 behavior_on_fail)
{
	void	*ptr;
	si4	err;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	errno_reset_m12();
	
	if (n_bytes == 0)
		return((void *) NULL);
	
#ifdef MATLAB_PERSISTENT_m12
	ptr = mxMalloc((mwSize) n_bytes);
#else
	ptr = malloc(n_bytes);
#endif
	if (ptr == NULL) {
		if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
			(void)fprintf_m12(stderr, "%c\n\t%s() failed to allocate the requested array (%ld bytes)\n", 7, __FUNCTION__, n_bytes);
			err = errno_m12();
			(void)fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
			if (function != NULL)
				(void)fprintf_m12(stderr, "\tcalled from function %s()\n", function);
			if (behavior_on_fail & RETURN_ON_FAIL_m12)
				(void)fprintf_m12(stderr, "\t=> returning NULL\n\n");
			else if (behavior_on_fail & EXIT_ON_FAIL_m12)
				(void)fprintf_m12(stderr, "\t=> exiting program\n\n");
			fflush(stderr);
		}
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			return(NULL);
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(-1);
	}
	
	// alloc tracking
#ifdef AT_DEBUG_m12
	AT_add_entry_m12(ptr, (size_t) n_bytes, function);
#endif

#ifdef MATLAB_PERSISTENT_m12
	mexMakeMemoryPersistent(ptr);
#endif
	
	return(ptr);
}
		

// not a standard function, but closely related
void	**malloc_2D_m12(size_t dim1, size_t dim2, size_t el_size, const si1 *function, ui4 behavior_on_fail)
{
	ui1	**ptr;
	size_t  i, dim1_bytes, dim2_bytes, content_bytes, total_bytes;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Returns pointer to 2 dimensional array (not zeroed) of dim1 by dim2 elements of size el_size
	// ptr[0] points to a one dimensional array of size (dim1 * dim2)
	// The whole block can be freed with free(ptr)
	
	if (dim1 == 0 || dim2 == 0 || el_size == 0)
		return((void **) NULL);
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	dim1_bytes = dim1 * sizeof(void *);
	dim2_bytes = dim2 * el_size;
	content_bytes = dim1 * dim2_bytes;
	total_bytes = dim1_bytes + content_bytes;
	ptr = (ui1 **) malloc_m12(total_bytes, function, behavior_on_fail);
	ptr[0] = (ui1 *) (ptr + dim1);
	
	for (i = 1; i < dim1; ++i)
		ptr[i] = ptr[i - 1] + dim2_bytes;
	
	return((void **) ptr);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
size_t	malloc_size_m12(void *address)
{
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (address == NULL)
		return((size_t) 0);
	
#ifdef AT_DEBUG_m12
	si8		i;
	AT_NODE		*atn;
	
	atn = globals_m12->AT_nodes;
	for (i = globals_m12->AT_node_count; i--; ++atn) {
		if (atn->address == address)
			return(atn->actual_bytes);
	}
	return((size_t) 0);
#endif
	
#ifdef MACOS_m12
	return(malloc_size(address));
#endif
	
#ifdef LINUX_m12
	// seg faults if address not allocated (no way around it)
	return(malloc_usable_size(address));
#endif
	
#ifdef WINDOWS_m12
	// process terminates without signal on non-allocated pointer (no way around it without using Windows DEBUG functions)
	return(_msize(address));
#endif
}


void	memset_m12(void *ptr, const void *pattern, size_t pat_len, size_t n_members)
{
	si8	i;
	si2	*si2_p, si2_pat;
	si4	*si4_p, si4_pat;
	si8	*si8_p, si8_pat;
	size_t	buf_len;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	buf_len = n_members * pat_len;
	
	// regular memset()
	if (pat_len == 1) {
		memset(ptr, (si4) *((si1 *) pattern), buf_len);
		return;
	}
	
#ifdef MACOS_m12
	switch (pat_len) {  // optimized versions currently only for MacOS
		case 4:
			memset_pattern4(ptr, pattern, buf_len);
			return;
		case 8:
			memset_pattern8(ptr, pattern, buf_len);
			return;
		case 16:
			memset_pattern16(ptr, pattern, buf_len);
			return;
	}
#endif
	
	switch (pat_len) {
		case 2:
			si2_p = (si2 *) ptr;
			si2_pat = *((si2 *) pattern);
			for (i = buf_len >> 1; i--;)
				*si2_p++ = si2_pat;
			return;
		case 4:
			si4_p = (si4 *) ptr;
			si4_pat = *((si4 *) pattern);
			for (i = buf_len >> 2; i--;)
				*si4_p++ = si4_pat;
			return;
		case 8:
			si8_p = (si8 *) ptr;
			si8_pat = *((si8 *) pattern);
			for (i = buf_len >> 3; i--;)
				*si8_p++ = si8_pat;
			return;
		// case 16:  removed because some OSs silently implement sf16 as sf8, which would be quite bad with this usage
		default:
			G_warning_message_m12("%s(): unsupported pattern length\n", __FUNCTION__);
			return;
	}
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
TERN_m12	mlock_m12(void *addr, size_t len, TERN_m12 zero_data, const si1 *function, ui4 behavior_on_fail)
{
	si1			*err_str;
	si4			ret_val, err;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif

	errno_reset_m12();

	#if defined MACOS_m12 || defined LINUX_m12
	ret_val = mlock(addr, len);
	#endif
	
	#ifdef WINDOWS_m12
	if (VirtualLock(addr, len))
		ret_val = 0;
	else
		ret_val = -1;
	#endif
	
	if (ret_val == 0) {
		if (zero_data == TRUE_m12)
			memset(addr, 0, len);  // forces OS to give real memory before return (otherwise there may be a lag)
		return(TRUE_m12);
	}
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
		err = errno_m12();
		#if defined MACOS_m12 || defined LINUX_m12
		err_str = strerror(err);
		#endif
		#ifdef WINDOWS_m12
		if (err = 1453)
			err_str = "insufficient quota to complete the requested service";
		else
			err_str = "unknown error";
		#endif
		fprintf_m12(stderr, "%c\n\t%s() failed to lock the requested array (%ld bytes)\n", 7, __FUNCTION__, len);
		fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, err_str);
		if (function != NULL)
			fprintf_m12(stderr, "\tcalled from function %s()\n", function);
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			fprintf_m12(stderr, "\t=> returning FALSE\n\n");
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			fprintf_m12(stderr, "\t=> exiting program\n\n");
		fflush(stderr);
	}
	if (behavior_on_fail & EXIT_ON_FAIL_m12)
		exit_m12(-1);
	
	return(FALSE_m12);
}

	    
#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
TERN_m12	munlock_m12(void *addr, size_t len, const si1 *function, ui4 behavior_on_fail)
{
	si4	err;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	errno_reset_m12();
	
	#if defined MACOS_m12 || defined LINUX_m12
	if (munlock(addr, len) == 0)
		return(TRUE_m12);
	#endif
	
	#ifdef WINDOWS_m12
	if (VirtualUnlock(addr, len))  // returns non-zero on success
		return(TRUE_m12);
	#endif
		
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;

	if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
		fprintf_m12(stderr, "%c\n\t%s() failed to unlock the requested array (%ld bytes)\n", 7, __FUNCTION__, len);
		err = errno_m12();
		fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
		if (function != NULL)
			fprintf_m12(stderr, "\tcalled from function %s()\n", function);
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			fprintf_m12(stderr, "\t=> returning FALSE\n\n");
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			fprintf_m12(stderr, "\t=> exiting program\n\n");
		fflush(stderr);
	}
	if (behavior_on_fail & EXIT_ON_FAIL_m12)
		exit_m12(-1);
	
	return(FALSE_m12);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     printf_m12(si1 *fmt, ...)
{
	si1		*temp_str;
	si4		ret_val;
	va_list		args;
	
	
	va_start(args, fmt);
	ret_val = vasprintf_m12(&temp_str, fmt, args);  // could just call vprintf_m12() here & be done, but it's hardly any extra code, so duplicate & skip extra function call
	va_end(args);
	
	if (ret_val >= 0) {
#ifdef MATLAB_m12
		ret_val = mexPrintf("%s", temp_str);
		// mexEvalString("drawnow;");  // flush output to Matlab console => does not work
		// Note flush can be done more efficiently by calling [int ioFlush(void)] from ${MATLABROOT}/bin/<platform>/libmwservices.dll,
		// but involves loading a dynamic library; mechanism for this differs across platforms => not worth the effort
		// stackoverflow: "how can I make a mex function printf while its running" contains some guidance on this, but needs adjustment
#else
		ret_val = printf("%s", temp_str);
#endif
		free((void *) temp_str);
	}
		
	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	putc_m12(si4 c, FILE *stream)
{
	return(fputc_m12(c, stream));
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	putch_m12(si4 c)
{
	si4	ret_val;


#ifdef MATLAB_m12
	ret_val = mexPrintf("%c", c);
#else
	#ifdef WINDOWS_m12
		ret_val = _putch(c);
	#else
		ret_val = fputc_m12(c, stdout);
	#endif
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	putchar_m12(si4 c)
{
	return(fputc_m12(c, stdout));
}


void	*realloc_m12(void *orig_ptr, size_t n_bytes, const si1 *function, ui4 behavior_on_fail)
{
	void	*ptr;
	si4	err;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	if (n_bytes == 0) {
		if (orig_ptr != NULL)
			free_m12((void *) orig_ptr, function);
		return((void *) NULL);
	}
	
#ifdef AT_DEBUG_m12
	ui8	alloced_bytes;
	
	// see if already has enough memory
	if (orig_ptr != NULL)
		alloced_bytes = AT_alloc_size_m12(orig_ptr);
	else
		alloced_bytes = 0;
	if (alloced_bytes >= n_bytes)
		return(orig_ptr);
#endif
	
	err = errno_m12();
	
#ifdef MATLAB_PERSISTENT_m12
	ptr = mxRealloc(orig_ptr, (mwSize) n_bytes);
#else
	ptr = realloc(orig_ptr, n_bytes);
#endif
	if (ptr == NULL) {
		if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
			fprintf_m12(stderr, "%c\n\t%s() failed to reallocate the requested array (%ld bytes)\n", 7, __FUNCTION__, n_bytes);
			fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
			if (function != NULL)
				fprintf_m12(stderr, "\tcalled from function %s()\n", function);
			if (behavior_on_fail & RETURN_ON_FAIL_m12)
				fprintf_m12(stderr, "\t=> returning unreallocated pointer\n\n");
			else if (behavior_on_fail & EXIT_ON_FAIL_m12)
				fprintf_m12(stderr, "\t=> exiting program\n\n");
			fflush(stderr);
		}
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			return(orig_ptr);
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(-1);
	}
	
	// alloc tracking
#ifdef AT_DEBUG_m12
	AT_update_entry_m12(orig_ptr, ptr, n_bytes, function);
#endif
#ifdef MATLAB_PERSISTENT_m12
	mexMakeMemoryPersistent(ptr);
#endif

	return(ptr);
}


// not a standard function, but closely related
void	**realloc_2D_m12(void **curr_ptr, size_t curr_dim1, size_t new_dim1, size_t curr_dim2, size_t new_dim2, size_t el_size, const si1 *function, ui4 behavior_on_fail)
{
	void	**new_ptr;
	size_t	i, least_dim1, least_dim2;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// Returns pointer to a reallocated 2 dimensional array of new_dim1 by new_dim2 elements of size el_size (new unused elements are zeroed)
	// ptr[0] points to a one dimensional array of size (dim1 * dim2)
	// The whole block can be freed with free(ptr)
	// Assumes memory was allocated with malloc_2D_m12() or calloc_2D_m12()
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	if (new_dim1 == 0 || new_dim2 == 0 || el_size == 0) {
		if (curr_ptr != NULL)
			free_m12((void *) curr_ptr, function);
		return((void **) NULL);
	}
	
	if (curr_ptr == NULL) {
		G_error_message_m12("%s(): attempting to re-allocate NULL pointer, called from function %s()\n", __FUNCTION__, function);
		return(NULL);
	}
	
	if (new_dim1 < curr_dim1)
		G_warning_message_m12("%s(): re-allocating first dimension to smaller size, called from function %s()\n", __FUNCTION__, function);
	if (new_dim2 < curr_dim2)
		G_warning_message_m12("%s(): re-allocating second dimension to smaller size, called from function %s()\n", __FUNCTION__, function);
	
	new_ptr = calloc_2D_m12(new_dim1, new_dim2, el_size, function, behavior_on_fail);
	
	least_dim1 = (curr_dim1 <= new_dim1) ? curr_dim1 : new_dim1;
	least_dim2 = (curr_dim2 <= new_dim2) ? curr_dim2 : new_dim2;
	for (i = 0; i < least_dim1; ++i)
		memcpy((void *) new_ptr[i], curr_ptr[i], (size_t) (least_dim2 * el_size));
	
	free_m12((void *) curr_ptr, function);
	
	return((void **) new_ptr);
}
		
		
// not a standard function, but closely related
void	*recalloc_m12(void *orig_ptr, size_t curr_bytes, size_t new_bytes, const si1 *function, ui4 behavior_on_fail)
{
	void	*ptr;
	ui1	*ui1_p;
	si4	err;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	if (new_bytes == 0) {
		if (orig_ptr != NULL)
			free_m12((void *) orig_ptr, function);
		return((void *) NULL);
	}
	
	errno_reset_m12();
		
#ifdef MATLAB_PERSISTENT_m12
	ptr = mxRealloc(orig_ptr, (mwSize) new_bytes);
#else
	ptr = realloc(orig_ptr, new_bytes);
#endif
	if (ptr == NULL) {
		if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
			fprintf_m12(stderr, "%c\n\t%s() failed to reallocate the requested array (%ld bytes)\n", 7, __FUNCTION__, new_bytes);
			err = errno_m12();
			fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
			if (function != NULL)
				fprintf_m12(stderr, "\tcalled from function %s()\n", function);
			if (behavior_on_fail & RETURN_ON_FAIL_m12)
				fprintf_m12(stderr, "\t=> returning unreallocated pointer\n\n");
			else if (behavior_on_fail & EXIT_ON_FAIL_m12)
				fprintf_m12(stderr, "\t=> exiting program\n\n");
			fflush(stderr);
		}
		if (behavior_on_fail & RETURN_ON_FAIL_m12)
			return(orig_ptr);
		else if (behavior_on_fail & EXIT_ON_FAIL_m12)
			exit_m12(-1);
	}
	
	// zero new bytes
	if (new_bytes > curr_bytes) {
		ui1_p = (ui1 *) ptr + curr_bytes;
		memset(ui1_p, 0, new_bytes - curr_bytes);
	}
	
	// alloc tracking
#ifdef AT_DEBUG_m12
	AT_update_entry_m12(orig_ptr, ptr, new_bytes, function);
#endif
	
#ifdef MATLAB_PERSISTENT_m12
	mexMakeMemoryPersistent(ptr);
#endif
	
	return(ptr);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     scanf_m12(si1 *fmt, ...)
{
	si4         ret_val;
	va_list     args;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef WINDOWS_m12
	si1* new_fmt = NULL;
	
	// convert format string
	new_fmt = WN_windify_format_string_m12(fmt);
	
	va_start(args, fmt);
	ret_val = vscanf(new_fmt, args);
	va_end(args);
	
	if (new_fmt != fmt)
		free((void *) new_fmt);
#endif
	
#if defined MACOS_m12 || defined LINUX_m12
	va_start(args, fmt);
	ret_val = vscanf(fmt, args);
	va_end(args);
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4    snprintf_m12(si1 *target, si4 target_field_bytes, si1 *fmt, ...)
{
	si4		ret_val;
	va_list		args;
	
	
	// as opposed to standard snprintf(), snprintf_m12() allows source & target strings to overlap
	
	va_start(args, fmt);
	ret_val = vsnprintf_m12(target, target_field_bytes, fmt, args);
	va_end(args);
	
	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4    sprintf_m12(si1 *target, si1 *fmt, ...)
{
	si1		*tmp_str;
	si4		ret_val;
	va_list		args;
	
	
	// as opposed to standard sprintf(), sprintf_m12() allows source & target strings to overlap
		
	va_start(args, fmt);
	ret_val = vasprintf_m12(&tmp_str, fmt, args);  	// could just call vsprintf_m12() here & be done, but it's hardly any extra code, so duplicate & skip extra function call
	va_end(args);
	
	memcpy(target, tmp_str, ret_val + 1);
	free((void *) tmp_str);

	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     sscanf_m12(si1 *target, si1 *fmt, ...)
{
	si4		ret_val;
	va_list		args;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
#ifdef WINDOWS_m12
	si1* new_fmt = NULL;
	
	// convert format string
	new_fmt = WN_windify_format_string_m12(fmt);
	
	va_start(args, fmt);
	ret_val = vsscanf(target, new_fmt, args);
	va_end(args);
	
	if (new_fmt != fmt)
		free((void *) new_fmt);
#endif
	
#if defined MACOS_m12 || defined LINUX_m12
	va_start(args, fmt);
	ret_val = vsscanf(target, fmt, args);
	va_end(args);
#endif
	
	return(ret_val);
}


si8     strcat_m12(si1 *target, si1 *source)
{
	si1	*c;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns final length (not including terminal zero)
	
	if (target == NULL || source == NULL)
		return(-1);
	
	c = target;
	while ((*c++));
	--c;
	while ((*c++ = *source++));
	
	return((si8)((c - target) - 1));
}


si8     strcpy_m12(si1 *target, si1 *source)
{
	si1	*c;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns length (not including terminal zero)
	
	if (target == NULL || source == NULL)
		return(-1);
	
	c = target;
	while ((*c++ = *source++));
	
	return((si8) ((c - target) - 1));
}


si8    strncat_m12(si1 *target, si1 *source, si4 target_field_bytes)
{
	si1	*c;
	si8	len = 0;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns final length (not including terminal zeros)
	
	if (target == NULL)
		return(-1);
	if (target_field_bytes < 1) {
		*target = 0;
		return(-1);
	}
	
	c = target;
	if (source == NULL) {
		--target_field_bytes;
	} else {
		while (--target_field_bytes)
			if (*c++ == '\0')
				break;
	}
	
	--c;
	++target_field_bytes;
	
	while (--target_field_bytes)
		if ((*c++ = *source++) == '\0')
			break;
	len = (si8)((c - target) - 1);
	if (target_field_bytes) {
		while (--target_field_bytes)
			*c++ = '\0';
	} else {
		G_warning_message_m12("%s(): target string truncated\n", __FUNCTION__);
	}
	
	*c = '\0';
	
	return(len);
}


si8    strncpy_m12(si1 *target, si1 *source, si4 target_field_bytes)
{
	si1	*c;
	si8	len = 0;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// returns length (not including terminal zeros)
	
	if (target == NULL)
		return(-1);
	
	if (target_field_bytes < 1) {
		*target = 0;
		return(-1);
	}
	
	c = target;
	if (source == NULL) {
		--target_field_bytes;
	} else {
		while (--target_field_bytes) {
			if ((*c++ = *source++) == 0)
				break;
		}
		len = (si8)((c - target) - 1);
	}
	
	if (target_field_bytes) {
		while (--target_field_bytes)
			*c++ = '\0';
	} else {
		G_warning_message_m12("%s(): target string truncated\n", __FUNCTION__);
	}
	
	*c = '\0';
	
	return(len);
}


si4     system_m12(si1 *command, TERN_m12 null_std_streams, const si1 *function, ui4 behavior_on_fail)
{
	si1	*temp_command;
	si4	ret_val, len, err;
	
#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	if (behavior_on_fail == USE_GLOBAL_BEHAVIOR_m12)
		behavior_on_fail = globals_m12->behavior_on_fail;
	
	if (null_std_streams == TRUE_m12) {
		len = strlen(command);
		temp_command = malloc(len + (FULL_FILE_NAME_BYTES_m12 * 2) + 9);
		sprintf(temp_command, "%s 1> %s 2> %s", command, NULL_DEVICE_m12, NULL_DEVICE_m12);  // don't use sprintf_m12() here - can screw up Windows options
		command = temp_command;
	}
	
	errno_reset_m12();
#if defined MACOS_m12 || defined LINUX_m12
	ret_val = system(command);
#endif
#ifdef WINDOWS_m12
	ret_val = WN_system_m12(command);
#endif

	if (ret_val) {
		if (behavior_on_fail & RETRY_ONCE_m12) {
			G_nap_m12("1 ms");  // wait 1 ms
			errno_reset_m12();
#if defined MACOS_m12 || defined LINUX_m12
			ret_val = system(command);
#endif
#ifdef WINDOWS_m12
			ret_val = WN_system_m12(command);
#endif
			if (ret_val == 0) {
				if (null_std_streams == TRUE_m12)
					free((void *) temp_command);
				return(0);
			}
		}
		err = errno_m12();
		if (!(behavior_on_fail & SUPPRESS_ERROR_OUTPUT_m12)) {
			fprintf_m12(stderr, "%c\n%s() failed\n", 7, __FUNCTION__);
			fprintf_m12(stderr, "\tcommand: \"%s\"\n", command);
			fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
			fprintf_m12(stderr, "\tshell return value %d\n", ret_val);
			if (function != NULL)
				fprintf_m12(stderr, "\tcalled from function %s()\n", function);
			if (behavior_on_fail & RETURN_ON_FAIL_m12)
				fprintf_m12(stderr, "\t=> returning -1\n\n");
			else if (behavior_on_fail & EXIT_ON_FAIL_m12)
				fprintf_m12(stderr, "\t=> exiting program\n\n");
			fflush(stderr);
		}
		// make error negative, if not
		err = (err > 0) ? -err : err;
		if (behavior_on_fail & RETURN_ON_FAIL_m12) {
			if (null_std_streams == TRUE_m12)
				free((void *) temp_command);
			return(err);
		} else if (behavior_on_fail & EXIT_ON_FAIL_m12) {
			exit_m12(err);
		}
	}
	
	if (null_std_streams == TRUE_m12)
		free((void *) temp_command);
	
	return(0);
}


// not a standard function, but closely related
#if defined MACOS_m12 || defined LINUX_m12
si4	system_pipe_m12(si1 **buffer_ptr, si8 buf_len, si1 *command, ui4 flags, const si1 *function, ui4 behavior, ...)  // varargs(SPF_SEPERATE_STREAMS_m12 set): si1 **e_buffer_ptr, si8 *e_buf_len
{
	TERN_m12	no_command, command_needs_shell, assign_buffer, assign_e_buffer, free_buffer, free_e_buffer, retried;
	si1		**e_buffer_ptr, *buffer, *e_buffer, *c;
	si4		ret_val, status, err, BUFFER_SIZE_INC;
	si4		master_fd, stdout_master_fd, stdout_slave_fd, stderr_master_fd, stderr_slave_fd;
	si8		bytes_in_buffer, bytes_in_e_buffer, bytes_avail, *e_buf_len;
	pid_t		child_pid;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// executes command (for output, more efficient than redirecting to temp file & reading)
	// if buffer_ptr == NULL, no buffer is returned
	// if *buffer_ptr == NULL buffer is allocated on the heap (caller responsible for freeing)
	// else if *buffer_ptr is heap allocated, it will be dynamically reallocated as needed
	// *buffer_ptr contains a NULL terminated string from the system command, if passed
	// returns negative system error number or buffer string length on success (zero if no buffer returned)
	// if SP_SEPERATE_STREAMS_m12 flag is set, returns error buffer string length on success in e_buf_len (zero if no buffer returned)
	
	if (behavior == USE_GLOBAL_BEHAVIOR_m12)
		behavior = globals_m12->behavior_on_fail;
	
	no_command = FALSE_m12;
	if (command == NULL)
		no_command = TRUE_m12;
	else if (*command == 0)
		no_command = TRUE_m12;
	if (no_command == TRUE_m12) {
		if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
			G_warning_message_m12("%s(): no command\n", __FUNCTION__);
		return(-1);
	}
	
	// see if shell required
	command_needs_shell = FALSE_m12;
	c = --command;  // (command re-incremented below)
	while (*++c) {
		switch (*c) {
			case '>':
			case '<':
			case '&':
			case '|':
			case '*':
			case '?':
			case '^':
			case '$':
			case '[':
			case '{':
			case 39:  // single quote / apostrophe
			case 96:  // grave accent
				command_needs_shell = TRUE_m12;
				goto SYSTEM_PIPE_NEEDS_SHELL_m12;  // break out of while loop
		}
	} SYSTEM_PIPE_NEEDS_SHELL_m12:

	// skip any leading spaces in command (& re-increment from above)
	while (*++command == 32);

	if (buffer_ptr == NULL) {
		free_buffer = TRUE_m12;
		assign_buffer = FALSE_m12;
		buffer = NULL;
		buf_len = 0;
	} else {
		free_buffer = FALSE_m12;
		buffer = *buffer_ptr;
		if (buffer == NULL) {
			assign_buffer = TRUE_m12;
			buf_len = 0;
		} else {
			assign_buffer = freeable_m12((void *) buffer);
			if (assign_buffer == TRUE_m12)
				buf_len = malloc_size_m12((void *) buffer);
		}
	}
	
	BUFFER_SIZE_INC = global_tables_m12->HW_params.system_page_size;
	if (buf_len == 0) {
		buf_len = BUFFER_SIZE_INC;
		buffer = (si1 *) malloc_m12((size_t) buf_len, __FUNCTION__, behavior);
	}
	
	// get varargs & set up error buffer
	if (flags & SP_SEPERATE_STREAMS_m12) {
		va_list		v_args;
		
		va_start(v_args, behavior);
		e_buffer_ptr = va_arg(v_args, si1 **);
		e_buf_len = va_arg(v_args, si8 *);
		va_end(v_args);

		if (e_buffer_ptr == NULL) {
			free_e_buffer = TRUE_m12;
			assign_e_buffer = FALSE_m12;
			e_buffer = NULL;
			*e_buf_len = 0;
		} else {
			free_e_buffer = FALSE_m12;
			e_buffer = *buffer_ptr;
			if (e_buffer == NULL) {
				assign_e_buffer = TRUE_m12;
				*e_buf_len = 0;
			} else {
				assign_e_buffer = freeable_m12((void *) e_buffer);
				if (assign_e_buffer == TRUE_m12)
					*e_buf_len = malloc_size_m12((void *) e_buffer);
			}
		}
		
		if (*e_buf_len == 0) {
			*e_buf_len = BUFFER_SIZE_INC;
			e_buffer = (si1 *) malloc_m12((size_t) *e_buf_len, __FUNCTION__, behavior);
		}
	} else {
		free_e_buffer = assign_e_buffer = FALSE_m12;
	}

	retried = FALSE_m12;
	
SYSTEM_PIPE_RETRY_m12:
	
	// spawn child and connect to a pseudoterminal
	*buffer = 0;
	err = 0;
	
	if (flags & SP_SEPERATE_STREAMS_m12) {
		stdout_master_fd = stdout_slave_fd = stderr_master_fd = stderr_slave_fd = 0;
		*e_buffer = 0;
		// create master & slave ends of pseudoterminal
		if (openpty(&stdout_master_fd, &stdout_slave_fd, NULL, NULL, NULL) == -1) {
			if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
				G_warning_message_m12("%s(): openpty() error\n", __FUNCTION__);
			goto SYSTEM_PIPE_FAIL_m12;
		}
		if (openpty(&stderr_master_fd, &stderr_slave_fd, NULL, NULL, NULL) == -1) {
			if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
				G_warning_message_m12("%s(): openpty() error\n", __FUNCTION__);
			goto SYSTEM_PIPE_FAIL_m12;
		}
		// set close on exec on master ends of pseudoterminal
		if ((fcntl(stdout_master_fd, F_SETFD, FD_CLOEXEC)) == -1) {
			if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
				G_warning_message_m12("%s(): fcntl() error\n", __FUNCTION__);
			goto SYSTEM_PIPE_FAIL_m12;
		}
		if ((fcntl(stderr_master_fd, F_SETFD, FD_CLOEXEC)) == -1) {
			if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
				G_warning_message_m12("%s(): fcntl() error\n", __FUNCTION__);
			goto SYSTEM_PIPE_FAIL_m12;
		}
		child_pid = fork();
		if (child_pid == -1) {
			if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
				G_warning_message_m12("%s(): fork() error\n", __FUNCTION__);
			goto SYSTEM_PIPE_FAIL_m12;
		}
	} else {
		master_fd = 0;
		child_pid = forkpty(&master_fd, NULL, NULL, NULL);
		if (child_pid == -1) {
			if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
				G_warning_message_m12("%s(): forkpty() error\n", __FUNCTION__);
			goto SYSTEM_PIPE_FAIL_m12;
		}
	}
	
	if (child_pid == 0) {  // child process
		
		si1		*tmp_command, **args, *c2, *c3;
		si4		arg_cnt, alloced_args, ALLOCED_ARGS_INC;
		si8		command_len;

		
		// allocate argument pointers
		if (command_needs_shell == TRUE_m12)
			ALLOCED_ARGS_INC = 3;
		else
			ALLOCED_ARGS_INC = 10;
		alloced_args = ALLOCED_ARGS_INC;
		args = (si1 **) malloc((size_t) (alloced_args + 1) * sizeof(si1 *));  // exec_arge_ptr allow parent process to free args after execvp() has copied
		
		// use shell to expand regex (less efficient, but simplest)
		if (command_needs_shell == TRUE_m12) {
			#ifdef MACOS_m12
			args[0] = "/bin/sh";
			#endif
			#ifdef LINUX_m12
			args[0] = "/usr/bin/sh";
			#endif
			args[1] = "-c";
			args[2] = command;
			args[3] = (char *) NULL;
			tmp_command = NULL;
		} else {  // parse args
			
			// copy command so not modified
			command_len = strlen(command) + 1;
			tmp_command = (si1 *) malloc((size_t) command_len);
			memcpy((void *) tmp_command, (void *) command, (size_t) command_len);
			c = tmp_command;
			
			arg_cnt = 0;
			args[arg_cnt++] = c;
			while (*c) {
				if (arg_cnt == alloced_args) {
					alloced_args += ALLOCED_ARGS_INC;
					args = (si1 **) realloc((void *) args, (size_t) (alloced_args + 1) * sizeof(si1 *));
				}
				if (*c == 34) {  // double quote, include all characters
					args[arg_cnt++] = ++c;  // skip initial quote
					while (*c != 34 && *c)
						++c;
					*c++ = 0;  // zero terminal quote
					continue;
				}
				if (*c == 32) {  // space delimiter
					if (*(c - 1) == 92) {  // escaped space, move rest of command back one character (shell would remove escape characters)
						c2 = c - 1;
						c3 = c;
						while ((*c2++ = *c3++));
						continue;
					}
					if (*(c + 1)) {
						*c = 0;
						args[arg_cnt++] = ++c;
						continue;
					}
				}
				++c;
			}
			args[arg_cnt] = (si1 *) NULL;  // terminal NULL argument
		}
		
		if (flags & SP_SEPERATE_STREAMS_m12) {
			// assign child stdout & stderr to slave file descriptors
			if (login_tty(stdout_slave_fd)) {
				if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
					G_warning_message_m12("%s(): login_tty() error\n", __FUNCTION__);
				exit(-1);
			}
			// make slave end of stderr file descriptor equal stderr
			if ((dup2(stderr_slave_fd, STDERR_FILENO)) == -1) {
				if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
					G_warning_message_m12("%s(): dup2() error\n", __FUNCTION__);
				exit(-1);
			}
		}
		
		// convert child to command
		// if execvp() is successful, it does not return
		// "p" version uses environment path if no "/" in args[0]
		// child-allocated memory will be freed by kernel on exit
		errno_reset_m12();
		if (execvp(args[0], args) == -1) {
			err = errno_m12();  // capture errno to send back to parent
			if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
				if (!(behavior & RETRY_ONCE_m12) || retried == TRUE_m12)
					printf("%s(): execvp() error\n", __FUNCTION__);  // goes to pipe
			exit_m12(err);  // exit child to allow parent to continue
		}
	}  // rest is parent

	// read child output

	// close slave ends of pseudoterminal
	if (flags & SP_SEPERATE_STREAMS_m12) {
		close(stdout_slave_fd);
		close(stderr_slave_fd);
		master_fd = stdout_master_fd;  // use master_fd to read stdout
	}
	
	// read combined output, or stdout
	bytes_in_buffer = 0;
	bytes_avail = buf_len;
	while (bytes_avail > 1) {
		ret_val = read(master_fd, buffer + bytes_in_buffer, bytes_avail - 1);  // leave room for terminal zero
		if (ret_val <= 0)
			break;
		bytes_in_buffer += ret_val;
		bytes_avail -= ret_val;
		if (assign_buffer == TRUE_m12) {
			if (bytes_avail < 2) {
				buf_len += BUFFER_SIZE_INC;
				buffer = (si1 *) realloc_m12((void *) buffer, (size_t) buf_len, __FUNCTION__, __LINE__);
				bytes_avail += BUFFER_SIZE_INC;
			}
		}
	}
	buffer[bytes_in_buffer] = 0;  // set terminal zero
	
	// read stderr
	if (flags & SP_SEPERATE_STREAMS_m12) {
		bytes_in_e_buffer = 0;
		bytes_avail = *e_buf_len;
		while (bytes_avail > 1) {
			ret_val = read(stderr_master_fd, e_buffer + bytes_in_e_buffer, bytes_avail - 1);  // leave room for terminal zero
			if (ret_val <= 0)
				break;
			bytes_in_e_buffer += ret_val;
			bytes_avail -= ret_val;
			if (assign_e_buffer == TRUE_m12) {
				if (bytes_avail < 2) {
					*e_buf_len += BUFFER_SIZE_INC;
					e_buffer = (si1 *) realloc_m12((void *) e_buffer, (size_t) *e_buf_len, __FUNCTION__, __LINE__);
					bytes_avail += BUFFER_SIZE_INC;
				}
			}
		}
		e_buffer[bytes_in_e_buffer] = 0;  // set terminal zero
	}

	// wait for child
	waitpid(child_pid, &status, 1);  // "1": wait specifically & only for this child
	err = WEXITSTATUS(status);  // save any error code
	if (err)
		goto SYSTEM_PIPE_FAIL_m12;

	// close master ends of pseudoterminal
	if (flags & SP_SEPERATE_STREAMS_m12) {
		if (stdout_master_fd)
			close(stdout_master_fd);
		if (stderr_master_fd)
			close(stderr_master_fd);
	} else if (master_fd) {
		close(master_fd);
	}
	
	if (flags & SP_TEE_TO_TERMINAL_m12) {
		if (!(behavior & SUPPRESS_MESSAGE_OUTPUT_m12)) {
			printf_m12("%s[%s() tee]%s: %s%s%s\n%s\n", TC_GREEN_m12, __FUNCTION__, TC_RESET_m12, TC_BLUE_m12, command, TC_RESET_m12, buffer);
			if (flags & SP_SEPERATE_STREAMS_m12)
				printf_m12("%s\n", e_buffer);
		}
	}

	if (free_e_buffer == TRUE_m12) {
		free((void *) e_buffer);
		*e_buf_len = 0;
	}
	if (free_buffer == TRUE_m12) {
		free((void *) buffer);
		return(0);
	}
		
	if (assign_buffer == TRUE_m12)
		*buffer_ptr = buffer;
	if (assign_e_buffer == TRUE_m12)
		*e_buffer_ptr = e_buffer;
	
	if (flags & SP_SEPERATE_STREAMS_m12)
		*e_buf_len = bytes_in_e_buffer;  // return value for error buffer

	return(bytes_in_buffer);
	
SYSTEM_PIPE_FAIL_m12:
	
	// close master ends of pseudoterminal
	if (flags & SP_SEPERATE_STREAMS_m12) {
		if (stdout_master_fd)
			close(stdout_master_fd);
		if (stderr_master_fd)
			close(stderr_master_fd);
	} else if (master_fd) {
		close(master_fd);
	}

	if (behavior & RETRY_ONCE_m12) {
		if (retried == FALSE_m12) {
			G_nap_m12("1 ms");  // wait 1 ms
			retried = TRUE_m12;
			goto SYSTEM_PIPE_RETRY_m12;
		}
	}

	// try with system_m12() redirected to temp file(s)
	si1	*tmp_command, tmp_file[FULL_FILE_NAME_BYTES_m12], *e_tmp_file;
	si8	len;
	FILE	*fp;
	
	if (flags & SP_SEPERATE_STREAMS_m12) {
		e_tmp_file = (si1 *) malloc_m12((size_t) FULL_FILE_NAME_BYTES_m12, __FUNCTION__, behavior);
		G_unique_temp_file_m12(e_tmp_file);
	} else {
		e_tmp_file = tmp_file;
	}
	
	len = strlen(command) + (2 * FULL_FILE_NAME_BYTES_m12) + 9;
	tmp_command = (si1 *) malloc(len);
	G_unique_temp_file_m12(tmp_file);
	sprintf_m12(tmp_command, "%s 1> %s 2> %s", command, tmp_file, e_tmp_file);
	err = system_m12(tmp_command, FALSE_m12, __FUNCTION__, SUPPRESS_OUTPUT_m12 | RETURN_ON_FAIL_m12);
	free((void *) tmp_command);
	fp = fopen_m12(tmp_file, "r", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	bytes_in_buffer = G_file_length_m12(fp, NULL);
	if (assign_buffer == TRUE_m12) {
		if (bytes_in_buffer >= buf_len) {
			buf_len = bytes_in_buffer;
			buffer = (si1 *) realloc_m12((void *) buffer, (size_t) (bytes_in_buffer + 1), __FUNCTION__, __LINE__);  // allow for terminal zero
		}
	}
	fread((void *) buffer, sizeof(si1), (size_t) buf_len, fp);
	fclose(fp);
	buffer[buf_len] = 0;  // terminal zero
	G_remove_path_m12(tmp_file);  // delete temp file
	
	if (flags & SP_SEPERATE_STREAMS_m12) {
		fp = fopen_m12(e_tmp_file, "r", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free_m12((void *) e_tmp_file, __FUNCTION__);
		bytes_in_e_buffer = G_file_length_m12(fp, NULL);
		if (assign_e_buffer == TRUE_m12) {
			if (bytes_in_e_buffer >= *e_buf_len) {
				*e_buf_len = bytes_in_e_buffer;
				e_buffer = (si1 *) realloc_m12((void *) buffer, (size_t) (bytes_in_e_buffer + 1), __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);  // allow for terminal zero
			}
		}
		fread((void *) e_buffer, sizeof(si1), (size_t) *e_buf_len, fp);
		fclose(fp);
		e_buffer[*e_buf_len] = 0;  // terminal zero
		G_remove_path_m12(e_tmp_file);  // delete temp file
	}

	if (err) {
		err = (err < 0) ? -err : err;  // make positive for strerror() below
	} else {
		if (flags & SP_TEE_TO_TERMINAL_m12) {
			if (!(behavior & SUPPRESS_MESSAGE_OUTPUT_m12)) {
				printf_m12("%s[%s() tee]%s: %s%s%s\n%s\n", TC_GREEN_m12, __FUNCTION__, TC_RESET_m12, TC_BLUE_m12, command, TC_RESET_m12, buffer);
				if (flags & SP_SEPERATE_STREAMS_m12)
					printf_m12("%s\n", e_buffer);
			}
		}
		if (free_e_buffer == TRUE_m12) {
			free((void *) e_buffer);
			*e_buf_len = 0;
		}
		if (free_buffer == TRUE_m12) {
			free((void *) buffer);
			return(0);
		}
		if (assign_buffer == TRUE_m12)
			*buffer_ptr = buffer;
		if (assign_e_buffer == TRUE_m12)
			*e_buffer_ptr = e_buffer;
		
		return(bytes_in_buffer);
	}

	if (!(behavior & SUPPRESS_ERROR_OUTPUT_m12)) {
		fprintf_m12(stderr, "%c\n%s() failed\n", 7, __FUNCTION__);
		fprintf_m12(stderr, "\tcommand: \"%s\"\n", command);
		fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
		if (flags & SP_TEE_TO_TERMINAL_m12) {
			if (flags & SP_SEPERATE_STREAMS_m12) {
				if (*buffer)
					printf_m12("\tstandard out: \"%s\"\n", buffer);
				if (*e_buffer)
					printf_m12("\n\tstandard error: \"%s\"\n", e_buffer);
			} else if (*buffer) {
					printf_m12("\tcaptured output: \"%s\"\n", buffer);
			}
		}
		if (function != NULL)
			fprintf_m12(stderr, "\tcalled from function %s()\n", function);
		if (behavior & EXIT_ON_FAIL_m12)
			fprintf_m12(stderr, "\t=> exiting\n\n");
		else
			fprintf_m12(stderr, "\t=> returning\n\n");
		fflush(stderr);
	}

	if (behavior & EXIT_ON_FAIL_m12)
		exit_m12(-1);

	if (free_buffer == TRUE_m12)
		free_m12((void *) buffer, __FUNCTION__);
	if (free_e_buffer == TRUE_m12) {
		free_m12((void *) e_buffer, __FUNCTION__);
		*e_buf_len = 0;
	}

	// make negative, for return
	err = -err;
	
	return(err);
}
#endif  // MACOS_m12 || LINUX_m12


// not a standard function, but closely related
#ifdef WINDOWS_m12
si4	system_pipe_m12(si1 **buffer_ptr, si8 buf_len, si1 *command, ui4 flags, const si1 *function, ui4 behavior, ...)  // varargs(SPF_SEPERATE_STREAMS_m12 set): si1 **e_buffer_ptr, si8 *e_buf_len
{
	TERN_m12		no_command, assign_buffer, assign_e_buffer, free_buffer, free_e_buffer, retried;
	si1			**e_buffer_ptr, *buffer, *e_buffer, cmd_exe_path[MAX_PATH], *tmp_command;
	si4			BUFFER_SIZE_INC, err;
	si8			len, *e_buf_len;
	PROCESS_INFORMATION	process_info;
	STARTUPINFOA		startup_info;
	SECURITY_ATTRIBUTES 	sec_attr;
	HANDLE 			read_h, e_read_h, write_h, e_write_h;
	DWORD 			n_bytes_read, bytes_in_buffer, bytes_in_e_buffer, bytes_avail, exit_code;
	BOOL 			success;

#ifdef FN_DEBUG_m12
	G_message_m12("%s()\n", __FUNCTION__);
#endif
	
	// executes command (for output, more efficient than redirecting to temp file & reading)
	// if buffer_ptr == NULL, no buffer is returned
	// if *buffer_ptr == NULL buffer is allocated on the heap (caller responsible for freeing)
	// else if *buffer_ptr is heap allocated, it will be dynamically reallocated as needed
	// *buffer_ptr contains a NULL terminated string from the system command, if passed
	// returns negative system error number or buffer string length on success (zero if no buffer returned)
	// if SP_SEPERATE_STREAMS_m12 flag is set, returns error buffer string length on success in e_buf_len (zero if no buffer returned)

	if (behavior == USE_GLOBAL_BEHAVIOR_m12)
		behavior = globals_m12->behavior_on_fail;
	
	no_command = FALSE_m12;
	if (command == NULL)
		no_command = TRUE_m12;
	else if (*command == 0)
		no_command = TRUE_m12;
	if (no_command == TRUE_m12) {
		if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
			G_warning_message_m12("%s(): no command\n", __FUNCTION__);
		return(-1);
	}

	if (buffer_ptr == NULL) {
		free_buffer = TRUE_m12;
		assign_buffer = FALSE_m12;
		buffer = NULL;
		buf_len = 0;
	} else {
		free_buffer = FALSE_m12;
		buffer = *buffer_ptr;
		if (buffer == NULL) {
			assign_buffer = TRUE_m12;
			buf_len = 0;
		} else {
			assign_buffer = freeable_m12((void *) buffer);
			if (assign_buffer == TRUE_m12)
				buf_len = malloc_size_m12((void *) buffer);
		}
	}
	
	BUFFER_SIZE_INC = global_tables_m12->HW_params.system_page_size;
	if (buf_len == 0) {
		buf_len = BUFFER_SIZE_INC;
		buffer = (si1 *) malloc_m12((size_t) buf_len, __FUNCTION__, behavior);
	}

	// get varargs & set up error buffer
	if (flags & SP_SEPERATE_STREAMS_m12) {
		va_list		v_args;
		
		va_start(v_args, behavior);
		e_buffer_ptr = va_arg(v_args, si1 **);
		e_buf_len = va_arg(v_args, si8 *);
		va_end(v_args);

		if (e_buffer_ptr == NULL) {
			free_e_buffer = TRUE_m12;
			assign_e_buffer = FALSE_m12;
			e_buffer = NULL;
			*e_buf_len = 0;
		} else {
			free_e_buffer = FALSE_m12;
			e_buffer = *buffer_ptr;
			if (e_buffer == NULL) {
				assign_e_buffer = TRUE_m12;
				*e_buf_len = 0;
			} else {
				assign_e_buffer = freeable_m12((void *) e_buffer);
				if (assign_e_buffer == TRUE_m12)
					*e_buf_len = malloc_size_m12((void *) e_buffer);
			}
		}
		
		if (*e_buf_len == 0) {
			*e_buf_len = BUFFER_SIZE_INC;
			e_buffer = (si1 *) malloc_m12((size_t) *e_buf_len, __FUNCTION__, behavior);
		}
	} else {
		free_e_buffer = assign_e_buffer = FALSE_m12;
	}
	
	retried = FALSE_m12;
	
SYSTEM_PIPE_RETRY_m12:
	tmp_command = NULL;
	read_h = e_read_h =NULL;
	write_h = e_write_h = NULL;
	ZeroMemory(&process_info, sizeof(PROCESS_INFORMATION));
	ZeroMemory(&startup_info, sizeof(STARTUPINFO));

	// create pipes
	sec_attr.nLength = sizeof(SECURITY_ATTRIBUTES);
	sec_attr.lpSecurityDescriptor = NULL;
	sec_attr.bInheritHandle = TRUE;
	if (CreatePipe(&read_h, &write_h, &sec_attr, 0) == FALSE) {
		if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
			G_warning_message_m12("%s(): CreatePipe() failed\n", __FUNCTION__);
		goto SYSTEM_PIPE_FAIL_m12;
	}
	if (SetHandleInformation(read_h, HANDLE_FLAG_INHERIT, 0) == FALSE) {  // process should not inherit read handle of read pipe
		if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
			G_warning_message_m12("%s(): SetHandleInformation() failed\n", __FUNCTION__);
		goto SYSTEM_PIPE_FAIL_m12;
	}
	if (flags & SP_SEPERATE_STREAMS_m12) {
		if (CreatePipe(&e_read_h, &e_write_h, &sec_attr, 0) == FALSE) {
			if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
				G_warning_message_m12("%s(): CreatePipe() failed\n", __FUNCTION__);
			goto SYSTEM_PIPE_FAIL_m12;
		}
		if (SetHandleInformation(e_read_h, HANDLE_FLAG_INHERIT, 0) == FALSE) {  // process should not inherit read handle of read pipe
			if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
				G_warning_message_m12("%s(): SetHandleInformation() failed\n", __FUNCTION__);
			goto SYSTEM_PIPE_FAIL_m12;
		}
	}
	
	// set up process
	GetEnvironmentVariableA("COMSPEC", cmd_exe_path, MAX_PATH);
	len = 5;
	len += strlen(cmd_exe_path);
	len += strlen(command);
	tmp_command = (si1 *) malloc((size_t) len);
	sprintf(tmp_command, "%s /c %s", cmd_exe_path, command);

	startup_info.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;  // make nShowWindow member valid
	startup_info.wShowWindow = SW_HIDE;
	startup_info.hStdOutput = write_h;
	if (flags & SP_SEPERATE_STREAMS_m12)
		startup_info.hStdError = e_write_h;
	else
		startup_info.hStdError = write_h;  // put stdout & stderr on same pipe
	
	// start process
	errno_reset_m12();
	if (CreateProcessA(cmd_exe_path, tmp_command, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &startup_info, &process_info) == 0) {
		if (!(behavior & SUPPRESS_WARNING_OUTPUT_m12))
			G_warning_message_m12("%s(): CreateProcess() failed\n", __FUNCTION__);
		goto SYSTEM_PIPE_FAIL_m12;
	}
	
	// close unused pipe ends
	CloseHandle(write_h);
	if (flags & SP_SEPERATE_STREAMS_m12)
		CloseHandle(e_write_h);

	// read combined or stdout pipe
	bytes_in_buffer = 0;
	bytes_avail = buf_len;
	while (bytes_avail > 1) {
		if (assign_buffer == TRUE_m12) {
			if (bytes_avail < BUFFER_SIZE_INC) {
				buf_len += BUFFER_SIZE_INC;
				buffer = (si1 *) realloc_m12((void *) buffer, (size_t) buf_len, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
				bytes_avail += BUFFER_SIZE_INC;
			}
		}
		success = ReadFile(read_h, buffer + bytes_in_buffer, bytes_avail - 1, &n_bytes_read, NULL);  // leave room for terminal zero
		if (success == FALSE || n_bytes_read == 0)
			break;
		bytes_in_buffer += n_bytes_read;
		bytes_avail -= n_bytes_read;
	}
	buffer[bytes_in_buffer] = 0;  // set terminal zero
	CloseHandle(read_h);

	if (flags & SP_SEPERATE_STREAMS_m12) {
		bytes_in_e_buffer = 0;
		bytes_avail = *e_buf_len;
		while (bytes_avail > 1) {
			if (assign_e_buffer == TRUE_m12) {
				if (bytes_avail < BUFFER_SIZE_INC) {
					*e_buf_len += BUFFER_SIZE_INC;
					buffer = (si1 *) realloc_m12((void *) buffer, (size_t) *e_buf_len, __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
					bytes_avail += BUFFER_SIZE_INC;
				}
			}
			success = ReadFile(read_h, buffer + bytes_in_buffer, bytes_avail - 1, &n_bytes_read, NULL);  // leave room for terminal zero
			if (success == FALSE || n_bytes_read == 0)
				break;
			bytes_in_e_buffer += n_bytes_read;
			bytes_avail -= n_bytes_read;
		}
		buffer[bytes_in_e_buffer] = 0;  // set terminal zero
		CloseHandle(e_read_h);
	}

	free((void *) tmp_command);
	CloseHandle(process_info.hProcess);  // process handle
	CloseHandle(process_info.hThread);  // process' primary thread handle

	if (flags & SP_TEE_TO_TERMINAL_m12) {
		if (!(behavior & SUPPRESS_MESSAGE_OUTPUT_m12)) {
			printf_m12("%s[%s() tee]%s: %s%s%s\n%s\n", TC_GREEN_m12, __FUNCTION__, TC_RESET_m12, TC_BLUE_m12, command, TC_RESET_m12, buffer);
			if (flags & SP_SEPERATE_STREAMS_m12)
				printf_m12("%s\n", e_buffer);
		}
	}

	if (free_e_buffer == TRUE_m12) {
		free_m12((void *) e_buffer, __FUNCTION__);
		*e_buf_len = 0;
	}
	if (free_buffer == TRUE_m12) {
		free_m12((void *) buffer, __FUNCTION__);
		return(0);
	}
	
	if (assign_buffer == TRUE_m12)
		*buffer_ptr = buffer;
	if (assign_e_buffer == TRUE_m12)
		*e_buffer_ptr = e_buffer;
	
	if (flags & SP_SEPERATE_STREAMS_m12)
		*e_buf_len = bytes_in_e_buffer;  // return value for error buffer

	return(bytes_in_buffer);

SYSTEM_PIPE_FAIL_m12:
	
	// check process
	if (GetExitCodeProcess(process_info.hProcess, &exit_code))  // call to GetExitCodeProcess() succeeded, not the process itself
		err = (si4) exit_code;
	else
		err = errno_m12();

	if (tmp_command != NULL)
		free((void *) tmp_command);
	if (read_h != NULL)
		CloseHandle(read_h);
	if (process_info.hProcess != NULL)
		CloseHandle(process_info.hProcess);
	if (process_info.hThread != NULL)
		CloseHandle(process_info.hThread);

	if (behavior & RETRY_ONCE_m12) {
		if (retried == FALSE_m12) {
			G_nap_m12("1 ms");  // wait 1 ms
			retried = TRUE_m12;
			goto SYSTEM_PIPE_RETRY_m12;
		}
	}

	// try with system_m12() redirected to temp file
	si1	tmp_file[FULL_FILE_NAME_BYTES_m12], *e_tmp_file;
	FILE	*fp;
	
	if (flags & SP_SEPERATE_STREAMS_m12) {
		e_tmp_file = (si1 *) malloc_m12((size_t) FULL_FILE_NAME_BYTES_m12, __FUNCTION__, behavior);
		G_unique_temp_file_m12(e_tmp_file);
	} else {
		e_tmp_file = tmp_file;
	}
	
	len = strlen(command) + (2 * FULL_FILE_NAME_BYTES_m12) + 9;
	tmp_command = (si1 *) malloc((size_t) len);
	G_unique_temp_file_m12(tmp_file);
	sprintf_m12(tmp_command, "%s 1> %s 2> %s", command, tmp_file, e_tmp_file);
	err = system_m12(tmp_command, FALSE_m12, __FUNCTION__, SUPPRESS_OUTPUT_m12 | RETURN_ON_FAIL_m12);
	free((void *) tmp_command);
	fp = fopen_m12(tmp_file, "r", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
	bytes_in_buffer = G_file_length_m12(fp, NULL);
	if (assign_buffer == TRUE_m12) {
		if (bytes_in_buffer >= buf_len) {
			buf_len = bytes_in_buffer;
			buffer = (si1 *) realloc_m12((void *) buffer, (size_t) (bytes_in_buffer + 1), __FUNCTION__, __LINE__);  // allow for terminal zero
		}
	}
	fread((void *) buffer, sizeof(si1), (size_t) buf_len, fp);
	fclose(fp);
	buffer[buf_len] = 0;  // terminal zero
	G_remove_path_m12(tmp_file);  // delete temp file
		
	if (flags & SP_SEPERATE_STREAMS_m12) {
		fp = fopen_m12(e_tmp_file, "r", __FUNCTION__, USE_GLOBAL_BEHAVIOR_m12);
		free_m12((void *) e_tmp_file, __FUNCTION__);
		bytes_in_e_buffer = G_file_length_m12(fp, NULL);
		if (assign_e_buffer == TRUE_m12) {
			if (bytes_in_e_buffer >= *e_buf_len) {
				*e_buf_len = bytes_in_e_buffer;
				e_buffer = (si1 *) realloc_m12((void *) buffer, (size_t) (bytes_in_e_buffer + 1), __FUNCTION__, __LINE__);  // allow for terminal zero
			}
		}
		fread((void *) e_buffer, sizeof(si1), (size_t) *e_buf_len, fp);
		fclose(fp);
		e_buffer[*e_buf_len] = 0;  // terminal zero
		G_remove_path_m12(e_tmp_file);  // delete temp file
	}
	
	if (err) {
		err = (err < 0) ? -err : err;  // make positive for strerror() below
	} else {
		if (flags & SP_TEE_TO_TERMINAL_m12) {
			if (!(behavior & SUPPRESS_MESSAGE_OUTPUT_m12)) {
				printf_m12("%s[%s() tee]%s: %s%s%s\n%s\n", TC_GREEN_m12, __FUNCTION__, TC_RESET_m12, TC_BLUE_m12, command, TC_RESET_m12, buffer);
				if (flags & SP_SEPERATE_STREAMS_m12)
					printf_m12("%s\n", e_buffer);
			}
		}
		if (free_e_buffer == TRUE_m12) {
			free_m12((void *) e_buffer, __FUNCTION__);
			*e_buf_len = 0;
		}
		if (free_buffer == TRUE_m12) {
			free_m12((void *) buffer, __FUNCTION__);
			return(0);
		}
		if (assign_buffer == TRUE_m12)
			*buffer_ptr = buffer;
		if (assign_e_buffer == TRUE_m12)
			*e_buffer_ptr = e_buffer;

		return(bytes_in_buffer);
	}

	if (!(behavior & SUPPRESS_ERROR_OUTPUT_m12)) {
		fprintf_m12(stderr, "%c\n%s() failed\n", 7, __FUNCTION__);
		fprintf_m12(stderr, "\tcommand: \"%s\"\n", command);
		fprintf_m12(stderr, "\tsystem error number %d (%s)\n", err, strerror(err));
		if (flags & SP_TEE_TO_TERMINAL_m12) {
			if (flags & SP_SEPERATE_STREAMS_m12) {
				if (*buffer)
					printf_m12("\tstandard out: \"%s\"\n", buffer);
				if (*e_buffer)
					printf_m12("\n\tstandard error: \"%s\"\n", e_buffer);
			} else if (*buffer) {
					printf_m12("\tcaptured output: \"%s\"\n", buffer);
			}
		}
		if (function != NULL)
			fprintf_m12(stderr, "\tcalled from function %s()\n", function);
		if (behavior & EXIT_ON_FAIL_m12)
			fprintf_m12(stderr, "\t=> exiting\n\n");
		else
			fprintf_m12(stderr, "\t=> returning\n\n");
		fflush(stderr);
	}

	if (behavior & EXIT_ON_FAIL_m12)
		exit_m12(-1);
	
	if (free_buffer == TRUE_m12)
		free_m12((void *) buffer, __FUNCTION__);
	if (free_e_buffer == TRUE_m12) {
		free_m12((void *) e_buffer, __FUNCTION__);
		*e_buf_len = 0;
	}

	// make negative for return
	err = -err;
	
	return(err);
}
#endif  // WINDOWS_m12
		    

#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4	vasprintf_m12(si1 **target, si1 *fmt, va_list args)
{
	si4	ret_val;
	

#ifdef WINDOWS_m12  // no vasprintf() in Windows
	va_list		args_copy;
	
	*target = (si1 *) calloc((size_t) PRINTF_BUF_LEN_m12, sizeof(si1));
	va_copy(args_copy, args);  // save a copy before use in case need to realloc
	G_push_behavior_m12(RETURN_ON_FAIL_m12 | SUPPRESS_OUTPUT_m12);
	ret_val = vsnprintf_m12(*target, PRINTF_BUF_LEN_m12, fmt, args);
	G_pop_behavior_m12();
	
	// expand memory to required size
	*target = (si1 *) realloc((void *) *target, (size_t) (ret_val + 1));
	if (ret_val >= PRINTF_BUF_LEN_m12)
		ret_val = vsnprintf_m12(*target, ret_val + 1, fmt, args_copy);
#endif
	
#if defined MACOS_m12 || defined LINUX_m12
	ret_val = vasprintf(target, fmt, args);
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     vfprintf_m12(FILE *stream, si1 *fmt, va_list args)
{
	si1	*temp_str;
	si4	ret_val;
	
	
	ret_val = vasprintf_m12(&temp_str, fmt, args);
	
	if (ret_val >= 0) {
#ifdef MATLAB_m12
		if (stream == stderr || stream == stdout)
			ret_val = mexPrintf("%s", temp_str);
		else
#endif
		ret_val = fprintf(stream, "%s", temp_str);
		free((void *) temp_str);
	}
	

	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4     vprintf_m12(si1 *fmt, va_list args)
{
	si1	*temp_str;
	si4	ret_val;
	
	
	ret_val = vasprintf_m12(&temp_str, fmt, args);
	
	if (ret_val >= 0) {
#ifdef MATLAB_m12
		ret_val = mexPrintf("%s", temp_str);
#else
		ret_val = printf("%s", temp_str);
#endif
		free((void *) temp_str);
	}
	
	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4    vsnprintf_m12(si1 *target, si4 target_field_bytes, si1 *fmt, va_list args)
{
	si4	ret_val;
	si1	*temp_str;
	
	
	//******** vsnprintf_m12() CONTAINS THE WINDOWS FORMATTING FOR ALL MED PRINTF FUNCTIONS ********//
	
	// as opposed to standard vsnprintf(), vsnprintf_m12() allows source & target strings to overlap
	
	if (target_field_bytes <= 1) {
		if (target_field_bytes == 1) {
			*target = 0;
			return(0);
		}
		return(-1);
	}
	
#ifdef WINDOWS_m12
	TERN_m12	free_fmt = FALSE_m12;
	si1		*new_fmt;
	
	// convert format string
	new_fmt = WN_windify_format_string_m12(fmt);
	
	if (new_fmt != fmt) {
		fmt = new_fmt;
		free_fmt = TRUE_m12;
	}
#endif
	// guarantee zeros in unused bytes per MED requirements
	temp_str = (si1 *) calloc((size_t) target_field_bytes, sizeof(si1));
	ret_val = vsnprintf(temp_str, target_field_bytes, fmt, args);
	
	// Guarantee terminal zero on overflow (not done in Linux & Windows)
	if (ret_val >= target_field_bytes) {
		temp_str[target_field_bytes - 1] = 0;
		G_warning_message_m12("%s(): target string truncated\n", __FUNCTION__);
	}
	memcpy(target, temp_str, target_field_bytes);
	free((void *) temp_str);
	
#ifdef WINDOWS_m12
	// convert file system paths
	WN_windify_file_paths_m12(NULL, target);

	// clean up
	if (free_fmt == TRUE_m12)
		free((void *) new_fmt);
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m12  // inline causes linking problem in Windows
inline
#endif
si4    vsprintf_m12(si1 *target, si1 *fmt, va_list args)
{
	si1		*tmp_str;
	si4		ret_val;
	
	
	// as opposed to standard vsprintf(), vsprintf_m12() allows source & target strings to overlap
	
	ret_val = vasprintf_m12(&tmp_str, fmt, args);
	
	memcpy(target, tmp_str, ret_val + 1);
	free((void *) tmp_str);

	return(ret_val);
}

