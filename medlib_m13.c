
//**********************************************************************************//
//*******************************  MED 1.1.3 C Library  ****************************//
//**********************************************************************************//


// Multiscale Electrophysiology Data (MED) Format Software Library, Version 1.1.3
// Written by Matt Stead


// LICENSE & COPYRIGHT:

// MED library source code (medlib) is copyrighted by Dark Horse Neuro Inc, 2021

// Medlib is free software:
// You can redistribute it and/or modify it under the terms of the Gnu General Public License (Gnu GPL),
// version 2, or any later version (as published by the Free Software Foundation).
// The Gnu GPL requires that any object code built and distributed using this software
// is accompanied by the FULL SOURCE CODE used to generate the object code.

// This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the Gnu GPL for more details.

// If you did not receive a copy of the Gnu GPL along with this code, you can find it on the GNU website ( http://www.gnu.org ).
// You may also obtain a copy by writing to the Free Software Foundation, Inc at:
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

// We kindly ask you to acknowledge medlib in any program or publication in which you use it, but you are not required to do so.

// Commercial versions of medlib may be licensed from Dark Horse Neuro Inc, Bozeman, MT, USA.
// Commercially licensed copies do not require object code using medlib to be accompanied by the corresponding full source code.
// Users interested in a commercial license may contact us through the medformat website ( http://www.medformat.org ).


// ACKNOWLEDGEMENTS:

// MED derives from the Multiscale Electrophysiology Format (MEF), versions 1-3.
// Many people contributed to the MEF effort, but special mention is owed to
// Greg Worrell, Casey Stengel, Andy Gardner, Mark Bower, Vince Vasoli, Ben Brinkmann,
// Dan Crepeau, Jan Cimb√°lnik, Jon Lange, and Jon Halford for their contributions
// in design, coding, testing, implementation, and adoption.

// The encryption / decryption algorithm is the 128-bit AES standard ( http://www.csrc.nist.gov/publications/fips/fips197/fips-197.pdf ).
// AES routines (128 bit only) are included in the library, with attribution, for convenience.

// The hash algorithm is the SHA-256 standard ( http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf ).
// Basic SHA-256 routines are included in the library, with attribution, for convenience.

// Strings are encoded in the Universal Character Set standard, ISO/IEC 10646:2012 otherwise known as UTF-8.
// ( http://standards.iso.org/ittf/PubliclyAvailableStandards/c056921_ISO_IEC_10646_2012.zip )
// Minimal UTF-8 manipulation routines are included in the library, for convenience.

// Error detection is implemented with 32-bit cyclic redundancy checksums (CRCs).
// Basic CRC-32 manipulation routines are included in the library, with attribution, for convenience.


// USAGE:

// The library is optimized for 64-bit operating systems on 64-bit processors with 64-bit words and addressing.
// However, it can be used with in 32-bit contexts without modification at a performance cost.

// The library is written with tab width = indent width = 8 spaces and a monospaced font.
// Tabs are tabs characters, not spaces.
// Set your editor preferences to these for intended alignment.

// The library utilizes some non-standard structures:
// 	required compiler option (gcc, clang): -fms-extensions
// 	suppress warnings with: -Wno-microsoft-anon-tag


// VERSIONING:

// All functions, constants, macros, and data types defined in the library are tagged
// with the suffix "_mFL" (for "MED major format 'F', library 'L'").

// MED_FORMAT_VERSION_MAJOR is restricted to single digits 1 through 9
// MED_FORMAT_VERSION_MINOR is restricted to 0 through 254, minor version resets to zero with new major format version
// MED_LIBRARY_VERSION is restricted to 1 through 255, library version resets to one with new major format version

// MED_FULL_FORMAT_NAME == "<MED_VERSION_MAJOR>.<MED_VERSION_MINOR>"
// MED_FULL_LIBRARY_NAME == "<MED_FULL_FORMAT_NAME>.<MED_LIBRARY_VERSION>"
// MED_LIBRARY_TAG == "<MED_VERSION_MAJOR>.<MED_LIBRARY_VERSION>"

// Tag Examples:
// "_m13" indicates "MED format major version 1, library version 3"
// "_m21" indicates "MED format major version 2, library version 1" (for MED 2)
// "_m213" indicates "MED format major version 2, library version 13" (for MED 2)

// All library versions associated with a particular major format version are guaranteed to work on MED files of that major version.
// Minor format versions may add fields to the format in protected regions, but no preexisting fields will be removed or moved.
// Only library versions released on or afer a minor version will make use of new fields, and only if the minor version of the files contains them.
// Backward compatibility will be maintained between major versions if practical.


#include "medlib_m13.h"

// Globals (variable name tagged in case using with other versions of the library)
#ifdef MATLAB_m13
// "static" qualifier necessary for Matlab to maintain values between mex calls
// limits scope to current file - prevents linking across compiled libraries
static GLOBALS_m13	*globals_m13 = NULL;
#else
GLOBALS_m13		*globals_m13 = NULL;
#endif


//*********************************//
// MARK: GENERAL MED FUNCTIONS  (G)
//*********************************//


CHAN_m13	*G_active_channel_m13(SESS_m13 *sess, si1 chan_type)
{
	si4		i, n_chans;
	CHAN_m13	*chan;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// check time series channels
	if (chan_type == DEFAULT_CHAN_m13 || chan_type == DEFAULT_TS_CHAN_m13) {
		n_chans = sess->n_ts_chans;
		for (i = 0; i < n_chans; ++i) {
			chan = sess->ts_chans[i];
			if (chan->flags & LH_CHAN_ACTIVE_m13)
				return_m13(chan);
		}
	}

	// check video channels
	if (chan_type == DEFAULT_CHAN_m13 || chan_type == DEFAULT_VID_CHAN_m13) {
		n_chans = sess->n_vid_chans;
		for (i = 0; i < n_chans; ++i) {
			chan = sess->vid_chans[i];
			if (chan->flags & LH_CHAN_ACTIVE_m13)
				return_m13(chan);
		}
	}
	
	G_set_error_m13(E_UNKN_m13, "no active channels");
	
	return_m13(NULL);
}


ui4 	G_add_level_extension_m13(si1 *directory_name)
{
	tern	from_root;
	si1	full_path[PATH_BYTES_m13], enclosing_dir[PATH_BYTES_m13];
	si1	base_name[SEG_NAME_BYTES_m13], *extension;
	ui4	type_code;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// returns type code of existing level
	// appends extension to passed directory_name (enough space assumed to be available)

	from_root = G_full_path_m13(directory_name, full_path);  // returns T/F on whether full_path path wsa from root
	G_path_parts_m13(full_path, enclosing_dir, base_name, NULL);
		
	// try session
	extension = SESS_TYPE_STR_m13;
	sprintf_m13(full_path, "%s/%s.%s", enclosing_dir, base_name, extension);
	if (G_exists_m13(full_path) == DIR_EXISTS_m13) {
		type_code = SESS_TYPE_CODE_m13;
		goto ADD_LEVEL_EXTENSION_MATCH_m13;
	}

	// try time series channel
	extension = TS_CHAN_TYPE_STR_m13;
	sprintf_m13(full_path, "%s/%s.%s", enclosing_dir, base_name, extension);
	if (G_exists_m13(full_path) == DIR_EXISTS_m13) {
		type_code = TS_CHAN_TYPE_CODE_m13;
		goto ADD_LEVEL_EXTENSION_MATCH_m13;
	}

	// try video series channel
	extension = VID_CHAN_TYPE_STR_m13;
	sprintf_m13(full_path, "%s/%s.%s", enclosing_dir, base_name, extension);
	if (G_exists_m13(full_path) == DIR_EXISTS_m13) {
		type_code = VID_CHAN_TYPE_CODE_m13;
		goto ADD_LEVEL_EXTENSION_MATCH_m13;
	}

	// try time series segment
	extension = TS_SEG_TYPE_STR_m13;
	sprintf_m13(full_path, "%s/%s.%s", enclosing_dir, base_name, extension);
	if (G_exists_m13(full_path) == DIR_EXISTS_m13) {
		type_code = TS_SEG_TYPE_CODE_m13;
		goto ADD_LEVEL_EXTENSION_MATCH_m13;
	}

	// try video series segment
	extension = VID_SEG_TYPE_STR_m13;
	sprintf_m13(full_path, "%s/%s.%s", enclosing_dir, base_name, extension);
	if (G_exists_m13(full_path) == DIR_EXISTS_m13) {
		type_code = VID_SEG_TYPE_CODE_m13;
		goto ADD_LEVEL_EXTENSION_MATCH_m13;
	}

	// try segmented session records
	extension = SSR_TYPE_STR_m13;
	sprintf_m13(full_path, "%s/%s.%s", enclosing_dir, base_name, extension);
	if (G_exists_m13(full_path) == DIR_EXISTS_m13) {
		type_code = SSR_TYPE_CODE_m13;
		goto ADD_LEVEL_EXTENSION_MATCH_m13;
	}

	return_m13(NO_TYPE_CODE_m13);
	
ADD_LEVEL_EXTENSION_MATCH_m13:
	
	// attempt to append extension (may cause seg fault or memory corruption)
	if (from_root == TRUE_m13)
		sprintf_m13(directory_name, "%s/%s.%s", enclosing_dir, base_name, extension);
	else
		sprintf_m13(directory_name, "%s.%s", base_name, extension);
	
	return_m13(type_code);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_add_behavior_exec_m13(const si1 *function, si4 line, ui4 code)
{
	si4			n_behaviors;
	BEHAVIOR_m13		*behavior, *new_behaviors;
	BEHAVIOR_STACK_m13	*stack;
	

	// ORs to current behavior & pushes to stack as new entry
	
	stack = G_behavior_stack_m13();
	if (stack == NULL)
		return;
	
	// expand stack
	n_behaviors = stack->top_idx + 1;
	if (n_behaviors == stack->size) {
		n_behaviors += GLOBALS_BEHAVIOR_STACK_SIZE_INCREMENT_m13;
		new_behaviors = (BEHAVIOR_m13 *) realloc((void *) stack->behaviors, (size_t) n_behaviors * sizeof(BEHAVIOR_m13));
		if (new_behaviors == NULL) {
			G_set_error_m13(E_ALLOC_m13, NULL);
			return;
		}
		stack->behaviors = new_behaviors;
		stack->size = n_behaviors;
	}
	
	behavior = stack->behaviors + (++stack->top_idx);
	behavior->function = function;
	behavior->line = line;
	if (stack->top_idx)
		behavior->code = (behavior - 1)->code | code;
	else
		behavior->code = globals_m13->behavior_stack_list->default_behavior | code;

	return;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	G_all_zeros_m13(ui1 *bytes, si4 field_length)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	while (field_length--)
		if (*bytes++)
			return_m13(FALSE_m13);
	
	return_m13(TRUE_m13);
}


CHAN_m13	*G_alloc_channel_m13(CHAN_m13 *chan, FPS_m13 *proto_fps, si1 *path, LH_m13  *parent, si4 n_segs, tern chan_recs, tern seg_recs)
{
	si1			*seg_type_str, tmp_str[PATH_BYTES_m13], num_str[FILE_NUMBERING_DIGITS_m13 + 1];
	ui4			type_code;
	si8			i;
	UH_m13	*uh;
	SEG_m13		*seg;
	PROC_GLOBS_m13	*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// path is path to the channel, including channel directory itself
	// if records are requested, enough memory for 1 record of size REC_LARGEST_RECORD_BYTES_m13 is allocated (FPS_reallocate_m13() to change this)
	// if records are requested, enough memory for 1 record index is allocated (FPS_reallocate_m13() to change this)
	// pass NULL for parent if processing channel independently
	
	// allocate channel
	if (chan == NULL) {
		if (STR_empty_m13(path) == TRUE_m13) {
			G_set_error_m13(E_UNKN_m13, "channel or path must be passed");
			return_m13(NULL);
		}
		chan = (CHAN_m13 *) calloc_m13((size_t) 1, sizeof(CHAN_m13));
		if (chan == NULL)
			return_m13(NULL);
		type_code = G_MED_path_components_m13(path, chan->path, chan->name);
		chan->path = chan->local_path;
		chan->name = chan->local_name;
	} else if (STR_empty_m13(path) == FALSE_m13) {  // passed path supesedes chan->path/name
		type_code = G_MED_path_components_m13(path, chan->path, chan->name);
	} else {
		type_code = G_MED_type_code_from_string_m13(chan->path);
	}
	
	// set level header type codes
	switch (type_code) {
		case TS_CHAN_TYPE_m13:
			chan->type_code = TS_CHAN_TYPE_CODE_m13;
			seg_type_str = TS_SEG_TYPE_STR_m13;
			break;
		case VID_CHAN_TYPE_m13:
			chan->type_code = VID_CHAN_TYPE_CODE_m13;
			seg_type_str = VID_SEG_TYPE_STR_m13;
			break;
		default:
			G_set_error_m13(E_MED_m13, "unrecognized channel type code \"0x%08x\"", type_code);
			return_m13(NULL);
	}
	
	// set parent
	chan->parent = parent;
	proc_globs = G_proc_globs_m13((LH_m13 *) chan);
	proc_globs->current_session.n_mapped_segments = n_segs;
	
	// make new prototype fps (don't modify original)
	if (proto_fps)
		proto_fps = FPS_clone_m13(proto_fps, chan->path, FPS_PROTOTYPE_BYTES_m13, 0, parent);
	else
		proto_fps = FPS_init_m13(NULL, chan->path, NULL, FPS_PROTOTYPE_BYTES_m13, parent);
	if (proto_fps == NULL) {
		G_free_channel_m13(&chan);
		return_m13(NULL);
	}
	
	uh = proto_fps->uh;
	if (uh->channel_UID == UID_NO_ENTRY_m13)
		G_generate_UID_m13(&uh->channel_UID);
	uh->segment_number = UH_CHANNEL_LEVEL_CODE_m13;
	strncpy_m13(uh->channel_name, chan->name, NAME_BYTES_m13);

	// allocate channel records
	if (chan_recs == TRUE_m13) {
		// indices
		sprintf_m13(tmp_str, "%s/%s.%s", chan->path, chan->name, REC_INDS_TYPE_CODE_m13);
		chan->rec_inds_fps = FPS_clone_m13(proto_fps, tmp_str, INDEX_BYTES_m13, 0, (LH_m13 *) chan);
		if (chan->rec_inds_fps == NULL) {
			G_free_channel_m13(&chan);
			FPS_free_m13(&proto_fps);
			return_m13(NULL);
		}
		
		// data
		sprintf_m13(tmp_str, "%s/%s.%s", chan->path, chan->name, REC_DATA_TYPE_CODE_m13);
		chan->rec_data_fps = FPS_clone_m13(proto_fps, tmp_str, REC_LARGEST_RECORD_BYTES_m13, 0, (LH_m13 *) chan);
		if (chan->rec_data_fps == NULL) {
			G_free_channel_m13(&chan);
			FPS_free_m13(&proto_fps);
			return_m13(NULL);
		}
	} else {
		chan->rec_inds_fps = chan->rec_data_fps = NULL;
	}

	// allocate segments
	if (n_segs) {
		chan->segs = (SEG_m13 **) calloc_2D_m13((size_t) n_segs, 1, -sizeof(SEG_m13));
		if (chan->segs == NULL) {
			G_free_channel_m13(&chan);
			FPS_free_m13(&proto_fps);
			return_m13(NULL);
		}
		for (i = 0; i < n_segs; ++i) {
			seg = chan->segs[i];
			STR_fixed_width_int_m13(num_str, FILE_NUMBERING_DIGITS_m13, i + 1);
			sprintf_m13(tmp_str, "%s/%s_s%s.%s", chan->path, chan->name, num_str, seg_type_str);
			seg = G_alloc_segment_m13(seg, proto_fps, tmp_str, (LH_m13 *) chan, (si4) i + 1, seg_recs);
			if (seg == NULL) {
				G_free_channel_m13(&chan);
				FPS_free_m13(&proto_fps);
				return_m13(NULL);
			}
		}
	}

	// clean up
	FPS_free_m13(&proto_fps);
	
	return_m13(chan);
}


SEG_m13	*G_alloc_segment_m13(SEG_m13 *seg, FPS_m13 *proto_fps, si1 *path, LH_m13  *parent, si4 seg_num, tern seg_recs)
{
	si1 tmp_str[PATH_BYTES_m13];
	ui4			type_code;
	UH_m13	*uh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// path is the path to the segment including segment directory itself
	// if time series channels are requested, the CPS_m13 structures will be allocated with no block memory.
	// enough memory for one time series or video index is allocated in data indices files (FPS_realloc_m13() to change this)
	// if records are requested, enough memory for 1 record of size REC_LARGEST_RECORD_BYTES_m13 is allocated (use FPS_reallocate_m13() to change this)
	// if records are requested, enough memory for 1 record index is allocated (FPS_realloc_m13() to change this)
	// pass NULL for parent if processing independently

	// allocate segment
	if (seg == NULL) {
		if (STR_empty_m13(path) == TRUE_m13) {
			G_set_error_m13(E_UNKN_m13, "segment or path must be passed");
			return_m13(NULL);
		}
		seg = (SEG_m13 *) calloc_m13((size_t) 1, sizeof(SEG_m13));
		if (seg == NULL)
			return_m13(NULL);
		seg->path = seg->local_path;
		seg->name = seg->local_name;
		type_code = G_MED_path_components_m13(path, seg->path, seg->name);
	} else if (STR_empty_m13(path) == FALSE_m13) {  // passed path supesedes chan->path/name
		type_code = G_MED_path_components_m13(path, seg->path, seg->name);
	} else {
		type_code = G_MED_type_code_from_string_m13(seg->path);
	}
	seg->type_code = TS_SEG_TYPE_CODE_m13;
	
	// set parent
	seg->parent = parent;
	
	// make new prototype fps (don't modify original)
	if (proto_fps)
		proto_fps = FPS_clone_m13(proto_fps, seg->path, FPS_PROTOTYPE_BYTES_m13, 0, parent);
	else
		proto_fps = FPS_init_m13(NULL, seg->path, NULL, FPS_PROTOTYPE_BYTES_m13, parent);
	if (proto_fps == NULL) {
		G_free_segment_m13(&seg);
		return_m13(NULL);
	}
	uh = seg->metadata_fps->uh;
	if (uh->segment_UID == UID_NO_ENTRY_m13)
		G_generate_UID_m13(&uh->segment_UID);
	uh->segment_number = seg_num;

	// allocate metadata, data, & indices
	switch (type_code) {
		case TS_CHAN_TYPE_m13:
			seg->type_code = TS_SEG_TYPE_CODE_m13;

			// time series metadata
			sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, TS_METADATA_TYPE_CODE_m13);
			seg->metadata_fps = FPS_clone_m13(proto_fps, tmp_str, METADATA_BYTES_m13, 0, (LH_m13 *) seg);
			if (seg->metadata_fps == NULL) {
				G_free_segment_m13(&seg);
				FPS_free_m13(&proto_fps);
				return_m13(NULL);
			}
			
			// time series indices
			sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, TS_INDS_TYPE_CODE_m13);
			seg->ts_inds_fps = FPS_clone_m13(proto_fps, tmp_str, INDEX_BYTES_m13, 0, (LH_m13 *) seg);
			if (seg->ts_inds_fps == NULL) {
				G_free_segment_m13(&seg);
				FPS_free_m13(&proto_fps);
				return_m13(NULL);
			}

			// time series data
			sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, TS_DATA_TYPE_CODE_m13);
			seg->ts_data_fps = FPS_clone_m13(proto_fps, tmp_str, 0, 0, (LH_m13 *) seg);
			if (seg->ts_inds_fps == NULL) {
				G_free_segment_m13(&seg);
				FPS_free_m13(&proto_fps);
				return_m13(NULL);
			}
			seg->ts_data_fps->params.cps = (CPS_m13 *) calloc_m13((size_t) 1, sizeof(CPS_m13));  // time series data CPS
			break;
		case VID_CHAN_TYPE_m13:
			seg->type_code = VID_SEG_TYPE_CODE_m13;
			
			// video metadata
			sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, VID_METADATA_TYPE_CODE_m13);
			seg->metadata_fps = FPS_clone_m13(proto_fps, tmp_str, METADATA_BYTES_m13, 0, (LH_m13 *) seg);
			if (seg->metadata_fps == NULL) {
				G_free_segment_m13(&seg);
				FPS_free_m13(&proto_fps);
				return_m13(NULL);
			}
			
			// video indices
			sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, VID_INDS_TYPE_CODE_m13);
			seg->vid_inds_fps = FPS_clone_m13(proto_fps, tmp_str, INDEX_BYTES_m13, 0, (LH_m13 *) seg);
			if (seg->ts_inds_fps == NULL) {
				G_free_segment_m13(&seg);
				FPS_free_m13(&proto_fps);
				return_m13(NULL);
			}
			break;
		default:
			G_set_error_m13(E_MED_m13, "unrecognized channel type code \"0x%08x\"", type_code);
			return_m13(NULL);
	}
	
	// allocate segment records
	if (seg_recs == TRUE_m13) {
		// indices
		sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, REC_INDS_TYPE_CODE_m13);
		seg->rec_inds_fps = FPS_clone_m13(proto_fps, tmp_str, INDEX_BYTES_m13, 0, (LH_m13 *) seg);
		if (seg->rec_inds_fps == NULL) {
			G_free_segment_m13(&seg);
			FPS_free_m13(&proto_fps);
			return_m13(NULL);
		}
		
		// data
		sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, REC_DATA_TYPE_CODE_m13);
		seg->rec_data_fps = FPS_clone_m13(proto_fps, tmp_str, REC_LARGEST_RECORD_BYTES_m13, 0, (LH_m13 *) seg);
		if (seg->rec_data_fps == NULL) {
			G_free_segment_m13(&seg);
			FPS_free_m13(&proto_fps);
			return_m13(NULL);
		}
	} else {
		seg->rec_data_fps = seg->rec_inds_fps = NULL;
	}

	// clean up
	FPS_free_m13(&proto_fps);

	return_m13(seg);
}


SESS_m13	*G_alloc_session_m13(FPS_m13 *proto_fps, si1 *path, si4 n_ts_chans, si4 n_vid_chans, si4 n_segs, si1 **ts_chan_names, si1 **vid_chan_names, tern sess_recs, tern seg_sess_recs, tern chan_recs, tern seg_recs)
{
	si1		free_names, tmp_str[PATH_BYTES_m13], number_str[FILE_NUMBERING_DIGITS_m13 + 1];
	si8		i;
	SESS_m13	*sess;
	UH_m13		*uh;
	FPS_m13		*gen_fps;
	SSR_m13		*ssr;
	CHAN_m13	*chan;
	PROC_GLOBS_m13	*proc_globs;

	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// path is the path to the session directory
	// if records are requested, enough memory for 1 record of data size REC_LARGEST_RECORD_BYTES_m13 is allocated (FPS_reallocate_m13() to change this)
	// if records are requested, enough memory for 1 record index is allocated (FPS_reallocate_m13() to change this)
	
	// allocate session
	if (STR_empty_m13(path) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "path must be passed");
		return_m13(NULL);
	}
	sess = (SESS_m13 *) calloc_m13((size_t) 1, sizeof(SESS_m13));
	if (sess == NULL)
		return_m13(NULL);
	proc_globs = G_proc_globs_m13((LH_m13 *) sess);
	proc_globs->current_session.n_mapped_segments = n_segs;
	sess->parent = (LH_m13 *) proc_globs;
	sess->path = proc_globs->current_session.directory;
	sess->name = proc_globs->current_session.fs_name;
	G_path_parts_m13(path, sess->path, sess->name, NULL);
	strcpy(proc_globs->current_session.uh_name, sess->name);  // alloc for writing, so fs & uh names should be the same
	proc_globs->current_session.n_mapped_segments = n_segs;
	sess->type_code = SESS_TYPE_CODE_m13;
	sess->n_ts_chans = n_ts_chans;
	sess->n_vid_chans = n_vid_chans;
	
	// make new prototype fps (don't modify original)
	if (proto_fps)
		proto_fps = FPS_clone_m13(proto_fps, sess->path, FPS_PROTOTYPE_BYTES_m13, 0, sess->parent);
	else
		proto_fps = FPS_init_m13(NULL, sess->path, NULL, FPS_PROTOTYPE_BYTES_m13, sess->parent);
	if (proto_fps == NULL) {
		G_free_session_m13(&sess);
		return_m13(NULL);
	}
	
	uh = proto_fps->uh;
	if (uh->session_UID == UID_NO_ENTRY_m13)
		G_generate_UID_m13(&uh->session_UID);
	uh->segment_number = UH_SESSION_LEVEL_CODE_m13;
	strncpy_m13(uh->session_name, sess->name, NAME_BYTES_m13);
		
	// allocate channels
	if (n_ts_chans) {
		free_names = FALSE_m13;
		if (ts_chan_names == NULL) {
			ts_chan_names = G_generate_numbered_names_m13(NULL, "tch_", n_ts_chans);
			if (ts_chan_names == NULL) {
				G_free_session_m13(&sess);
				FPS_free_m13(&proto_fps);
				return_m13(NULL);
			}
			free_names = TRUE_m13;
		}
		sess->ts_chans = (CHAN_m13 **) calloc_2D_m13((size_t) n_ts_chans, 1, -sizeof(CHAN_m13));
		if (sess->ts_chans == NULL) {
			G_free_session_m13(&sess);
			FPS_free_m13(&proto_fps);
			if (free_names == TRUE_m13)
				free_m13((void *) ts_chan_names);
			return_m13(NULL);
		}
		for (i = 0; i < n_ts_chans; ++i) {
			chan = sess->ts_chans[i];
			sprintf_m13(tmp_str, "%s/%s.%s", sess->path, ts_chan_names[i], TS_CHAN_TYPE_CODE_m13);
			chan = G_alloc_channel_m13(chan, proto_fps, tmp_str, (LH_m13 *) sess, n_segs, chan_recs, seg_recs);
			if (chan == NULL) {
				G_free_session_m13(&sess);
				FPS_free_m13(&proto_fps);
				if (free_names == TRUE_m13)
					free_m13((void *) ts_chan_names);
				return_m13(NULL);
			}
		}
		if (free_names == TRUE_m13)
			free_m13((void *) ts_chan_names);
	}
	
	if (n_vid_chans) {
		free_names = FALSE_m13;
		if (vid_chan_names == NULL) {
			vid_chan_names = G_generate_numbered_names_m13(NULL, "vch_", n_vid_chans);
			if (vid_chan_names == NULL) {
				G_free_session_m13(&sess);
				FPS_free_m13(&proto_fps);
				return_m13(NULL);
			}
			free_names = TRUE_m13;
		}
		sess->vid_chans = (CHAN_m13 **) calloc_2D_m13((size_t) n_vid_chans, 1, -sizeof(CHAN_m13));
		if (sess->ts_chans == NULL) {
			G_free_session_m13(&sess);
			FPS_free_m13(&proto_fps);
			if (free_names == TRUE_m13)
				free_m13((void *) vid_chan_names);
			return_m13(NULL);
		}
		for (i = 0; i < n_vid_chans; ++i) {
			chan = sess->vid_chans[i];
			sprintf_m13(tmp_str, "%s/%s.%s", sess->path, ts_chan_names[i], VID_CHAN_TYPE_CODE_m13);
			chan = G_alloc_channel_m13(chan, proto_fps, tmp_str, (LH_m13 *) sess, n_segs, chan_recs, seg_recs);
			if (chan == NULL) {
				G_free_session_m13(&sess);
				FPS_free_m13(&proto_fps);
				if (free_names == TRUE_m13)
					free_m13((void *) vid_chan_names);
				return_m13(NULL);
			}
		}
		if (free_names == TRUE_m13)
			free((void *) vid_chan_names);
	}

	// allocate session records
	if (sess_recs == TRUE_m13) {
		// indices
		sprintf_m13(tmp_str, "%s/%s.%s", sess->path, sess->name, REC_INDS_TYPE_CODE_m13);
		chan->rec_inds_fps = FPS_clone_m13(proto_fps, tmp_str, INDEX_BYTES_m13, 0, (LH_m13 *) sess);
		if (chan->rec_inds_fps == NULL) {
			G_free_session_m13(&sess);
			FPS_free_m13(&proto_fps);
			return_m13(NULL);
		}
		
		// data
		sprintf_m13(tmp_str, "%s/%s.%s", sess->path, sess->name, REC_DATA_TYPE_CODE_m13);
		chan->rec_data_fps = FPS_clone_m13(proto_fps, tmp_str, REC_LARGEST_RECORD_BYTES_m13, 0, (LH_m13 *) sess);
		if (chan->rec_data_fps == NULL) {
			G_free_session_m13(&sess);
			FPS_free_m13(&proto_fps);
			return_m13(NULL);
		}
	}
		
	// allocate segmented session records
	if (seg_sess_recs == TRUE_m13) {
		ssr = sess->ssr = (SSR_m13 *) calloc_m13((size_t) 1, -sizeof(SSR_m13));
		if (ssr == NULL) {
			G_free_session_m13(&sess);
			FPS_free_m13(&proto_fps);
			return_m13(NULL);
		}
		ssr->path = ssr->local_path;
		sprintf_m13(ssr->path, "%s/%s.%s", sess->path, sess->name, SSR_TYPE_STR_m13);
		ssr->name = sess->name;
		ssr->type_code = SSR_TYPE_CODE_m13;
		ssr->flags = sess->flags;
		ssr->parent = (LH_m13 *) sess;

		// record indices fps array
		ssr->rec_inds_fps = (FPS_m13 **) calloc_2D_m13((size_t) n_segs, 1, -sizeof(FPS_m13));
		if (ssr->rec_inds_fps == NULL) {
			G_free_session_m13(&sess);
			FPS_free_m13(&proto_fps);
			return_m13(NULL);
		}
		
		// record data fps array
		ssr->rec_data_fps = (FPS_m13 **) calloc_2D_m13((size_t) n_segs, 1, -sizeof(FPS_m13));
		if (ssr->rec_data_fps == NULL) {
			G_free_session_m13(&sess);
			FPS_free_m13(&proto_fps);
			return_m13(NULL);
		}
		
		// finished with this prototype
		FPS_free_m13(&proto_fps);
		
		for (i = 0; i < n_segs; ++i) {
			// get a segment prototype
			if (n_ts_chans)
				proto_fps = sess->ts_chans[0]->segs[i]->metadata_fps;
			else if (n_vid_chans)
				proto_fps = sess->vid_chans[0]->segs[i]->metadata_fps;
			
			// record indices fps
			STR_fixed_width_int_m13(number_str, FILE_NUMBERING_DIGITS_m13, (si4) i + 1); // segments numbered from 1
			sprintf_m13(ssr->rec_inds_fps[i]->path, "%s/%s_s%s.%s", ssr->path, ssr->name, number_str, REC_INDS_TYPE_STR_m13);
			gen_fps = FPS_clone_m13(proto_fps, ssr->rec_inds_fps[i]->path, INDEX_BYTES_m13, 0, (LH_m13 *) ssr);
			if (gen_fps == NULL) {
				G_free_session_m13(&sess);
				return_m13(NULL);
			}
			uh = gen_fps->uh;
			memset((void *) uh->channel_name, 0, NAME_BYTES_m13);
			uh->channel_UID = UID_NO_ENTRY_m13;
			
			// record data fps
			sprintf_m13(ssr->rec_data_fps[i]->path, "%s/%s_s%s.%s", ssr->path, ssr->name, number_str, REC_DATA_TYPE_STR_m13);
			gen_fps = FPS_clone_m13(proto_fps, ssr->rec_data_fps[i]->path, REC_LARGEST_RECORD_BYTES_m13, 0, (LH_m13 *) ssr);
			if (gen_fps == NULL) {
				G_free_session_m13(&sess);
				return_m13(NULL);
			}
			uh = gen_fps->uh;
			memset((void *) uh->channel_name, 0, NAME_BYTES_m13);
			uh->channel_UID = UID_NO_ENTRY_m13;
		}
	} else {
		sess->ssr = NULL;
	}

	return_m13(sess);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_apply_recording_time_offset_m13(si8 *time, si8 recording_time_offset)
{
	if (*time != UUTC_NO_ENTRY_m13)
		*time -= recording_time_offset;
	
	return;
}


si1 	*G_base_name_m13(LH_m13 *lh, const si1 *path, si1 *base_name)
{
	tern		free_base_name = FALSE_m13;
	si1		enc_dir[PATH_BYTES_m13];
	ui4		level_code;
	si8		len;
	EXT_CODE_m13	type = {0};
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// returns base name (session or channel name) without segment or video file number extentions
	
	if (STR_empty_m13(path) == TRUE_m13) {
		if (lh) {
			path = lh->path;
			if (STR_empty_m13(path) == TRUE_m13)
				return_m13(NULL);
		}
	}
	
	if (base_name == NULL) {  // caller takes ownership
		base_name = malloc_m13((size_t) MAX_NAME_BYTES_m13);
		free_base_name = TRUE_m13;
	}
	
	// get base name
	G_path_parts_m13(path, enc_dir, base_name, type.ext);
	switch (type.code) {
		case REC_INDS_TYPE_CODE_m13:
		case REC_DATA_TYPE_CODE_m13:
			level_code = G_MED_type_code_from_string_m13(enc_dir);
			switch(level_code) {
				case SESS_TYPE_CODE_m13:
				case TS_CHAN_TYPE_CODE_m13:
				case VID_CHAN_TYPE_CODE_m13:
					break;
				case SSR_TYPE_CODE_m13:
				case TS_SEG_TYPE_CODE_m13:
				case VID_SEG_TYPE_CODE_m13:
					len = strlen(base_name);
					*((base_name + len) - 6) = 0;
					break;
			}
			break;
		case SESS_TYPE_CODE_m13:
		case SSR_TYPE_CODE_m13:
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
			break;
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
		case TS_METADATA_TYPE_CODE_m13:
		case TS_DATA_TYPE_CODE_m13:
		case TS_INDS_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
			len = strlen(base_name);
			*((base_name + len) - 6) = 0;
			break;
		default:
			if (G_video_data_m13(path) == TRUE_m13) {
				len = strlen(base_name);
				if (len > 12) {
					*((base_name + len) - 12) = 0;
					break;
				}
			}
			if (free_base_name == TRUE_m13)
				free_m13((void *) base_name);
			G_set_error_m13(E_MED_m13, NULL);
			return_m13(NULL);
	}

	return_m13(base_name);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
BEHAVIOR_STACK_m13	*G_behavior_stack_m13(void)
{
	si4				i, n_stacks;
	pid_t_m13			_id;
	BEHAVIOR_STACK_LIST_m13		*list;
	BEHAVIOR_STACK_m13		**stack_ptr, *stack, *new_stack;


	// get mutex
	list = globals_m13->behavior_stack_list;
	pthread_mutex_lock_m13(&list->mutex);

	// find stack
	_id = gettid_m13();
	stack_ptr = list->stack_ptrs;
	n_stacks = list->top_idx + 1;
	stack = NULL;
	for (i = n_stacks; i--; ++stack_ptr) {
		if ((*stack_ptr)->_id == _id) {
			stack = *stack_ptr;
			break;
		}
		if (stack)
			continue;
		if ((*stack_ptr)->top_idx == -1)  // first open stack
			stack = *stack_ptr;
	}
	
	// stack not found
	if (i == -1) {
		// create a new stack
		if (stack == NULL) {
			// expand list
			if (list->size == n_stacks) {
				n_stacks += GLOBALS_BEHAVIOR_STACKS_LIST_SIZE_INCREMENT_m13;
				stack_ptr = (BEHAVIOR_STACK_m13 **) realloc((void *) list->stack_ptrs, (size_t) n_stacks * sizeof(BEHAVIOR_STACK_m13 *));
				if (stack_ptr == NULL) {  // return with no changes to stacks
					pthread_mutex_unlock_m13(&list->mutex);
					G_set_error_m13(E_ALLOC_m13, NULL);
					return(NULL);
				}

				list->stack_ptrs = stack_ptr;
				list->size = n_stacks;
				++list->top_idx;
				
				// allocate & initialize new stacks (note: stacks allocated en bloc)
				new_stack = (BEHAVIOR_STACK_m13 *) malloc((size_t) GLOBALS_BEHAVIOR_STACKS_LIST_SIZE_INCREMENT_m13 * sizeof(BEHAVIOR_STACK_m13));
				if (new_stack == NULL) {
					G_set_error_m13(E_ALLOC_m13, NULL);
					pthread_mutex_unlock_m13(&list->mutex);
					return(NULL);
				}
				stack_ptr = list->stack_ptrs + list->top_idx;  // list->top_idx == old size at this point
				for (i = GLOBALS_BEHAVIOR_STACKS_LIST_SIZE_INCREMENT_m13; i--; ++new_stack) {
					*stack_ptr++ = new_stack;  // assign stack pointer
					// initialize new stacks (behaviors allocated as needed)
					new_stack->top_idx = -1;
					new_stack->size = 0;
				}
			}
			stack = *(list->stack_ptrs + list->top_idx);
		}
	
		// set up stack
		stack->top_idx = -1;
		stack->_id = gettid_m13();
	}
		
	pthread_mutex_unlock_m13(&list->mutex);

	return(stack);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_behavior_stack_exec_reset_m13(const si1 *function, si4 line, ui4 code)
{
	BEHAVIOR_m13		*behavior;
	BEHAVIOR_STACK_m13	*stack;


	// reduces stack to one entry which is set to behavior
	// pass DEFAULT_BEHAVIOR_m13 to set to list default behavior
	
	stack = G_behavior_stack_m13();  // gets mutex
	if (stack == NULL)
		return;


	stack->top_idx = 0;
	behavior = stack->behaviors;
	behavior->function = function;
	behavior->line = line;
	if (code == DEFAULT_BEHAVIOR_m13)  // set to list default
		behavior->code = globals_m13->behavior_stack_list->default_behavior;
	else
		behavior->code = code;

	return;
}


si1	*G_behavior_string_m13(ui4 behavior, si1 *behavior_string)
{
	si8	len;
	

	if (behavior_string == NULL) {  // caller takes ownership
		behavior_string = malloc_m13(256);
		if (behavior_string == NULL)
			return(NULL);
	}
	*behavior_string = 0;
		
	if (behavior & RETURN_ON_FAIL_m13)
		strcat(behavior_string, "RETURN ON FAIL | ");
	else
		strcat(behavior_string, "EXIT ON FAIL | ");
	if (behavior & SUPPRESS_ERROR_OUTPUT_m13)
		strcat(behavior_string, "SUPPRESS ERROR OUTPUT | ");
	else
		strcat(behavior_string, "SHOW ERROR OUTPUT | ");
	if (behavior & SUPPRESS_WARNING_OUTPUT_m13)
		strcat(behavior_string, "SUPPRESS WARNING OUTPUT | ");
	else
		strcat(behavior_string, "SHOW WARNING OUTPUT | ");
	if (behavior & SUPPRESS_MESSAGE_OUTPUT_m13)
		strcat(behavior_string, "SUPPRESS MESSAGE OUTPUT | ");
	else
		strcat(behavior_string, "SHOW MESSAGE OUTPUT | ");
	if (behavior & RETRY_ONCE_m13)
		strcat(behavior_string, "RETRY ONCE | ");
	else
		strcat(behavior_string, "DO NOT RETRY | ");
	if (behavior & IGNORE_SYSTEM_ERRORS_m13)
		strcat(behavior_string, "IGNORE SYSTEM ERRORS | ");
	else
		strcat(behavior_string, "HEED SYSTEM ERRORS | ");

	len = strlen(behavior_string);
	if (len)
		behavior_string[len - 3] = 0;
		
	return(behavior_string);
}


si8	G_build_contigua_m13(LH_m13 *lh)
{
	tern				force_discont, null_sample_numbers;
	si1				tmp_str[PATH_BYTES_m13];
	ui4				type_code;
	si4				n_segs, seg_idx, search_mode;
	si8				i, j, k, n_contigua, start_idx, end_idx, last_block_samples, last_block_frames;
	si8				last_block_usecs, new_bytes, absolute_numbering_offset;
	si8				last_segment_end_sample_number, last_segment_end_frame_number, last_segment_end_time, last_segment_number;
	sf8				samp_freq, frame_rate;
	PROC_GLOBS_m13			*proc_globs;
	SEG_m13				*seg;
	CHAN_m13			*chan;
	SESS_m13			*sess;
	SLICE_m13			*slice;
	TS_METADATA_SECTION_2_m13	*tmd2;
	VID_METADATA_SECTION_2_m13	*vmd2;
	CONTIGUON_m13			*contigua, *contiguon;
	TS_IDX_m13			*tsi;
	VID_IDX_m13			*vi;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// find contigua in current time slice, and set in level

	if (lh == NULL) {
		G_set_error_m13(E_UNKN_m13, "level is not open");
		return_m13(FALSE_m13);
	}

	proc_globs = G_proc_globs_m13(lh);
	switch (lh->type_code) {
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
			seg = (SEG_m13 *) lh;
			if (seg == NULL) {
				G_set_error_m13(E_UNKN_m13, "segment is not open");
				return_m13(FALSE_m13);
			}
			slice = &seg->slice;
			chan = NULL;
			type_code = lh->type_code;
			break;
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
			chan = (CHAN_m13 *) lh;
			if (chan == NULL) {
				G_set_error_m13(E_UNKN_m13, "channel is not open");
				return_m13(FALSE_m13);
			}
			slice = &chan->slice;
			type_code = lh->type_code;
			break;
		case SESS_TYPE_CODE_m13:
			sess = (SESS_m13 *) lh;
			if (sess == NULL) {
				G_set_error_m13(E_UNKN_m13, "session is not open");
				return_m13(FALSE_m13);
			}
			chan = proc_globs->current_session.index_channel;
			slice = &sess->slice;
			type_code = chan->type_code;  // use ref channel type for session
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "invalid level type");
			return_m13(FALSE_m13);
	}
	
	seg_idx = G_segment_index_m13(slice->start_seg_num, lh);
	if (seg_idx == FALSE_m13)
		return_m13(FALSE_m13);
	n_segs = SLICE_SEG_COUNT_m13(slice);
	if ((search_mode = G_search_mode_m13(slice)) == FALSE_m13)
		return_m13(FALSE_m13);
	
	contigua = NULL;
	n_contigua = 0;
	force_discont = TRUE_m13;  // force_discont set to open new contiguon for initial index
	new_bytes = 0;
	if (type_code == TS_CHAN_TYPE_CODE_m13) {
		for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
			if (chan)  // segment level passed
				seg = chan->segs[j];
			if (seg == NULL) {  // segment missing
				force_discont = TRUE_m13;
				continue;
			}

			// get metadata
			if (seg->metadata_fps == NULL) {
				sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, TS_METADATA_TYPE_STR_m13);
				if (G_exists_m13(tmp_str) == FILE_EXISTS_m13) {
					seg->metadata_fps = FPS_read_m13(NULL, 0, FPS_FULL_FILE_m13, 1, NULL, tmp_str, "r", NULL, (LH_m13 *) seg);
					if (seg->metadata_fps == NULL)
						return_m13(FALSE_m13);
				} else {
					force_discont = TRUE_m13;
					continue;
				}
			}
			tmd2 = &seg->metadata_fps->metadata->time_series_section_2;
			samp_freq = tmd2->sampling_frequency;
			absolute_numbering_offset = tmd2->session_start_sample_number;

			// get indices
			if (seg->ts_inds_fps == NULL) {
				sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, TS_INDS_TYPE_STR_m13);
				if (G_exists_m13(tmp_str) == FILE_EXISTS_m13) {
					seg->ts_inds_fps = FPS_read_m13(NULL, 0, FPS_FULL_FILE_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) seg);
					if (seg->ts_inds_fps == NULL)
						return_m13(FALSE_m13);
				} else {
					force_discont = TRUE_m13;
					continue;
				}
			}

			// build contigua
			tsi = seg->ts_inds_fps->ts_inds;
			if (search_mode == TIME_SEARCH_m13) {
				start_idx = G_find_index_m13(seg, slice->start_time, TIME_SEARCH_m13 | NO_OVERFLOWS_m13);
				end_idx = G_find_index_m13(seg, slice->end_time, TIME_SEARCH_m13 | NO_OVERFLOWS_m13);
			} else {  // SAMPLE_SEARCH_m13
				start_idx = G_find_index_m13(seg, slice->start_samp_num - absolute_numbering_offset, SAMPLE_SEARCH_m13 | NO_OVERFLOWS_m13);
				end_idx = G_find_index_m13(seg, slice->end_samp_num - absolute_numbering_offset, SAMPLE_SEARCH_m13 | NO_OVERFLOWS_m13);
			}

			for (k = start_idx; k <= end_idx; ++k) {
				if (tsi[k].file_offset < 0 || force_discont == TRUE_m13) {
					// close last contiguon
					if (n_contigua) {
						contiguon = contigua + (n_contigua - 1);
						contiguon->end_seg_num = (si4) j + 1;
						if (k) {
							contiguon->end_samp_num = (tsi[k].start_samp_num + absolute_numbering_offset) - 1;
							last_block_samples = tsi[k].start_samp_num - tsi[k - 1].start_samp_num;
							last_block_usecs = (si8) round(((sf8) last_block_samples / samp_freq) * (sf8) 1e6);
							contiguon->end_time = (tsi[k - 1].start_time + last_block_usecs) - 1;
						} else {  // discontinuity on segment transition
							contiguon->end_samp_num = last_segment_end_sample_number;
							contiguon->end_time = last_segment_end_time;
							contiguon->end_seg_num = (si4) last_segment_number;
						}
					}
					// open new contiguon
					new_bytes += sizeof(CONTIGUON_m13);
					contigua = (CONTIGUON_m13 *) realloc_m13((void *) contigua, new_bytes);
					contiguon = contigua + n_contigua++;
					contiguon->start_samp_num = tsi[k].start_samp_num + absolute_numbering_offset;
					contiguon->start_time = tsi[k].start_time;
					contiguon->start_seg_num = (si4) j + 1;

					force_discont = FALSE_m13;
				}
			}
			last_segment_end_sample_number = (tsi[k].start_samp_num + absolute_numbering_offset) - 1;
			last_segment_end_time = tsi[k].start_time - 1;
			last_segment_number = j + 1;
		}
		
		// close final contiguon
		contiguon->end_samp_num = (tsi[k].start_samp_num + absolute_numbering_offset) - 1;
		last_block_samples = tsi[k].start_samp_num - tsi[k - 1].start_samp_num;
		last_block_usecs = (si8) round(((sf8) last_block_samples / samp_freq) * (sf8) 1e6);
		contiguon->end_time = (tsi[k - 1].start_time + last_block_usecs) - 1;
		contiguon->end_seg_num = (si4) last_segment_number;
	} else {  // VID_CHAN_TYPE_CODE_m13
		for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
			if (chan)  // segment level passed
				seg = chan->segs[j];
			if (seg == NULL) {  // segment missing
				force_discont = TRUE_m13;
				continue;
			}
			// get metadata
			if (seg->metadata_fps == NULL) {
				sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, VID_METADATA_TYPE_STR_m13);
				if (G_exists_m13(tmp_str) == FILE_EXISTS_m13) {
					seg->metadata_fps = FPS_read_m13(NULL, 0, FPS_FULL_FILE_m13, 1, NULL, tmp_str, NULL, "r", (LH_m13 *) seg);
					if (seg->metadata_fps == NULL)
						return_m13(FALSE_m13);
				} else {
					force_discont = TRUE_m13;
					continue;
				}
			}
			vmd2 = &seg->metadata_fps->metadata->video_section_2;
			frame_rate = vmd2->frame_rate;
			absolute_numbering_offset = vmd2->session_start_frame_number;
			
			// get indices
			if (seg->ts_inds_fps == NULL) {
				sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, VID_INDS_TYPE_STR_m13);
				if (G_exists_m13(tmp_str) == FILE_EXISTS_m13) {
					seg->vid_inds_fps = FPS_read_m13(NULL, 0, FPS_FULL_FILE_m13, 0, NULL, tmp_str, NULL, "r", (LH_m13 *) seg);
					if (seg->vid_inds_fps == NULL)
						return_m13(FALSE_m13);
				} else {
					force_discont = TRUE_m13;
					continue;
				}
			}

			// build contigua
			vi = seg->vid_inds_fps->vid_inds;
			if (search_mode == TIME_SEARCH_m13) {
				start_idx = G_find_index_m13(seg, slice->start_time, TIME_SEARCH_m13 | NO_OVERFLOWS_m13);
				end_idx = G_find_index_m13(seg, slice->end_time, TIME_SEARCH_m13 | NO_OVERFLOWS_m13);
			} else {
				start_idx = G_find_index_m13(seg, slice->start_frame_num, SAMPLE_SEARCH_m13 | NO_OVERFLOWS_m13);
				end_idx = G_find_index_m13(seg, slice->end_frame_num, SAMPLE_SEARCH_m13 | NO_OVERFLOWS_m13);
			}
			for (k = start_idx; k <= end_idx; ++k) {
				if (vi[k].file_offset < 0 || force_discont == TRUE_m13) {
					// close last contiguon
					if (n_contigua) {
						contiguon = contigua + (n_contigua - 1);
						contiguon->end_seg_num = (si4) j + 1;
						// end time
						if (k) {
							contiguon->end_frame_num = ((si8) vi[k].start_frame_num + absolute_numbering_offset) - 1;
							last_block_frames = vi[k].start_frame_num - vi[k - 1].start_frame_num;
							last_block_usecs = (si8) round(((sf8) last_block_frames / frame_rate) * (sf8) 1e6);
							contiguon->end_time = (vi[k - 1].start_time + last_block_usecs) - 1;
						} else {  // discontinuity on segment transition
							contiguon->end_frame_num = last_segment_end_frame_number;
							contiguon->end_time = last_segment_end_time;
							contiguon->end_seg_num = (si4) last_segment_number;
						}
					}
					// open new contiguon
					new_bytes = (size_t) (n_contigua + 1) * sizeof(CONTIGUON_m13);
					contigua = (CONTIGUON_m13 *) realloc_m13((void *) contigua, new_bytes);
					contiguon = contigua + n_contigua++;
					contiguon->start_frame_num = vi[k].start_frame_num + absolute_numbering_offset;
					contiguon->start_time = vi[k].start_time;
					contiguon->start_seg_num = (si4) j + 1;
					
					force_discont = FALSE_m13;
				}
			}
			last_segment_end_frame_number = (vi[k].start_frame_num + absolute_numbering_offset) - 1;
			last_segment_end_time = vi[k].start_time - 1;
			last_segment_number = (si4) j + 1;
		}
		
		// close final contiguon
		contiguon->end_frame_num = (vi[k].start_frame_num + absolute_numbering_offset) - 1;
		last_block_frames = vi[k].start_frame_num - vi[k - 1].start_frame_num;
		last_block_usecs = (si8) round(((sf8) last_block_frames / frame_rate) * (sf8) 1e6);
		contiguon->end_time = (vi[k - 1].start_time + last_block_usecs) - 1;
		contiguon->end_seg_num = (si4) last_segment_number;
	}
	
	if (n_contigua == 0)
		return_m13((si4) FALSE_m13);
	
	// trim contigua ends to slice (sample_number == frame_number)
	if (contigua[0].start_time < slice->start_time)
		contigua[0].start_time = slice->start_time;
	if (contigua[n_contigua - 1].end_time > slice->end_time)
		contigua[n_contigua - 1].end_time = slice->end_time;
	if (contigua[0].start_samp_num < slice->start_samp_num)
		contigua[0].start_samp_num = slice->start_samp_num;
	if (contigua[n_contigua - 1].end_samp_num > slice->end_samp_num)
		contigua[n_contigua - 1].end_samp_num = slice->end_samp_num;
	
	// set sample/frame numbers to NO ENTRY for variable frequency sessions
	if (lh->type_code == SESS_TYPE_CODE_m13) {
		null_sample_numbers = FALSE_m13;
		if (type_code == TS_CHAN_TYPE_CODE_m13 && proc_globs->active_channels.sampling_frequencies_vary == TRUE_m13)
			null_sample_numbers = TRUE_m13;
		else if (type_code == VID_CHAN_TYPE_CODE_m13 && proc_globs->active_channels.frame_rates_vary == TRUE_m13)
			null_sample_numbers = TRUE_m13;
		if (null_sample_numbers == TRUE_m13) {
			for (i = 0; i < n_contigua; ++i)
				contigua[i].start_samp_num = contigua[i].end_samp_num = SAMPLE_NUMBER_NO_ENTRY_m13;  // sample_number == frame_number
		}
	}

	// assign to level
	switch (lh->type_code) {  // type_code for session is ref channel type, so use original value
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
			if (seg->contigua)
				free_m13((void *) seg->contigua);
			seg->contigua = contigua;
			seg->n_contigua = n_contigua;
			break;
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
			if (chan->contigua)
				free_m13((void *) chan->contigua);
			chan->contigua = contigua;
			chan->n_contigua = n_contigua;
			break;
		case SESS_TYPE_CODE_m13:
			if (sess->contigua)
				free_m13((void *) sess->contigua);
			sess->contigua = contigua;
			sess->n_contigua = n_contigua;
			break;
	}
		
	return_m13(n_contigua);
}


Sgmt_REC_m13	*G_build_Sgmt_records_m13(LH_m13 *lh, si4 search_mode, ui4 *source_type)
{
	tern			seek_mode, seg_exists;
	si1			**seg_list, *metadata_ext, tmp_str[PATH_BYTES_m13], seg_name[SEG_NAME_BYTES_m13];
	si4			n_segs;
	si8			i, file_offset, data_len, n_recs, seek_data_size;
	const si8		SEEK_THRESHOLD = 10;  // this factor is a guess, for now
	SESS_m13		*sess;
	SSR_m13			*ssr;
	CHAN_m13		*chan;
	SEG_m13			*seg;
	FPS_m13			*ri_fps, *rd_fps, *md_fps;
	REC_IDX_m13		*ri;
	Sgmt_REC_m13		*Sgmt_recs, *Sgmt_rec;
	PROC_GLOBS_m13		*proc_globs;

	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// level must be session or channel
	
	if (lh == NULL) {
		G_set_error_m13(E_UNKN_m13, "level_header is NULL");
		return_m13(NULL);
	}
	
	// get proc globals
	proc_globs = G_proc_globs_m13(lh);

	sess = NULL;
	ssr = NULL;
	chan = NULL;
	ri_fps = rd_fps = NULL;

	// get channel
	switch(lh->type_code) {
		case SSR_TYPE_CODE_m13:
		case SESS_TYPE_CODE_m13:
			if (lh->type_code == SSR_TYPE_CODE_m13) {
				ssr = (SSR_m13 *) lh;
				sess = (SESS_m13 *) lh->parent;
			} else {
				sess = (SESS_m13 *) lh;
			}
			chan = proc_globs->current_session.index_channel;
			if (chan == NULL) {
				chan = G_change_index_chan_m13(sess, NULL, NULL, DEFAULT_CHAN_m13);  // set reference channel
				if (chan == NULL)
					return_m13(NULL);
			}
			break;
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
			chan = (CHAN_m13 *) lh;
			if (lh->parent->type_code == SESS_TYPE_CODE_m13)
				sess = (SESS_m13 *) lh->parent;
			break;
	}
	
	// get channel records
	if (chan) {
		ri_fps = chan->rec_inds_fps;
		if (ri_fps == NULL) {
			sprintf_m13(tmp_str, "%s/%s.%s", chan->path, chan->name, REC_INDS_TYPE_STR_m13);
			if (G_exists_m13(tmp_str) == FILE_EXISTS_m13)
				ri_fps = chan->rec_inds_fps = FPS_read_m13(NULL, 0, FPS_FULL_FILE_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) chan);
		}
		rd_fps = chan->rec_data_fps;
		if (rd_fps == NULL) {
			sprintf_m13(tmp_str, "%s/%s.%s", chan->path, chan->name, REC_DATA_TYPE_STR_m13);
			if (G_exists_m13(tmp_str) == FILE_EXISTS_m13)
				rd_fps = chan->rec_data_fps = FPS_read_m13(NULL, 0, FPS_UH_ONLY_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) chan);
		}
		*source_type = chan->type_code;
	}

	// get session records
	if (ri_fps == NULL || rd_fps == NULL) {
		ri_fps = sess->rec_inds_fps;
		if (ri_fps == NULL) {
			sprintf_m13(tmp_str, "%s/%s.%s", proc_globs->current_session.directory, proc_globs->current_session.fs_name, REC_INDS_TYPE_STR_m13);
			if (G_exists_m13(tmp_str) == FILE_EXISTS_m13) {
				ri_fps = sess->rec_inds_fps = FPS_read_m13(NULL, 0, FPS_FULL_FILE_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) sess);
			} else if (proc_globs->current_session.names_differ == TRUE_m13){
				sprintf_m13(tmp_str, "%s/%s.%s", proc_globs->current_session.directory, proc_globs->current_session.uh_name, REC_INDS_TYPE_STR_m13);
				if (G_exists_m13(tmp_str) == FILE_EXISTS_m13)
					ri_fps = sess->rec_inds_fps = FPS_read_m13(NULL, 0, FPS_FULL_FILE_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) sess);
			}
		}
		rd_fps = sess->rec_data_fps;
		if (rd_fps == NULL) {
			sprintf_m13(tmp_str, "%s/%s.%s", proc_globs->current_session.directory, proc_globs->current_session.fs_name, REC_DATA_TYPE_STR_m13);
			if (G_exists_m13(tmp_str) == FILE_EXISTS_m13) {
				rd_fps = sess->rec_data_fps = FPS_read_m13(NULL, 0, FPS_UH_ONLY_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) sess);
			} else if (proc_globs->current_session.names_differ == TRUE_m13){
				sprintf_m13(tmp_str, "%s/%s.%s", proc_globs->current_session.directory, proc_globs->current_session.uh_name, REC_DATA_TYPE_STR_m13);
				if (G_exists_m13(tmp_str) == FILE_EXISTS_m13)
					rd_fps = sess->rec_data_fps = FPS_read_m13(NULL, 0, FPS_UH_ONLY_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) sess);
			}
		}
		*source_type = NO_TYPE_CODE_m13;
	}

	// use Sgmt records (preferred)
	n_segs = 0;
	if (ri_fps && rd_fps) {
		// full record index file already read in
		n_recs = rd_fps->uh->n_entries;
		if (proc_globs->current_session.n_segments == SEGMENT_NUMBER_NO_ENTRY_m13) {
			ri = ri_fps->rec_inds;
			for (n_segs = 0, i = n_recs; i--; ++ri)
				if (ri->type_code == REC_Sgmt_TYPE_CODE_m13)
					++n_segs;
			proc_globs->current_session.n_segments = n_segs;
		} else {
			n_segs = proc_globs->current_session.n_segments;
		}
		
		// allocate Sgmt_recs array
		if (n_segs) {
			Sgmt_recs = (Sgmt_REC_m13 *) calloc((size_t) n_segs, sizeof(Sgmt_REC_m13));
			if (Sgmt_recs == NULL)
				return_m13(NULL);
			
			// decide if more efficient to read full file, or seek to specific records
			seek_mode = FALSE_m13;
			if (rd_fps->params.full_file_read == FALSE_m13) {  // full file not already read in
				data_len = rd_fps->params.fp->len - FPS_UH_BYTES_m13;
				seek_data_size = (si8) n_segs * sizeof(Sgmt_REC_m13);
				if ((data_len / seek_data_size) >= SEEK_THRESHOLD) {
					seek_mode = TRUE_m13;
				} else {
					if (FPS_read_m13(rd_fps, 0, FPS_FULL_FILE_m13, 0, NULL) == NULL) {
						free((void *) Sgmt_recs);
						return_m13(NULL);
					}
				}
			}
			if (seek_mode == TRUE_m13) {  // ? more efficient to seek (large records files)
				ri = ri_fps->rec_inds;
				for (i = 0; i < n_segs; ++ri) {
					if (ri->type_code == REC_Sgmt_TYPE_CODE_m13) {
						if (FPS_read_m13(rd_fps, ri->file_offset, sizeof(Sgmt_REC_m13), 1, NULL) == NULL) {
							free((void *) Sgmt_recs);
							return_m13(NULL);
						}
						Sgmt_recs[i] = *((Sgmt_REC_m13 *) rd_fps->rec_data);
						Sgmt_recs[i++].total_record_bytes = sizeof(Sgmt_REC_m13);  // discard description, if any
					}
				}
			} else {  // full file read in
				ri = ri_fps->rec_inds;
				for (i = 0; i < n_segs; ++ri) {
					if (ri->type_code == REC_Sgmt_TYPE_CODE_m13) {
						file_offset = REMOVE_DISCONT_m13(ri->file_offset);
						Sgmt_recs[i] = *((Sgmt_REC_m13 *) (rd_fps->params.raw_data + file_offset));
						Sgmt_recs[i++].total_record_bytes = sizeof(Sgmt_REC_m13);  // discard description, if any
					}
				}
			}
		}

		// check session Sgmt records are sufficient
		if (search_mode == SAMPLE_SEARCH_m13) {
			if (Sgmt_recs[0].start_samp_num == SAMPLE_NUMBER_NO_ENTRY_m13) {
				n_segs = 0;  // force using metadata
				free((void *) Sgmt_recs);
			}
		}
	}

	// use metadata files (less efficient)
	if (n_segs == 0) {
		if (chan == NULL) {
			chan = G_change_index_chan_m13(sess, NULL, NULL, DEFAULT_CHAN_m13);  // set reference channel
			if (chan == NULL) {
				G_set_error_m13(E_UNKN_m13, "index channel not set");
				return_m13(NULL);
			}
		}
		seg_list = G_file_list_m13(NULL, &n_segs, chan->path, NULL, "?isd", GFL_FULL_PATH_m13);
		if (n_segs == 0) {
			G_set_error_m13(E_UNKN_m13, "no segments found");
			return_m13(NULL);
		}
		proc_globs->current_session.n_segments = n_segs;
		
		// allocate Sgmt_recs array
		Sgmt_recs = (Sgmt_REC_m13 *) calloc((size_t) n_segs, sizeof(Sgmt_REC_m13));
		if (Sgmt_recs == NULL)
			return_m13(NULL);

		switch (chan->type_code) {
			case TS_CHAN_TYPE_CODE_m13:
				metadata_ext = TS_METADATA_TYPE_STR_m13;
				break;
			case VID_CHAN_TYPE_CODE_m13:
				metadata_ext = VID_METADATA_TYPE_STR_m13;
				break;
		}
		
		for (i = 0; i < n_segs; ++i) {
			seg_exists = FALSE_m13;
			md_fps = NULL;
			if (chan->segs) {
				seg = chan->segs[i];
				md_fps = seg->metadata_fps;
				seg_exists = TRUE_m13;
			}
			if (seg_exists == FALSE_m13) {
				G_path_parts_m13(seg_list[i], NULL, seg_name, NULL);
				sprintf_m13(tmp_str, "%s/%s.%s", seg_list[i], seg_name, metadata_ext);
			}
			if (md_fps == NULL) {
				md_fps = FPS_read_m13(NULL, 0, FPS_FULL_FILE_m13, 1, NULL, tmp_str, "r", NULL, NULL);
				if (md_fps == NULL) {
					free((void *) Sgmt_recs);
					return_m13(NULL);
				}
			}
			Sgmt_rec = Sgmt_recs + i;
			Sgmt_rec->record_CRC = CRC_NO_ENTRY_m13;
			Sgmt_rec->total_record_bytes = REC_HDR_BYTES_m13 + REC_Sgmt_v11_BYTES_m13;  // no description
			Sgmt_rec->start_time = md_fps->uh->segment_start_time;
			Sgmt_rec->type_code = REC_Sgmt_TYPE_CODE_m13;
			Sgmt_rec->version_major = 1;
			Sgmt_rec->version_minor = 1;
			Sgmt_rec->encryption_level = NO_ENCRYPTION_m13;
			Sgmt_rec->end_time = md_fps->uh->segment_end_time;
			Sgmt_rec->seg_num = md_fps->uh->segment_number;
			switch (chan->type_code) {
				case TS_CHAN_TYPE_CODE_m13:
					Sgmt_rec->start_samp_num = md_fps->metadata->time_series_section_2.session_start_sample_number;
					Sgmt_rec->end_samp_num = Sgmt_rec->start_samp_num + md_fps->metadata->time_series_section_2.number_of_samples - 1;
					Sgmt_rec->samp_freq = (sf4) md_fps->metadata->time_series_section_2.sampling_frequency;
					break;
				case VID_CHAN_TYPE_CODE_m13:
					Sgmt_rec->start_frame_num = md_fps->metadata->video_section_2.session_start_frame_number;
					Sgmt_rec->end_frame_num = Sgmt_rec->start_frame_num + md_fps->metadata->video_section_2.number_of_frames - 1;
					Sgmt_rec->frame_rate = (sf4) md_fps->metadata->video_section_2.frame_rate;
					break;
			}
			if (seg_exists == TRUE_m13)
				seg->metadata_fps = md_fps;
			else
				FPS_free_m13(&md_fps);
		}
		free_m13((void *) seg_list);
		*source_type = chan->type_code;
	}

	// fill in global Sgmt fields
	proc_globs->current_session.end_time = Sgmt_recs[n_segs - 1].end_time;
	
	// set level Sgmt_record shortcuts
	chan->Sgmt_recs = Sgmt_recs;
	if (ssr)
		ssr->Sgmt_recs = Sgmt_recs;
	if (sess)
		sess->Sgmt_recs = Sgmt_recs;

	return_m13(Sgmt_recs);
}


si8	G_bytes_for_items_m13(FPS_m13 *fps, si8 *n_items, si8 offset)
{
	ui4				entry_size;
	si8				i, bytes, max_bytes, bytes_remaining;
	REC_HDR_m13		*rh;
	CMP_FIXED_BH_m13	*bh;
	UH_m13		*uh;
	
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// offset only needed for items with variable size data (TS_DATA_TYPE_CODE_m13 & REC_DATA_TYPE_CODE_m13)
	// offset == 0 for writing
	// returns FALSE_m13 for error
	
	uh = fps->uh;
	switch (uh->type_code) {
		case TS_INDS_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
		case REC_INDS_TYPE_CODE_m13:
			bytes = (*n_items) * INDEX_BYTES_m13;
			uh->maximum_entry_size = INDEX_BYTES_m13;
			return_m13(bytes);
		case TS_METADATA_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
			bytes = METADATA_BYTES_m13;
			uh->maximum_entry_size = METADATA_BYTES_m13;
			*n_items = 1;
			return_m13(bytes);
	}
	
	offset = REMOVE_DISCONT_m13(offset);
	bytes = 0;
	if (offset == 0) {  // writing (data is in memory)
		switch (uh->type_code) {
			case TS_DATA_TYPE_CODE_m13:
				bh = fps->params.cps->block_header;
				for (i = 0; i < *n_items; ++i) {
					entry_size = (si8) bh->total_block_bytes;
					if (uh->maximum_entry_size < entry_size)  // caller should've done this, but just in case
						uh->maximum_entry_size = entry_size;
					bytes += entry_size;
					bh = (CMP_FIXED_BH_m13 *) ((ui1 *) bh + entry_size);
				}
				break;
			case REC_DATA_TYPE_CODE_m13:
				rh = (REC_HDR_m13 *) fps->rec_data;
				for (i = 0; i < *n_items; ++i) {
					entry_size = (si8) rh->total_record_bytes;
					if (uh->maximum_entry_size < entry_size)  // caller should've done this, but just in case
						uh->maximum_entry_size = entry_size;
					bytes += entry_size;
					rh = (REC_HDR_m13 *) ((ui1 *) rh + entry_size);
				}
				break;
		}
		return_m13(bytes);
	}
	
	// reading (this is why it's better to pass this value)
	max_bytes = (si8) uh->maximum_entry_size * (*n_items);
	bytes_remaining = fps->params.fp->len - offset;
	if (max_bytes > bytes_remaining)
		max_bytes = bytes_remaining;
	if (FPS_realloc_m13(fps, max_bytes) == FALSE_m13)
		return_m13(FALSE_m13);
		
	if (FPS_read_m13(fps, offset, max_bytes, 0, NULL) == NULL)
		return_m13(FALSE_m13);
	switch (uh->type_code) {
		case TS_DATA_TYPE_CODE_m13:
			bh = fps->params.cps->block_header;
			for (i = 0; i < *n_items; ++i) {
				entry_size = (si8) bh->total_block_bytes;
				bytes += entry_size;
				if (bytes > max_bytes) {
					*n_items = i;
					bytes -= entry_size;
					break;
				}
				bh = (CMP_FIXED_BH_m13 *) ((ui1 *) bh + entry_size);
			}
			break;
		case REC_DATA_TYPE_CODE_m13:
			rh = (REC_HDR_m13 *) fps->rec_data;
			for (i = 0; i < *n_items; ++i) {
				entry_size = (si8) rh->total_record_bytes;
				bytes += entry_size;
				if (bytes > max_bytes) {
					*n_items = i;
					bytes -= entry_size;
					break;
				}
				rh = (REC_HDR_m13 *) ((ui1 *) rh + entry_size);
			}
			break;
	}
	
	return_m13(bytes);
}


tern  G_calculate_indices_CRCs_m13(FPS_m13 *fps)
{
	si8 		i;
	INDEX_m13		*idx;
	UH_m13	*uh;

	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	idx = (INDEX_m13 *) fps->data_ptrs;
	uh = fps->uh;
	for (i = fps->n_items; i--; ++idx)
		uh->body_CRC = CRC_update_m13((ui1 *) idx, INDEX_BYTES_m13, uh->body_CRC);
	
	return_m13(TRUE_m13);
}


tern	G_calculate_metadata_CRC_m13(FPS_m13 *fps)
{
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	fps->uh->body_CRC = CRC_calculate_m13((ui1 *) fps->data_ptrs, METADATA_BYTES_m13);
	
	return_m13(TRUE_m13);
}


tern	G_calculate_record_data_CRCs_m13(FPS_m13 *fps)
{
	ui4			temp_CRC, full_record_CRC;
	si8			i;
	REC_HDR_m13	*rh;
	UH_m13	*uh;
	
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	uh = fps->uh;
	rh = (REC_HDR_m13 *) fps->data_ptrs;
	for (i = fps->n_items; i--;) {
		rh->record_CRC = CRC_calculate_m13((ui1 *) rh + REC_HDR_CRC_START_OFFSET_m13, rh->total_record_bytes - REC_HDR_CRC_START_OFFSET_m13);
		
		temp_CRC = CRC_calculate_m13((ui1 *) rh, REC_HDR_CRC_START_OFFSET_m13);
		full_record_CRC = CRC_combine_m13(temp_CRC, rh->record_CRC, rh->total_record_bytes - REC_HDR_CRC_START_OFFSET_m13);
		uh->body_CRC = CRC_combine_m13(uh->body_CRC, full_record_CRC, rh->total_record_bytes);
		
		rh = (REC_HDR_m13 *) ((ui1 *) rh + rh->total_record_bytes);
	}
	
	return_m13(TRUE_m13);
}


tern	G_calculate_time_series_data_CRCs_m13(FPS_m13 *fps)
{
	ui4 			temp_CRC, full_block_CRC;
	si8 			i;
	UH_m13		*uh;
	CMP_FIXED_BH_m13	*bh;

	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	bh = (CMP_FIXED_BH_m13 *) fps->data_ptrs;
		
	uh = fps->uh;
	for (i = fps->n_items; i--;) {
		bh->block_CRC = CRC_calculate_m13((ui1 *) bh + CMP_BLOCK_CRC_START_OFFSET_m13, bh->total_block_bytes - CMP_BLOCK_CRC_START_OFFSET_m13);
		
		temp_CRC = CRC_calculate_m13((ui1 *) bh, CMP_BLOCK_CRC_START_OFFSET_m13);
		full_block_CRC = CRC_combine_m13(temp_CRC, bh->block_CRC, bh->total_block_bytes - CMP_BLOCK_CRC_START_OFFSET_m13);
		uh->body_CRC = CRC_combine_m13(uh->body_CRC, full_block_CRC, bh->total_block_bytes);
		
		bh = (CMP_FIXED_BH_m13 *) ((ui1 *) bh + bh->total_block_bytes);
	}
	
	return_m13(TRUE_m13);
}


tern	G_calculate_video_data_CRCs_m13(FPS_m13 *fps)
{
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	return_m13(TRUE_m13);
}
	

CHAN_m13	*G_change_index_chan_m13(SESS_m13 *sess, CHAN_m13 *chan, si1 *chan_name, si1 chan_type)
{
	tern			use_default_channel;
	si8			i, n_chans;
	CHAN_m13		*tmp_chan;
	PROC_GLOBS_m13		*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// pass either channel, or channel name (if both passed channel will be used)
	// if both NULL, use channel_type
	
	if (sess) {
		proc_globs = G_proc_globs_m13((LH_m13 *) sess);
	} else if (chan) {
		proc_globs = G_proc_globs_m13((LH_m13 *) chan);
	} else {
		G_set_error_m13(E_UNKN_m13, "both session and channel are NULL");
		return_m13(NULL);
	}

	// index channel passed
	if (chan) {
		proc_globs->current_session.index_channel = chan;
		if (*proc_globs->current_session.index_channel_name == 0)
			strcpy(proc_globs->current_session.index_channel_name, chan->name);
		return_m13(chan);
	}

	use_default_channel = FALSE_m13;
	if (chan == NULL) {
		if (STR_empty_m13(chan_name) == TRUE_m13) {
			if (*proc_globs->current_session.index_channel_name)
				chan_name = proc_globs->current_session.index_channel_name;
			else
				use_default_channel = TRUE_m13;
		}
	}
	if (use_default_channel == FALSE_m13)  // if channel or channel_name passed, channel type options ignored
		chan_type = DEFAULT_CHAN_m13;

	if (use_default_channel == TRUE_m13) {
		switch (chan_type) {
			case DEFAULT_CHAN_m13:
			case DEFAULT_TS_CHAN_m13:
			case DEFAULT_VID_CHAN_m13:
				break;
			case HIGHEST_RATE_TS_CHAN_m13:
				chan = proc_globs->active_channels.maximum_sampling_frequency_channel;
				chan_type = DEFAULT_TS_CHAN_m13;
				break;
			case LOWEST_RATE_TS_CHAN_m13:
				chan = proc_globs->active_channels.minimum_sampling_frequency_channel;
				chan_type = DEFAULT_TS_CHAN_m13;
				break;
			case HIGHEST_RATE_VID_CHAN_m13:
				chan = proc_globs->active_channels.maximum_frame_rate_channel;
				chan_type = DEFAULT_VID_CHAN_m13;
				break;
			case LOWEST_RATE_VID_CHAN_m13:
				chan = proc_globs->active_channels.minimum_frame_rate_channel;
				chan_type = DEFAULT_VID_CHAN_m13;
				break;
			default:
				chan_type = DEFAULT_CHAN_m13;
				break;
		}
	}
	
	// find channel from name
	proc_globs->current_session.index_channel = NULL;
	if (chan == NULL) {
		if (use_default_channel == TRUE_m13) {
			chan = G_active_channel_m13(sess, chan_type);
			if (chan == NULL)
				return_m13(NULL);
			goto CHANGE_REF_MATCH_m13;
		}
		if (chan_type == DEFAULT_CHAN_m13 || chan_type == DEFAULT_TS_CHAN_m13) {
			n_chans = sess->n_ts_chans;  // check for match in time_series_channels
			for (i = 0; i < n_chans; ++i) {
				tmp_chan = sess->ts_chans[i];
				if (tmp_chan->flags & LH_CHAN_ACTIVE_m13) {
					if (strcmp_m13(tmp_chan->name, chan_name) == 0) {
						chan = tmp_chan;
						goto CHANGE_REF_MATCH_m13;
					}
				}
			}
		}
		if (chan_type == DEFAULT_CHAN_m13 || chan_type == DEFAULT_VID_CHAN_m13) {
			n_chans = sess->n_vid_chans;
			for (i = 0; i < n_chans; ++i) {
				tmp_chan = sess->vid_chans[i];
				if (tmp_chan->flags & LH_CHAN_ACTIVE_m13) {
					if (strcmp_m13(tmp_chan->name, chan_name) == 0) {
						chan = tmp_chan;
						goto CHANGE_REF_MATCH_m13;
					}
				}
			}
		}
	} else {  // channel known
		if (chan->flags & LH_CHAN_ACTIVE_m13)
			goto CHANGE_REF_MATCH_m13;
		chan = G_active_channel_m13(sess, chan_type);
		if (chan)
			goto CHANGE_REF_MATCH_m13;
	}

	G_set_error_m13(E_UNKN_m13, "no matching active channels");
	return_m13(NULL);
	
CHANGE_REF_MATCH_m13:
	
	proc_globs->current_session.index_channel = chan;
	strcpy(proc_globs->current_session.index_channel_name, chan->name);

	return_m13(chan);
}


ui4	G_channel_type_from_path_m13(si1 *path)
{
	si1	*c, temp_path[PATH_BYTES_m13], extension[TYPE_BYTES_m13];
	ui4	type_code;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// move pointer to end of string
	c = path + strlen(path) - 1;
	
	// ignore terminal "/" if present
	if (*c == '/')
		c--;
	
	c -= 4;
	if (*c != '.')
		return_m13(UNKNOWN_CHANNEL_TYPE_m13);
	memcpy((void *) &type_code, (void *) ++c, 4);
	
	// record types => get extension of next level up the hierarchy
	if (type_code == REC_DATA_TYPE_CODE_m13 || type_code == REC_INDS_TYPE_CODE_m13) {
		G_path_parts_m13(path, temp_path, NULL, NULL);
		G_path_parts_m13(temp_path, NULL, NULL, extension);
		memcpy((void *) &type_code, (void *) extension, 4);
	}
	
	// compare extension
	switch (type_code) {
		case TS_CHAN_TYPE_CODE_m13:
		case TS_SEG_TYPE_CODE_m13:
		case TS_METADATA_TYPE_CODE_m13:
		case TS_DATA_TYPE_CODE_m13:
		case TS_INDS_TYPE_CODE_m13:
			return_m13(TS_CHAN_TYPE_m13);
			
		case VID_CHAN_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
			return_m13(VID_CHAN_TYPE_m13);
			
		default:  // session, segmented session records, or non-MED
			return_m13(UNKNOWN_CHANNEL_TYPE_m13);
	}
}


tern	G_check_char_type_m13(void)
{
	char	c;

	
	// check size of "char"
	if (sizeof(char) != 1)
		return(FALSE_m13);

	// check signedness of "char"
	c = -1;
	if ((si4) c != (si4) -1)
		return(FALSE_m13);
	
	return(TRUE_m13);
}


tern	G_check_file_list_m13(si1 **file_list, si4 n_files)
{
	si4	i;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// G_file_list_m13() does a lot of stuff, but often just need to ensure list contains full paths with no regex
	
	if (file_list == NULL)
		return_m13(FALSE_m13);
	if (file_list[0] == NULL)
		return_m13(FALSE_m13);
	
	for (i = 0; i < n_files; ++i) {
		if (STR_contains_regex_m13(file_list[i]) == TRUE_m13)
			return_m13(FALSE_m13);
		if (G_full_path_m13(file_list[i], NULL) == FALSE_m13)
			return_m13(FALSE_m13);
	}

	return_m13(TRUE_m13);
}


tern	G_check_file_system_m13(si1 *file_system_path, si4 is_cloud, ...)  // varargs (is_could == TRUE_m13): si1 *cloud_directory, si1 *cloud_service_name, si1 *cloud_utilities_directory
{
	si1		command[PATH_BYTES_m13 + 64], cloud_prefix[PATH_BYTES_m13];
	si1		full_path[PATH_BYTES_m13];
	si1		*cloud_directory, *cloud_service_name, *cloud_utilities_directory;
	si4		ret_val;
	va_list		v_args;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (STR_empty_m13(file_system_path) == TRUE_m13)
		file_system_path = ".";
	G_full_path_m13(file_system_path, full_path);
	
	// make directory if it doesn't exist
	md_m13(full_path);

	// check write ability on file system
	sprintf_m13(command, "echo x > \"%s/test_file-remove_me\"", full_path);  // create non-empty file in case file system is cloud
	ret_val = system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
	if (ret_val) {
		G_set_error_m13(E_WRITE_m13, "cannot create files on \"%s\"", full_path);
		return_m13(FALSE_m13);
	}

	// check write ability on cloud
	if (is_cloud == TRUE_m13) {
		va_start(v_args, is_cloud);
		cloud_directory = va_arg(v_args, si1 *);
		cloud_service_name = va_arg(v_args, si1 *);
		cloud_utilities_directory = va_arg(v_args, si1 *);
		va_end(v_args);
		
		if (strcmp_m13(cloud_service_name, "amazon") == 0)
			sprintf_m13(cloud_prefix, "%s/gustil ", cloud_utilities_directory);
		else if (strcmp_m13(cloud_service_name, "google") == 0)
			sprintf_m13(cloud_prefix, "%s/aws s3 ", cloud_utilities_directory);
		
		// copy file system test file to cloud
		sprintf(command, "%scp %s/test_file-remove_me %s/test_file-remove_me", cloud_prefix, file_system_path, cloud_directory);
		ret_val = system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
		if (ret_val) {
			G_set_error_m13(E_WRITE_m13, "cannot create files on \"%s\"", cloud_directory);
			return_m13(FALSE_m13);
		} else {
			// clean up
			sprintf(command, "%srm %s/test_file-remove_me", cloud_prefix, cloud_directory);
			ret_val = system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
		}
	}
	
	// clean up
	rm_m13(full_path);

	return_m13(TRUE_m13);
}


tern	G_check_password_m13(si1 *password)
{
	si4	pw_len;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// check pointer: return FALSE_m13 for NULL
	if (password == NULL) {
		G_set_error_m13(E_ACC_m13, "password is NULL");
		return_m13(FALSE_m13);
	}
		
	// check password length
	pw_len = UTF8_strlen_m13(password);
	if (pw_len == 0) {
		G_set_error_m13(E_ACC_m13, "password has no characters");
		return_m13(FALSE_m13);
	}
	if (pw_len > MAX_PASSWORD_CHARACTERS_m13) {
		G_set_error_m13(E_ACC_m13, "password too long (1 to  %d characters)", MAX_PASSWORD_CHARACTERS_m13);
		return_m13(FALSE_m13);
	}
		
	// return TRUE_m13 for valid password
	return_m13(TRUE_m13);
}


si4	G_check_segment_map_m13(SLICE_m13 *slice, SESS_m13 *sess)
{
	si4 			start_seg, end_seg, seg_idx, first_mapped_seg, last_mapped_seg;
	si4			remapped_start_seg, remapped_end_seg, remapped_seg_cnt;
	si4			i, j, offset, mapped_segs, sess_segs;
	CHAN_m13		*chan;
	SEG_m13		**remapped_segs;
	PROC_GLOBS_m13	*proc_globs;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns offset of start_segment_number into segments array
	// if segment range needs to be remapped, this is done before return
	// call from read_session_m13() before any channel reading to avoid any conflicts with threads if remapping required
	// returns (si4) FALSE_m13 on error

	start_seg = slice->start_seg_num;
	end_seg = slice->end_seg_num;
	if (start_seg == SEGMENT_NUMBER_NO_ENTRY_m13 || end_seg == SEGMENT_NUMBER_NO_ENTRY_m13) {
		G_set_error_m13(E_UNKN_m13, "segment range not fully specified");
		return_m13((si4) FALSE_m13);
	}
	
	proc_globs = G_proc_globs_m13((LH_m13 *) sess);
	sess_segs = proc_globs->current_session.n_segments;
	if (start_seg < 1 || end_seg > sess_segs) {
		G_set_error_m13(E_UNKN_m13, "segment range not valid");
		return_m13((si4) FALSE_m13);
	}

	// all segments mapped
	mapped_segs = proc_globs->current_session.n_mapped_segments;
	if (mapped_segs == sess_segs)
		if (start_seg >= 1 && end_seg <= sess_segs)
			return_m13(start_seg - 1);
	
	first_mapped_seg = proc_globs->current_session.first_mapped_segment_number;
	last_mapped_seg = (first_mapped_seg + mapped_segs) - 1;
	if (start_seg >= first_mapped_seg && end_seg <= last_mapped_seg)
		return_m13(start_seg - first_mapped_seg);
	
	// remapping required
	remapped_start_seg = (start_seg < first_mapped_seg) ? start_seg : first_mapped_seg;
	remapped_end_seg = (end_seg > last_mapped_seg) ? end_seg : last_mapped_seg;
	remapped_seg_cnt = (remapped_end_seg - remapped_start_seg) + 1;
	for (i = 0; i < sess->n_ts_chans; ++i) {
		chan = sess->ts_chans[i];
		remapped_segs = (SEG_m13 **) calloc_m13((size_t) remapped_seg_cnt, -sizeof(SEG_m13 *));  // flag as lh 
		offset = first_mapped_seg - remapped_start_seg;
		for (j = 0; j < mapped_segs; ++j, ++offset)
			remapped_segs[offset] = chan->segs[j];
		free_m13((void *) chan->segs);
		chan->segs = remapped_segs;
	}
	for (i = 0; i < sess->n_vid_chans; ++i) {
		chan = sess->vid_chans[i];
		remapped_segs = (SEG_m13 **) calloc_m13((size_t) remapped_seg_cnt, -sizeof(SEG_m13 *));  // flag as lh 
		offset = first_mapped_seg - remapped_start_seg;
		for (j = 0; j < mapped_segs; ++j, ++offset)
			remapped_segs[offset] = chan->segs[j];
		free_m13((void *) chan->segs);
		chan->segs = remapped_segs;
	}

	proc_globs->current_session.first_mapped_segment_number = remapped_start_seg;
	proc_globs->current_session.n_mapped_segments = remapped_seg_cnt;
	seg_idx = first_mapped_seg - remapped_start_seg;

	return_m13(seg_idx);
}


void	G_clear_error_m13(LH_m13 *lh)
{
	ERR_m13		*err;
	PROC_GLOBS_m13	*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// call G_set_error_m13() for causal errors only
	// return error local error condition for errors returned from functions, no messages necessary
	
	// set thread specific flag for void functions
	proc_globs = G_proc_globs_m13(lh);
	proc_globs->miscellaneous.proc_error_state = FALSE_m13;  // should always be set if there is an error, but can be cleared

	// check global error
	err = &globals_m13->error;
	err->code = E_NONE_m13;
	*err->message = 0;
	err->line = 0;
	err->function = NULL;
		
	return_void_m13;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	G_clear_terminal_m13(void)
{
	si4	ret_val;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

#if defined MACOS_m13 || defined LINUX_m13
	ret_val = system_m13(NULL, "clear", TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
#endif
#ifdef WINDOWS_m13
	ret_val = (WN_clear_m13() == TRUE_m13) ? 0 : FALSE_m13;  // change to system_m13() convention
#endif
	
	if (ret_val)
		return_m13(FALSE_m13);
	
	return_m13(TRUE_m13);
}


si4	G_compare_acq_nums_m13(const void *a, const void *b)
{
	ACQ_NUM_SORT_m13	*as, *bs;
	
	
	as = (ACQ_NUM_SORT_m13 *) a;
	bs = (ACQ_NUM_SORT_m13 *) b;
	
	if (as->acq_num > bs->acq_num)
		return(1);
	if (as->acq_num < bs->acq_num)
		return(-1);
	return(0);
}


si4	G_compare_record_index_times(const void *a, const void *b)
{
	REC_IDX_m13	*ria, *rib;
	
	
	ria = (REC_IDX_m13 *) a;
	rib = (REC_IDX_m13 *) b;
	
	// can't return time diff - cast to int may overflow
	if (ria->start_time > rib->start_time)
		return(1);
	if (ria->start_time < rib->start_time)
		return(-1);
	
	return(0);
}


tern	G_condition_password_m13(si1 *password, si1 *password_bytes, tern expand_password)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	if (STR_empty_m13(password) == TRUE_m13) {
		G_set_error_m13(E_ENC_m13, "password is empty");
		return_m13(FALSE_m13);
	}
	
	if (G_check_password_m13(password) == FALSE_m13)
		return_m13(FALSE_m13);
	
	if (password_bytes == NULL)
		password_bytes = (si1 *) calloc_m13((size_t) PASSWORD_BYTES_m13, sizeof(ui1));
	
	if (expand_password == TRUE_m13)
		G_expand_password_m13(password, password_bytes);
	else
		G_terminal_password_bytes_m13(password, password_bytes);
	
	return_m13(TRUE_m13);
}


tern	G_condition_slice_m13(SLICE_m13 *slice, LH_m13 *lh)
{
	si8		test_time;
	PROC_GLOBS_m13	*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (slice == NULL) {
		G_set_error_m13(E_UNKN_m13, "slice is NULL");
		return_m13(FALSE_m13);
	}
	
	proc_globs = G_proc_globs_m13(lh);
	
	if (proc_globs->time_constants.recording_time_offset == FALSE_m13) {
		proc_globs->time_constants.recording_time_offset = GLOBALS_RECORDING_TIME_OFFSET_DEFAULT_m13;  // == 0
		if (proc_globs->current_session.start_time == UUTC_NO_ENTRY_m13)
			proc_globs->current_session.start_time = BEGINNING_OF_TIME_m13;
	}
	
	if (slice->start_time <= 0) {
		if (slice->start_time == UUTC_NO_ENTRY_m13) {
			if (slice->start_samp_num == SAMPLE_NUMBER_NO_ENTRY_m13)
				slice->start_time = BEGINNING_OF_TIME_m13;
		} else {  // relative time
			slice->start_time = proc_globs->current_session.start_time - slice->start_time;
		}
	} else {  // ? unoffset time
		test_time = slice->start_time - proc_globs->time_constants.recording_time_offset;
		if (test_time > 0)  // start time is not offset
			slice->start_time = test_time;
	}
	
	if (slice->end_time <= 0) {
		if (slice->end_time == UUTC_NO_ENTRY_m13) {
			if (slice->end_samp_num == SAMPLE_NUMBER_NO_ENTRY_m13)
				slice->end_time = END_OF_TIME_m13;
		} else {  // relative time
			slice->end_time = proc_globs->current_session.start_time - slice->end_time;
		}
	} else {  // ? unoffset time
		test_time = slice->end_time - proc_globs->time_constants.recording_time_offset;
		if (test_time > 0 && slice->end_time != END_OF_TIME_m13)  // end time is not offset
			slice->end_time = test_time;
	}
	
	slice->conditioned = TRUE_m13;
	
	return_m13(TRUE_m13);
}


tern	G_condition_timezone_info_m13(TIMEZONE_INFO_m13 *tz_info)
{
	si4			i;
	si8			len;
	TIMEZONE_ALIAS_m13	*tz_aliases_table;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (globals_m13->tables->timezone_table == NULL)
		G_init_timezone_tables_m13();

	// Country: at this time there are no 2 or 3 letter country names => user probably entered acronym
	if (*tz_info->country) {
		len = strlen(tz_info->country);
		if (len == 2) {
			strcpy(tz_info->country_acronym_2_letter, tz_info->country);
			*tz_info->country = 0;
		} else if (len == 3) {
			strcpy(tz_info->country_acronym_3_letter, tz_info->country);
			*tz_info->country = 0;
		}
	}
	
	// Territory: at this time there are no 2 letter territory names => user probably entered acronym
	if (*tz_info->territory) {
		len = strlen(tz_info->territory);
		if (len == 2) {
			strcpy(tz_info->territory_acronym, tz_info->territory);
			*tz_info->territory = 0;
		}
	}
	
	// change potentially matching strings to caps
	STR_to_upper_m13(tz_info->country);
	STR_to_upper_m13(tz_info->country_acronym_2_letter);
	STR_to_upper_m13(tz_info->country_acronym_3_letter);
	STR_to_upper_m13(tz_info->territory);
	STR_to_upper_m13(tz_info->territory_acronym);
	STR_to_upper_m13(tz_info->standard_timezone);
	STR_to_upper_m13(tz_info->standard_timezone_acronym);
	STR_to_upper_m13(tz_info->daylight_timezone);
	STR_to_upper_m13(tz_info->daylight_timezone_acronym);
	
	// check country aliases
	tz_aliases_table = globals_m13->tables->country_aliases_table;
	
	if (*tz_info->country) {
		for (i = 0; i < TZ_COUNTRY_ALIASES_ENTRIES_m13; ++i) {
			if ((strcmp_m13(tz_info->country, tz_aliases_table[i].alias)) == 0) {
				strcpy(tz_info->country, tz_aliases_table[i].table_name);
				break;
			}
		}
	}
	
	// check country acronyms
	tz_aliases_table = globals_m13->tables->country_acronym_aliases_table;
	
	if (*tz_info->country_acronym_2_letter) {
		for (i = 0; i < TZ_COUNTRY_ACRONYM_ALIASES_ENTRIES_m13; ++i) {
			if ((strcmp_m13(tz_info->country_acronym_2_letter, tz_aliases_table[i].alias)) == 0) {
				strcpy(tz_info->country_acronym_2_letter, tz_aliases_table[i].table_name);
				break;
			}
		}
	}
	
	if (*tz_info->country_acronym_3_letter) {
		for (i = 0; i < TZ_COUNTRY_ALIASES_ENTRIES_m13; ++i) {
			if ((strcmp_m13(tz_info->country_acronym_3_letter, tz_aliases_table[i].alias)) == 0) {
				strcpy(tz_info->country_acronym_3_letter, tz_aliases_table[i].table_name);
				break;
			}
		}
	}

	return_m13(TRUE_m13);
}


tern	G_correct_universal_header_m13(FPS_m13 *fps)
{
	static tern			warning_given = FALSE_m13;
	tern				free_fps2;
	si1				path[PATH_BYTES_m13], name[SEG_NAME_BYTES_m13];
	si8				n_entries, file_offset, idx;
	ui4				maximum_entry_size;
	FPS_m13				*fps2;
	UH_m13		*uh, *uh2;
	SEG_m13			*seg;
	SSR_m13		*ssr;
	LH_m13 				*lh;
	CMP_FIXED_BH_m13	bh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// called if uh->n_entries == 0 in live recording or improperly closed file
		
	if (fps->params.fp->len == UH_BYTES_m13)  // no actual entries, zero is correct
		return_m13(TRUE_m13);
	
	if (warning_given == FALSE_m13) {  // don't give this warning for every file
		G_warning_message_m13("%s(): file header not complete.\nThis can occur if the file is still being recorded, or was not closed properly.\n", __FUNCTION__);
		warning_given = TRUE_m13;
	}
	
	uh = fps->uh;
	n_entries = 0;
	maximum_entry_size = 0;
	free_fps2 = FALSE_m13;
	switch (uh->type_code) {
		case VID_INDS_TYPE_CODE_m13:
		case TS_INDS_TYPE_CODE_m13:
		case REC_INDS_TYPE_CODE_m13:
			n_entries = (fps->params.fp->len - (si8) FPS_UH_BYTES_m13) / (si8) INDEX_BYTES_m13;
			maximum_entry_size = (ui4) INDEX_BYTES_m13;
			break;
		case TS_DATA_TYPE_CODE_m13:
			// see if indices known
			fps2 = NULL;
			seg = (SEG_m13 *) fps->parent;
			if (seg) {  // try using parent
				fps2 = seg->ts_inds_fps;
			} else {  // try using file name
				G_path_parts_m13(fps->path, path, name, NULL);
				sprintf_m13(path, "%s/%s.%s", path, name, TS_INDS_TYPE_STR_m13);
				G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
				fps2 = FPS_read_m13(fps2, 0, FPS_UH_ONLY_m13, 0, NULL, path, "r", NULL, fps->parent);
				if (fps2)
					free_fps2 = TRUE_m13;
				G_pop_behavior_m13();
			}
			if (fps2) {
				uh2 = fps2->uh;
				if (uh2->n_entries != 0)
					n_entries = uh2->n_entries;
				else
					n_entries = (fps2->params.fp->len - (si8) UH_BYTES_m13) / (si8) INDEX_BYTES_m13;
				--n_entries;  // don't include last index
				if (free_fps2 == TRUE_m13)
					FPS_free_m13(&fps2);
			}
			if (n_entries > 0) {  // read second block header for maximum entry size (CPS will reallocate if needed, but first block often truncated)
				// read first block header
				file_offset = FPS_UH_BYTES_m13;
				G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
				if (fseek_m13(fps->params.fp, file_offset, SEEK_SET) == -1) {
					G_pop_behavior_m13();
					break;
				}
				if (fread_m13((void *) &bh, sizeof(CMP_FIXED_BH_m13), (size_t) 1, fps->params.fp) == -1) {
					G_pop_behavior_m13();
					break;
				}
				// read second block header
				file_offset += bh.total_block_bytes;
				if (fseek_m13(fps->params.fp, file_offset, SEEK_SET) == -1) {
					G_pop_behavior_m13();
					break;
				}
				if (fread_m13((void *) &bh, sizeof(CMP_FIXED_BH_m13), (size_t) 1, fps->params.fp) == -1) {
					G_pop_behavior_m13();
					break;
				}
				maximum_entry_size = bh.total_block_bytes;
			}  // the only other option would be to read full data file counting blocks - will add this if need arises, but for now, just fail
			break;
		case VID_METADATA_TYPE_CODE_m13:
		case TS_METADATA_TYPE_CODE_m13:
			break;  // these are wirtten on close - there won't be anything to read except universal header
		case REC_DATA_TYPE_CODE_m13:
			// see if indices known
			lh = (LH_m13 *) fps->parent;  // try using parent
			fps2 = NULL;
			if (lh) {
				switch (lh->type_code) {
					case TS_SEG_TYPE_CODE_m13:
					case VID_SEG_TYPE_CODE_m13:
						fps2 = ((SEG_m13 *) lh)->rec_inds_fps;
						break;
					case TS_CHAN_TYPE_CODE_m13:
					case VID_CHAN_TYPE_CODE_m13:
						fps2 = ((CHAN_m13 *) lh)->rec_inds_fps;
						break;
					case SESS_TYPE_CODE_m13:
						fps2 = ((SESS_m13 *) lh)->rec_inds_fps;
						break;
					case SSR_TYPE_CODE_m13:
						ssr = (SSR_m13 *) lh;
						if (ssr->rec_inds_fps) {
							idx = fps - ssr->rec_data_fps[0];
							fps2 = ssr->rec_inds_fps[idx];
						}
						break;
				}
			}
			if (fps2 == NULL) {  // try using file name
				G_path_parts_m13(fps->path, path, name, NULL);
				sprintf_m13(path, "%s/%s.%s", path, name, REC_INDS_TYPE_STR_m13);
				G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
				fps2 = FPS_read_m13(fps2, 0, FPS_UH_ONLY_m13, 0, NULL, path, "r", NULL, fps->parent);
				if (fps2)
					free_fps2 = TRUE_m13;
				G_pop_behavior_m13();
			}
			if (fps2) {
				uh2 = fps2->uh;
				if (uh2->n_entries != 0)
					n_entries = uh2->n_entries;
				else
					n_entries = (fps2->params.fp->len - (si8) UH_BYTES_m13) / (si8) INDEX_BYTES_m13;
				--n_entries;  // don't include last index
				if (free_fps2 == TRUE_m13)
					FPS_free_m13(&fps2);
			}
			if (n_entries > 0)  // the only option to get true maximum record size would be to read full record data (or index) file
				maximum_entry_size = REC_LARGEST_RECORD_BYTES_m13;
			// the only other option would be to read full record data file counting records - will add this if need arises, but for now, just fail
			break;
		default:
			G_set_error_m13(E_MED_m13, NULL);
			return_m13(FALSE_m13);
	}
	
	if (n_entries <= 0 || maximum_entry_size <= 0) {
		G_set_error_m13(E_UNKN_m13, "bad entry size or number of entries");
		return_m13(FALSE_m13);
	}

	uh->n_entries = n_entries;
	uh->maximum_entry_size = maximum_entry_size;
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
ui4	G_current_behavior_m13(void)
{
	BEHAVIOR_STACK_m13	*stack;
	

	stack = G_behavior_stack_m13();
	if (stack == NULL)
		return(globals_m13->behavior_stack_list->default_behavior);
	else if (stack->top_idx == -1)
		return(globals_m13->behavior_stack_list->default_behavior);
	
	return(stack->behaviors[stack->top_idx].code);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
BEHAVIOR_m13	*G_current_behavior_entry_m13(void)
{
	BEHAVIOR_m13		*behavior;
	BEHAVIOR_STACK_m13	*stack;
	

	stack = G_behavior_stack_m13();
	if (stack == NULL)
		behavior = NULL;
	else if (stack->top_idx == -1)
		behavior = NULL;
	else
		behavior = stack->behaviors + stack->top_idx;
	
	return(behavior);
}


#if defined MACOS_m13 || defined LINUX_m13
inline si8  G_current_uutc_m13(void)
{
	struct timeval  tv;
	si8 uutc;
	

	gettimeofday(&tv, NULL);
	uutc = ((si8) tv.tv_sec * (si8) 1000000) + (si8) tv.tv_usec;
	
	return(uutc);
}
#endif


#ifdef WINDOWS_m13
si8  G_current_uutc_m13(void)
{
	static const ui8  EPOCH = (ui8) 116444736000000000;
	struct timeval  tv;
	si8 uutc, sec, usec;
	SYSTEMTIME  system_time;
	FILETIME  file_time;
	ui8 time;
	

	GetSystemTime(&system_time);
	SystemTimeToFileTime(&system_time, &file_time);
	time = ((ui8) file_time.dwLowDateTime);
	time += ((ui8) file_time.dwHighDateTime) << 32;
	
	sec = (si8) (time - EPOCH) / (si8) 10000000;
	usec = (si8) system_time.wMilliseconds * (si8) 1000;
	uutc = (sec * (si8) 1000000) + usec;
	
	return(uutc);
}
#endif


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4  G_days_in_month_m13(si4 month, si4 year)
{
	static const si4  standard_days[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
	si4 days;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Note month is [0 - 11], January == 0, as in unix struct tm.tm_mon
	// Note struct tm.tm_year is (year - 1900), this function expects the full value

	days = standard_days[month];
	
	// leap years
	if (month == 1) {  // February
		if ((year % 4) == 0) {  // leap year
			++days;
			if ((year % 100) == 0) {  // centurial exception
				--days;
				if ((year % 400) == 0) {  // centurial exception exception
					++days;
				}
			}
		}
	}
	
	return_m13(days);
}


tern	G_decrypt_metadata_m13(FPS_m13 *fps)
{
	ui1			*decryption_key, encryption_rounds;
	si1			*encryption_2, *encryption_3;
	PROC_GLOBS_m13		*proc_globs;
	PASSWORD_DATA_m13	*pwd;
	METADATA_SECTION_3_m13	*section_3;
	UH_m13			*uh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (fps == NULL) {
		G_set_error_m13(E_MET_m13, "FPS is NULL");
		return_m13(FALSE_m13);
	}
	
	uh = fps->uh;
	if (MED_VER_1_0_m13(uh) == TRUE_m13) {  // handle MED 1.0
		encryption_2 = (si1 *) uh + MED_10_METADATA_SECTION_2_ENCRYPTION_LEVEL_OFFSET_m13;
		encryption_3 = (si1 *) uh + MED_10_METADATA_SECTION_3_ENCRYPTION_LEVEL_OFFSET_m13;
		encryption_rounds = 1;
	} else {
		encryption_2 = &uh->encryption_2;
		encryption_3 = &uh->encryption_3;
		encryption_rounds = uh->encryption_rounds;
	}

	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	pwd = &proc_globs->password_data;
	
	// decrypt section 2
	if (*encryption_2 > NO_ENCRYPTION_m13) {  // natively & currently encrypted
		if (pwd->access_level >= *encryption_2 ) {
			if (uh->encryption_2 == LEVEL_1_ENCRYPTION_m13)
				decryption_key = pwd->level_1_encryption_key;
			else
				decryption_key = pwd->level_2_encryption_key;
			AES_decrypt_m13(fps->params.raw_data + METADATA_SECTION_2_OFFSET_m13, METADATA_SECTION_2_BYTES_m13, NULL, decryption_key, encryption_rounds);
			*encryption_2 = -(*encryption_2);  // mark as currently decrypted
		} else {
			G_show_password_hints_m13(pwd, *encryption_2);
			G_set_error_m13(E_ENC_m13, "Section 2 of the metadata is encrypted at level %hhd => cannot decrypt", *encryption_2);
			return_m13(FALSE_m13);
		}
	}

	// decrypt section 3
	if (*encryption_3 > NO_ENCRYPTION_m13) {  // natively & currently encrypted
		if (pwd->access_level >= *encryption_3) {
			if (uh->encryption_3 == LEVEL_1_ENCRYPTION_m13)
				decryption_key = pwd->level_1_encryption_key;
			else
				decryption_key = pwd->level_2_encryption_key;
			AES_decrypt_m13(fps->params.raw_data + METADATA_SECTION_3_OFFSET_m13, METADATA_SECTION_3_BYTES_m13, NULL, decryption_key, encryption_rounds);
			*encryption_3 = -(*encryption_3);  // mark as currently decrypted
		} else {
			proc_globs->time_constants.RTO_known = FALSE_m13;
			proc_globs->time_constants.set = TRUE_m13;  // set to defaults
			return_m13(TRUE_m13);  // MED functions without section 3, so return TRUE_m13
		}
	}
	
	// set global time data (section 3 unencrypted if get here)
	if (proc_globs->time_constants.set == FALSE_m13) {
		section_3 = &fps->metadata->section_3;
		proc_globs->time_constants.recording_time_offset = section_3->recording_time_offset;
		proc_globs->time_constants.standard_UTC_offset = section_3->standard_UTC_offset;
		strncpy_m13(proc_globs->time_constants.standard_timezone_acronym, section_3->standard_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m13);
		strncpy_m13(proc_globs->time_constants.standard_timezone_string, section_3->standard_timezone_string, TIMEZONE_STRING_BYTES_m13);
		strncpy_m13(proc_globs->time_constants.daylight_timezone_acronym, section_3->daylight_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m13);
		strncpy_m13(proc_globs->time_constants.daylight_timezone_string, section_3->daylight_timezone_string, TIMEZONE_STRING_BYTES_m13);
		if ((proc_globs->time_constants.daylight_start_code.value = section_3->daylight_time_start_code.value) == DTCC_VALUE_NOT_OBSERVED_m13)
			proc_globs->time_constants.observe_DST = FALSE_m13;
		else
			proc_globs->time_constants.observe_DST = TRUE_m13;
		proc_globs->time_constants.RTO_known = TRUE_m13;
		proc_globs->time_constants.daylight_end_code.value = section_3->daylight_time_end_code.value;
		proc_globs->time_constants.set = TRUE_m13;
	}

	return_m13(TRUE_m13);
}


tern	G_decrypt_record_data_m13(FPS_m13 *fps, ...)  // varargs (fps == NULL): REC_HDR_m13 *rh, si8 n_records
{
	ui1			*encryption_key, encryption_rounds;
	si8			i, n_records;
	va_list			v_args;
	REC_HDR_m13		*rh;
	PASSWORD_DATA_m13	*pwd;
	PROC_GLOBS_m13		*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// always returns TRUE_m13 - failed decryption on per record basis may be expected
	
	if (fps == NULL) {
		va_start(v_args, fps);
		rh = va_arg(v_args, REC_HDR_m13 *);
		n_records = va_arg(v_args, si8);
		va_end(v_args);
	} else {
		rh = (REC_HDR_m13 *) fps->rec_data;
		n_records = fps->n_items;
	}
	if (n_records == 0)  // failure == all records unreadable, not no records
		return_m13(TRUE_m13);
	
	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	pwd = &proc_globs->password_data;
	encryption_rounds = fps->uh->encryption_rounds;

	for (i = 0; i < n_records; ++i) {
		if (rh->encryption_level > NO_ENCRYPTION_m13) {
			if (pwd->access_level >= rh->encryption_level) {
				if (rh->encryption_level == LEVEL_1_ENCRYPTION_m13)
					encryption_key = pwd->level_1_encryption_key;
				else
					encryption_key = pwd->level_2_encryption_key;
				AES_decrypt_m13((ui1 *) rh + REC_HDR_BYTES_m13, rh->total_record_bytes - REC_HDR_BYTES_m13, NULL, encryption_key, encryption_rounds);
				rh->encryption_level = -rh->encryption_level;  // mark as currently decrypted
			}
		}
		rh = (REC_HDR_m13 *) ((ui1 *) rh + rh->total_record_bytes);
	}

	return_m13(TRUE_m13);
}


tern G_decrypt_time_series_data_m13(FPS_m13 *fps)
{
	static tern			warning_delivered = FALSE_m13;
	ui1				*key, encryption_rounds;
	si1				enc_level;
	si8 i, encryption_bytes, encryptable_bytes, n_items;
	CPS_m13				*cps;
	CMP_FIXED_BH_m13	*bh;
	PASSWORD_DATA_m13		*pwd;
	PROC_GLOBS_m13		*proc_globs;
	UH_m13		*uh;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (fps == NULL) {
		G_set_error_m13(E_MET_m13, "FPS is NULL");
		return_m13(FALSE_m13);
	}
	uh = fps->uh;
	enc_level = uh->encryption_1;
	if (enc_level == NO_ENCRYPTION_m13)
		return_m13(TRUE_m13);
	
	cps = fps->params.cps;
	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	pwd = &proc_globs->password_data;
	if (pwd->access_level >= enc_level) {
		if (enc_level == LEVEL_1_ENCRYPTION_m13)
			key = pwd->level_1_encryption_key;
		else
			key = pwd->level_2_encryption_key;
	} else {
		if (warning_delivered == FALSE_m13) {
			G_warning_message_m13("%s(): Cannot decrypt data => returning without decrypting\n", __FUNCTION__);
			warning_delivered = TRUE_m13;
		}
		return_m13(FALSE_m13);
	}

	// decrypt
	bh = cps->block_header;
	n_items = fps->n_items;
	encryption_rounds = uh->encryption_rounds;
	for (i = n_items; i--;) {
		
		// check if block already decrypted
		if (!(bh->block_flags & CMP_BF_ENCRYPTED_m13)) {
			bh = (CMP_FIXED_BH_m13 *) ((ui1 *) bh + bh->total_block_bytes); // set pointer to next block
			continue;
		}
		  
		// calculate encryption bytes
		encryptable_bytes = bh->total_block_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m13;
		if (bh->block_flags | CMP_BF_MBE_ENCODING_m13) {
			encryption_bytes = encryptable_bytes;
		} else {
			encryption_bytes = (bh->total_header_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m13) + ENCRYPTION_BLOCK_BYTES_m13;
			if (encryption_bytes > encryptable_bytes)
				encryption_bytes = encryptable_bytes;
		}
		
		// decrypt
		AES_decrypt_m13((ui1 *) bh + CMP_BLOCK_ENCRYPTION_START_OFFSET_m13, encryption_bytes, NULL, key, encryption_rounds);
		
		// mark block as decrypted
		bh->block_flags &= ~CMP_BF_ENCRYPTED_m13;
		
		// set pointer to next block
		bh = (CMP_FIXED_BH_m13 *) ((ui1 *) bh + bh->total_block_bytes);
	}
	
	return_m13(TRUE_m13);
}


tern  	G_decrypt_video_data_m13(FPS_m13 *fps)
{
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_delete_behavior_stack_m13(void)
{
	BEHAVIOR_STACK_LIST_m13		*list;
	BEHAVIOR_STACK_m13		*stack;


	stack = G_behavior_stack_m13();
	if (stack == NULL)
		return;
	
	// reduce list search extents
	list = globals_m13->behavior_stack_list;
	if (stack == *(list->stack_ptrs + list->top_idx))
		--list->top_idx;
	
	// reset stack for re-use (leave size intact, behaviors allocated)
	stack->_id = 0;
	stack->top_idx = -1;

	return;
}

#ifdef FT_DEBUG_m13
#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_delete_function_stack_m13(void)
{
	FUNCTION_STACK_LIST_m13		*list;
	FUNCTION_STACK_m13		*stack;

	
	stack = G_function_stack_m13(0);
	if (stack == NULL)
		return;
	
	// reduce list search extents
	list = globals_m13->function_stack_list;
	if (stack == *(list->stack_ptrs + list->top_idx))
		--list->top_idx;
	
	// reset stack for re-use (leave size intact, functions allocated)
	stack->_id = stack->_pid = 0;
	stack->top_idx = -1;

	return;
}
#endif  // FT_DEBUG_m13


si4 G_DST_offset_m13(si8 uutc)
{
	si4 i, month, DST_start_month, DST_end_month;
	si4 first_weekday_of_month, target_day_of_month, last_day_of_month;
	time_t  utc, local_utc, change_utc;
	struct tm time_info = { 0 }, change_time_info = { 0 };
	DAYLIGHT_TIME_CHANGE_CODE_m13	*first_DTCC, *last_DTCC, *change_DTCC;
	PROC_GLOBS_m13		*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns seconds to add to standard time (as UUTC) to adjust for DST on that date, in the globally specified timezone
	proc_globs = G_proc_globs_m13(NULL);  // find proc globals by process id
	if (proc_globs->time_constants.set == FALSE_m13) {
		G_warning_message_m13("%s(): library time constants not set\n", __FUNCTION__);
		return_m13(0);
	}
	if (proc_globs->time_constants.observe_DST != TRUE_m13)
		return_m13(0);
	if (proc_globs->time_constants.daylight_start_code.value == DTCC_VALUE_NO_ENTRY_m13) {
		G_warning_message_m13("%s(): daylight change data not available\n", __FUNCTION__);
		return_m13(0);
	}

	utc = uutc / (si8) 1000000;
	
	// get broken out time info
#if defined MACOS_m13 || defined LINUX_m13
	if (proc_globs->time_constants.daylight_start_code.reference_time == DTCC_LOCAL_REFERENCE_TIME) {
		local_utc = utc + (si8) proc_globs->time_constants.standard_UTC_offset;
		gmtime_r(&local_utc, &time_info);
	} else {
		gmtime_r(&utc, &time_info);
	}
#endif
#ifdef WINDOWS_m13
	if (proc_globs->time_constants.daylight_start_code.reference_time == DTCC_LOCAL_REFERENCE_TIME) {
		local_utc = utc + (si8) proc_globs->time_constants.standard_UTC_offset;
		time_info = *(gmtime(&local_utc));
	} else {
		time_info = *(gmtime(&utc));
	}
#endif
	
	month = time_info.tm_mon;
	DST_start_month = proc_globs->time_constants.daylight_start_code.month;
	DST_end_month = proc_globs->time_constants.daylight_end_code.month;
	if (DST_start_month < DST_end_month) {
		first_DTCC = &proc_globs->time_constants.daylight_start_code;
		last_DTCC = &proc_globs->time_constants.daylight_end_code;
	} else {
		first_DTCC = &proc_globs->time_constants.daylight_end_code;
		last_DTCC = &proc_globs->time_constants.daylight_start_code;
	}
	
	// take care of dates not in change months
	if (month != DST_start_month && month != DST_end_month) {
		if (month > first_DTCC->month && month < last_DTCC->month) {
			if (first_DTCC->month == DST_start_month)
				return_m13((si4) first_DTCC->shift_minutes * (si4) 60);
			else
				return_m13(0);
		} else if (month < first_DTCC->month) {
			if (first_DTCC->month == DST_start_month)
				return_m13(0);
			else
				return_m13((si4) first_DTCC->shift_minutes * (si4) 60);
		} else {  // month > last_DTCC->month
			if (last_DTCC->month == DST_end_month)
				return_m13(0);
			else
				return_m13((si4) first_DTCC->shift_minutes * (si4) 60);
		}
	}
	
	// get change utc
	if (month == first_DTCC->month)
		change_DTCC = first_DTCC;
	else
		change_DTCC = last_DTCC;
	
	change_time_info.tm_hour = change_DTCC->hours_of_day;
	change_time_info.tm_mon = month;
	change_time_info.tm_year = time_info.tm_year;
	
	if (change_DTCC->day_of_month == DTCC_DAY_OF_MONTH_NO_ENTRY) { // get target day of month
		first_weekday_of_month = time_info.tm_wday - ((time_info.tm_mday - 1) % 7);
		target_day_of_month = (change_DTCC->day_of_week - first_weekday_of_month) + 1;
		if (target_day_of_month < 1)
			target_day_of_month += 7;
		if (change_DTCC->relative_weekday_of_month == DTCC_LAST_RELATIVE_WEEKDAY_OF_MONTH) {
			last_day_of_month = G_days_in_month_m13(month, time_info.tm_year + 1900);
			while (target_day_of_month <= last_day_of_month)
				target_day_of_month += 7;
			target_day_of_month -= 7;
		} else {
			for (i = 1; i < change_DTCC->relative_weekday_of_month; ++i)
				target_day_of_month += 7;
		}
		change_time_info.tm_mday = target_day_of_month;
	} else {
		change_time_info.tm_mday = change_DTCC->day_of_month;
	}
	
#if defined MACOS_m13 || defined LINUX_m13
	change_utc = timegm(&change_time_info);
#endif
#ifdef WINDOWS_m13
	change_utc = _mkgmtime(&change_time_info);
#endif
	if (proc_globs->time_constants.daylight_start_code.reference_time == DTCC_LOCAL_REFERENCE_TIME)
		change_utc -= proc_globs->time_constants.standard_UTC_offset;
	
	if (change_DTCC->month == DST_start_month) {
		if (utc >= change_utc)
			return_m13((si4) change_DTCC->shift_minutes * (si4) 60);
		else
			return_m13(0);
	} else {  // change_DTCC->month == DST_end_month
		if (utc < change_utc)
			return_m13((si4) change_DTCC->shift_minutes * (si4) -60);
		else
			return_m13(0);
	}
	
	return_m13(0);
}


tern	G_encrypt_metadata_m13(FPS_m13 *fps)
{
	ui1			*encryption_key;
	PASSWORD_DATA_m13	*pwd;
	METADATA_m13		*md;
	PROC_GLOBS_m13	*proc_globs;
	UH_m13	*uh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	pwd = &proc_globs->password_data;
	md = fps->metadata;
	uh = fps->uh;

	// section 2 encrypt
	if (uh->encryption_2 < NO_ENCRYPTION_m13) {  // natively encrypted and currently decrypted
		if (pwd->access_level >= -uh->encryption_2) {
			uh->encryption_2 = -uh->encryption_2;  // mark as currently encrypted
			if (uh->encryption_2 == LEVEL_1_ENCRYPTION_m13)
				encryption_key = pwd->level_1_encryption_key;
			else
				encryption_key = pwd->level_2_encryption_key;
			AES_encrypt_m13((ui1 *) &md->section_2, METADATA_SECTION_2_BYTES_m13, NULL, encryption_key, uh->encryption_rounds);
		}
	}
	
	// section 3 encrypt
	if (uh->encryption_3 < NO_ENCRYPTION_m13) {  // natively encrypted and currently decrypted
		if (pwd->access_level >= -uh->encryption_3) {
			uh->encryption_3 = -uh->encryption_3;  // mark as currently encrypted
			if (uh->encryption_3 == LEVEL_1_ENCRYPTION_m13)
				encryption_key = pwd->level_1_encryption_key;
			else
				encryption_key = pwd->level_2_encryption_key;
			AES_encrypt_m13((ui1 *) &md->section_3, METADATA_SECTION_3_BYTES_m13, NULL, encryption_key, uh->encryption_rounds);
		}
	}
	
	return_m13(TRUE_m13);
}


tern	G_encrypt_record_data_m13(FPS_m13 *fps)
{
	ui1			*encryption_key;
	si8			i;
	PASSWORD_DATA_m13	*pwd;
	REC_HDR_m13	*rh;
	PROC_GLOBS_m13	*proc_globs;
	UH_m13	*uh;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	pwd = &proc_globs->password_data;
	rh = (REC_HDR_m13 *) fps->rec_data;
	uh = fps->uh;

	for (i = fps->n_items; i--;) {
		if (rh->encryption_level < NO_ENCRYPTION_m13) {
			rh->encryption_level = -rh->encryption_level;  // mark as currently encrypted
			if (rh->encryption_level == LEVEL_1_ENCRYPTION_m13)
				encryption_key = pwd->level_1_encryption_key;
			else
				encryption_key = pwd->level_2_encryption_key;
			AES_encrypt_m13((ui1 *) rh + REC_HDR_BYTES_m13, rh->total_record_bytes - REC_HDR_BYTES_m13, NULL, encryption_key, uh->encryption_rounds);
		}
		rh = (REC_HDR_m13 *) ((ui1 *) rh + rh->total_record_bytes);
	}
	
	return_m13(TRUE_m13);
}
		
		
tern G_encrypt_time_series_data_m13(FPS_m13 *fps)
{
	static tern			warning_delivered = FALSE_m13;
	ui1				*key, encryption_rounds;
	si1				enc_level;
	si8				i, encryptable_bytes, encryption_bytes;
	PASSWORD_DATA_m13		*pwd;
	CMP_FIXED_BH_m13	*bh;
	PROC_GLOBS_m13		*proc_globs;
	UH_m13		*uh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (fps == NULL) {
		G_set_error_m13(E_MET_m13, "FPS is NULL");
		return_m13(FALSE_m13);
	}

	uh = fps->uh;
	enc_level = uh->encryption_1;
	if (enc_level == NO_ENCRYPTION_m13)
		return_m13(TRUE_m13);

	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	pwd = &proc_globs->password_data;
	if (pwd->access_level >= enc_level) {
		if (enc_level == LEVEL_1_ENCRYPTION_m13)
			key = pwd->level_1_encryption_key;
		else
			key = pwd->level_2_encryption_key;
	} else {
		if (warning_delivered == FALSE_m13) {
			G_warning_message_m13("%s(): Cannot encrypt data => returning without encrypting\n", __FUNCTION__);
			warning_delivered = TRUE_m13;
		}
		return_m13(FALSE_m13);
	}

	bh = (CMP_FIXED_BH_m13 *) fps->ts_data;
	encryption_rounds = uh->encryption_rounds;
	for (i = fps->n_items; i--;) {
			
		// check if block already encrypted
		if (bh->block_flags & CMP_BF_ENCRYPTED_m13) {
			bh = (CMP_FIXED_BH_m13 *) ((ui1 *) bh + bh->total_block_bytes);
			continue;
		}
		
		// calculate encryption bytes
		encryptable_bytes = bh->total_block_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m13;
		if (bh->block_flags | CMP_BF_MBE_ENCODING_m13) {
			encryption_bytes = encryptable_bytes;
		} else {
			encryption_bytes = (bh->total_header_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m13) + ENCRYPTION_BLOCK_BYTES_m13;
			if (encryption_bytes > encryptable_bytes)
				encryption_bytes = encryptable_bytes;
		}
		
		// encrypt
		AES_encrypt_m13((ui1 *) bh + CMP_BLOCK_ENCRYPTION_START_OFFSET_m13, encryption_bytes, NULL, key, encryption_rounds);

		// mark block as encrypted
		bh->block_flags |= CMP_BF_ENCRYPTED_m13;

		bh = (CMP_FIXED_BH_m13 *) ((ui1 *) bh + bh->total_block_bytes);
	}
	
	return_m13(TRUE_m13);
}
		
		
tern  	G_encrypt_video_data_m13(FPS_m13 *fps)
{
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	return_m13(TRUE_m13);
}


#if defined MACOS_m13 || defined LINUX_m13
tern	G_enter_ascii_password_m13(si1 *password, si1 *prompt, tern confirm_no_entry, sf8 timeout_secs, tern create_password)
{
	si1		pw_copy[MAX_ASCII_PASSWORD_STRING_BYTES_m13], dc[8];
	const si4	MAX_ATTEMPTS = 3;
	si4		i, c, attempts;
	struct termios	term, saved_term;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// pass timeout_secs == 0.0 for no timeout

	if (password == NULL) {
		G_set_error_m13(E_UNKN_m13, "password is NULL");
		return_m13(FALSE_m13);
	}
		
	if (prompt == NULL)
		prompt = "Enter Password";
	else if (*prompt == 0)
		prompt = "Enter Password";
	
	// get settings of STDIN_FILENO and copy for resetting
	tcgetattr(STDIN_FILENO, &term);
	saved_term = term;
	
	// unset the echo bit in the termios struct (displays "key" character)
	term.c_lflag &= ~(ECHO);
	
	// set the new bits
	tcsetattr(STDIN_FILENO, TCSANOW, &term);
	
	
ENTER_ASCII_PASSWORD_RETRY_1_m13:
		
	if (timeout_secs > (sf8) 0.0) {
		struct timeval	tv;
		fd_set		fds;
		si4		fds_ready;
		
		printf_m13("%s %s[%0.1lfs timeout]%s: ", prompt, TC_GREEN_m13, timeout_secs, TC_RESET_m13);
		fflush(stdout);

		// set timeout
		tv.tv_sec = (time_t) timeout_secs;
		timeout_secs -= (sf8) tv.tv_sec;
		tv.tv_usec = (time_t) (timeout_secs * (sf8) 1e6);

		// wait for keyboard entry
		FD_ZERO(&fds);
		FD_SET(0, &fds);
		fds_ready = select(1, &fds, NULL, NULL, &tv);  // just the stdin read descriptor
		if (fds_ready <= 0) {  // timed out
			putchar_m13('\n'); fflush(stdout);
			tcsetattr(STDIN_FILENO, TCSANOW, &saved_term);  // reset terminal
			return_m13(FALSE_m13);
		}
	} else {
		printf_m13("%s: ", prompt); fflush(stdout);
	}

	// read password from the console
	i = 0;
	while ((c = getchar()) != '\n' && c != EOF && i < MAX_PASSWORD_CHARACTERS_m13) {
		// check that it is acceptable character
		if (c < 33 || c > 126 || c == '\"' || c == '\'') {
			putchar_m13(7);  // beep
			continue;
		}
		password[i++] = c;
	}
	password[i] = 0;
	putchar_m13('\n');
	if (*password == 0) {
		if (confirm_no_entry == TRUE_m13) {
			printf_m13("\tIs %s<no entry>%s correct (y/n): ", TC_RED_m13, TC_RESET_m13);
			fflush(stdout);
			*dc = 0;
			scanf("%[^\n]", dc);
			getchar();  // clear '\n' from stdin
			putchar_m13(*dc);
		} else {
			*dc = 'y';
		}
		if (*dc == 'y' || *dc == 'Y') {
			putchar_m13('\n');
			tcsetattr(STDIN_FILENO, TCSANOW, &saved_term);
			return_m13(TRUE_m13);  // user intends no entry so return TRUE. Calling function should decide what to do with no password.
		} else {
			putchar_m13('\n');
			goto ENTER_ASCII_PASSWORD_RETRY_1_m13;
		}
	}

	// confirm
	attempts = 0;
	if (create_password == TRUE_m13) {
		
	ENTER_ASCII_PASSWORD_RETRY_2_m13:
		
		printf_m13("Re-enter password: ");
		i = 0;
		while ((c = getchar())!= '\n' && c != EOF && i < MAX_PASSWORD_CHARACTERS_m13){
			// check that it is acceptable character
			if (c < 33 || c > 126 || c == '\"' || c == '\'') {
				putchar_m13(7);  // beep
				continue;
			}
			pw_copy[i++] = c;
		}
		pw_copy[i] = 0;
		putchar_m13('\n');
		if (strcmp_m13(password, pw_copy)) {
			if (++attempts == MAX_ATTEMPTS) {
				printf_m13("%sPasswords do not match. Maximum attempts made.\n%s", TC_RED_m13, TC_RESET_m13);
				tcsetattr(STDIN_FILENO, TCSANOW, &saved_term);
				return_m13(FALSE_m13);
			}
			printf_m13("%sPasswords do not match. Try again.\n%s", TC_RED_m13, TC_RESET_m13);
			goto ENTER_ASCII_PASSWORD_RETRY_2_m13;
		}
	}
	
	// reset terminal
	tcsetattr(STDIN_FILENO, TCSANOW, &saved_term);
	
	return_m13(TRUE_m13);
}
#endif  // MACOS_m13 || LINUX_m13


#ifdef WINDOWS_m13
tern	G_enter_ascii_password_m13(si1* password, si1* prompt, tern confirm_no_entry, sf8 timeout_secs, tern create_password)
{
	si1		pw_copy[MAX_ASCII_PASSWORD_STRING_BYTES_m13];
	const si4	MAX_ATTEMPTS = 3;
	si4		i, c, dc, primary_attempts, match_attempts;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// pass timeout_secs == 0.0 for no timeout
	if (password == NULL) {
		G_set_error_m13(E_UNKN_m13, "password is NULL");
		return_m13(FALSE_m13);
	}
	
	if (prompt == NULL)
		prompt = "Enter password";
	else if (*prompt == 0)
		prompt = "Enter password";
	
	primary_attempts = 0;
	ENTER_ASCII_PASSWORD_RETRY_1_m13:
	
	if (timeout_secs > (sf8) 0.0) {
		struct timeval	tv;
		fd_set		fds;
		si4		fds_ready;
		
		printf_m13("%s %s[%0.1lfs timeout]%s: ", prompt, TC_GREEN_m13, timeout_secs, TC_RESET_m13);
		fflush(stdout);
		
		// set timeout
		tv.tv_sec = (time_t) timeout_secs;
		timeout_secs -= (sf8) tv.tv_sec;
		tv.tv_usec = (time_t) (timeout_secs * (sf8) 1e6);

		// wait for keyboard entry
		FD_ZERO(&fds);
		FD_SET(0, &fds);
		fds_ready = select(1, &fds, NULL, NULL, &tv);  // just the read descriptor
		if (fds_ready <= 0)
			return_m13(FALSE_m13);
	} else {
		printf_m13("%s: ", prompt); fflush(stdout);
	}
	
	// read password from the console
	*password = 0;
	i = 0;
	while (i < MAX_PASSWORD_CHARACTERS_m13) {
		c = _getch();
		// carriage return or CTRL-C (finished)
		if (c == '\r' || c == 3) {
			putch_m13('\r'); putch_m13('\n');
			password[i] = 0;
			break;
		}
		// backspace
		if (c == '\b') {
			if (i) {
				putch_m13('\b'); putch_m13(' '); putch_m13('\b');
				password[--i] = 0;
				continue;
			}
			// else fall through to bad character
		}
		// check that it is acceptable character
		if (c < 33 || c > 126 || c == '\"' || c == '\'') {
			putch_m13(7);  // beep
			continue;
		}
		putch_m13(c);
		Sleep(300);
		putch_m13('\b'); putch_m13('*');
		password[i++] = c;
	}
	
	if (*password == 0) {
		if (confirm_no_entry == TRUE_m13) {
			printf_m13("\tIs %s<no entry>%s correct (y/n): ", TC_RED_m13, TC_RESET_m13);
			fflush(stdout);
			dc = _getch();
			putch_m13(dc); putch_m13('\r'); putch_m13('\n');
		} else {
			dc = 'y';
		}
		if (dc == 'y' || dc == 'Y') {
			return_m13(TRUE_m13);  // user intends no entry so return TRUE. Calling function should decide what to do with no password.
		} else if (++primary_attempts < MAX_ATTEMPTS) {
			goto ENTER_ASCII_PASSWORD_RETRY_1_m13;
		} else {
			printf_m13("%sMaximum attempts made.\n%s", TC_RED_m13, TC_RESET_m13);
			return_m13(FALSE_m13);
		}
	}

	// confirm
	match_attempts = 0;
	if (create_password == TRUE_m13) {

	ENTER_ASCII_PASSWORD_RETRY_2_m13:

		printf_m13("Re-enter password: ");
		i = 0;

		pw_copy[0] = 0;
		i = 0;
		while (i < MAX_PASSWORD_CHARACTERS_m13) {
			c = _getch();
			// carriage return or CTRL-C (finished)
			if (c == '\r' || c == 3) {
				putch_m13('\r'); putch_m13('\n');
				pw_copy[i] = 0;
				break;
			}
			// backspace
			if (c == '\b') {
				if (i) {
					putch_m13('\b'); putch_m13(' '); putch_m13('\b');
					password[--i] = 0;
					continue;
				}
				// else fall through to bad character
			}
			// check that it is acceptable character
			if (c < 33 || c > 126 || c == '\"' || c == '\'') {
				putch_m13(7);  // beep
				continue;
			}
			putch_m13(c);
			Sleep(300);
			putch_m13('\b'); putch_m13('*');
			pw_copy[i++] = c;
		}

		if (strcmp_m13(password, pw_copy)) {
			if (++match_attempts == MAX_ATTEMPTS) {
				if (++primary_attempts < MAX_ATTEMPTS) {
					printf_m13("%sPasswords do not match. Re-enter password.\n%s", TC_RED_m13, TC_RESET_m13);
					goto ENTER_ASCII_PASSWORD_RETRY_1_m13;
				} else {
					printf_m13("%sPasswords do not match. Maximum attempts made.\n%s", TC_RED_m13, TC_RESET_m13);
					return_m13(FALSE_m13);
				}
			}
			printf_m13("%sPasswords do not match. Try again.\n%s", TC_RED_m13, TC_RESET_m13);
			goto ENTER_ASCII_PASSWORD_RETRY_2_m13;
		}
	}

	return_m13(TRUE_m13);
}
#endif  // WINDOWS_m13


void  G_error_message_m13(const si1 *fmt, ...)
{
	ui4		behavior;
	va_list		v_args;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	behavior = G_current_behavior_m13();
	
	// RED suppressible text to stderr with option to exit program
	if (!(behavior & SUPPRESS_ERROR_OUTPUT_m13)) {
		#ifndef MATLAB_m13
		fprintf(stderr, TC_RED_m13);
		#endif
		
		va_start(v_args, fmt);
		vfprintf_m13(stderr_m13, fmt, v_args);
		va_end(v_args);
			
		#ifndef MATLAB_m13
		fprintf(stderr, TC_RESET_m13);
		fflush(stderr);
		#endif
	}
	
	if (behavior & RETURN_ON_FAIL_m13) {
		#ifdef MATLAB_m13
		mexPrintf("Exiting.\n\n");
		#else
		fprintf(stderr, "Exiting.\n\n");
		#endif
		return_void_m13;
	}
	
	exit_m13(-1);
}


si1	G_exists_m13(const si1 *path)
{
	si1			tmp_path[PATH_BYTES_m13];
	si4 			err;
	struct_stat_m13 	sb;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// can be used for files or directories
	
	if (path == NULL)
		return_m13(DOES_NOT_EXIST_m13);
	
	if (*path == 0)
		return_m13(DOES_NOT_EXIST_m13);
	
	tmp_path[0] = 0;
	G_full_path_m13(path, tmp_path);
	
	errno_reset_m13();
	err = stat_m13(tmp_path, &sb);
	if (err == -1) {
		err = errno_m13();
		if (err == ENOENT)
			return_m13(DOES_NOT_EXIST_m13);
		G_set_error_m13(E_UNKN_m13, "passed path \"%s\" resulted in error", path);
		return_m13(EXISTS_ERR_m13);
	}
	
#if defined MACOS_m13 || defined LINUX_m13
	if (S_ISDIR(sb.st_mode))
		return_m13(DIR_EXISTS_m13);
#endif
#ifdef WINDOWS_m13
	if ((sb.st_mode & S_IFMT) == S_IFDIR)
		return_m13(DIR_EXISTS_m13);
#endif
	
	return_m13(FILE_EXISTS_m13);
}


tern	G_expand_password_m13(si1 *password, si1 *password_bytes)
{
	si1	*c;
	ui4	ui4_val, m_w, m_z;
	si4	i;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// initialize random number generator with password bytes
	// fill password with replicable random values
	// (does not require G_termimal_password_bytes_m13())
	
	// seed generator
	for (c = password - 1, ui4_val = 0; *++c; ui4_val += (ui4) *c);
	m_w = (ui4) 0x80000000 + ui4_val;
	m_z = (ui4) 0x7FFFFFFF - ui4_val;

	// fill password bytes
	for (c = password_bytes, i = PASSWORD_BYTES_m13; i--;) {
		ui4_val = CMP_random_ui4_m13(&m_w, &m_z);
		*c++ = (si1) (ui4_val & (ui4) 0x000000FF);
	}
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si8	G_file_length_m13(FILE_m13 *fp, si1 *path)
{
	si4			fd;
	tern			is_stream;
	si8			len;
	struct_stat_m13		sb;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// pass either FILE pointer, or path to file
		
	if (fp) {
		is_stream = FILE_stream_m13(fp);  // fp not NULL
		if (is_stream == FALSE_m13) {
			if (fp->flags & FILE_FLAGS_LEN_m13)
				return_m13(fp->len);
		}
		fd = fileno_m13(fp);
	} else if (STR_empty_m13(path) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "both fp & path are empty");
		return_m13(-1);
	} else {
		is_stream = UNKNOWN_m13;
	}
	
	if (fp)
		fstat_m13(fd, &sb);
	else
		stat_m13(path, &sb);
	len = (si8) sb.st_size;
	
	if (is_stream == FALSE_m13)
		fp->len = len;
	
	return_m13(len);
}
		
		
si1	**G_file_list_m13(si1 **file_list, si4 *n_files, const si1 *enclosing_directory, const si1 *name, const si1 *extension, ui4 flags)
{
	tern	regex;
	si1		tmp_enclosing_directory[PATH_BYTES_m13], tmp_path[PATH_BYTES_m13];
	si1		tmp_name[PATH_BYTES_m13], tmp_extension[16], tmp_ext[16], *buffer, *c, *c2;
	si1		**tmp_ptr_ptr;
	ui4		path_parts;
	si4		i, j, n_in_files, *n_out_files;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// can be used to get a directory list also
	// file_list entries, enclosing_directory, name, & extension can contain regexp
	// if file_list is null it will be allocated
	
	n_in_files = *n_files;
	n_out_files = n_files;
	path_parts = flags & GFL_PATH_PARTS_MASK_m13;
	
	// shortcut for nothing to do (file_list passed, paths are from root, & contain no regex)
	if (file_list && n_in_files > 0) {
		if (G_check_file_list_m13(file_list, n_in_files) == TRUE_m13) {
			if ((flags & GFL_FREE_INPUT_LIST_m13) == 0) {  // caller expects a copy to be returned
				tmp_ptr_ptr = (si1 **) calloc_2D_m13((size_t) n_in_files, PATH_BYTES_m13, sizeof(si1));
				for (i = 0; i < n_in_files; ++i)
					strcpy(tmp_ptr_ptr[i], file_list[i]);
				file_list = tmp_ptr_ptr;
			}
			goto GFL_CONDITION_RETURN_DATA_m13;
		}
	}
	
	// copy incoming arguments so as not to modify, and in case they are statically allocated
	if (enclosing_directory == NULL)
		*tmp_enclosing_directory = 0;
	else
		strcpy(tmp_enclosing_directory, enclosing_directory);
	enclosing_directory = tmp_enclosing_directory;
				
	if (name == NULL)
		*tmp_name = 0;
	else
		strcpy(tmp_name, name);
	name = tmp_name;
	
	if (extension == NULL)
		*tmp_extension = 0;
	else
		strcpy(tmp_extension, extension);
	extension = tmp_extension;
	
	// file list passed:
	// If list components do not have a file name, and one is passed, it is used.
	// If list components do not have a file name, and none is passed, "*" is used.
	// If list components do not have an enclosing directory, and one is passed, it is used.
	// If list components do not have an enclosing directory, and none is passed, G_full_path_m13() is used.
	// If list components do not have an extension, and one is passed, it is used.
	// If list components do not have an extension, and none is passed, none is used.
	regex = FALSE_m13;
	if (file_list) {
		tmp_ptr_ptr = (si1 **) calloc_2D_m13((size_t) n_in_files, PATH_BYTES_m13, sizeof(si1));
		// copy file_list
		for (i = 0; i < n_in_files; ++i) {
			// check for regex
			if (regex == FALSE_m13)
				regex = STR_contains_regex_m13(file_list[i]);
			// fill in list entry path components
			G_path_parts_m13(file_list[i], tmp_path, NULL, tmp_ext);
			if (*tmp_path == 0) {
				if (*enclosing_directory == 0)
					sprintf_m13(tmp_ptr_ptr[i], "%s/%s", enclosing_directory, file_list[i]);
				else
					G_full_path_m13(file_list[i], file_list[i]);
				
			} else {
				strcpy(tmp_ptr_ptr[i], file_list[i]);
			}
			if (*tmp_ext == 0 && *extension)
				sprintf_m13(tmp_ptr_ptr[i], "%s.%s", tmp_ptr_ptr[i], extension);
		}
		if (flags & GFL_FREE_INPUT_LIST_m13)
			free_2D_m13((void **) file_list, n_in_files);
		file_list = tmp_ptr_ptr;
	}

	// no file_list passed (+/- enclosing_directory, +/- name, +/- extension, are passed instead)
	// If no enclosing_directory passed, G_full_path_m130() is used.
	// If no name is passed, "*" is used.
	// If no extension is passed, none is used.
	else {  // file_list == NULL
		file_list = (si1 **) calloc_2D_m13((size_t) 1, PATH_BYTES_m13, sizeof(si1));
		G_full_path_m13(enclosing_directory, (si1 *) enclosing_directory);
		enclosing_directory = (const si1 *) tmp_enclosing_directory;
		if (*name)
			sprintf_m13(file_list[0], "%s/%s", enclosing_directory, name);
		else
			sprintf_m13(file_list[0], "%s/*", enclosing_directory);
		if (*extension)
			sprintf_m13(file_list[0], "%s.%s", file_list[0], extension);
		n_in_files = 1;
		if (STR_contains_regex_m13(file_list[0]) == TRUE_m13)
			regex = TRUE_m13;
	}

	// expand regex (use system shell to expand regex)
	if (regex == TRUE_m13) {
		
	#if defined MACOS_m13 || defined LINUX_m13
		si1		*command;
		si4		ret_val;
		size_t		len;

		len = n_in_files * PATH_BYTES_m13;
		if (flags & GFL_INCLUDE_INVISIBLE_m13)
			len <<= 1;
		len += 16;
		command = (si1 *) malloc((size_t) len);
		#ifdef MACOS_m13
		strcpy(command, "/bin/ls -1d");
		#endif
		#ifdef LINUX_m13
		strcpy(command, "/usr/bin/ls -1d");
		#endif
		for (i = 0; i < n_in_files; ++i) {
			STR_escape_chars_m13(file_list[i], (si1) 0x20, PATH_BYTES_m13);  // escape spaces
			STR_escape_chars_m13(file_list[i], (si1) 0x27, PATH_BYTES_m13);  // escape apostrophes
			STR_escape_chars_m13(file_list[i], (si1) 0x60, PATH_BYTES_m13);  // escape grave accent
			len = sprintf_m13(command, "%s %s", command, file_list[i]);
			if (flags & GFL_INCLUDE_INVISIBLE_m13) {
				G_path_parts_m13(file_list[i], NULL, (si1 *) name, (si1 *) extension);
				len = sprintf_m13(command, "%s %s/.%s", command, enclosing_directory, name);  // explicitly include hidden files & directories with a prepended "."
				if (*extension)
					len = sprintf_m13(command, "%s.%s", command, extension);
			}
		}
		free_2D_m13((void **) file_list, n_in_files);

		buffer = NULL;
		G_push_behavior_m13(SUPPRESS_ERROR_OUTPUT_m13 | IGNORE_SYSTEM_ERRORS_m13 | RETURN_ON_FAIL_m13);
		ret_val = system_pipe_m13(&buffer, 0, command, SP_SEPARATE_STREAMS_m13, NULL, 0);  // NULL because don't actually want error output
		G_pop_behavior_m13();
		free((void *) command);
		if (ret_val || STR_empty_m13(buffer) == TRUE_m13) {
			*n_out_files = 0;
			if (buffer)
				free_m13((void *) buffer);
			return_m13(NULL);
		}

		// count expanded file list
		c = buffer;
		*n_out_files = 0;
		while (*c++) {
			if (*c == '\n')
				++(*n_out_files);
		}
		if (*n_out_files == 0) {
			free_m13((void *) buffer);
			return_m13(NULL);
		}

		// re-allocate
		file_list = (si1 **) calloc_2D_m13((size_t) *n_out_files, PATH_BYTES_m13, sizeof(si1));
		
		// build file list
		c = buffer;
		for (i = 0; i < *n_out_files; ++i) {
			c2 = file_list[i];
			while (*c != '\n')
				*c2++ = *c++;
			*c2 = 0;
			++c;
		}
	#endif  // MACOS_m13 || LINUX_m13
		
	#ifdef WINDOWS_m13
		buffer = NULL;
		*n_out_files = WN_ls_1d_to_buf_m13(file_list, n_in_files, TRUE_m13, &buffer);
		free_m13((void *) file_list);
		if (*n_out_files <= 0) {  // error
			*n_out_files = 0;
			return_m13(NULL);
		}

		// re-allocate
		file_list = (si1 **) calloc_2D_m13((size_t) *n_out_files, PATH_BYTES_m13, sizeof(si1));
		
		// build file list
		c = buffer;
		for (i = 0; i < *n_out_files; ++i) {
			c2 = file_list[i];
			while (*c != '\n' && *c != '\r')
				*c2++ = *c++;
			*c2 = 0;
			if (*c == '\r')
				++c;
			++c;
		}
	#endif  // WINDOWS_m13
		
		free_m13((void *) buffer);
	}

GFL_CONDITION_RETURN_DATA_m13:
	
	// return requested path parts
	for (i = j = 0; i < *n_out_files; ++i) {
		G_path_parts_m13(file_list[i], (si1 *) enclosing_directory, (si1 *) name, (si1 *) extension);
		if ((flags & GFL_INCLUDE_INVISIBLE_m13) == 0)  // exclude invisible files
			if (*name == '.')
				continue;
		if ((flags & GFL_INCLUDE_PARITY_m13) == 0)  // exclude parity files
			if (strncmp_m13(name, "parity", 6) == 0)
				continue;
		switch (path_parts) {
			case GFL_FULL_PATH_m13:
				if (i != j)
					strcpy(file_list[j], file_list[i]);
				break;
			case (GFL_PATH_m13 | GFL_NAME_m13):
				sprintf_m13(file_list[j], "%s/%s", enclosing_directory, name);
				break;
			case (GFL_NAME_m13 | GFL_EXTENSION_m13):
				sprintf(file_list[j], "%s.%s", name, extension);
				break;
			case GFL_NAME_m13:
				strcpy(file_list[j], name);
				break;
			default:
				G_set_error_m13(E_UNKN_m13, "unrecognized path component combination (path_parts == 0x%08x)", path_parts);
				return_m13(NULL);
		}
		++j;
	}
	*n_out_files = j;

	// sort file list (so results are consistent across operating systems)
	STR_sort_m13(file_list, *n_out_files);

	return_m13(file_list);
}


FILE_TIMES_m13	*G_file_times_m13(FILE_m13 *fp, si1 *path, FILE_TIMES_m13 *ft, tern set_time)
{
	FILE	*std_fp;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (fp == NULL && STR_empty_m13(path) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "both fp & path are empty");
		return_m13(NULL);
	}

	std_fp = NULL;
	if (fp) {
		if (FILE_stream_m13(fp) == TRUE_m13)
			std_fp = (FILE *) fp;
		else
			std_fp = fp->fp;
	}

	// caller must free
	if (ft == NULL)
		ft = (FILE_TIMES_m13 *) malloc_m13(sizeof(FILE_TIMES_m13));

#if defined MACOS_m13 || defined LINUX_m13
	si4		fd;
	struct_stat_m13	sb;
	struct timeval 	set_times[2] = {0};
	
	
	// set times: access and modification only
	if (set_time == TRUE_m13) {
		// set access & modification times to current time
		if (ft == NULL) {
			gettimeofday(set_times, NULL);
			set_times[1] = set_times[0];
		} else {  // use passed times (if non-zero)
			if (ft->access) {
				set_times[0].tv_sec = ft->access / (si8) 1000000;
				set_times[0].tv_usec = ft->access % (si8) 1000000;
			}
			if (ft->modification) {
				set_times[1].tv_sec = ft->modification / (si8) 1000000;
				set_times[1].tv_usec = ft->modification % (si8) 1000000;
			}
		}
	}
	
	if (std_fp == NULL) {
		stat(path, &sb);
	} else {
		fd = fileno(std_fp);
		fstat(fd, &sb);
	}

	#ifdef MACOS_m13
		#ifdef _DARWIN_FEATURE_64_BIT_INODE
			ft->creation = ((si8) sb.st_birthtimespec.tv_sec * (si8) 1000000) + ((si8) sb.st_birthtimespec.tv_nsec / (si8) 1000);
		#else
			ft->creation = ((si8) sb.st_ctimespec.tv_sec * (si8) 1000000) + ((si8) sb.st_ctim.tv_nsec / (si8) 1000);  // time of last status change - may be creation time - not guaranteed
		#endif
		ft->access = ((si8) sb.st_atimespec.tv_sec * (si8) 1000000) + ((si8) sb.st_atimespec.tv_nsec / (si8) 1000);
		ft->modification = ((si8) sb.st_mtimespec.tv_sec * (si8) 1000000) + ((si8) sb.st_mtimespec.tv_nsec / (si8) 1000);
	#endif
	#ifdef LINUX_m13
		ft->creation = ((si8) sb.st_ctim.tv_sec * (si8) 1000000) + ((si8) sb.st_ctim.tv_nsec / (si8) 1000);  // time of last status change - may be creation time - not guaranteed
		ft->access = ((si8) sb.st_atim.tv_sec * (si8) 1000000) + ((si8) sb.st_atim.tv_nsec / (si8) 1000);
		ft->modification = ((si8) sb.st_mtim.tv_sec * (si8) 1000000) + ((si8) sb.st_mtim.tv_nsec / (si8) 1000);
	#endif

	// set times: access and modification only
	if (set_time == TRUE_m13) {
		if (set_times[0].tv_sec == 0) {
			set_times[0].tv_sec = ft->access / (si8) 1000000;
			set_times[0].tv_usec = ft->access % (si8) 1000000;
		}
		if (set_times[1].tv_sec == 0) {
			set_times[1].tv_sec = ft->modification / (si8) 1000000;
			set_times[1].tv_usec = ft->modification % (si8) 1000000;
		}
		utimes(path, set_times);
	}
	
	return_m13(ft);
#endif  // MACOS_m13 || LINUX_m13

#ifdef WINDOWS_m13
	si4		fd;
	HANDLE		file_h;
	FILETIME	win_create_time, win_access_time, win_modify_time;
	FILETIME	set_access_time, set_modify_time;
	SYSTEMTIME 	sys_time;
	
	
	if (set_time == TRUE_m13) {
		if (ft == NULL) {
			GetSystemTime(&sys_time);
			SystemTimeToFileTime(&sys_time, &set_access_time);
			set_modify_time = set_access_time;
		} else {
			set_access_time = WN_uutc_to_win_time_m13(ft->access);
			set_modify_time = WN_uutc_to_win_time_m13(ft->modification);
		}
	}

	if (std_fp == NULL) {
		if ((file_h = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE) {
			G_set_error_m13(E_UNKN_m13, "CreateFile failed with error %d", GetLastError());
			return_m13(NULL);
		}
	} else {
		fd = _fileno(std_fp);
		if ((file_h = (HANDLE) _get_osfhandle(fd)) == INVALID_HANDLE_VALUE) {
			G_set_error_m13(E_UNKN_m13, "get_osfhandle failed with error %d", GetLastError());
			return_m13(NULL);
		}
	}
	
	if (set_time == TRUE_m13) {
		if (!SetFileTime(file_h, NULL, &set_access_time, &set_modify_time)) {
			G_set_error_m13(E_UNKN_m13, "SetFileTime failed with error %d", GetLastError());
			return_m13(NULL);
		}
	}

	if (!GetFileTime(file_h, &win_create_time, &win_access_time, &win_modify_time)) {
		G_set_error_m13(E_UNKN_m13, "GetFileTime failed with error %d", GetLastError());
		return_m13(NULL);
	}
	
	if (ft == NULL) {
		ft = (FILE_TIMES_m13 *) malloc_m13(sizeof(FILE_TIMES_m13));
		if (ft == NULL)
			return_m13(NULL);
	}

	ft->creation = WN_time_to_uutc_m13(win_create_time);
	ft->access = WN_time_to_uutc_m13(win_access_time);
	ft->modification = WN_time_to_uutc_m13(win_modify_time);
	
	if (std_fp == NULL)
		CloseHandle(file_h);
	
	return_m13(ft);
#endif
}


CONTIGUON_m13	*G_find_discontinuities_m13(LH_m13 *lh, si8 *n_contigua)
{
	si1					tmp_str[PATH_BYTES_m13];
	si4					i, start_seg_num, end_seg_num, seg_idx, n_segs, last_seg_num;
	si8					j, k, nc, n_indices, *sample_offsets;
	sf8					samp_period, sf8_samps;
	FPS_m13					**tsi_fps;
	PROC_GLOBS_m13			*proc_globs;
	TS_IDX_m13			*tsi, *last_tsi;
	TS_METADATA_SECTION_2_m13	*md2;
	SEG_m13				*seg;
	CHAN_m13				*chan;
	SESS_m13				*sess;
	CONTIGUON_m13				*contigua;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// The difference between this function & G_build_contigua_m13(), is that this does not use time slice as delimiter for returned contigua.
	// Caller is responsible for freeing contigua.
	
	switch (lh->type_code) {
		case TS_SEG_TYPE_CODE_m13:
			seg = (SEG_m13 *) lh;
			chan = NULL;
			start_seg_num = end_seg_num = seg->metadata_fps->uh->segment_number;
			break;
		case TS_CHAN_TYPE_CODE_m13:
		case SESS_TYPE_CODE_m13:
			proc_globs = G_proc_globs_m13(lh);
			if (lh->type_code == TS_CHAN_TYPE_CODE_m13) {
				chan = (CHAN_m13 *) lh;
			} else {
				chan = proc_globs->current_session.index_channel;
				if (chan->type_code != TS_CHAN_TYPE_CODE_m13) {
					sess = (SESS_m13 *) lh;
					chan = sess->ts_chans[0];
				}
			}
			start_seg_num = 1;
			end_seg_num = proc_globs->current_session.n_segments;
			break;
		case VID_CHAN_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
			G_set_error_m13(E_UNKN_m13, "not coded for video channels yet");
			return_m13(NULL);
		default:
			G_set_error_m13(E_UNKN_m13, "invalid level type");
			return_m13(NULL);
	}

	n_segs = (end_seg_num - start_seg_num) + 1;
	tsi_fps = (FPS_m13 **) calloc((size_t) n_segs, sizeof(FPS_m13 *));
	sample_offsets = (si8 *) malloc((size_t) n_segs * sizeof(si8));
	
	// get time series indices & sample offsets
	seg_idx = G_segment_index_m13(start_seg_num, lh);
	samp_period = (sf8) 0.0;
	for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
		if (chan) {
			seg = chan->segs[j];
			sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, TS_INDS_TYPE_STR_m13);
			seg->ts_inds_fps = FPS_read_m13(seg->ts_inds_fps, 0, FPS_FULL_FILE_m13, 0, NULL, tmp_str, "r", NULL, NULL);
			sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, TS_INDS_TYPE_STR_m13);
			seg->metadata_fps = FPS_read_m13(seg->metadata_fps, 0, FPS_FULL_FILE_m13, 0, NULL, tmp_str, "r", NULL, NULL);
		}
		tsi_fps[i] = seg->ts_inds_fps;
		md2 = &seg->metadata_fps->metadata->time_series_section_2;
		sample_offsets[i] = md2->session_start_sample_number;
		if (samp_period == (sf8) 0.0)
			samp_period = (sf8) 1e6 / md2->sampling_frequency;
	}
	
	// count contigua
	nc = 0;
	for (i = 0; i < n_segs; ++i) {
		tsi = tsi_fps[i]->ts_inds;
		n_indices = tsi_fps[i]->uh->n_entries - 1;  // exclude terminal index
		for (j = 0; j < n_indices; ++j)
			if (tsi[j].file_offset < 0)
				++nc;
	}
	contigua = (CONTIGUON_m13 *) calloc_m13((size_t) nc, sizeof(CONTIGUON_m13));
	
	// start first contiguon
	tsi = tsi_fps[0]->ts_inds;
	contigua[0].start_time = tsi[0].start_time;
	contigua[0].start_samp_num = 0;
	contigua[0].start_seg_num = start_seg_num;
	nc = 0;
	last_tsi = tsi;
	last_seg_num = 1;

	// fill in contigua
	for (i = start_seg_num, j = 0; i <= end_seg_num; ++i, ++j) {
		tsi = tsi_fps[j]->ts_inds;
		n_indices = tsi_fps[j]->uh->n_entries - 1;  // exclude terminal index
		for (k = 0; k < n_indices; ++k) {
			// make sample numbers global
			tsi[k].start_samp_num += sample_offsets[j];
			if (tsi[k].file_offset < 0) {
				// skip first block encountered, as it is a duplicate of contigua[0]'s start info
				if (k == 0 && j == 0) {
					last_tsi = tsi + k;
					last_seg_num = i;
					continue;
				}
				// finish last contiguon
				sf8_samps = (sf8) (tsi[k].start_samp_num - last_tsi->start_samp_num);
				contigua[nc].end_time = last_tsi->start_time + (si8) ((sf8_samps * samp_period) + (sf8) 0.5);
				contigua[nc].end_samp_num = tsi[k].start_samp_num - 1;
				contigua[nc].end_seg_num = last_seg_num;
				// start new contiguon
				++nc;
				contigua[nc].start_time = tsi[k].start_time;
				contigua[nc].start_samp_num = tsi[k].start_samp_num;
				contigua[nc].start_seg_num = i;
				// nc = 0;
			}
		  last_tsi = tsi + k;
		  last_seg_num = i;
		}
	}
	// finish last contiguon (using terminal index values)
	contigua[nc].end_time = tsi[k].start_time;
	contigua[nc].end_samp_num = tsi[k].start_samp_num + sample_offsets[j - 1] - 1;
	contigua[nc].end_seg_num = last_seg_num;
	
	// clean up
	if (lh->type_code == TS_SEG_TYPE_CODE_m13)
		for (i = 0; i < n_segs; ++i)
			FPS_free_m13(tsi_fps + i);
	free((void *) tsi_fps);
	free((void *) sample_offsets);
	
	*n_contigua = nc + 1;
	
	return_m13(contigua);
}
	

si8	G_find_index_m13(SEG_m13 *seg, si8 target, ui4 mode)
{
	ui4			target_frame_number;
	si8			i, n_inds, seg_start_time, seg_end_time;
	si8			block_samples, block_duration, seg_samples, clip_frames, clip_duration, seg_frames;
	TS_IDX_m13	*tsi_base, *tsi;
	VID_IDX_m13		*vi_base, *vi;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns index containing requested time/sample
	// returns -1 if before first index
	// returns n_inds - 1 (terminal index index) if after last index
	// NO_OVERFLOWS_m13: restrict returned index to valid segment values (ORed with search type)
	// SAMPLE_SEARCH_m13: indices must be session-relative (global indexing)
	// TIME_SEARCH_m13: times must be offset uutc

	n_inds = seg->ts_inds_fps->uh->n_entries - 1;  // account for terminal index here - cleaner code below
	
	if (seg->type_code == TS_SEG_TYPE_CODE_m13) {
		tsi_base = seg->ts_inds_fps->ts_inds;
		if (mode & TIME_SEARCH_m13) {
			seg_start_time = seg->ts_inds_fps->uh->segment_start_time;
			if (target < seg_start_time) {
				if (mode & NO_OVERFLOWS_m13)
					return_m13(0);
				return_m13(-1);
			}
			seg_end_time = seg->ts_inds_fps->uh->segment_end_time;
			if (target > seg_end_time) {
				if (mode & NO_OVERFLOWS_m13)
					return_m13(n_inds - 1);
				return_m13(n_inds);
			}
			// estimate index
			block_duration = (si8) (seg->metadata_fps->metadata->time_series_section_2.maximum_block_duration + (sf8) 0.5);
			i = (target - seg_start_time) / block_duration;
			if (i > n_inds)
				i = n_inds;
			// search: exit at first index <= target
			tsi = tsi_base + i;
			if (tsi->start_time <= target) {  // forward linear search
				while (tsi->start_time <= target)
					++tsi;
				--tsi;
			} else {  // backward linear search
				while (tsi->start_time > target)
					--tsi;
			}
		} else {  //  SAMPLE_SEARCH_m13
			target -= seg->metadata_fps->metadata->time_series_section_2.session_start_sample_number;  // convert target to local indexing
			if (target < 0) {
				if (mode & NO_OVERFLOWS_m13)
					return_m13(0);
				return_m13(-1);
			}
			seg_samples = seg->metadata_fps->metadata->time_series_section_2.number_of_samples;
			if (target >= seg_samples) {
				if (mode & NO_OVERFLOWS_m13)
					return_m13(n_inds - 1);
				return_m13(n_inds);
			}
			// estimate index
			block_samples = (si8) seg->metadata_fps->metadata->time_series_section_2.maximum_block_samples;
			i = target / block_samples;
			if (i > n_inds)
				i = n_inds;
			// search: exit at first index <= target
			tsi = tsi_base + i;
			if (tsi->start_samp_num <= target) {  // forward linear search
				while (tsi->start_samp_num <= target)
					++tsi;
				--tsi;
			} else {  // backward linear search
				while (tsi->start_samp_num > target)
					--tsi;
			}
		}
		i = tsi - tsi_base;
	} else {  // LEVEL_VIDEO_SEG_m13
		vi_base = seg->vid_inds_fps->vid_inds;
		if (mode & TIME_SEARCH_m13) {
			seg_start_time = seg->vid_inds_fps->uh->segment_start_time;
			if (target < seg_start_time) {
				if (mode & NO_OVERFLOWS_m13)
					return_m13(0);
				return_m13(-1);
			}
			seg_end_time = seg->vid_inds_fps->uh->segment_end_time;
			if (target > seg_end_time) {
				if (mode & NO_OVERFLOWS_m13)
					return_m13(n_inds - 1);
				return_m13(n_inds);
			}
			// estimate index
			clip_duration = (si8) (seg->metadata_fps->metadata->video_section_2.maximum_clip_duration + (sf8) 0.5);
			i = (target - seg_start_time) / clip_duration;
			if (i > n_inds)
				i = n_inds;
			// search: exit at first index <= target
			vi = vi_base + i;
			if (vi->start_time <= target) {  // forward linear search
				while (vi->start_time <= target)
					++vi;
				--vi;
			} else {  // backward linear search
				while (vi->start_time > target)
					--vi;
			}
		} else {  //  SAMPLE_SEARCH_m13  (target frame numbers must be in absolute frame)
			target -= seg->metadata_fps->metadata->video_section_2.session_start_frame_number;  // convert target to local indexing
			if (target < 0) {
				if (mode & NO_OVERFLOWS_m13)
					return_m13(0);
				return_m13(-1);
			}
			seg_frames = seg->metadata_fps->metadata->video_section_2.number_of_frames;
			if (target >= seg_frames) {
				if (mode & NO_OVERFLOWS_m13)
					return_m13(n_inds - 1);
				return_m13(n_inds);
			}
			// estimate index
			clip_frames = (si8) seg->metadata_fps->metadata->video_section_2.maximum_clip_frames;
			i = target / clip_frames;
			// search: exit at first index <= target
			vi = vi_base + i;
			target_frame_number = (ui4) target;
			if (vi->start_frame_num <= target_frame_number) {  // forward linear search
				while (vi->start_frame_num <= target_frame_number)
					++vi;
				--vi;
			} else {  // backward linear search
				while (vi->start_frame_num > target_frame_number)
					--vi;
			}
		}
		i = vi - vi_base;
	}
	
	if (mode & NO_OVERFLOWS_m13) {
		if (i == -1)
			return_m13(0);
		else if (i == n_inds)
			return_m13(n_inds - 1);
	}
	
	return_m13(i);
}


#if defined MACOS_m13 || defined LINUX_m13
si1	*G_find_metadata_file_m13(si1 *path, si1 *md_path)
{
	tern	match;
	si1		*c, *name;
	ui4		code;
	size_t		len;
	DIR		*dir;
	struct dirent	*entry;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// large directory trees can take a long time to search with "find" or "ls"
	// cumbersome code => function unrolled for speed

	if (STR_empty_m13(path) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "path is empty");
		return_m13(NULL);
	}

	// caller responsible for freeing, if allocated
	if (md_path == NULL)
		md_path = (si1 *) malloc_m13((size_t) PATH_BYTES_m13);
	
	// find entry level
	G_full_path_m13(path, md_path);
	code = G_MED_type_code_from_string_m13(md_path);
	switch(code) {
		case SESS_TYPE_CODE_m13:
			break;
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
			goto FIND_MDF_CHAN_LEVEL_m13;
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
			goto FIND_MDF_SEG_LEVEL_m13;
		default:
			G_set_error_m13(E_MED_m13, "input path must be a MED session, channel, or segment directory");  // global error
			return_m13(NULL);
	}
	
	// session level
	dir = opendir(md_path);
	if (dir == NULL) {
		G_set_error_m13(E_UNKN_m13, "opendir() failed");
		return_m13(NULL);
	}
	match = FALSE_m13;
	while ((entry = readdir(dir))) {
		if (entry->d_type != DT_DIR)
			continue;
		name = entry->d_name;
		if (*name == '.')
			continue;
		len = strlen(name);
		if (len < 6)  // min 1 letter channel name + 5 chars for extension
			continue;
		c = name + len - 5;
		if (*c++ != '.')
			continue;
		// check for MED channel ([tv]icd extension)
		if (*c == 't' || *c == 'v') {
			if (*++c == 'i') {
				if (*++c == 'c') {
					if (*++c == 'd') {
						match = TRUE_m13;
						break;
					}
				}
			}
		}
	}
	
	if (match == FALSE_m13) {
		G_set_error_m13(E_MET_m13, NULL);  // global error
		return_m13(NULL);
	}
	
	len = strlen(md_path);
	md_path[len++] = '/';
	strcpy(md_path + len, name);
	closedir(dir);
	
FIND_MDF_CHAN_LEVEL_m13:
	dir = opendir(md_path);
	if (dir == NULL) {
		G_set_error_m13(E_UNKN_m13, "opendir() failed");
		return_m13(NULL);
	}
	match = FALSE_m13;
	while ((entry = readdir(dir))) {
		if (entry->d_type != DT_DIR)
			continue;
		name = entry->d_name;
		if (*name == '.')
			continue;
		len = strlen(name);
		if (len < 12)  // min 1 letter channel name + 6 chars for segment designation + 5 chars for extension
			continue;
		c = name + len - 5;
		if (*c++ != '.')
			continue;
		// check for MED segment ([tv]isd extension)
		if (*c == 't' || *c == 'v') {
			if (*++c == 'i') {
				if (*++c == 's') {
					if (*++c == 'd') {
						match = TRUE_m13;
						break;
					}
				}
			}
		}
	}
	
	if (match == FALSE_m13) {
		G_set_error_m13(E_MET_m13, NULL);  // global error
		return_m13(NULL);
	}
	
	len = strlen(md_path);
	md_path[len++] = '/';
	strcpy(md_path + len, name);
	closedir(dir);

FIND_MDF_SEG_LEVEL_m13:
	dir = opendir(md_path); // open the path
	if (dir == NULL) {
		G_set_error_m13(E_MET_m13, NULL);
		return_m13(NULL); // if was not able, return
	}
	match = FALSE_m13;
	while ((entry = readdir(dir))) {  // if we were able to read something from the directory
		if (entry->d_type != DT_REG && entry->d_type != DT_LNK)
			continue;
		name = entry->d_name;
		if (*name == '.')
			continue;
		len = strlen(name);
		if (len < 12)  // min 1 letter channel name + 6 chars for segment desiognation + 5 chars for extension
			continue;
		c = name + len - 5;
		if (*c++ != '.')
			continue;
		// check for MED metadata ([tv]met extension)
		if (*c == 't' || *c == 'v') {
			if (*++c == 'm') {
				if (*++c == 'e') {
					if (*++c == 't') {
						match = TRUE_m13;
						break;
					}
				}
			}
		}
	}
	
	if (match == FALSE_m13) {
		G_set_error_m13(E_MET_m13, NULL);  // global error
		return_m13(NULL);
	}
	
	len = strlen(md_path);
	md_path[len++] = '/';
	strcpy(md_path + len, name);
	closedir(dir);

	return_m13(md_path);
}
#endif  // MACOS_m13 || LINUX_m13


#ifdef WINDOWS_m13
si1	*G_find_metadata_file_m13(si1 *path, si1 *md_path)
{
	si1			*name;
	ui4			code;
	size_t			len;
	WIN32_FIND_DATAA 	ffd;
	HANDLE 		  find_h;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// large directory trees can take a long time to search with "find" or "ls"
	// cumbersome code => function unrolled for speed

	// caller responsible for freeing, if allocated
	if (md_path == NULL)
		md_path = (si1 *) malloc_m13((size_t) PATH_BYTES_m13);
	
	// find entry level
	G_full_path_m13(path, md_path);
	code = G_MED_type_code_from_string_m13(path);
	switch(code) {
		case SSR_TYPE_CODE_m13:
			G_path_parts_m13(md_path, md_path, NULL, NULL);
			code = SESS_TYPE_CODE_m13;
			break;
		case SESS_TYPE_CODE_m13:
			break;
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
			goto WIN_FIND_MDF_CHAN_LEVEL_m13;
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
			goto WIN_FIND_MDF_SEG_LEVEL_m13;
		default:
			G_set_error_m13(E_MED_m13, "input path must be a MED session, channel, or segment directory");  // global error
			return_m13(NULL);
	}
	
	// session level
	len = strlen(md_path);
	strcpy(md_path + len, "\\*.?icd");
	find_h = FindFirstFileA((LPCSTR) md_path, &ffd);
	if (find_h == INVALID_HANDLE_VALUE) {
		G_set_error_m13(E_UNKN_m13, "FindFirstFileA() failed");
		return_m13(NULL);
	}
	name = ffd.cFileName;
	while (*name == '.') {
		if (FindNextFileA(find_h, &ffd) == 0)
			return_m13(NULL);
		name = ffd.cFileName;
	}
	strcpy(md_path + len + 1, name);
	FindClose(find_h);
	
	// channel level
WIN_FIND_MDF_CHAN_LEVEL_m13:
	len = strlen(md_path);
	strcpy(md_path + len, "\\*.?isd");
	find_h = FindFirstFileA((LPCSTR) md_path, &ffd);
	if (find_h == INVALID_HANDLE_VALUE) {
		G_set_error_m13(E_UNKN_m13, "FindFirstFileA() failed");
		return_m13(NULL);
	}
	name = ffd.cFileName;
	while (*name == '.') {
		if (FindNextFileA(find_h, &ffd) == 0)
			return_m13(NULL);
		name = ffd.cFileName;
	}
	strcpy(md_path + len + 1, name);
	FindClose(find_h);

	// segment level
WIN_FIND_MDF_SEG_LEVEL_m13:
	len = strlen(md_path);
	strcpy(md_path + len, "\\*.?met");
	find_h = FindFirstFileA((LPCSTR) md_path, &ffd);
	if (find_h == INVALID_HANDLE_VALUE) {
		G_set_error_m13(E_UNKN_m13, "FindFirstFileA() failed");
		return_m13(NULL);
	}
	name = ffd.cFileName;
	while (*name == '.') {
		if (FindNextFileA(find_h, &ffd) == 0)
			return_m13(NULL);
		name = ffd.cFileName;
	}
	strcpy(md_path + len + 1, name);
	FindClose(find_h);

	return_m13(md_path);
}
#endif  // WINDOWS_m13


si8	G_find_record_index_m13(FPS_m13 *rec_inds_fps, si8 target_time, ui4 mode, si8 low_idx)
{
	si8				i, idx, n_inds, high_idx, high_time_diff, low_time_diff;
	REC_IDX_m13		*ri;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Modes (note there can be multiple records with the same start time):
	//	FIND_CLOSEST_m13: If target_time == start_time, and there are multiple indices with the
	//			  same start time, the function will return the first of these indices.
	//			  If they are equally close, the lower index will be returned.
	//	FIND_LAST_BEFORE_m13
	//	FIND_FIRST_ON_OR_AFTER_m13
	//	FIND_LAST_ON_OR_BEFORE_m13
	//	FIND_FIRST_AFTER_m13
	//
	//	low_idx: as indices are often needed in pairs, pass low_idx to reduce search time if known (if not, pass zero)

	// NOTE: this function does not currently handle record files with no terminal index
	// needs to be updated

	ri = rec_inds_fps->rec_inds;
	n_inds = rec_inds_fps->uh->n_entries;
	if (n_inds <= 1) {
		if (n_inds == 1) {
			if (ri->type_code == REC_Term_TYPE_CODE_m13)
				return_m13(NO_IDX_m13);  // only a terminal index, no records
		} else {
			return_m13(NO_IDX_m13); // no records
		}
	}

	if (target_time < ri[low_idx].start_time) {
		switch (mode) {
			case FIND_FIRST_AFTER_m13:
			case FIND_CLOSEST_m13:
			case FIND_FIRST_ON_OR_AFTER_m13:
				return_m13(low_idx);
			// "on" or "before" condition impossible
			case FIND_LAST_ON_OR_BEFORE_m13:
			case FIND_LAST_BEFORE_m13:
				return_m13(NO_IDX_m13);
			default:
				G_set_error_m13(E_UNKN_m13, "unsupported mode (%u)", mode);
				return_m13(NO_IDX_m13);
		}
	}
	high_idx = n_inds - 1;
	if (ri[high_idx].type_code == REC_Term_TYPE_CODE_m13)
		--high_idx;  // last true index (only a terminal index handled above)
	if (target_time >= ri[high_idx].start_time) {
		switch (mode) {
			case FIND_CLOSEST_m13:
			case FIND_LAST_BEFORE_m13:
			case FIND_LAST_ON_OR_BEFORE_m13:
				return_m13(high_idx);
			// "on" or "after" condition impossible
			case FIND_FIRST_ON_OR_AFTER_m13:
			case FIND_FIRST_AFTER_m13:
				return_m13(NO_IDX_m13);
		}
	}
	if (low_idx == high_idx)
		return_m13(low_idx);
	
	// binary search
	do {
		idx = (low_idx + high_idx) >> 1;
		if (ri[idx].start_time > target_time)
			high_idx = idx;
		else
			low_idx = idx;
	} while ((high_idx - low_idx) > 1);
	if (target_time >= ri[high_idx].start_time)
		idx = high_idx;
	else if (target_time < ri[high_idx].start_time)
		idx = low_idx;
	// search exits with idx == FIND_LAST_ON_OR_BEFORE_m13 condition
	// i.e. where:  ri[idx].start_time <= target_time < ri[idx + 1].start_time
	// i.e. the last index where target_time >= index start_time

	switch (mode) {
		case FIND_CLOSEST_m13:
			low_time_diff = target_time - ri[idx].start_time;
			high_time_diff = ri[idx + 1].start_time - target_time;
			if (high_time_diff < low_time_diff)
				++idx;  // advance to first record of next time
			else
				for (i = idx - 1; ri[i].start_time == ri[idx].start_time; idx = i--);  // rewind to first record of this time
			break;
		case FIND_LAST_BEFORE_m13:
			if (target_time == ri[idx].start_time) {
				for (i = idx - 1; ri[i].start_time == ri[idx].start_time; idx = i--);  // rewind to first record of this time
				--idx;  // step back to last record of last time
			}
			// there may be other records with the same time preceding this one
			break;
		case FIND_FIRST_ON_OR_AFTER_m13:
			if (target_time == ri[idx].start_time)  // "on" condition
				for (i = idx - 1; ri[i].start_time == ri[idx].start_time; idx = i--);  // rewind to first record of this time
			else
				++idx;  // advance to first record of next time
		case FIND_LAST_ON_OR_BEFORE_m13:
			break;  // no rewind: there may be other records with the same time preceding this one
		case FIND_FIRST_AFTER_m13:
			++idx;  // advance to first record of next time
			break;
	}
	
	return_m13(idx);
}


si8 G_frame_number_for_uutc_m13(LH_m13 *lh, si8 target_uutc, ui4 mode, ...)  // varargs: si8 ref_frame_number, si8 ref_uutc, sf8 frame_rate
{
	tern			terminal_index;
	si1			tmp_str[PATH_BYTES_m13], num_str[FILE_NUMBERING_DIGITS_m13 + 1];
	si4			seg_num, seg_idx;
	si8			n_inds, i, absolute_numbering_offset;
	si8			ref_frame_number, ref_uutc, test_time;
	sf8			tmp_sf8, frame_rate, rounded_frame_num, frame_num_eps;
	ui4			mask;
	va_list			v_args;
	PROC_GLOBS_m13		*proc_globs;
	SEG_m13			*seg;
	CHAN_m13		*chan;
	SESS_m13		*sess;
	VID_IDX_m13		*vi;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// G_frame_number_for_uutc_m13(NULL, si8 target_uutc, ui4 mode, si8 ref_index, si8 ref_uutc, sf8 frame_rate);
	// returns frame number extrapolated from ref_frame_number (relative / absolute is determined by magnitude of reference values)
	
	// G_frame_number_for_uutc_m13(seg, target_uutc, mode);
	// returns frame number extrapolated from closest video index in reference frame specified by mode
	
	// mode FIND_ABSOLUTE_m13 (default): session relative frame numbering
	// mode FIND_RELATIVE_m13: segment relative frame numbering
	// mode FIND_CURRENT_m13 (default): frame period within which the target_uutc falls
	// mode FIND_CLOSEST_m13: frame number closest to the target_uutc
	// mode FIND_NEXT_m13: frame number following the frame period within which the target_uutc falls ( == FIND_CURRENT_m13 + 1)
	// mode FIND_PREVIOUS_m13: frame number preceding the frame period within which the target_uutc falls ( == FIND_CURRENT_m13 - 1)

	if (lh == NULL) {  // reference points passed
		va_start(v_args, mode);
		ref_frame_number = va_arg(v_args, si8);
		ref_uutc = va_arg(v_args, si8);
		frame_rate = va_arg(v_args, sf8);
		va_end(v_args);
		absolute_numbering_offset = 0;
		vi = NULL;
	} else {  // level header passed
		proc_globs = G_proc_globs_m13(lh);
		switch (lh->type_code) {
			case VID_SEG_TYPE_CODE_m13:
				seg = (SEG_m13 *) lh;
				break;
			case VID_CHAN_TYPE_CODE_m13:
			case SESS_TYPE_CODE_m13:
				seg_num = G_segment_for_uutc_m13(lh, target_uutc);
				seg_idx = G_segment_index_m13(seg_num, lh);
				if (seg_idx == FALSE_m13)
					return_m13(FRAME_NUMBER_NO_ENTRY_m13);
				if (lh->type_code == VID_CHAN_TYPE_CODE_m13) {
					chan = (CHAN_m13 *) lh;
				} else {
					chan = proc_globs->current_session.index_channel;
					if (chan->type_code != VID_CHAN_TYPE_CODE_m13) {
						sess = (SESS_m13 *) lh;
						chan = sess->vid_chans[0];
					}
				}
				seg = chan->segs[seg_idx];
				break;
			case TS_CHAN_TYPE_CODE_m13:
			case TS_SEG_TYPE_CODE_m13:
				return_m13(G_sample_number_for_uutc_m13(lh, target_uutc, mode));
			default:
				G_set_error_m13(E_UNKN_m13, "invalid level type");
				return_m13(FRAME_NUMBER_NO_ENTRY_m13);
		}
		if (seg == NULL) {  // channel or session
			STR_fixed_width_int_m13(num_str, FILE_NUMBERING_DIGITS_m13, seg_num);
			sprintf_m13(tmp_str, "%s/%s_s%s.%s", chan->path, chan->name, num_str, VID_SEG_TYPE_STR_m13);
			seg = chan->segs[seg_idx] = G_open_segment_m13(NULL, NULL, tmp_str, (LH_m13 *) chan, chan->flags, NULL);
			if (seg == NULL)
				return_m13(FRAME_NUMBER_NO_ENTRY_m13);
		}

		vi = seg->vid_inds_fps->vid_inds;
		if (vi == NULL) {
			G_set_error_m13(E_UNKN_m13, "video indices are NULL");
			return_m13(FRAME_NUMBER_NO_ENTRY_m13);
		}
		n_inds = seg->vid_inds_fps->uh->n_entries;
		if (seg->vid_inds_fps->uh->segment_end_time > 0) {
			--n_inds;  // account for terminal index here - cleaner code below
			terminal_index = TRUE_m13;
		} else {
			terminal_index = FALSE_m13;
		}
		if (mode & FIND_RELATIVE_m13)
			absolute_numbering_offset = 0;
		else  // FIND_ABSOLUTE_m13 (default)
			absolute_numbering_offset = seg->metadata_fps->metadata->video_section_2.session_start_frame_number;

		// condition target
		if (target_uutc < 0)  // relative time
			target_uutc = proc_globs->current_session.start_time - target_uutc;
		test_time = target_uutc - proc_globs->time_constants.recording_time_offset;
		if (test_time > 0 && target_uutc != END_OF_TIME_m13)  // end time is not offset
			target_uutc = test_time;

		// get index
		i = G_find_index_m13(seg, target_uutc, TIME_SEARCH_m13);
		if (i == -1)  // target time earlier than segment start => return segment start sample
			return_m13(absolute_numbering_offset);

		vi += i;
		if (i == n_inds) {  // target time later than segment end => return segment end sample number
			--vi;
			if (terminal_index == TRUE_m13)
				return_m13((vi->start_frame_num - 1) + absolute_numbering_offset);
		}
		ref_frame_number = vi->start_frame_num;
		ref_uutc = vi->start_time;
		if (terminal_index == FALSE_m13 && i == n_inds) {
			frame_rate = seg->metadata_fps->metadata->video_section_2.frame_rate / (sf8) 1e6;
		} else {
			++vi;
			frame_rate = (sf8) (vi->start_frame_num - ref_frame_number) / (sf8) (vi->start_time - ref_uutc);  // frames per microsecond
		}
	}
	
	// round up if very close to next frame
	tmp_sf8 = (sf8) (target_uutc - ref_uutc) * frame_rate;
	rounded_frame_num = (sf8) ((si8) (tmp_sf8 + (sf8) 0.5));
	frame_num_eps = rounded_frame_num - tmp_sf8;
	if (frame_num_eps > (sf8) 0.0)
		if (frame_num_eps < FRAME_NUMBER_EPS_m13)
			tmp_sf8 = rounded_frame_num;
	
	mask = (ui4) (FIND_CLOSEST_m13 | FIND_NEXT_m13 | FIND_CURRENT_m13 | FIND_PREVIOUS_m13);
	switch (mode & mask) {
		case FIND_CLOSEST_m13:
			tmp_sf8 += (sf8) 0.5;
			break;
		case FIND_NEXT_m13:
			tmp_sf8 += (sf8) 1.0;
			break;
		case FIND_PREVIOUS_m13:
			if (tmp_sf8 >= (sf8) 1.0)
				tmp_sf8 -= (sf8) 1.0;
			break;
		case FIND_CURRENT_m13:
		default:
			break;
	}
	
	return_m13(ref_frame_number + (si8) tmp_sf8 + absolute_numbering_offset);
}


tern	G_free_channel_m13(CHAN_m13 **chan_ptr)
{
	si4			i;
	PROC_GLOBS_m13		*proc_globs;
	CHAN_m13		*chan;
	SEG_m13			*seg;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns FALSE_m13 if does not free channel
	
	if (chan_ptr == NULL) {
		G_set_error_m13(E_UNKN_m13, "chan_ptr is NULL");
		return_m13(FALSE_m13);
	}
	chan = *chan_ptr;
	if (chan_ptr == NULL) {
		G_set_error_m13(E_UNKN_m13, "chan is NULL");
		return_m13(FALSE_m13);
	}

	if (chan->segs) {
		proc_globs = G_proc_globs_m13((LH_m13 *) chan);
		for (i = 0; i < proc_globs->current_session.n_mapped_segments; ++i) {
			seg = chan->segs[i];
			if (seg)
				G_free_segment_m13(&seg);
		}
		free_m13((void *) chan->segs);  // ok whether allocated en bloc or not
	}
	if (chan->metadata_fps)
		FPS_free_m13(&chan->metadata_fps);
	if (chan->rec_data_fps)
		FPS_free_m13(&chan->rec_data_fps);
	if (chan->rec_inds_fps)
		FPS_free_m13(&chan->rec_inds_fps);
	if (chan->contigua)
		free_m13(chan->contigua);
	
	// delete proc_globs only if top of hierarchy, otherwise may still be used by other threads
	if (chan->parent)
		if (chan->parent->type_code == PROC_GLOBS_TYPE_CODE_m13)
			G_proc_globs_delete_m13((LH_m13 *) chan);
	
	// can't set stack addresses to NULL
	// shouldn't set en_bloc addresses to NULL
	if (chan->flags & LH_ALLOCATED_m13) {
		free_m13((void *) chan);
		*chan_ptr = NULL;
	} else {
		memset((void *) chan, 0, sizeof(CHAN_m13));
	}

	return_m13(TRUE_m13);
}


void	G_free_global_tables_m13(void)
{
	GLOBAL_TABLES_m13	*tables;
	
	
	tables = globals_m13->tables;
	if (tables == NULL)
		return;
		
	if (tables->timezone_table)
		free((void *) tables->timezone_table);
	
	if (tables->country_aliases_table)
		free((void *) tables->country_aliases_table);
	
	if (tables->country_acronym_aliases_table)
		free((void *) tables->country_acronym_aliases_table);
	
	if (tables->CRC_table)
		free((void *) tables->CRC_table);
	
	if (tables->AES_sbox_table)
		free((void *) tables->AES_sbox_table);
	
	if (tables->AES_rsbox_table)
		free((void *) tables->AES_rsbox_table);
	
	if (tables->AES_rcon_table)
		free((void *) tables->AES_rcon_table);
	
	if (tables->SHA_h0_table)
		free((void *) tables->SHA_h0_table);
	
	if (tables->SHA_k_table)
		free((void *) tables->SHA_k_table);

	if (tables->CMP_normal_CDF_table)
		free((void *) tables->CMP_normal_CDF_table);

	if (tables->CMP_VDS_threshold_map)
		free((void *) tables->CMP_VDS_threshold_map);

	if (tables->E_strings_table)
		free((void *) tables->E_strings_table);

	#ifdef WINDOWS_m13
	if (globals_m13->tables->hNTdll)
		FreeLibrary(globals_m13->tables->hNTdll);
	#endif

	// destroy mutex
	pthread_mutex_destroy_m13(&tables->mutex);
	
	free((void *) tables);
	globals_m13->tables = NULL;
	
	return;
}


void  G_free_globals_m13(tern cleanup_for_exit)
{
	si4	i;
	
	
	if (cleanup_for_exit == TRUE_m13) {
		rm_m13(globals_m13->temp_file);
		#ifdef WINDOWS_m13
		WN_cleanup_m13();
		#endif
	}
	
	if (globals_m13->record_filters) {
		// often statically allocated, so can't just free()
		// e.g. si4 rec_filts = { REC_Seiz_TYPE_CODE_m13, REC_Note_TYPE_CODE_m13, NO_TYPE_CODE_m13 };
		// proc_globs->record_filters = rec_filts;
		if (freeable_m13(globals_m13->record_filters) == TRUE_m13)
			free_m13((void *) globals_m13->record_filters);
	}
			
	if (globals_m13->behavior_stack_list) {
		for (i = 0; i < globals_m13->behavior_stack_list->size; i += GLOBALS_BEHAVIOR_STACK_SIZE_INCREMENT_m13)
			free((void *) globals_m13->behavior_stack_list->stack_ptrs[i]->behaviors);
		free((void *) globals_m13->behavior_stack_list->stack_ptrs);
		pthread_mutex_destroy_m13(&globals_m13->behavior_stack_list->mutex);
		free((void *) globals_m13->behavior_stack_list);
	}

	if (globals_m13->file_lock_list) {
		for (i = 0; i < globals_m13->file_lock_list->size; i += GLOBALS_FLOCK_LIST_SIZE_INCREMENT_m13)
			free((void *) globals_m13->file_lock_list->lock_ptrs[i]);
		free((void *) globals_m13->file_lock_list->lock_ptrs);
		pthread_mutex_destroy_m13(&globals_m13->file_lock_list->mutex);
		free((void *) globals_m13->file_lock_list);
	}

#ifdef FT_DEBUG_m13
	if (globals_m13->function_stack_list) {
		for (i = 0; i < globals_m13->function_stack_list->size; i += GLOBALS_FUNCTION_STACK_SIZE_INCREMENT_m13)
			free((void *) globals_m13->function_stack_list->stack_ptrs[i]->functions[i]);
		free((void *) globals_m13->function_stack_list->stack_ptrs);
		pthread_mutex_destroy_m13(&globals_m13->function_stack_list->mutex);
		free((void *) globals_m13->function_stack_list);
	}
#endif

	if (globals_m13->proc_globs_list) {
		for (i = 0; i < globals_m13->proc_globs_list->size; i += GLOBALS_PROC_GLOBS_LIST_SIZE_INCREMENT_m13)
			free((void *) globals_m13->proc_globs_list->proc_globs_ptrs[i]);
		free((void *) globals_m13->proc_globs_list->proc_globs_ptrs);
		pthread_mutex_destroy_m13(&globals_m13->proc_globs_list->mutex);
		free((void *) globals_m13->proc_globs_list);
	}
	
#ifdef AT_DEBUG_m13
	if (globals_m13->AT_list) {
		free_all_m13();  // display memory still allocated & free it
		free((void *) globals_m13->AT_list->entries);
		pthread_mutex_destroy_m13(&globals_m13->AT_list->mutex);
		free((void *) globals_m13->AT_list);
	}
#endif
	
	pthread_mutex_destroy_m13(&globals_m13->error.mutex);
	
	G_free_global_tables_m13();

	free((void *) globals_m13);

	return;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_free_thread_local_storage_m13(LH_m13 *lh)
{
	// Call this function to release thread-local memory when leaving a thread.
	// If not done, memory will be released by G_free_globals_m13(), or program termination.
	// Only important in programs where many threads start & complete during course of operation.
	// Currently the behavior stack, & function stack are the only (pure) thread-local globals, but this could change in the future.
	// proc_globs can be shared between threads
	
	G_delete_behavior_stack_m13();
	
#ifdef FT_DEBUG_m13
	G_delete_function_stack_m13();
#endif

	return;
}


tern	G_free_segment_m13(SEG_m13 **seg_ptr)
{
	SEG_m13		*seg;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns FALSE_m13 if did not free segment
	
	if (seg_ptr == NULL) {
		G_set_error_m13(E_UNKN_m13, "seg_ptr is NULL");
		return_m13(FALSE_m13);
	}
	seg = *seg_ptr;
	if (seg == NULL) {
		G_set_error_m13(E_UNKN_m13, "seg is NULL");
		return_m13(FALSE_m13);
	}

	if (seg->metadata_fps)
		FPS_free_m13(&seg->metadata_fps);
	if (seg->ts_data_fps)  // also does video data fps (when it exists), due to union
		FPS_free_m13(&seg->ts_data_fps);
	if (seg->ts_inds_fps)  // also does video indices, due to union
		FPS_free_m13(&seg->ts_inds_fps);
	if (seg->rec_data_fps)
		FPS_free_m13(&seg->rec_data_fps);
	if (seg->rec_inds_fps)
		FPS_free_m13(&seg->rec_inds_fps);
	if (seg->contigua)
		free_m13(seg->contigua);
	
	// delete proc_globs only if top of hierarchy, otherwise may still be used by other threads
	if (seg->parent)
		if (seg->parent->type_code == PROC_GLOBS_TYPE_CODE_m13)
			G_proc_globs_delete_m13((LH_m13 *) seg);
	
	// can't set stack addresses to NULL
	// shouldn't set en_bloc addresses to NULL
	if (seg->flags & LH_ALLOCATED_m13) {
		free_m13((void *) seg);
		*seg_ptr = NULL;
	} else {
		memset((void *) seg, 0, sizeof(SEG_m13));
	}

	return_m13(TRUE_m13);
}


tern	G_free_session_m13(SESS_m13 **sess_ptr)
{
	si4			i;
	SESS_m13 		*sess;
	CHAN_m13		*chan;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns FALSE_m13 if did not free session

	if (sess_ptr == NULL) {
		G_set_error_m13(E_UNKN_m13, "sess_ptr is NULL");
		return_m13(FALSE_m13);
	}
	sess = *sess_ptr;
	if (sess == NULL) {
		G_set_error_m13(E_UNKN_m13, "sess is NULL");
		return_m13(FALSE_m13);
	}

	if (sess->ts_metadata_fps)
		FPS_free_m13(&sess->ts_metadata_fps);
	if (sess->vid_metadata_fps)
		FPS_free_m13(&sess->vid_metadata_fps);
	if (sess->rec_data_fps)
		FPS_free_m13(&sess->rec_data_fps);
	if (sess->rec_inds_fps)
		FPS_free_m13(&sess->rec_inds_fps);
	if (sess->ts_chans) {
		for (i = 0; i < sess->n_ts_chans; ++i) {
			chan = sess->ts_chans[i];
			if (chan)
				G_free_channel_m13(&chan);
		}
		free_m13((void *) sess->ts_chans);
	}
	if (sess->vid_chans) {
		for (i = 0; i < sess->n_vid_chans; ++i) {
			chan = sess->vid_chans[i];
			if (chan)
				G_free_channel_m13(&chan);
		}
		free_m13((void *) sess->vid_chans);
	}
	if (sess->ssr)
		G_free_ssr_m13(&sess->ssr);

	if (sess->contigua)
		free_m13(sess->contigua);

	// session is always top of hierarchy, so always delete proc_globs
	G_proc_globs_delete_m13((LH_m13 *) sess);

	// can't set stack addresses to NULL
	// shouldn't set en_bloc addresses to NULL
	if (sess->flags & LH_ALLOCATED_m13) {
		free_m13((void *) sess);
		*sess_ptr = NULL;
	} else {
		memset((void *) sess, 0, sizeof(SESS_m13));
	}
	
	return_m13(TRUE_m13);
}


tern	G_free_ssr_m13(SSR_m13 **ssr_ptr)
{
	si4			i, n_segs;
	FPS_m13			*gen_fps;
	SSR_m13	*ssr;
	PROC_GLOBS_m13	*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns FALSE_m13 if did not free ssr

	if (ssr_ptr == NULL) {
		G_set_error_m13(E_UNKN_m13, "ssr_ptr is NULL");
		return_m13(FALSE_m13);
	}
	ssr = *ssr_ptr;
	if (ssr == NULL) {
		G_set_error_m13(E_UNKN_m13, "ssr is NULL");
		return_m13(FALSE_m13);
	}

	proc_globs = G_proc_globs_m13((LH_m13 *) ssr);
	n_segs = proc_globs->current_session.n_mapped_segments;
	for (i = 0; i < n_segs; ++i) {
		gen_fps = ssr->rec_inds_fps[i];
		if (gen_fps)
			FPS_free_m13(&gen_fps);
		gen_fps = ssr->rec_data_fps[i];
		if (gen_fps)
			FPS_free_m13(&gen_fps);
	}
	free_m13((void *) ssr->rec_inds_fps);
	free_m13((void *) ssr->rec_data_fps);

	if (ssr->parent)
		if (ssr->parent->type_code == PROC_GLOBS_TYPE_CODE_m13)
			G_proc_globs_delete_m13((LH_m13 *) ssr);

	if (ssr->flags & LH_ALLOCATED_m13) {
		free_m13((void *) ssr);
		*ssr_ptr = NULL;
	} else {
		memset((void *) ssr, 0, sizeof(SSR_m13));
	}

	return_m13(TRUE_m13);
}


tern	G_frequencies_vary_m13(SESS_m13 *sess)
{
	si4			i, n_chans, seg_idx;
	sf8			rate, min_rate, max_rate;
	PROC_GLOBS_m13	*proc_globs;
	CHAN_m13		*chan, *max_chan, *min_chan;
	SEG_m13		*seg;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// sets proc globals values
	// returns TRUE_m13 if any frequencies vary
	
	proc_globs = G_proc_globs_m13((LH_m13 *) sess);
	
	// check time series channels
	seg_idx = G_segment_index_m13(FIRST_OPEN_SEG_m13, (LH_m13 *) sess);
	n_chans = sess->n_ts_chans;
	proc_globs->active_channels.sampling_frequencies_vary = UNKNOWN_m13;
	proc_globs->active_channels.minimum_sampling_frequency = proc_globs->active_channels.maximum_sampling_frequency = RATE_NO_ENTRY_m13;
	proc_globs->active_channels.minimum_sampling_frequency_channel = proc_globs->active_channels.maximum_sampling_frequency_channel = NULL;
	if (n_chans) {
		for (i = 0; i < n_chans; ++i) {
			chan = sess->ts_chans[i];
			if (chan->flags & LH_CHAN_ACTIVE_m13)
				break;
		}
		if (i < n_chans) {
			min_chan = max_chan = chan;
			seg = chan->segs[seg_idx];
			min_rate = max_rate = seg->metadata_fps->metadata->time_series_section_2.sampling_frequency;
			for (++i; i < n_chans; ++i) {
				chan = sess->ts_chans[i];
				if (chan->flags & LH_CHAN_ACTIVE_m13) {
					seg = chan->segs[seg_idx];
					rate = seg->metadata_fps->metadata->time_series_section_2.sampling_frequency;
					if (min_rate > rate) {
						min_rate = rate;
						min_chan = chan;
					} else if (max_rate < rate) {
						max_rate = rate;
						max_chan = chan;
					}
				}
			}
			if (min_rate == max_rate)
				proc_globs->active_channels.sampling_frequencies_vary = FALSE_m13;
			else
				proc_globs->active_channels.sampling_frequencies_vary = TRUE_m13;
			proc_globs->active_channels.minimum_sampling_frequency = min_rate;
			proc_globs->active_channels.maximum_sampling_frequency = max_rate;
			proc_globs->active_channels.minimum_sampling_frequency_channel = min_chan;
			proc_globs->active_channels.maximum_sampling_frequency_channel = max_chan;
		}
	}

	// check video channels
	n_chans = sess->n_vid_chans;
	proc_globs->active_channels.frame_rates_vary = UNKNOWN_m13;
	proc_globs->active_channels.minimum_frame_rate = proc_globs->active_channels.maximum_frame_rate = RATE_NO_ENTRY_m13;
	proc_globs->active_channels.minimum_frame_rate_channel = proc_globs->active_channels.maximum_frame_rate_channel = NULL;
	if (n_chans) {
		for (i = 0; i < n_chans; ++i) {
			chan = sess->vid_chans[i];
			if (chan->flags & LH_CHAN_ACTIVE_m13)
				break;
		}
		if (i < n_chans) {
			min_chan = max_chan = chan;
			seg = chan->segs[seg_idx];
			min_rate = max_rate = seg->metadata_fps->metadata->video_section_2.frame_rate;
			for (++i; i < n_chans; ++i) {
				chan = sess->vid_chans[i];
				if (chan->flags & LH_CHAN_ACTIVE_m13) {
					seg = chan->segs[seg_idx];
					rate = seg->metadata_fps->metadata->video_section_2.frame_rate;
					if (min_rate > rate) {
						min_rate = rate;
						min_chan = chan;
					} else if (max_rate < rate) {
						max_rate = rate;
						max_chan = chan;
					}
				}
				if (min_rate == max_rate)
					proc_globs->active_channels.frame_rates_vary = FALSE_m13;
				else
					proc_globs->active_channels.frame_rates_vary = TRUE_m13;
				proc_globs->active_channels.minimum_frame_rate = min_rate;
				proc_globs->active_channels.maximum_frame_rate = max_rate;
				proc_globs->active_channels.minimum_frame_rate_channel = min_chan;
				proc_globs->active_channels.maximum_frame_rate_channel = max_chan;
			}
		}
	}
	
	if (proc_globs->active_channels.sampling_frequencies_vary == TRUE_m13 || proc_globs->active_channels.frame_rates_vary == TRUE_m13)
		return_m13(TRUE_m13);

	return_m13(FALSE_m13);
}


tern	G_full_path_m13(const si1 *path, si1 *full_path)
{
	tern	contains_formatting, from_root, modify_path;
	si1	tmp_path[PATH_BYTES_m13];
	si8	len;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// assumes full_path has adequate space for new path
	
	// if full_path == NULL : return T/F on path, do not modify path
	// if full_path == path : return T/F on path, do modify path
	// if full_path != path && full_path : return T/F on path, return path from root in full_path, leaving path unmodified
	
	if (path == NULL) {
		if (full_path)
			*full_path = 0;
		return_m13(FALSE_m13);
	}
	
	from_root = contains_formatting = modify_path = FALSE_m13;
	contains_formatting = STR_contains_formatting_m13(path, tmp_path);  // remove formatting
	if (full_path)
		modify_path = TRUE_m13;
	
#if defined MACOS_m13 || defined LINUX_m13
	si1	*c, *c2, base_dir[PATH_BYTES_m13];

	// already from root
	if (*tmp_path == '/')
		from_root = TRUE_m13;

	if (modify_path == FALSE_m13)
		goto PATH_FROM_ROOT_EXIT_m13;

	strcpy(full_path, tmp_path);

	// remove terminal '/' from passed path if present
	len = strlen(full_path);
	if (len)
		if (full_path[len - 1] == '/')
			full_path[--len] = 0;
	
	if (*full_path == '/')
		return_m13(TRUE_m13);
	
	// get base directory
	c = full_path;
	if (*c == '~') {
		strcpy(base_dir, getenv("HOME"));
		++c;  // skip '~'
		if (*c == '/')  // skip "~/"
			++c;
	} else {
		getcwd_m13(base_dir, PATH_BYTES_m13);
	}
	
	// drop terminal '/' from base_dir, if present
	len = strlen(base_dir);
	if (base_dir[len - 1] == '/') {
		if (len > 1)  // not at root
			base_dir[--len] = 0;
	}
	
	// handle "." & ".."
	while (*c == '.') {
		if (*(c + 1) == '.') {  // backup base_dir to previous directory
			c2 = base_dir + len;
			while (*--c2 != '/');
			if (c2 == base_dir)  // at root
				*++c2 = 0;
			else
				*c2 = 0;
			len = c2 - base_dir;
			++c;
		}
		c2 = c + 1;
		if (*c2) {
			if (*c2 == '/')
				c += 2;
			else
				break;  // ".filename" (invisible) form
		} else {
			*c = 0;  // single "."
		}
	}

	if (*c)
		sprintf_m13(full_path, "%s/%s", base_dir, c);  // Note c may overlap full_path so use sprintf_m13()
	else
		strcpy(full_path, base_dir);
#endif
	
#ifdef WINDOWS_m13
	si1		tmp_path2[PATH_BYTES_m13];
		
	len = (si8) GetFullPathNameA(tmp_path, (DWORD) PATH_BYTES_m13, tmp_path2, NULL);
	if (len == 0) {  // can't resolve path
		if (full_path != path)  // if in place, leave path intact
			*full_path = 0;
		from_root = FALSE_m13;
		goto PATH_FROM_ROOT_EXIT_m13;
	}
	
	if (strncmp_m13(tmp_path, tmp_path2, len) == 0)
		from_root = TRUE_m13;
	
	// don't modify path, just return T/F
	if (modify_path == FALSE_m13)
		goto PATH_FROM_ROOT_EXIT_m13;
	
	strcpy(full_path, tmp_path2);
#endif
	
PATH_FROM_ROOT_EXIT_m13:
	
	if (contains_formatting == TRUE_m13 && modify_path == FALSE_m13)  // only give message if not modifying path
		G_warning_message_m13("%s(): path contains formatting\n", __FUNCTION__);

	return_m13(from_root);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
FUNCTION_STACK_m13	*G_function_stack_m13(pid_t_m13 _id)
{
	si4				i, n_stacks;
	FUNCTION_STACK_LIST_m13		*list;
	FUNCTION_STACK_m13		**stack_ptr, *stack, *new_stack;


	// pass zero for current thread function stack
	
	// get arguments
	if (_id == 0)
		_id = gettid_m13();

	// get mutex
	list = globals_m13->function_stack_list;
	pthread_mutex_lock_m13(&list->mutex);

	// find stack
	_id = gettid_m13();
	stack_ptr = list->stack_ptrs;
	n_stacks = list->top_idx + 1;
	stack = NULL;
	for (i = n_stacks; i--; ++stack_ptr) {
		if ((*stack_ptr)->_id == _id) {
			stack = *stack_ptr;
			break;
		}
		if (stack)
			continue;
		if ((*stack_ptr)->top_idx == -1)  // first open stack
			stack = *stack_ptr;
	}
	
	// stack not found
	if (i == -1) {
		// create a new stack
		if (stack == NULL) {
			// expand list
			if (list->size == n_stacks) {
				n_stacks += GLOBALS_FUNCTION_STACKS_LIST_SIZE_INCREMENT_m13;
				stack_ptr = (FUNCTION_STACK_m13 **) realloc((void *) list->stack_ptrs, (size_t) n_stacks * sizeof(FUNCTION_STACK_m13 *));
				if (stack_ptr == NULL) {  // return with no changes to stacks
					pthread_mutex_unlock_m13(&list->mutex);
					G_set_error_m13(E_ALLOC_m13, NULL);
					return(NULL);
				}

				list->stack_ptrs = stack_ptr;
				stack_ptr = list->stack_ptrs + list->size;
				list->size = n_stacks;
				++list->top_idx;
				
				// allocate & initialize new stacks (note: stacks allocated en bloc)
				new_stack = (FUNCTION_STACK_m13 *) malloc((size_t) GLOBALS_BEHAVIOR_STACKS_LIST_SIZE_INCREMENT_m13 * sizeof(FUNCTION_STACK_m13));
				if (new_stack == NULL) {
					pthread_mutex_unlock_m13(&list->mutex);
					G_set_error_m13(E_ALLOC_m13, NULL);
					return(NULL);
				}
				stack_ptr = list->stack_ptrs + list->top_idx;  // list->top_idx == old size at this point
				for (i = GLOBALS_FUNCTION_STACKS_LIST_SIZE_INCREMENT_m13; i--; ++new_stack) {
					*stack_ptr++ = new_stack;  // assign stack pointer
					// initialize new stacks (functions allocated as needed)
					new_stack->top_idx = -1;
					new_stack->size = 0;
				}
			}
			stack = *(list->stack_ptrs + list->top_idx);
		}
	
		// set up stack
		stack->top_idx = -1;
		stack->_id = gettid_m13();
	}
		
	pthread_mutex_unlock_m13(&list->mutex);

	return(stack);
}


void	G_function_stack_set_pid_m13(pid_t_m13 _id, pid_t_m13 _pid)
{
#ifdef FN_DEBUG_m13
	FUNCTION_STACK_m13	*stack;
	
	// set _id stack's _pid
	
	stack = G_function_stack_m13(_id);
	if (stack == NULL)
		return;
	
	stack->_pid = _pid

#endif
	return;
}


void	G_function_stack_trap_m13(si4 sig_num)
{
	static volatile tern	trapped = FALSE_m13;
	const si1		*error_type, *error_desc;
	pid_t_m13		_id;
	ERR_m13			*err;
	FUNCTION_STACK_m13	*stack;

		
	// check if causal error set
	_id = gettid_m13();
	err = &globals_m13->error;
	pthread_mutex_lock_m13(&err->mutex);  // get error mutex
	if (err->code)
		if (err->thread_id != _id)
			trapped = TRUE_m13;
	
	// wait for error to clear or process to exit
	if (trapped == TRUE_m13) {
		while (1) {
			pthread_mutex_unlock_m13(&err->mutex);  // release error mutex
			nap_m13("100 ms");
			pthread_mutex_lock_m13(&err->mutex);  // release error mutex
			if (err->code == E_NONE_m13)
				break;
		}
	}
	trapped = TRUE_m13;
	
	switch (sig_num) {
		case SIGINT:
			error_type = "SIGINT";
			error_desc = "user interrupt";
			break;
		case SIGILL:
			error_type = "SIGILL";
			error_desc = "illegal hardware instruction";
			break;
		case SIGABRT:
			error_type = "SIGABRT";
			error_desc = "abnormal termination";
			break;
		case SIGFPE:
			error_type = "SIGFPE";
			error_desc = "floating point exception";
			break;
		case SIGSEGV:
			error_type = "SIGSEGV";
			error_desc = "memory segment violation";
			break;
		case SIGTERM:
			error_type = "SIGTERM";
			error_desc = "terminate";
			break;
		#if defined MACOS_m13 || defined LINUX_m13  // Windows signal mechanism is more limited
		case SIGBUS:
			error_type = "SIGBUS";
			error_desc = "bus error";
			break;
		case SIGKILL:
			error_type = "SIGKILL";
			error_desc = "process killed";
			break;
		case SIGQUIT:
			error_type = "SIGQUIT";
			error_desc = "process quit";
			break;
		case SIGTRAP:
			error_type = "SIGTRAP";
			error_desc = "trace trap";
			break;
		case SIGUSR1:
			error_type = "SIGUSR1";
			error_desc = "user defined signal #1";
			break;
		case SIGUSR2:
			error_type = "SIGUSR2";
			error_desc = "user defined signal #2";
			break;
		case SIGXCPU:
			error_type = "SIGXCPU";
			error_desc = "CPU time limit exceeded";
			break;
		case SIGXFSZ:
			error_type = "SIGXFSZ";
			error_desc = "file size limit exceeded";
			break;
		#endif
		default:
			sig_num = -1;
			error_type = "SIGUNKN";
			error_desc = "unrecogized signal";
			return;
	}
	
	// set error
	err->code = E_SIG_m13;
	err->signal = sig_num;
	err->line = E_UNKNOWN_LINE_m13;
	stack = G_function_stack_m13(0);
	if (stack) {
		err->function = stack->functions[stack->top_idx];
		pthread_mutex_unlock_m13(&globals_m13->function_stack_list->mutex);  // release function stack list mutex
	} else {
		err->function = (const si1 *) "<unknown>";
	}
	pthread_getname_m13(0, err->thread_name, (size_t) PROC_THREAD_NAME_LEN_DEFAULT_m13);
	err->thread_id = _id;
#ifdef MATLAB_m13
	sprintf(err->message, "%s  [%s (%d)]", error_desc, error_type, sig_num);
#else
	sprintf(err->message, "%s  %s[%s (%d)]%s", error_desc, TC_YELLOW_m13, error_type, sig_num, TC_RESET_m13);
#endif
	
	// release error mutex
	pthread_mutex_unlock_m13(&err->mutex);

	exit_m13(E_SIG_m13);  // exit_m13() shows function stack if FN_DEBUG_m13 defined

	return;
}


si1	**G_generate_numbered_names_m13(si1 **names, si1 *prefix, si4 n_names)
{
	si8 i;
	si1 number_str[FILE_NUMBERING_DIGITS_m13 + 1];
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (names == NULL) {
		names = (si1 **) calloc_2D_m13((size_t) n_names, SEG_NAME_BYTES_m13, sizeof(si1));
		if (names == NULL)
			return_m13(NULL);
	}
	
	for (i = 0; i < n_names; ++i) {
		STR_fixed_width_int_m13(number_str, FILE_NUMBERING_DIGITS_m13, i + 1);
		snprintf_m13(names[i], SEG_NAME_BYTES_m13, "%s%s", prefix, number_str);
	}
	
	return_m13(names);
}


tern	G_generate_password_data_m13(FPS_m13* fps, si1 *L1_pw, si1 *L2_pw, si1 *L3_pw, si1 *L1_pw_hint, si1 *L2_pw_hint)
{
	tern			expand_passwords;
	PASSWORD_DATA_m13	*pwd;
	ui1			hash[SHA_HASH_BYTES_m13];
	si1			L1_pw_bytes[PASSWORD_BYTES_m13] = { 0 }, L2_pw_bytes[PASSWORD_BYTES_m13] = { 0 }, L3_pw_bytes[PASSWORD_BYTES_m13] = { 0 };
	si4			i;
	PROC_GLOBS_m13	*proc_globs;
	METADATA_SECTION_1_m13	*md1;
	UH_m13	*uh;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (STR_empty_m13(L1_pw) == TRUE_m13) {  // need at least a level 1 password to generate any password data fields
		G_set_error_m13(E_UNKN_m13, "level 1 password id empty");
		return_m13(FALSE_m13);
	}
	if (STR_empty_m13(L2_pw) == TRUE_m13)
		L2_pw = NULL;
	if (STR_empty_m13(L3_pw) == TRUE_m13)
		L3_pw = NULL;
	if (STR_empty_m13(L1_pw_hint) == TRUE_m13)
		L1_pw_hint = NULL;
	if (STR_empty_m13(L2_pw_hint) == TRUE_m13)
		L2_pw_hint = NULL;

	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	pwd = &proc_globs->password_data;
	memset((void *) pwd, 0, sizeof(PASSWORD_DATA_m13));
	pwd->processed = TRUE_m13;

	// copy password hints to password data
	if (L1_pw_hint)
		strncpy_m13(pwd->level_1_password_hint, L1_pw_hint, PASSWORD_HINT_BYTES_m13);
	if (L2_pw_hint)
		strncpy_m13(pwd->level_2_password_hint, L2_pw_hint, PASSWORD_HINT_BYTES_m13);

	// copy password hints to metadata if possible
	if (fps) {
		uh = fps->uh;
		if (METADATA_CODE_m13(uh->type_code) == TRUE_m13) {
			md1 = &fps->metadata->section_1;
			if (L1_pw_hint)
				strncpy_m13(md1->level_1_password_hint, L1_pw_hint, PASSWORD_HINT_BYTES_m13);
			if (L2_pw_hint)
				strncpy_m13(md1->level_2_password_hint, L2_pw_hint, PASSWORD_HINT_BYTES_m13);
		}
		expand_passwords = uh->expanded_passwords;
	} else {
		G_warning_message_m13("%s(): fps is NULL; not copying hints & assuming expand passwords is false\n", __FUNCTION__);
		expand_passwords = FALSE_m13;
	}

	// user passed level 1 password: generate validation field and encryption key
	if (G_condition_password_m13(L1_pw, L1_pw_bytes, expand_passwords) == FALSE_m13)
		return_m13(FALSE_m13);
	
	// passed a level 1 password - at least level 1 access
	pwd->access_level = LEVEL_1_ACCESS_m13;
	
	// generate Level 1 password validation field
	SHA_hash_m13((ui1 *) L1_pw_bytes, PASSWORD_BYTES_m13, hash);
	memcpy(uh->level_1_password_validation_field, hash, PASSWORD_VALIDATION_FIELD_BYTES_m13);
	
	// generate encryption key
	AES_key_expansion_m13(pwd->level_1_encryption_key, L1_pw_bytes);
	
	// user also passed level 2 password: generate validation field and encryption key
	// level 2 encryption requires a level 1 password, even if level 1 encryption is not used
	if (L2_pw) {
		if (G_condition_password_m13(L2_pw, L2_pw_bytes, expand_passwords) == FALSE_m13)
			return_m13(FALSE_m13);
					
		// passed a level 2 password - level 2 access
		pwd->access_level = LEVEL_2_ACCESS_m13;
		
		// generate Level 2 password validation field
		SHA_hash_m13((ui1 *) L2_pw_bytes, PASSWORD_BYTES_m13, hash);
		memcpy(uh->level_2_password_validation_field, hash, PASSWORD_VALIDATION_FIELD_BYTES_m13);
		
		// exclusive or with level 1 password bytes
		for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m13; ++i)
			uh->level_2_password_validation_field[i] ^= L1_pw_bytes[i];
		
		// generate encryption key
		AES_key_expansion_m13(pwd->level_2_encryption_key, L2_pw_bytes);
	}
	
	// user also passed level 3 password for recovery: generate validation field
	if (L3_pw) {
		if (G_condition_password_m13(L3_pw, L3_pw_bytes, expand_passwords) == FALSE_m13)
			return_m13(FALSE_m13);
		
		// generate Level 3 password validation field
		SHA_hash_m13((ui1 *) L3_pw_bytes, PASSWORD_BYTES_m13, hash);
		memcpy(uh->level_3_password_validation_field, hash, PASSWORD_VALIDATION_FIELD_BYTES_m13);
		
		if (pwd->access_level == LEVEL_1_ACCESS_m13) {  // only level 1 password passed
			for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m13; ++i) // exclusive or with level 1 password bytes
				uh->level_3_password_validation_field[i] ^= L1_pw_bytes[i];
		} else {  // level 1 & level 2 passwords passed
			for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m13; ++i) // exclusive or with level 2 password bytes
				uh->level_3_password_validation_field[i] ^= L2_pw_bytes[i];
		}
	}

	return_m13(TRUE_m13);
}


si8	G_generate_recording_time_offset_m13(si8 recording_start_time_uutc)
{
	time_t			recording_start_time_utc, offset_utc_time, UTC_offset, secs_since_midnight;
	struct tm		time_info;
	PROC_GLOBS_m13	*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// receives UNOFFSET recording start time (or CURRENT_TIME_m13)
	// returns OFFSET recording start time
	
	proc_globs = G_proc_globs_m13(NULL);
	
	if (recording_start_time_uutc == CURRENT_TIME_m13) // use current system time
		recording_start_time_uutc = G_current_uutc_m13();
	
	recording_start_time_utc = recording_start_time_uutc / (si8) 1000000;
	
	// convert to same time of day in GMT
	// (can't just use localtime() because might system may not be in timezone of recording, as in conversions)
	if (proc_globs->time_constants.set == TRUE_m13) {
		UTC_offset = proc_globs->time_constants.standard_UTC_offset;
	} else {
		G_warning_message_m13("%s(): global time constants not set, using local UTC offset\n", __FUNCTION__);
#if defined MACOS_m13 || defined LINUX_m13
		localtime_r(&recording_start_time_utc, &time_info);
		UTC_offset = time_info.tm_gmtoff;  // this is offset to standard time regardless of DST status (same number if tm_isdst true or false)
#endif
#ifdef WINDOWS_m13
		TIME_ZONE_INFORMATION	win_tz_info;
		
		time_info = *(localtime(&recording_start_time_utc));
				
		GetTimeZoneInformation(&win_tz_info);
		UTC_offset = (win_tz_info.Bias + win_tz_info.StandardBias) * -60;
#endif
	}
	offset_utc_time = recording_start_time_utc + UTC_offset;
	
	// get GMT time structure
#if defined MACOS_m13 || defined LINUX_m13
	gmtime_r(&offset_utc_time, &time_info);
#endif
#ifdef WINDOWS_m13
	time_info = *(gmtime(&offset_utc_time));
#endif
	// get time from midnight, same day in GMT
	secs_since_midnight = (time_info.tm_hour * 3600) + (time_info.tm_min * 60) + time_info.tm_sec;

	// set global offset
	proc_globs->time_constants.recording_time_offset = (recording_start_time_utc - secs_since_midnight) * (si8) 1000000;
		
	if (recording_start_time_uutc == proc_globs->time_constants.recording_time_offset)	// recording started at exactly midnight local standard time
		--proc_globs->time_constants.recording_time_offset;				// this can cause problems with oUTC and BEGINNING_OF_TIME_m13 (== 0)
	proc_globs->time_constants.RTO_known = TRUE_m13;

	return_m13(recording_start_time_uutc - proc_globs->time_constants.recording_time_offset);
}


si1	*G_generate_segment_name_m13(FPS_m13 *fps, si1 *segment_name)
{
	si1	segment_number_str[FILE_NUMBERING_DIGITS_m13 + 1];
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (segment_name == NULL)  // if NULL is passed, this will be allocated, but the calling function has the responsibility to free it.
		segment_name = (si1 *) malloc_m13((size_t) SEG_NAME_BYTES_m13);
	
	STR_fixed_width_int_m13(segment_number_str, FILE_NUMBERING_DIGITS_m13, fps->uh->segment_number);
	
	snprintf_m13(segment_name, SEG_NAME_BYTES_m13, "%s_s%s", fps->uh->channel_name, segment_number_str);
	
	return_m13(segment_name);
}


ui8	G_generate_UID_m13(ui8 *uid)
{
	si4	  i;
	ui1		*ui1_p;
	static ui8  local_UID;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Note if NULL is passed for uid, this function is not thread-safe
	if (uid == NULL)
		uid = (ui8 *) &local_UID;
	ui1_p = (ui1 *) uid;
	
RESERVED_UID_VALUE_m13:
#if defined MACOS_m13 || defined LINUX_m13
	for (i = 0; i < UID_BYTES_m13; ++i)
		ui1_p[i] = (ui1) (random() % (ui8) 0x100);
#endif
#ifdef WINDOWS_m13
	for (i = 0; i < UID_BYTES_m13; ++i)
		ui1_p[i] = (ui1) ((ui4) rand() % (ui4) 0x100);
#endif
	switch (*uid) {
		case UID_NO_ENTRY_m13:
			goto RESERVED_UID_VALUE_m13;
		case CMP_BLOCK_START_UID_m13:
			goto RESERVED_UID_VALUE_m13;
	}
	
	return_m13(*uid);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern G_include_record_m13(ui4 type_code, si4 *record_filters)
{
	si1			mode;
	const si1		INCLUDE_POSITIVE = 1, EXCLUDE_NEGATIVE = -1;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// record_filters is a signed, "NULL terminated" array version of MED record type codes to include or exclude when reading records.
	// The terminal entry is NO_TYPE_CODE_m13 (== zero). NULL or no filter codes includes all records (== no filters).
	// filter modes: match positive: include
	//		 match negative: exclude
	//		 no match:
	//			all filters positive: exclude
	//			else: include
	// Note: as type codes are composed of ascii bytes values (< 0x80), it is always possible to make them negative without promotion.
	//
	// Example usage: si4	my_rec_filters[] = { REC_Sgmt_TYPE_CODE_m13, REC_Note_TYPE_CODE_m13, NO_TYPE_CODE_m13 };
	//
	// If the passed record_filters is null, the global record_filters will be used.
	// If the global record_filters are null, all records will be accepted.
	// If record_filters is a "zero-length" array (i.e. record_filters = { NO_TYPE_CODE_m13 }), all records will be accepted.

	
	if (record_filters == NULL)
		record_filters = globals_m13->record_filters;
	if (record_filters == NULL)
		return_m13(TRUE_m13);
	if (*record_filters == NO_TYPE_CODE_m13)
		return_m13(TRUE_m13);

	for (mode = 0; *record_filters; ++record_filters) {
		if (*record_filters > 0) {
			if (type_code == (si4) *record_filters)
				return_m13(TRUE_m13);
			if (mode)
				continue;
			mode = INCLUDE_POSITIVE;
		} else {
			if (type_code == -(*record_filters))
				return_m13(FALSE_m13);
			mode = EXCLUDE_NEGATIVE;
		}
	}
	
	if (mode == INCLUDE_POSITIVE)
		return_m13(FALSE_m13);
	
	return_m13(TRUE_m13);
}


//***********************************************************************//
//****************************  MED GLOBALS  ****************************//
//***********************************************************************//


tern	G_init_error_tables_m13(void)
{
	GLOBAL_TABLES_m13	*tables;
	
	
	tables = globals_m13->tables;
	if (tables->E_strings_table)
		return(TRUE_m13);

	pthread_mutex_lock_m13(&tables->mutex);
	if (tables->E_strings_table) {  // may have been done by another thread while waiting
		pthread_mutex_unlock_m13(&tables->mutex);
		return(TRUE_m13);
	}
	
	// error strings table
	tables->E_strings_table = (const si1 **) calloc((size_t) E_STR_TABLE_ENTRIES_m13, sizeof(const si1 *));
	if (tables->E_strings_table == NULL) {
		pthread_mutex_unlock_m13(&tables->mutex);
		return(FALSE_m13);
	}
	{
		const si1	*temp[E_STR_TABLE_ENTRIES_m13] = E_STR_TABLE_m13;
		memcpy((void *) tables->E_strings_table, (void *) temp, (size_t) E_STR_TABLE_ENTRIES_m13 * sizeof(const si1 *));
	}

	// error strings table
	tables->E_tags_table = (const si1 **) calloc((size_t) E_TAG_TABLE_ENTRIES_m13, sizeof(const si1 *));
	if (tables->E_tags_table == NULL) {
		pthread_mutex_unlock_m13(&tables->mutex);
		return(FALSE_m13);
	}
	{
		const si1	*temp[E_TAG_TABLE_ENTRIES_m13] = E_TAG_TABLE_m13;
		memcpy((void *) tables->E_tags_table, (void *) temp, (size_t) E_TAG_TABLE_ENTRIES_m13 * sizeof(const si1 *));
	}

	pthread_mutex_unlock_m13(&tables->mutex);

	return(TRUE_m13);
}


tern	G_init_global_tables_m13(tern init_all_tables)
{
	tern			ret_val;
	GLOBAL_TABLES_m13	*tables;
	

	ret_val = TRUE_m13;
	
	if (globals_m13->tables == NULL) {
		globals_m13->tables = (GLOBAL_TABLES_m13 *) calloc((size_t) 1, sizeof(GLOBAL_TABLES_m13));
		if (globals_m13->tables == NULL)
			return(FALSE_m13);
	}

	// initialize all table muticies
	tables = globals_m13->tables;
	pthread_mutex_init_m13(&tables->mutex, NULL);

	if (init_all_tables == TRUE_m13) {  // otherwise load on demand
		if (CRC_init_tables_m13() == FALSE_m13)  // do this before initializing hardware tables (CRC used to get machine code)
			ret_val = FALSE_m13;
		if (HW_init_tables_m13() == FALSE_m13)
			ret_val = FALSE_m13;
		if (NET_init_tables_m13() == FALSE_m13)
			ret_val = FALSE_m13;
		if (AES_init_tables_m13() == FALSE_m13)
			ret_val = FALSE_m13;
		if (SHA_init_tables_m13() == FALSE_m13)
			ret_val = FALSE_m13;
		if (CMP_init_tables_m13() == FALSE_m13)
			ret_val = FALSE_m13;
		if (G_init_timezone_tables_m13() == FALSE_m13)
			ret_val = FALSE_m13;
		if (G_init_error_tables_m13() == FALSE_m13)
			ret_val = FALSE_m13;
	} else {
		if (HW_get_endianness_m13() == FALSE_m13)  // the library is only written for little endian machines right now, so always done
			ret_val = FALSE_m13;
		if (HW_get_memory_info_m13() == FALSE_m13)  // this is needed for alloc operations, so always done
			ret_val = FALSE_m13;
		if (G_init_error_tables_m13() == FALSE_m13)  // standard MED error strings - always done
			ret_val = FALSE_m13;
		if (GLOBALS_FILE_LOCK_MODE_DEFAULT_m13)  // file locking requires CRCs
			if (CRC_init_tables_m13() == FALSE_m13)
				ret_val = FALSE_m13;
	}

	// NT dylib loaded by WN_nap_m13() if used
	#ifdef WINDOWS_m13
	tables->hNTdll = NULL;
	#endif

	return(ret_val);
}


tern	G_init_globals_m13(tern init_all_tables, si1 *app_path, ... )  // varargs (app_path) ui4 version_major, ui4 version_minor
{
	if (globals_m13)
		return(TRUE_m13);
	globals_m13 = (GLOBALS_m13 *) calloc((size_t) 1, sizeof(GLOBALS_m13));
	if (globals_m13 == NULL) {
		#ifdef MATLAB_m13
		mexErrMsgTxt("G_init_globals_m13(): calloc() failure for globals => exiting\n");
		#else
		fprintf(stderr, "%s(): calloc() failure for globals => exiting\n", __FUNCTION__);
		exit(-1);
		#endif
	}
	pthread_mutex_init_m13(&globals_m13->mutex, NULL);
	pthread_mutex_lock_m13(&globals_m13->mutex);
	
	// Allocation tracking (do this before anything else)
#ifdef AT_DEBUG_m13
	globals_m13->AT_list = (AT_LIST_m13 *) calloc((size_t) 1, sizeof(AT_LIST_m13));
	if (globals_m13->AT_list == NULL) {
		#ifdef MATLAB_m13
		mexErrMsgTxt("G_init_globals_m13(): calloc() failure for AT list => exiting\n");
		#else
		fprintf(stderr, "%s(): calloc() failure for AT list => exiting\n", __FUNCTION__);
		exit(-1);
		#endif
	}
	globals_m13->AT_list->entries = (AT_ENTRY_m13 *) calloc((size_t) GLOBALS_AT_LIST_SIZE_INCREMENT_m13, sizeof(AT_ENTRY_m13));
	if (globals_m13->AT_list->entries == NULL) {
		#ifdef MATLAB_m13
		mexErrMsgTxt("G_init_globals_m13(): calloc() failure for AT list => exiting\n");
		#else
		fprintf(stderr, "%s(): calloc() failure for AT list => exiting\n", __FUNCTION__);
		exit(-1);
		#endif
	}
	globals_m13->AT_list->top_idx = -1;
	globals_m13->AT_list->size = GLOBALS_AT_LIST_SIZE_INCREMENT_m13;
	pthread_mutex_init_m13(&globals_m13->AT_list->mutex, NULL);
	if (!(GLOBALS_BEHAVIOR_DEFAULT_m13 & SUPPRESS_MESSAGE_OUTPUT_m13)) {
		#ifdef MATLAB_m13
		mexPrintf("Allocation tracking enabled\n");
		#else
		printf("%sAllocation tracking enabled%s\n", TC_BLUE_m13, TC_RESET_m13);
		#endif
	}
#endif

	// Function Stacks (do this before anything else, except allocation tracking)
#ifdef FT_DEBUG_m13
	globals_m13->function_stack_list = (FUNCTION_STACK_LIST_m13 *) calloc((size_t) 1, sizeof(FUNCTION_STACK_LIST_m13));
	if (globals_m13->function_stack_list == NULL) {
		#ifdef MATLAB_m13
		mexErrMsgTxt("G_init_globals_m13(): calloc() failure for function stack list => exiting\n");
		#else
		fprintf(stderr, "%s(): calloc() failure for function stack list => exiting\n", __FUNCTION__);
		exit(-1);
		#endif
	}
	globals_m13->function_stack_list->top_idx = -1;
	pthread_mutex_init_m13(&globals_m13->function_stack_list->mutex, NULL);
	G_push_function_exec_m13("main");  // main doesn't push itself because it has to initialize globals first
	if ((GLOBALS_BEHAVIOR_DEFAULT_m13 & SUPPRESS_MESSAGE_OUTPUT_m13) == 0) {
		#ifdef MATLAB_m13
		mexPrintf("Function tracking enabled\n");
		#else
		printf("%sFunction tracking enabled%s\n", TC_BLUE_m13, TC_RESET_m13);
		#endif
	}
#endif

	// tables
	if (globals_m13->tables == NULL)
		G_init_global_tables_m13(init_all_tables);

	// behavior stacks
	globals_m13->behavior_stack_list = (BEHAVIOR_STACK_LIST_m13 *) calloc((size_t) 1, sizeof(BEHAVIOR_STACK_LIST_m13));
	if (globals_m13->behavior_stack_list == NULL) {
		#ifdef MATLAB_m13
		mexErrMsgTxt("G_init_globals_m13(): calloc() failure for behavior stack list => exiting\n");
		#else
		fprintf(stderr, "%s(): calloc() failure for behavior stack list => exiting\n", __FUNCTION__);
		exit(-1);
		#endif
	}
	globals_m13->behavior_stack_list->top_idx = -1;
	globals_m13->behavior_stack_list->default_behavior = DEFAULT_BEHAVIOR_m13;
	pthread_mutex_init_m13(&globals_m13->behavior_stack_list->mutex, NULL);
	
	// file locks
	if (GLOBALS_FILE_LOCK_MODE_DEFAULT_m13) {  // any file locking
		globals_m13->file_lock_list = (FLOCK_LIST_m13 *) calloc((size_t) 1, sizeof(FLOCK_LIST_m13));
		if (globals_m13->file_lock_list == NULL) {
			#ifdef MATLAB_m13
			mexErrMsgTxt("G_init_globals_m13(): calloc() failure for file lock list => exiting\n");
			#else
			fprintf(stderr, "%s(): calloc() failure for file lock list => exiting\n", __FUNCTION__);
			exit(-1);
			#endif
		}
		globals_m13->file_lock_list->top_idx = -1;
		pthread_mutex_init_m13(&globals_m13->file_lock_list->mutex, NULL);
	}
	
	// process globals
	globals_m13->proc_globs_list = (PROC_GLOBS_LIST_m13 *) calloc((size_t) 1, sizeof(PROC_GLOBS_LIST_m13));
	if (globals_m13->proc_globs_list == NULL) {
		#ifdef MATLAB_m13
		mexErrMsgTxt("G_init_globals_m13(): calloc() failure for process globals list => exiting\n");
		#else
		fprintf(stderr, "%s(): calloc() failure for process globals list => exiting\n", __FUNCTION__);
		exit(-1);
		#endif
	}
	globals_m13->proc_globs_list->top_idx = -1;
	pthread_mutex_init_m13(&globals_m13->proc_globs_list->mutex, NULL);

	// application info
	if (app_path) {
		va_list		v_args;
		
		globals_m13->app_info = (APP_INFO_m13 *) calloc((size_t) 1, sizeof(APP_INFO_m13));
		if (globals_m13->app_info == NULL) {
			#ifdef MATLAB_m13
			mexErrMsgTxt("G_init_globals_m13(): calloc() failure for application info => exiting\n");
			#else
			fprintf(stderr, "%s(): calloc() failure for application info => exiting\n", __FUNCTION__);
			exit(-1);
			#endif
		}
		
		va_start(v_args, app_path);
		globals_m13->app_info->version_major = (ui1) va_arg(v_args, ui4);  // varargs can't take single byte arguments
		globals_m13->app_info->version_minor = (ui1) va_arg(v_args, ui4);  // varargs can't take single byte arguments
		va_end(v_args);
		
		G_full_path_m13(app_path, globals_m13->app_info->path);
		G_path_parts_m13(globals_m13->app_info->path, NULL, globals_m13->app_info->name, NULL);
		
		G_file_times_m13(NULL, globals_m13->app_info->path, &globals_m13->app_info->file_times, FALSE_m13);
	}
	
	// record filters
	globals_m13->record_filters = NULL;
	
	// miscellaneous
	pthread_mutex_init_m13(&globals_m13->error.mutex, NULL);
	pthread_mutex_init_m13(&globals_m13->error.exit_mutex, NULL);
	#if defined MACOS_m13 || defined LINUX_m13
	strcpy(globals_m13->temp_dir, "/tmp");
	strcpy(globals_m13->temp_file, "/tmp/MED_junk");
	#endif
	#ifdef WINDOWS_m13
	si8	len;

	GetTempPathA(PATH_BYTES_m13, globals_m13->temp_dir);
	sprintf(globals_m13->temp_file, "%sMED_junk", globals_m13->temp_dir);
	len = strlen(globals_m13->temp_dir);
	globals_m13->temp_dir[len] = 0;  // remove trailing '\'
	#endif
	globals_m13->file_creation_umask = GLOBALS_FILE_CREATION_UMASK_DEFAULT_m13;
	globals_m13->main_id = gettid_m13();
	globals_m13->access_times = GLOBALS_ACCESS_TIMES_DEFAULT_m13;
	globals_m13->threading = GLOBALS_THREADING_DEFAULT_m13;  // used to set process_globals default (process values can be set independently)
	globals_m13->CRC_mode = GLOBALS_CRC_MODE_DEFAULT_m13;
	globals_m13->file_lock_mode = GLOBALS_FILE_LOCK_MODE_DEFAULT_m13;
	globals_m13->file_lock_timeout = GLOBALS_FILE_LOCK_TIMEOUT_DEFAULT_m13;
	globals_m13->write_sorted_records = GLOBALS_WRITE_SORTED_RECORDS_DEFAULT_m13;
	globals_m13->update_header_names = GLOBALS_UPDATE_HEADER_NAMES_DEFAULT_m13;
	globals_m13->update_MED_version = GLOBALS_UPDATE_MED_VERSION_DEFAULT_m13;
	if (globals_m13->update_header_names == TRUE_m13 || globals_m13->update_MED_version == TRUE_m13)
		pthread_mutex_init(&globals_m13->update_mutex, NULL);
	globals_m13->update_parity = GLOBALS_UPDATE_PARITY_DEFAULT_m13;
		
	pthread_mutex_unlock_m13(&globals_m13->mutex);
	
	return(TRUE_m13);
}


tern	G_init_medlib_m13(tern init_all_tables, si1 *app_path, ...)  // varargs(app_path): ui4 version_major, ui4 version_minor
{
	tern	ret_val = TRUE_m13;
	ui4	version_major, version_minor;


	// get varargs, if present
	if (app_path) {
		va_list		v_args;
		
		va_start(v_args, app_path);
		version_major = va_arg(v_args, ui4);  // varargs can't take single byte arguments
		version_minor = va_arg(v_args, ui4);  // varargs can't take single byte arguments
		va_end(v_args);
	} else {
		version_major = version_minor = 0;
	}

	// set up globals
	if (globals_m13 == NULL) {
		if (G_init_globals_m13(init_all_tables, app_path, version_major, version_minor) == FALSE_m13) {
			printf_m13("%s(): error initializing globals\n", __FUNCTION__);
			exit_m13(-1);
		}
	}

#ifdef FT_DEBUG_m13
	signal(SIGABRT, G_function_stack_trap_m13);  // Abnormal termination
	signal(SIGFPE, G_function_stack_trap_m13);  // Floating point exception
	signal(SIGILL, G_function_stack_trap_m13);  // Illegal instruction
	signal(SIGINT, G_function_stack_trap_m13);  // Ctrl-C interrupt (often caught on Windows before gets here [b/c == "Copy"])
	signal(SIGSEGV, G_function_stack_trap_m13);  // Segmentation violation
	signal(SIGTERM, G_function_stack_trap_m13);  // Terminate
	#if defined MACOS_m13 || defined LINUX_m13  // supported on Unix-like OS's
		signal(SIGBUS, G_function_stack_trap_m13);  // Bus error
		signal(SIGKILL, G_function_stack_trap_m13);  // Kill
		signal(SIGQUIT, G_function_stack_trap_m13);  // Quit
		signal(SIGTRAP, G_function_stack_trap_m13);  // Trace Trap (unhandled exception, or debugger breakpoint)
		signal(SIGUSR1, G_function_stack_trap_m13);  // User-defined signal 1
		signal(SIGUSR2, G_function_stack_trap_m13);  // User-defined signal 2
		signal(SIGXCPU, G_function_stack_trap_m13);  // CPU time limit
		signal(SIGXFSZ, G_function_stack_trap_m13);  // File size limit
	#endif
#endif

	// check cpu endianness
	if (globals_m13->tables->HW_params.endianness != LITTLE_ENDIAN_m13) {
		G_remove_behavior_m13(RETURN_ON_FAIL_m13);
		G_set_error_m13(E_UNKN_m13, "library only coded for little-endian machines currently");
	}
	
	// check "char" type
	if (G_check_char_type_m13() == FALSE_m13) {
		G_remove_behavior_m13(RETURN_ON_FAIL_m13);
		G_set_error_m13(E_UNKN_m13, "library only coded for 8-bit signed chars currently");
	}
		
	// umask
#if defined MACOS_m13 || defined LINUX_m13
	umask(globals_m13->file_creation_umask);
#endif
#ifdef WINDOWS_m13
	_umask(globals_m13->file_creation_umask);
#endif

	// seed random number generator
#if defined MACOS_m13 || defined LINUX_m13
	srandom((ui4) time(NULL));
#endif
#ifdef WINDOWS_m13
	srand((ui4) time(NULL));
#endif

#if defined WINDOWS_m13
	#ifdef WIN_SOCKETS_m13  // initialize Windows sockets DLL
	if (WN_socket_startup_m13() == FALSE_m13)
		ret_val = FALSE_m13;
	#endif
	#ifndef MATLAB_m13  // initialize Windows terminal
	if (WN_initialize_terminal_m13() == FALSE_m13)
		ret_val = FALSE_m13;
	#endif
#endif

	return(ret_val);
}


tern	G_init_metadata_m13(FPS_m13 *fps, tern init_for_update)
{
	PROC_GLOBS_m13			*proc_globs;
	TS_METADATA_SECTION_2_m13	*tmd2;
	VID_METADATA_SECTION_2_m13		*vmd2;
	METADATA_SECTION_3_m13			*md3;
	UH_m13			*uh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// shortcuts
	tmd2 = &fps->metadata->time_series_section_2;
	vmd2 = &fps->metadata->video_section_2;
	md3 = &fps->metadata->section_3;
	uh = fps->uh;
	
	// section 2 fields
	
	// type independent fields
	memset(tmd2->session_description, 0, METADATA_SESSION_DESCRIPTION_BYTES_m13);
	memset(tmd2->channel_description, 0, METADATA_CHANNEL_DESCRIPTION_BYTES_m13);
	memset(tmd2->segment_description, 0, METADATA_SEGMENT_DESCRIPTION_BYTES_m13);
	memset(tmd2->equipment_description, 0, METADATA_EQUIPMENT_DESCRIPTION_BYTES_m13);
	tmd2->acquisition_channel_number = METADATA_ACQUISITION_CHANNEL_NUMBER_NO_ENTRY_m13;
	
	// type specific fields
	switch (uh->type_code) {
		case TS_METADATA_TYPE_CODE_m13:
			tmd2->sampling_frequency = RATE_NO_ENTRY_m13;
			tmd2->low_frequency_filter_setting = RATE_NO_ENTRY_m13;
			tmd2->high_frequency_filter_setting = RATE_NO_ENTRY_m13;
			tmd2->notch_filter_frequency_setting = RATE_NO_ENTRY_m13;
			tmd2->AC_line_frequency = RATE_NO_ENTRY_m13;
			tmd2->amplitude_units_conversion_factor = TS_METADATA_AMPLITUDE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m13;
			tmd2->time_base_units_conversion_factor = TS_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m13;
			tmd2->session_start_sample_number = TS_METADATA_SESSION_START_SAMPLE_NUMBER_NO_ENTRY_m13;
			if (init_for_update == TRUE_m13) {
				tmd2->number_of_samples = 0;
				tmd2->number_of_blocks = 0;
				tmd2->maximum_block_bytes = 0;
				tmd2->maximum_block_samples = 0;
				tmd2->maximum_block_keysample_bytes = 0;
				tmd2->maximum_block_duration = 0.0;
				tmd2->number_of_discontinuities = 0;
				tmd2->maximum_contiguous_blocks = 0;
				tmd2->maximum_contiguous_block_bytes = 0;
				tmd2->maximum_contiguous_samples = 0;
			} else {
				tmd2->number_of_samples = TS_METADATA_NUMBER_OF_SAMPLES_NO_ENTRY_m13;
				tmd2->number_of_blocks = TS_METADATA_NUMBER_OF_BLOCKS_NO_ENTRY_m13;
				tmd2->maximum_block_bytes = TS_METADATA_MAXIMUM_BLOCK_BYTES_NO_ENTRY_m13;
				tmd2->maximum_block_samples = TS_METADATA_MAXIMUM_BLOCK_SAMPLES_NO_ENTRY_m13;
				tmd2->maximum_block_keysample_bytes = TS_METADATA_MAXIMUM_BLOCK_KEYSAMPLE_BYTES_NO_ENTRY_m13;
				tmd2->maximum_block_duration = TS_METADATA_MAXIMUM_BLOCK_DURATION_NO_ENTRY_m13;
				tmd2->number_of_discontinuities = TS_METADATA_NUMBER_OF_DISCONTINUITIES_NO_ENTRY_m13;
				tmd2->maximum_contiguous_blocks = TS_METADATA_MAXIMUM_CONTIGUOUS_BLOCKS_NO_ENTRY_m13;
				tmd2->maximum_contiguous_block_bytes = TS_METADATA_MAXIMUM_CONTIGUOUS_BLOCK_BYTES_NO_ENTRY_m13;
				tmd2->maximum_contiguous_samples = TS_METADATA_MAXIMUM_CONTIGUOUS_SAMPLES_NO_ENTRY_m13;
			}
			break;
		case VID_METADATA_TYPE_CODE_m13:
			vmd2->time_base_units_conversion_factor = VID_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m13;
			vmd2->session_start_frame_number = VID_METADATA_SESSION_START_FRAME_NUMBER_NO_ENTRY_m13;
			vmd2->frame_rate = VID_METADATA_FRAME_RATE_NO_ENTRY_m13;
			vmd2->horizontal_pixels = VID_METADATA_HORIZONTAL_PIXELS_NO_ENTRY_m13;
			vmd2->vertical_pixels = VID_METADATA_VERTICAL_PIXELS_NO_ENTRY_m13;
			if (init_for_update == TRUE_m13) {
				vmd2->number_of_frames = 0;
				vmd2->number_of_clips = 0;
				vmd2->maximum_clip_bytes = 0;
				vmd2->maximum_clip_frames = 0;
				vmd2->number_of_video_files = 0;
				vmd2->maximum_clip_duration = 0.0;
				vmd2->number_of_discontinuities = 0;
				vmd2->maximum_contiguous_clips = 0;
				vmd2->maximum_contiguous_clip_bytes = 0;
				vmd2->maximum_contiguous_frames = 0;
			} else {
				vmd2->number_of_frames = VID_METADATA_NUMBER_OF_FRAMES_NO_ENTRY_m13;
				vmd2->number_of_clips = VID_METADATA_NUMBER_OF_CLIPS_NO_ENTRY_m13;
				vmd2->maximum_clip_bytes = VID_METADATA_MAXIMUM_CLIP_BYTES_NO_ENTRY_m13;
				vmd2->maximum_clip_frames = VID_METADATA_MAXIMUM_CLIP_FRAMES_NO_ENTRY_m13;
				vmd2->number_of_video_files = VID_METADATA_NUMBER_OF_VIDEO_FILES_NO_ENTRY_m13;
				vmd2->maximum_clip_duration = VID_METADATA_MAXIMUM_CLIP_DURATION_NO_ENTRY_m13;
				vmd2->number_of_discontinuities = VID_METADATA_NUMBER_OF_DISCONTINUITIES_NO_ENTRY_m13;
				vmd2->maximum_contiguous_clips = VID_METADATA_MAXIMUM_CONTIGUOUS_CLIPS_NO_ENTRY_m13;
				vmd2->maximum_contiguous_clip_bytes = VID_METADATA_MAXIMUM_CONTIGUOUS_CLIP_BYTES_NO_ENTRY_m13;
				vmd2->maximum_contiguous_frames = VID_METADATA_MAXIMUM_CONTIGUOUS_FRAMES_NO_ENTRY_m13;
			}
			break;
		default:
			G_set_error_m13(E_MED_m13, "unrecognized metadata section 2 type in file \"%s\"", fps->path);
			break;
	}
	
	// section 3 fields
	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	md3->recording_time_offset = proc_globs->time_constants.recording_time_offset;
	md3->daylight_time_start_code = proc_globs->time_constants.daylight_start_code;
	md3->daylight_time_end_code = proc_globs->time_constants.daylight_end_code;
	strncpy_m13(md3->standard_timezone_acronym, proc_globs->time_constants.standard_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m13);
	strncpy_m13(md3->standard_timezone_string, proc_globs->time_constants.standard_timezone_string, TIMEZONE_STRING_BYTES_m13);
	strncpy_m13(md3->daylight_timezone_acronym, proc_globs->time_constants.daylight_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m13);
	strncpy_m13(md3->daylight_timezone_string, proc_globs->time_constants.daylight_timezone_string, TIMEZONE_STRING_BYTES_m13);
	memset(md3->subject_name_1, 0, METADATA_SUBJECT_NAME_BYTES_m13);
	memset(md3->subject_name_2, 0, METADATA_SUBJECT_NAME_BYTES_m13);
	memset(md3->subject_name_3, 0, METADATA_SUBJECT_NAME_BYTES_m13);
	memset(md3->subject_ID, 0, METADATA_SUBJECT_ID_BYTES_m13);
	memset(md3->recording_country, 0, METADATA_RECORDING_LOCATION_BYTES_m13);
	memset(md3->recording_territory, 0, METADATA_RECORDING_LOCATION_BYTES_m13);
	memset(md3->recording_locality, 0, METADATA_RECORDING_LOCATION_BYTES_m13);
	memset(md3->recording_institution, 0, METADATA_RECORDING_LOCATION_BYTES_m13);
	memset(md3->geotag_format, 0, METADATA_GEOTAG_FORMAT_BYTES_m13);
	memset(md3->geotag_data, 0, METADATA_GEOTAG_DATA_BYTES_m13);
	md3->standard_UTC_offset = proc_globs->time_constants.standard_UTC_offset;
	
	return_m13(TRUE_m13);
}


SLICE_m13	*G_init_slice_m13(SLICE_m13 *slice)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// NOTE: also initializes for frame numbers (via unions)
	// returns NULL on failure
	
	if (slice == NULL) {  // caller responsible for freeing
		slice = (SLICE_m13 *) malloc_m13(sizeof(SLICE_m13));
		if (slice == NULL)
			return_m13(NULL);
	}
	slice->conditioned = FALSE_m13;
	slice->n_segs = UNKNOWN_m13;  // n_segments == 0
	slice->start_time = slice->end_time = UUTC_NO_ENTRY_m13;
	slice->start_samp_num = slice->end_samp_num = SAMPLE_NUMBER_NO_ENTRY_m13;
	slice->start_seg_num = slice->end_seg_num = SEGMENT_NUMBER_NO_ENTRY_m13;

	return_m13(slice);
}


tern	G_init_timezone_tables_m13(void)
{
	GLOBAL_TABLES_m13	*tables;
	
	
	tables = globals_m13->tables;
	if (tables->timezone_table)
		return(TRUE_m13);

	pthread_mutex_lock_m13(&tables->mutex);
	if (tables->timezone_table) {  // may have been done by another thread while waiting
		pthread_mutex_unlock_m13(&tables->mutex);
		return(TRUE_m13);
	}
	
	// timezone table
	tables->timezone_table = (TIMEZONE_INFO_m13 *) calloc((size_t) TZ_TABLE_ENTRIES_m13, sizeof(TIMEZONE_INFO_m13));
	if (tables->timezone_table == NULL) {
		pthread_mutex_unlock_m13(&tables->mutex);
		return(FALSE_m13);
	}
	{
		TIMEZONE_INFO_m13 temp[TZ_TABLE_ENTRIES_m13] = TZ_TABLE_m13;
		memcpy((void *) globals_m13->tables->timezone_table, (void *) temp, TZ_TABLE_ENTRIES_m13 * sizeof(TIMEZONE_INFO_m13));
	}

	// country aliases
	tables->country_aliases_table = (TIMEZONE_ALIAS_m13 *) calloc((size_t) TZ_COUNTRY_ALIASES_ENTRIES_m13, sizeof(TIMEZONE_ALIAS_m13));
	if (tables->country_aliases_table == NULL) {
		pthread_mutex_unlock_m13(&tables->mutex);
		return(FALSE_m13);
	}
	{
		TIMEZONE_ALIAS_m13 temp[TZ_COUNTRY_ALIASES_ENTRIES_m13] = TZ_COUNTRY_ALIASES_TABLE_m13;
		memcpy((void *) tables->country_aliases_table, (void *) temp, TZ_COUNTRY_ALIASES_ENTRIES_m13 * sizeof(TIMEZONE_ALIAS_m13));
	}

	// country acronym aliases
	tables->country_acronym_aliases_table = (TIMEZONE_ALIAS_m13 *) calloc((size_t)TZ_COUNTRY_ACRONYM_ALIASES_ENTRIES_m13, sizeof(TIMEZONE_ALIAS_m13));
	if (tables->country_acronym_aliases_table == NULL) {
		pthread_mutex_unlock_m13(&tables->mutex);
		return(FALSE_m13);
	}
	{
		TIMEZONE_ALIAS_m13 temp[TZ_COUNTRY_ACRONYM_ALIASES_ENTRIES_m13] = TZ_COUNTRY_ACRONYM_ALIASES_TABLE_m13;
		memcpy((void *) tables->country_acronym_aliases_table, (void *) temp, TZ_COUNTRY_ACRONYM_ALIASES_ENTRIES_m13 * sizeof(TIMEZONE_ALIAS_m13));
	}

	pthread_mutex_unlock_m13(&tables->mutex);

	return(TRUE_m13);
}


tern	G_init_universal_header_m13(FPS_m13 *fps, ui4 type_code, tern generate_file_UID, tern originating_file)
{
	UH_m13	*uh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	uh = fps->uh;
	
	uh->header_CRC = uh->body_CRC = CRC_START_VALUE_m13;
	uh->segment_number = UH_SEGMENT_NUMBER_NO_ENTRY_m13;
	uh->type_code = type_code;
	uh->MED_version_major = MED_FORMAT_VERSION_MAJOR_m13;
	uh->MED_version_minor = MED_FORMAT_VERSION_MINOR_m13;
	uh->byte_order_code = LITTLE_ENDIAN_m13;
	uh->session_start_time = UUTC_NO_ENTRY_m13;
	uh->segment_start_time = UUTC_NO_ENTRY_m13;
	uh->segment_end_time = UUTC_NO_ENTRY_m13;
	uh->n_entries = 0;
	uh->maximum_entry_size = 0;
	uh->ordered = TRUE_m13;  // empty, so inherently ordered
	uh->expanded_passwords = UH_EXPANDED_PASSWORDS_DEFAULT_m13;
	uh->encryption_rounds = UH_ENCRYPTION_ROUNDS_DEFAULT_m13;
	uh->encryption_1 = uh->encryption_2 = uh->encryption_3 = NO_ENCRYPTION_m13;

	if (generate_file_UID == TRUE_m13)
		G_generate_UID_m13(&uh->file_UID);
	if (originating_file == TRUE_m13)
		uh->provenance_UID = uh->file_UID;
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	G_is_level_header_m13(void *ptr)
{
	ui4			level_code;
	LH_m13			*lh;
	sig_handler_t_m13	current_handler;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns FALSE_m13 if NULL or lh->type_code not set
	
	if (ptr == NULL)
		return_m13(FALSE_m13);
	
	level_code = NO_TYPE_CODE_m13;
	lh = (LH_m13 *) ptr;
	
	// potential seg fault
	current_handler = signal(SIGSEGV, SIG_IGN);  // save current signal handler for SIGSEGV & set to ignore
	level_code = lh->type_code;
	signal(SIGSEGV, current_handler);  // restore previous signal handler
	
	switch (level_code) {
		case SESS_TYPE_CODE_m13:
		case SSR_TYPE_CODE_m13:
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
		case PROC_GLOBS_TYPE_CODE_m13:
		case TS_METADATA_TYPE_CODE_m13:
		case TS_INDS_TYPE_CODE_m13:
		case TS_DATA_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
		case VID_DATA_TYPE_CODE_m13:
		case REC_INDS_TYPE_CODE_m13:
		case REC_DATA_TYPE_CODE_m13:
			return_m13(TRUE_m13);
		default:
			return_m13(FALSE_m13);
	}
}


si8	G_items_for_bytes_m13(FPS_m13 *fps, si8 *n_bytes)
{
	si8				items, bytes;
	ui4				entry_size;
	UH_m13		*uh;
	REC_HDR_m13		*rh;
	CMP_FIXED_BH_m13	*bh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	items = 0;
	uh = fps->uh;
	switch (uh->type_code) {
		case TS_INDS_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
		case REC_INDS_TYPE_CODE_m13:
			items = (*n_bytes) / INDEX_BYTES_m13;
			uh->maximum_entry_size = INDEX_BYTES_m13;
			return_m13(items);
		case TS_METADATA_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
			items = 1;
			*n_bytes = METADATA_BYTES_m13;
			uh->maximum_entry_size = METADATA_BYTES_m13;
			return_m13(items);
	}
	
	switch (uh->type_code) {
		case TS_DATA_TYPE_CODE_m13:
			bh = fps->params.cps->block_header;
			for (bytes = 0; bytes < *n_bytes; ++items) {
				entry_size = bh->total_block_bytes;
				if (uh->maximum_entry_size < entry_size)  // caller should've done this, but just in case
					uh->maximum_entry_size = entry_size;
				bytes += (si8) entry_size;
				bh = (CMP_FIXED_BH_m13 *) ((ui1 *) bh + (si8) entry_size);
			}
			break;
		case REC_DATA_TYPE_CODE_m13:
			rh = (REC_HDR_m13 *) fps->rec_data;
			for (bytes = 0; bytes < *n_bytes; ++items) {
				entry_size = rh->total_record_bytes;
				if (uh->maximum_entry_size < entry_size)  // caller should've done this, but just in case
					uh->maximum_entry_size = entry_size;
				bytes += (si8) entry_size;
				rh = (REC_HDR_m13 *) ((ui1 *) rh + (si8) entry_size);
			}
	}
	*n_bytes = bytes;
	
	return_m13(items);
}


ui4	G_level_m13(si1 *full_file_name, ui4 *type_code)
{
	si1	enclosing_directory[PATH_BYTES_m13];
	ui4	code;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// pass type_code in address to get level from code
	// pass type_code address to get both level & code
	// set type_code locally to NO_TYPE_CODE_m13 (zero) before passing to receive type_code
	
	code = NO_TYPE_CODE_m13;
	if (type_code)
		code = *type_code;  // passed type code
	if (code == NO_TYPE_CODE_m13) {
		if (full_file_name) {
			code = G_MED_type_code_from_string_m13(full_file_name);
			if (type_code)
				*type_code = code;  // return type code
		}
	}

	switch (code) {
		case NO_TYPE_CODE_m13:
		case SESS_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
		case TS_CHAN_TYPE_CODE_m13:
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
		case SSR_TYPE_CODE_m13:
			return_m13(code);
		case TS_METADATA_TYPE_CODE_m13:
		case TS_DATA_TYPE_CODE_m13:
		case TS_INDS_TYPE_CODE_m13:
			return_m13(TS_SEG_TYPE_CODE_m13);
		case VID_METADATA_TYPE_CODE_m13:
		case VID_DATA_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
			return_m13(VID_SEG_TYPE_CODE_m13);
	}
	
	// record data or indices file
	if (full_file_name) {
		G_path_parts_m13(full_file_name, enclosing_directory, NULL, NULL);
		code = G_MED_type_code_from_string_m13(enclosing_directory);  // level code
		return_m13(code);
	}
	
	return_m13(NO_TYPE_CODE_m13);
}


ui4	G_level_from_base_name_m13(si1 *path, si1 *level_path)
{
	si1		tmp_path[PATH_BYTES_m13], tmp_path2[PATH_BYTES_m13];
	ui4		level;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// useful to allow users to pass just base names into apps
	
	// returns level type code, or NO_TYPE_CODE_m13 if can't find match
	
	// assumes level_path has adequate space for new path
	// if level_path == NULL : return type code on level_path, does not modify path
	// if level_path == path : return type code on level_path, does modify path
	// if level_path != path && level_path : return type code on level_path, return modified path in level_path, path unmodified
	
	if (path == NULL)
		return_m13(NO_TYPE_CODE_m13);
	
	// don't handle regex strings
	if (STR_contains_regex_m13(path) == TRUE_m13)
		return_m13(NO_TYPE_CODE_m13);
	
	// get path from root
	G_full_path_m13(path, tmp_path);
	
	// see if it already has a level
	level = G_level_m13(tmp_path, NULL);
	if (level != NO_TYPE_CODE_m13) {
		if (level_path)
			strcpy(level_path, tmp_path);
		return_m13(level);
	}
	
	// try session level
	sprintf_m13(tmp_path2, "%s.%s", tmp_path, SESS_TYPE_STR_m13);
	if (G_exists_m13(tmp_path2) == DIR_EXISTS_m13) {
		if (level_path)
			strcpy(level_path, tmp_path2);
		return_m13(SESS_TYPE_CODE_m13);
	}
	
	// try time series channel level
	sprintf_m13(tmp_path2, "%s.%s", tmp_path, TS_CHAN_TYPE_STR_m13);
	if (G_exists_m13(tmp_path2) == DIR_EXISTS_m13) {
		if (level_path)
			strcpy(level_path, tmp_path2);
		return_m13(TS_CHAN_TYPE_CODE_m13);
	}

	// try video channel level
	sprintf_m13(tmp_path2, "%s.%s", tmp_path, VID_CHAN_TYPE_STR_m13);
	if (G_exists_m13(tmp_path2) == DIR_EXISTS_m13) {
		if (level_path)
			strcpy(level_path, tmp_path2);
		return_m13(VID_CHAN_TYPE_CODE_m13);
	}

	// try time series segment level
	sprintf_m13(tmp_path2, "%s.%s", tmp_path, TS_SEG_TYPE_STR_m13);
	if (G_exists_m13(tmp_path2) == DIR_EXISTS_m13) {
		if (level_path)
			strcpy(level_path, tmp_path2);
		return_m13(TS_SEG_TYPE_CODE_m13);
	}

	// try video segment level
	sprintf_m13(tmp_path2, "%s.%s", tmp_path, VID_SEG_TYPE_STR_m13);
	if (G_exists_m13(tmp_path2) == DIR_EXISTS_m13) {
		if (level_path)
			strcpy(level_path, tmp_path2);
		return_m13(VID_SEG_TYPE_CODE_m13);
	}
	
	// doesn't exist
	if (level_path)
		if (level_path != path)
			*level_path = 0;

	return_m13(NO_TYPE_CODE_m13);
}


tern	G_location_info_m13(LOCATION_INFO_m13 *loc_info, si1 *ip_str, si1 *ipinfo_token, tern set_timezone_globals, tern prompt)
{
	tern		free_loc_info = FALSE_m13, local_ip = FALSE_m13;
	si1		command[256], *buffer, *pattern, *c;
	si4		ret_val;
	size_t		len;
	time_t 		curr_time;
	struct tm 	loc_time;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// pass NULL or "" for ip_str to get local info
	// pass NULL or "" for ipinfo_token if you don't have one (they're free)
	
	if (loc_info == NULL) {
		loc_info = (LOCATION_INFO_m13 *) calloc((size_t) 1, sizeof(LOCATION_INFO_m13));
		free_loc_info = TRUE_m13;
	} else {
		memset((void *) loc_info, 0, sizeof(LOCATION_INFO_m13));
	}
	
	// get timezone acronym from system
	if (STR_empty_m13(ip_str) == TRUE_m13) {
		curr_time = time(NULL);
		local_ip = TRUE_m13;
	}
	
#if defined MACOS_m13 || defined LINUX_m13
	len = strcpy_m13(command, "/usr/bin/curl --connect-timeout 5.0 -s ipinfo.io");
	
	// get timezone acronym from system
	if (local_ip == TRUE_m13) {
		size_t	len2;
		
		localtime_r(&curr_time, &loc_time);
		len2 = strlen(loc_time.tm_zone);
		if (len2 >= 3) { // the table does not contain 2 letter timezone acronyms (e.g. MT for MST)
			if (loc_time.tm_isdst)
				strcpy(loc_info->timezone_info.daylight_timezone_acronym, loc_time.tm_zone);
			else
				strcpy(loc_info->timezone_info.standard_timezone_acronym, loc_time.tm_zone);
		}
	}
#endif
#ifdef WINDOWS_m13
	len = strcpy_m13(command, "curl.exe --connect-timeout 5.0 -s ipinfo.io");
		
	// get timezone acronym from system
	if (local_ip == TRUE_m13) {
		loc_time = *(localtime(&curr_time));
		if (*_tzname[0])
			strcpy(loc_info->timezone_info.standard_timezone, _tzname[0]);
		if (*_tzname[1])
			strcpy(loc_info->timezone_info.daylight_timezone, _tzname[1]);
	}
#endif
	if (local_ip == TRUE_m13) {
		command[len++] = '/';
		len += strcpy_m13(command + len, ip_str);
	}
	if (STR_empty_m13(ipinfo_token) == FALSE_m13)
		sprintf(command + len, "?token=%s", ipinfo_token);
	
	buffer = NULL;
	ret_val = system_pipe_m13(&buffer, 0, command, SP_DEFAULT_m13, CURRENT_BEHAVIOR_m13);
	if (ret_val < 0)
		return_m13(FALSE_m13);
	
	// condition output
	STR_strip_character_m13(buffer, '"');
	
	// parse output
	pattern = "ip: ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL)
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%[^,]", loc_info->WAN_IPv4_address);
	
	pattern = "city: ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL)
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%[^,]", loc_info->locality);
	
	pattern = "region: ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL)
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%[^,]", loc_info->timezone_info.territory);
	
	pattern = "country: ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL)
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%[^,]", loc_info->timezone_info.country_acronym_2_letter);
	
	pattern = "loc: ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL)
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%lf,%lf", &loc_info->latitude, &loc_info->longitude);
	
	pattern = "postal: ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL)
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%[^,]", loc_info->postal_code);
	
	pattern = "timezone: ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL)
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
	else
		sscanf(c, "%[^, ]", loc_info->timezone_description);
	
	free((void *) buffer);
	
	ret_val = TRUE_m13;
	if (set_timezone_globals == TRUE_m13) {
		if (G_set_time_constants_m13(&loc_info->timezone_info, 0, prompt) == FALSE_m13) {
			G_warning_message_m13("%s(): could not set timezone globals => returning NULL\n", __FUNCTION__);
			ret_val = FALSE_m13;
		}
	}
	
	if (free_loc_info == TRUE_m13)
		free((void *) loc_info);

	return_m13((tern) ret_val);
}


ui4  G_MED_path_components_m13(const si1 *path, si1 *MED_dir, si1 *MED_name)
{
	si1 extension[TYPE_BYTES_m13], local_MED_name[SEG_NAME_BYTES_m13];
	si1 local_MED_dir[PATH_BYTES_m13];;
	si4 fe, name_bytes;
	ui4 code;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (MED_dir == NULL)
		*(MED_dir = local_MED_dir) = 0;
	if (MED_name == NULL)
		*(MED_name = local_MED_name) = 0;
	
	// copy & condition path
	strcpy(local_MED_dir, path);
	// escaped characters can happen if string with escaped chars is also quoted (e.g. by a shell script) => pretty uncommon
	STR_unescape_chars_m13(local_MED_dir, (si1) 0x20);  // spaces
	STR_unescape_chars_m13(local_MED_dir, (si1) 0x27);  // apostrophes
	STR_unescape_chars_m13(local_MED_dir, (si1) 0x60);  // graves
	G_full_path_m13(local_MED_dir, local_MED_dir);

	// check path: if file passed, get enclosing directory
	fe = G_exists_m13(local_MED_dir);
	if (fe == FILE_EXISTS_m13) {
		G_path_parts_m13(local_MED_dir, local_MED_dir, NULL, NULL);
	} else if (fe == DOES_NOT_EXIST_m13) {
		G_set_error_m13(E_UNKN_m13, "passed path \"%s\" does not exist", local_MED_dir);
		return_m13(NO_TYPE_CODE_m13);
	} else if (fe == EXISTS_ERR_m13) {  // G_exists_m13() sets error
		return_m13(NO_TYPE_CODE_m13);
	}

	// get name & extension
	G_path_parts_m13(local_MED_dir, NULL, local_MED_name, extension);

	code = G_MED_type_code_from_string_m13(extension);
	switch (code) {
		case SESS_TYPE_CODE_m13:
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
		case SSR_TYPE_CODE_m13:
			name_bytes = NAME_BYTES_m13;
			break;
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
			name_bytes = SEG_NAME_BYTES_m13;
			break;
		default:
			G_set_error_m13(E_MED_m13, "passed path \"%s\" is not a MED directory\n", local_MED_dir);
			return_m13(NO_TYPE_CODE_m13);
	}

	// copy to outputs, if provided
	if (MED_dir)
		snprintf_m13(MED_dir, PATH_BYTES_m13, "%s", local_MED_dir);
	if (MED_name)
		snprintf_m13(MED_name, name_bytes, "%s", local_MED_name);

	return_m13(code);
}


ui4	G_MED_type_code_from_string_m13(const si1 *string)
{
	si1		*c, *c2;
	si4 		i;
	EXT_CODE_m13	type;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (string == NULL) {
		G_set_error_m13(E_UNKN_m13, "string is NULL");
		return_m13(NO_TYPE_CODE_m13);
	}
	
	// move to end of string
	c = (si1 *) string - 1;
	while (*++c);
	
	// find last period period
	while (--c != string)
		if (*c == '.')
			break;
	
	if (*c == '.')  // has extension,
		++c;

	c2 = type.ext;
	for (i = sizeof(EXT_CODE_m13) - 1; i-- && *c;)
		*c2++ = *c++;
	*c2 = 0;

	switch (type.code) {
		case NO_TYPE_CODE_m13:
		case SESS_TYPE_CODE_m13:
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
		case SSR_TYPE_CODE_m13:
		case REC_DATA_TYPE_CODE_m13:
		case REC_INDS_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
		case VID_DATA_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
		case TS_CHAN_TYPE_CODE_m13:
		case TS_METADATA_TYPE_CODE_m13:
		case TS_DATA_TYPE_CODE_m13:
		case TS_INDS_TYPE_CODE_m13:
			return_m13(type.code);
		default:  // check tag to determine if this is a MED video data file
			if (G_video_data_m13(string) == TRUE_m13)
				return_m13(VID_DATA_TYPE_CODE_m13);
			break;
	}
		
	return_m13(NO_TYPE_CODE_m13);
}


const si1	*G_MED_type_string_from_code_m13(ui4 code)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// returns NULL for unrecognized code

	switch (code) {
		case SESS_TYPE_CODE_m13:
			return_m13(SESS_TYPE_STR_m13);
		case TS_SEG_TYPE_CODE_m13:
			return_m13(TS_SEG_TYPE_STR_m13);
		case VID_SEG_TYPE_CODE_m13:
			return_m13(VID_SEG_TYPE_STR_m13);
		case SSR_TYPE_CODE_m13:
			return_m13(SSR_TYPE_STR_m13);
		case REC_DATA_TYPE_CODE_m13:
			return_m13(REC_DATA_TYPE_STR_m13);
		case REC_INDS_TYPE_CODE_m13:
			return_m13(REC_INDS_TYPE_STR_m13);
		case VID_CHAN_TYPE_CODE_m13:
			return_m13(VID_CHAN_TYPE_STR_m13);
		case VID_METADATA_TYPE_CODE_m13:
			return_m13(VID_METADATA_TYPE_STR_m13);
		case VID_DATA_TYPE_CODE_m13:
			return_m13(VID_DATA_TYPE_STR_m13);
		case VID_INDS_TYPE_CODE_m13:
			return_m13(VID_INDS_TYPE_STR_m13);
		case TS_CHAN_TYPE_CODE_m13:
			return_m13(TS_CHAN_TYPE_STR_m13);
		case TS_METADATA_TYPE_CODE_m13:
			return_m13(TS_METADATA_TYPE_STR_m13);
		case TS_DATA_TYPE_CODE_m13:
			return_m13(TS_DATA_TYPE_STR_m13);
		case TS_INDS_TYPE_CODE_m13:
			return_m13(TS_INDS_TYPE_STR_m13);
	}
		
	return_m13(NULL);
}


tern	G_merge_metadata_m13(FPS_m13 *md_fps_1, FPS_m13 *md_fps_2, FPS_m13 *merged_md_fps)
{
	ui4 type_code;
	METADATA_SECTION_1_m13			*md1_1, *md1_2, *md1_m;
	TS_METADATA_SECTION_2_m13	*tmd2_1, *tmd2_2, *tmd2_m;
	VID_METADATA_SECTION_2_m13		*vmd2_1, *vmd2_2, *vmd2_m;
	METADATA_SECTION_3_m13			*md3_1, *md3_2, *md3_m;
	tern  	equal;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// if merged_md_fps == NULL, comparison results will be placed in md_fps_1->metadata
	// returns TRUE_m13 if md_fps_1->metadata == md_fps_2->metadata, FALSE_m13 otherwise

	// decrypt if needed
	if (md_fps_1->uh->encryption_2 > NO_ENCRYPTION_m13 || md_fps_1->uh->encryption_3 > NO_ENCRYPTION_m13)
		G_decrypt_metadata_m13(md_fps_1);
	if (md_fps_2->uh->encryption_2 > NO_ENCRYPTION_m13 || md_fps_2->uh->encryption_3 > NO_ENCRYPTION_m13)
		G_decrypt_metadata_m13(md_fps_2);
	
	// setup
	md1_1 = &md_fps_1->metadata->section_1;
	md1_2 = &md_fps_2->metadata->section_1;
	if (merged_md_fps == NULL)
		merged_md_fps = md_fps_1;
	else
		memcpy(merged_md_fps->metadata, md_fps_1->metadata, METADATA_BYTES_m13);
	md1_m = &merged_md_fps->metadata->section_1;
	
	type_code = md_fps_1->uh->type_code;
	if (type_code != md_fps_2->uh->type_code) {
		G_set_error_m13(E_UNKN_m13, "mismatched type codes");
		return_m13(UNKNOWN_m13);
	}
	
	switch (type_code) {
		case TS_METADATA_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
			break;
		default:
			G_set_error_m13(E_MED_m13, "unrecognized type code (0x%08x)", type_code);
			return_m13(UNKNOWN_m13);
	}
	equal = TRUE_m13;
	
	// section 1
	if (memcmp(md1_1->level_1_password_hint, md1_2->level_1_password_hint, PASSWORD_HINT_BYTES_m13)) {
		memset(md1_m->level_1_password_hint, 0, PASSWORD_HINT_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md1_1->level_2_password_hint, md1_2->level_2_password_hint, PASSWORD_HINT_BYTES_m13)) {
		memset(md1_m->level_2_password_hint, 0, PASSWORD_HINT_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md1_1->protected_region, md1_2->protected_region, METADATA_SECTION_1_PROTECTED_REGION_BYTES_m13)) {
		memset(md1_m->protected_region, 0, METADATA_SECTION_1_PROTECTED_REGION_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md1_1->discretionary_region, md1_2->discretionary_region, METADATA_SECTION_1_DISCRETIONARY_REGION_BYTES_m13)) {
		memset(md1_m->discretionary_region, 0, METADATA_SECTION_1_DISCRETIONARY_REGION_BYTES_m13); equal = FALSE_m13;
	}
	
	// section 2: time series channel
	if (type_code == TS_METADATA_TYPE_CODE_m13) {
		tmd2_1 = &md_fps_1->metadata->time_series_section_2;
		tmd2_2 = &md_fps_2->metadata->time_series_section_2;
		tmd2_m = &merged_md_fps->metadata->time_series_section_2;
		if (memcmp(tmd2_1->session_description, tmd2_2->session_description, METADATA_SESSION_DESCRIPTION_BYTES_m13)) {
			memset(tmd2_m->session_description, 0, METADATA_SESSION_DESCRIPTION_BYTES_m13); equal = FALSE_m13;
		}
		if (memcmp(tmd2_1->channel_description, tmd2_2->channel_description, METADATA_CHANNEL_DESCRIPTION_BYTES_m13)) {
			memset(tmd2_m->channel_description, 0, METADATA_CHANNEL_DESCRIPTION_BYTES_m13); equal = FALSE_m13;
		}
		if (memcmp(tmd2_1->segment_description, tmd2_2->segment_description, METADATA_SEGMENT_DESCRIPTION_BYTES_m13)) {
			memset(tmd2_m->segment_description, 0, METADATA_SEGMENT_DESCRIPTION_BYTES_m13); equal = FALSE_m13;
		}
		if (memcmp(tmd2_1->equipment_description, tmd2_2->equipment_description, METADATA_EQUIPMENT_DESCRIPTION_BYTES_m13)) {
			memset(tmd2_m->equipment_description, 0, METADATA_EQUIPMENT_DESCRIPTION_BYTES_m13); equal = FALSE_m13;
		}
		if (tmd2_1->acquisition_channel_number != tmd2_2->acquisition_channel_number) {
			tmd2_m->acquisition_channel_number = METADATA_ACQUISITION_CHANNEL_NUMBER_NO_ENTRY_m13; equal = FALSE_m13;
		}
		if (memcmp(tmd2_1->reference_description, tmd2_2->reference_description, TS_METADATA_REFERENCE_DESCRIPTION_BYTES_m13)) {
			memset(tmd2_m->reference_description, 0, TS_METADATA_REFERENCE_DESCRIPTION_BYTES_m13); equal = FALSE_m13;
		}
		if (tmd2_1->sampling_frequency != tmd2_2->sampling_frequency) {
			if (tmd2_1->sampling_frequency == RATE_NO_ENTRY_m13 || tmd2_2->sampling_frequency == RATE_NO_ENTRY_m13)
				tmd2_m->sampling_frequency = RATE_NO_ENTRY_m13; // no entry supercedes variable frequency
			else
				tmd2_m->sampling_frequency = RATE_VARIABLE_m13;
			equal = FALSE_m13;
		}
		if (tmd2_1->low_frequency_filter_setting != tmd2_2->low_frequency_filter_setting) {
			tmd2_m->low_frequency_filter_setting = RATE_NO_ENTRY_m13; equal = FALSE_m13;
		}
		if (tmd2_1->high_frequency_filter_setting != tmd2_2->high_frequency_filter_setting) {
			tmd2_m->high_frequency_filter_setting = RATE_NO_ENTRY_m13; equal = FALSE_m13;
		}
		if (tmd2_1->notch_filter_frequency_setting != tmd2_2->notch_filter_frequency_setting) {
			tmd2_m->notch_filter_frequency_setting = RATE_NO_ENTRY_m13; equal = FALSE_m13;
		}
		if (tmd2_1->AC_line_frequency != tmd2_2->AC_line_frequency) {
			tmd2_m->AC_line_frequency = RATE_NO_ENTRY_m13; equal = FALSE_m13;
		}
		if (tmd2_1->amplitude_units_conversion_factor != tmd2_2->amplitude_units_conversion_factor) {
			tmd2_m->amplitude_units_conversion_factor = TS_METADATA_AMPLITUDE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m13; equal = FALSE_m13;
		}
		if (memcmp(tmd2_1->amplitude_units_description, tmd2_2->amplitude_units_description, TS_METADATA_AMPLITUDE_UNITS_DESCRIPTION_BYTES_m13)) {
			memset(tmd2_m->amplitude_units_description, 0, TS_METADATA_AMPLITUDE_UNITS_DESCRIPTION_BYTES_m13); equal = FALSE_m13;
		}
		if (tmd2_1->time_base_units_conversion_factor != tmd2_2->time_base_units_conversion_factor) {
			tmd2_m->time_base_units_conversion_factor = TS_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m13; equal = FALSE_m13;
		}
		if (memcmp(tmd2_1->time_base_units_description, tmd2_2->time_base_units_description, TS_METADATA_TIME_BASE_UNITS_DESCRIPTION_BYTES_m13)) {
			memset(tmd2_m->time_base_units_description, 0, TS_METADATA_TIME_BASE_UNITS_DESCRIPTION_BYTES_m13); equal = FALSE_m13;
		}
		if (tmd2_1->session_start_sample_number > tmd2_2->session_start_sample_number) {
			tmd2_m->session_start_sample_number = tmd2_2->session_start_sample_number; equal = FALSE_m13;
		}
		if (tmd2_1->number_of_samples < tmd2_2->number_of_samples) {
			tmd2_m->number_of_samples = tmd2_2->number_of_samples; equal = FALSE_m13;
		}
		if (tmd2_1->number_of_blocks < tmd2_2->number_of_blocks) {
			tmd2_m->number_of_blocks = tmd2_2->number_of_blocks; equal = FALSE_m13;
		}
		if (tmd2_1->maximum_block_bytes < tmd2_2->maximum_block_bytes) {
			tmd2_m->maximum_block_bytes = tmd2_2->maximum_block_bytes; equal = FALSE_m13;
		}
		if (tmd2_1->maximum_block_samples < tmd2_2->maximum_block_samples) {
			tmd2_m->maximum_block_samples = tmd2_2->maximum_block_samples; equal = FALSE_m13;
		}
		if (tmd2_1->maximum_block_keysample_bytes < tmd2_2->maximum_block_keysample_bytes) {
			tmd2_m->maximum_block_keysample_bytes = tmd2_2->maximum_block_keysample_bytes; equal = FALSE_m13;
		}
		if (tmd2_1->maximum_block_duration < tmd2_2->maximum_block_duration) {
			tmd2_m->maximum_block_duration = tmd2_2->maximum_block_duration; equal = FALSE_m13;
		}
		if (tmd2_1->number_of_discontinuities < tmd2_2->number_of_discontinuities) {
			tmd2_m->number_of_discontinuities = tmd2_2->number_of_discontinuities; equal = FALSE_m13;
		}
		if (tmd2_1->maximum_contiguous_blocks < tmd2_2->maximum_contiguous_blocks) {
			tmd2_m->maximum_contiguous_blocks = tmd2_2->maximum_contiguous_blocks; equal = FALSE_m13;
		}
		if (tmd2_1->maximum_contiguous_block_bytes < tmd2_2->maximum_contiguous_block_bytes) {
			tmd2_m->maximum_contiguous_block_bytes = tmd2_2->maximum_contiguous_block_bytes; equal = FALSE_m13;
		}
		if (tmd2_1->maximum_contiguous_samples < tmd2_2->maximum_contiguous_samples) {
			tmd2_m->maximum_contiguous_samples = tmd2_2->maximum_contiguous_samples; equal = FALSE_m13;
		}
		if (memcmp(tmd2_1->protected_region, tmd2_2->protected_region, TS_METADATA_SECTION_2_PROTECTED_REGION_BYTES_m13)) {
			memset(tmd2_m->protected_region, 0, TS_METADATA_SECTION_2_PROTECTED_REGION_BYTES_m13); equal = FALSE_m13;
		}
		if (memcmp(tmd2_1->discretionary_region, tmd2_2->discretionary_region, TS_METADATA_SECTION_2_DISCRETIONARY_REGION_BYTES_m13)) {
			memset(tmd2_m->discretionary_region, 0, TS_METADATA_SECTION_2_DISCRETIONARY_REGION_BYTES_m13); equal = FALSE_m13;
		}
		// end section 2: time series channel
	}
	// section 2: video channel
	else if (type_code == VID_METADATA_TYPE_CODE_m13) {
		vmd2_1 = &md_fps_1->metadata->video_section_2;
		vmd2_2 = &md_fps_2->metadata->video_section_2;
		vmd2_m = &merged_md_fps->metadata->video_section_2;
		if (memcmp(vmd2_1->session_description, vmd2_2->session_description, METADATA_SESSION_DESCRIPTION_BYTES_m13)) {
			memset(vmd2_m->session_description, 0, METADATA_SESSION_DESCRIPTION_BYTES_m13); equal = FALSE_m13;
		}
		if (memcmp(vmd2_1->channel_description, vmd2_2->channel_description, METADATA_CHANNEL_DESCRIPTION_BYTES_m13)) {
			memset(vmd2_m->channel_description, 0, METADATA_CHANNEL_DESCRIPTION_BYTES_m13); equal = FALSE_m13;
		}
		if (memcmp(vmd2_1->segment_description, vmd2_2->segment_description, METADATA_SEGMENT_DESCRIPTION_BYTES_m13)) {
			memset(vmd2_m->segment_description, 0, METADATA_SEGMENT_DESCRIPTION_BYTES_m13); equal = FALSE_m13;
		}
		if (memcmp(vmd2_1->equipment_description, vmd2_2->equipment_description, METADATA_EQUIPMENT_DESCRIPTION_BYTES_m13)) {
			memset(vmd2_m->equipment_description, 0, METADATA_EQUIPMENT_DESCRIPTION_BYTES_m13); equal = FALSE_m13;
		}
		if (vmd2_1->acquisition_channel_number != vmd2_2->acquisition_channel_number) {
			vmd2_m->acquisition_channel_number = METADATA_ACQUISITION_CHANNEL_NUMBER_NO_ENTRY_m13; equal = FALSE_m13;
		}
		if (vmd2_1->time_base_units_conversion_factor != vmd2_2->time_base_units_conversion_factor) {
			vmd2_m->time_base_units_conversion_factor = VID_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m13; equal = FALSE_m13;
		}
		if (memcmp(vmd2_1->time_base_units_description, vmd2_2->time_base_units_description, VID_METADATA_TIME_BASE_UNITS_DESCRIPTION_BYTES_m13)) {
			memset(vmd2_m->time_base_units_description, 0, VID_METADATA_TIME_BASE_UNITS_DESCRIPTION_BYTES_m13); equal = FALSE_m13;
		}
		if (vmd2_1->session_start_frame_number > vmd2_2->session_start_frame_number) {
			vmd2_m->session_start_frame_number = vmd2_2->session_start_frame_number; equal = FALSE_m13;
		}
		if (vmd2_1->number_of_frames < vmd2_2->number_of_frames) {
			vmd2_m->number_of_frames = vmd2_2->number_of_frames; equal = FALSE_m13;
		}
		if (vmd2_1->frame_rate != vmd2_2->frame_rate) {
			vmd2_m->frame_rate = VID_METADATA_FRAME_RATE_NO_ENTRY_m13; equal = FALSE_m13;
		}
		if (vmd2_1->number_of_clips < vmd2_2->number_of_clips) {
			vmd2_m->number_of_clips = vmd2_2->number_of_clips; equal = FALSE_m13;
		}
		if (vmd2_1->maximum_clip_bytes < vmd2_2->maximum_clip_bytes) {
			vmd2_m->maximum_clip_bytes = vmd2_2->maximum_clip_bytes; equal = FALSE_m13;
		}
		if (vmd2_1->maximum_clip_frames < vmd2_2->maximum_clip_frames) {
			vmd2_m->maximum_clip_frames = vmd2_2->maximum_clip_frames; equal = FALSE_m13;
		}
		if (vmd2_1->number_of_video_files < vmd2_2->number_of_video_files) {
			vmd2_m->number_of_video_files = vmd2_2->number_of_video_files; equal = FALSE_m13;
		}
		if (vmd2_1->maximum_clip_duration < vmd2_2->maximum_clip_duration) {
			vmd2_m->maximum_clip_duration = vmd2_2->maximum_clip_duration; equal = FALSE_m13;
		}
		if (vmd2_1->number_of_discontinuities < vmd2_2->number_of_discontinuities) {
			vmd2_m->number_of_discontinuities = vmd2_2->number_of_discontinuities; equal = FALSE_m13;
		}
		if (vmd2_1->maximum_contiguous_clips < vmd2_2->maximum_contiguous_clips) {
			vmd2_m->maximum_contiguous_clips = vmd2_2->maximum_contiguous_clips; equal = FALSE_m13;
		}
		if (vmd2_1->maximum_contiguous_clip_bytes < vmd2_2->maximum_contiguous_clip_bytes) {
			vmd2_m->maximum_contiguous_clip_bytes = vmd2_2->maximum_contiguous_clip_bytes; equal = FALSE_m13;
		}
		if (vmd2_1->maximum_contiguous_frames < vmd2_2->maximum_contiguous_frames) {
			vmd2_m->maximum_contiguous_frames = vmd2_2->maximum_contiguous_frames; equal = FALSE_m13;
		}
		if (vmd2_1->horizontal_pixels != vmd2_2->horizontal_pixels) {
			vmd2_m->horizontal_pixels = VID_METADATA_HORIZONTAL_PIXELS_NO_ENTRY_m13; equal = FALSE_m13;
		}
		if (vmd2_1->vertical_pixels != vmd2_2->vertical_pixels) {
			vmd2_m->vertical_pixels = VID_METADATA_VERTICAL_PIXELS_NO_ENTRY_m13; equal = FALSE_m13;
		}
		if (memcmp(vmd2_1->video_format, vmd2_2->video_format, VID_METADATA_VIDEO_FORMAT_BYTES_m13)) {
			memset(vmd2_1->video_format, 0, VID_METADATA_VIDEO_FORMAT_BYTES_m13); equal = FALSE_m13;
		}
		if (memcmp(vmd2_1->protected_region, vmd2_2->protected_region, VID_METADATA_SECTION_2_PROTECTED_REGION_BYTES_m13)) {
			memset(vmd2_m->protected_region, 0, VID_METADATA_SECTION_2_PROTECTED_REGION_BYTES_m13); equal = FALSE_m13;
		}
		if (memcmp(vmd2_1->discretionary_region, vmd2_2->discretionary_region, VID_METADATA_SECTION_2_DISCRETIONARY_REGION_BYTES_m13)) {
			memset(vmd2_m->discretionary_region, 0, VID_METADATA_SECTION_2_DISCRETIONARY_REGION_BYTES_m13); equal = FALSE_m13;
		}
		// end section 2: video channel
	}
	
	// section 3
	md3_1 = &md_fps_1->metadata->section_3;
	md3_2 = &md_fps_2->metadata->section_3;
	md3_m = &merged_md_fps->metadata->section_3;
	if (md3_1->recording_time_offset != md3_2->recording_time_offset) {
		md3_m->recording_time_offset = UUTC_NO_ENTRY_m13; equal = FALSE_m13;
	}
	if (md3_1->daylight_time_start_code.value != md3_2->daylight_time_start_code.value) {
		md3_m->daylight_time_start_code.value = DTCC_VALUE_NO_ENTRY_m13; equal = FALSE_m13;
	}
	if (md3_1->daylight_time_end_code.value != md3_2->daylight_time_end_code.value) {
		md3_m->daylight_time_end_code.value = DTCC_VALUE_NO_ENTRY_m13; equal = FALSE_m13;
	}
	if (memcmp(md3_1->standard_timezone_acronym, md3_2->standard_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m13)) {
		memset(md3_m->standard_timezone_acronym, 0, TIMEZONE_ACRONYM_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->standard_timezone_string, md3_2->standard_timezone_string, TIMEZONE_STRING_BYTES_m13)) {
		memset(md3_m->standard_timezone_string, 0, TIMEZONE_STRING_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->daylight_timezone_acronym, md3_2->daylight_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m13)) {
		memset(md3_m->daylight_timezone_acronym, 0, TIMEZONE_ACRONYM_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->daylight_timezone_string, md3_2->daylight_timezone_string, TIMEZONE_STRING_BYTES_m13)) {
		memset(md3_m->daylight_timezone_string, 0, TIMEZONE_STRING_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->subject_name_1, md3_2->subject_name_1, METADATA_SUBJECT_NAME_BYTES_m13)) {
		memset(md3_m->subject_name_1, 0, METADATA_SUBJECT_NAME_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->subject_name_2, md3_2->subject_name_2, METADATA_SUBJECT_NAME_BYTES_m13)) {
		memset(md3_m->subject_name_2, 0, METADATA_SUBJECT_NAME_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->subject_name_3, md3_2->subject_name_3, METADATA_SUBJECT_NAME_BYTES_m13)) {
		memset(md3_m->subject_name_3, 0, METADATA_SUBJECT_NAME_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->subject_ID, md3_2->subject_ID, METADATA_SUBJECT_ID_BYTES_m13)) {
		memset(md3_m->subject_ID, 0, METADATA_SUBJECT_ID_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->recording_country, md3_2->recording_country, METADATA_RECORDING_LOCATION_BYTES_m13)) {
		memset(md3_m->recording_country, 0, METADATA_SUBJECT_ID_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->recording_territory, md3_2->recording_territory, METADATA_RECORDING_LOCATION_BYTES_m13)) {
		memset(md3_m->recording_territory, 0, METADATA_SUBJECT_ID_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->recording_locality, md3_2->recording_locality, METADATA_RECORDING_LOCATION_BYTES_m13)) {
		memset(md3_m->recording_locality, 0, METADATA_RECORDING_LOCATION_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->recording_institution, md3_2->recording_institution, METADATA_RECORDING_LOCATION_BYTES_m13)) {
		memset(md3_m->recording_institution, 0, METADATA_RECORDING_LOCATION_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->geotag_format, md3_2->geotag_format, METADATA_GEOTAG_FORMAT_BYTES_m13)) {
		memset(md3_m->geotag_format, 0, METADATA_GEOTAG_FORMAT_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->geotag_data, md3_2->geotag_data, METADATA_GEOTAG_DATA_BYTES_m13)) {
		memset(md3_m->geotag_data, 0, METADATA_GEOTAG_DATA_BYTES_m13); equal = FALSE_m13;
	}
	if (md3_1->standard_UTC_offset != md3_2->standard_UTC_offset) {
		md3_m->standard_UTC_offset = STANDARD_UTC_OFFSET_NO_ENTRY_m13; equal = FALSE_m13;
	}
	if (memcmp(md3_1->protected_region, md3_2->protected_region, METADATA_SECTION_3_PROTECTED_REGION_BYTES_m13)) {
		memset(md3_m->protected_region, 0, METADATA_SECTION_3_PROTECTED_REGION_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(md3_1->discretionary_region, md3_2->discretionary_region, METADATA_SECTION_3_DISCRETIONARY_REGION_BYTES_m13)) {
		memset(md3_m->discretionary_region, 0, METADATA_SECTION_3_DISCRETIONARY_REGION_BYTES_m13); equal = FALSE_m13;
	}
		
	return_m13(equal);
}


tern  G_merge_universal_headers_m13(FPS_m13 *fps_1, FPS_m13 * fps_2, FPS_m13 * merged_fps)
{
	UH_m13	*uh_1, *uh_2, *merged_uh;
	tern  equal = TRUE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// if merged_fps == NULL, comparison results will be placed in fps_1->uh
	// returns TRUE_m13 if fps_1->uh == fps_2->uh, FALSE_m13 otherwise
	
	if (merged_fps == NULL)
		merged_fps = fps_1;
	else
		memcpy(merged_fps->uh, fps_1->uh, UH_BYTES_m13);
	
	equal = TRUE_m13;
	uh_1 = fps_1->uh;
	uh_2 = fps_2->uh;
	merged_uh = merged_fps->uh;
	
	merged_uh->header_CRC = CRC_NO_ENTRY_m13; // CRCs not compared / merged
	merged_uh->body_CRC = CRC_NO_ENTRY_m13; // CRCs not compared / merged
	if (uh_1->type_code != uh_2->type_code) {
		// special case: merging metadata & record data universal headers for ephemeral data
		if ((uh_1->type_code == TS_METADATA_TYPE_CODE_m13 || uh_1->type_code == VID_METADATA_TYPE_CODE_m13) && uh_2->type_code == REC_DATA_TYPE_CODE_m13) {
			merged_uh->type_code = uh_1->type_code;
		} else if ((uh_2->type_code == TS_METADATA_TYPE_CODE_m13 || uh_2->type_code == VID_METADATA_TYPE_CODE_m13) && uh_1->type_code == REC_DATA_TYPE_CODE_m13) {
			merged_uh->type_code = uh_2->type_code;
		} else {
			merged_uh->type_code = NO_TYPE_CODE_m13; equal = FALSE_m13;
		}
	}
	if (uh_1->MED_version_major != uh_2->MED_version_major) {
		merged_uh->MED_version_major = UH_MED_VERSION_MAJOR_NO_ENTRY_m13; equal = FALSE_m13;
	}
	if (uh_1->MED_version_minor != uh_2->MED_version_minor) {
		merged_uh->MED_version_minor = UH_MED_VERSION_MINOR_NO_ENTRY_m13; equal = FALSE_m13;
	}
	if (uh_1->byte_order_code != uh_2->byte_order_code) {
		merged_uh->byte_order_code = UH_BYTE_ORDER_CODE_NO_ENTRY_m13; equal = FALSE_m13;
	}
	if (uh_1->session_start_time == UUTC_NO_ENTRY_m13) {
		if (uh_2->session_start_time == UUTC_NO_ENTRY_m13)
			merged_uh->session_start_time = UUTC_NO_ENTRY_m13;
		else
			merged_uh->session_start_time = uh_2->session_start_time;
	} else if (uh_2->session_start_time == UUTC_NO_ENTRY_m13) {
		merged_uh->session_start_time = uh_1->session_start_time;
	} else if (uh_1->session_start_time > uh_2->session_start_time) {
		merged_uh->session_start_time = uh_2->session_start_time; equal = FALSE_m13;
	}
	if (uh_1->segment_start_time == UUTC_NO_ENTRY_m13) {
		if (uh_2->segment_start_time == UUTC_NO_ENTRY_m13)
			merged_uh->segment_start_time = UUTC_NO_ENTRY_m13;
		else
			merged_uh->segment_start_time = uh_2->segment_start_time;
	} else if (uh_2->segment_start_time == UUTC_NO_ENTRY_m13) {
		merged_uh->segment_start_time = uh_1->segment_start_time;
	} else if (uh_1->segment_start_time > uh_2->segment_start_time) {
		merged_uh->segment_start_time = uh_2->segment_start_time; equal = FALSE_m13;
	}
	if (uh_1->segment_end_time == UUTC_NO_ENTRY_m13) {
		if (uh_2->segment_end_time == UUTC_NO_ENTRY_m13)
			merged_uh->segment_end_time = UUTC_NO_ENTRY_m13;
		else
			merged_uh->segment_end_time = uh_2->segment_end_time;
	} else if (uh_2->segment_end_time == UUTC_NO_ENTRY_m13) {
		merged_uh->segment_end_time = uh_1->segment_start_time;
	} else if (uh_1->segment_end_time < uh_2->segment_end_time) {
		merged_uh->segment_end_time = uh_2->segment_end_time; equal = FALSE_m13;
	}
	if (uh_1->n_entries < uh_2->n_entries) {
		merged_uh->n_entries = uh_2->n_entries; equal = FALSE_m13;
	}
	if (uh_1->maximum_entry_size < uh_2->maximum_entry_size) {
		merged_uh->maximum_entry_size = uh_2->maximum_entry_size; equal = FALSE_m13;
	}
	if (uh_1->segment_number != uh_2->segment_number) {
		merged_uh->segment_number = UH_SEGMENT_NUMBER_NO_ENTRY_m13; equal = FALSE_m13;
	}
	if (memcmp(uh_1->session_name, uh_2->session_name, NAME_BYTES_m13)) {
		memset(merged_uh->session_name, 0, NAME_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(uh_1->channel_name, uh_2->channel_name, NAME_BYTES_m13)) {
		memset(merged_uh->channel_name, 0, NAME_BYTES_m13); equal = FALSE_m13;
	}
	if (uh_1->session_UID != uh_2->session_UID) {
		merged_uh->session_UID = UID_NO_ENTRY_m13; equal = FALSE_m13;
	}
	if (uh_1->channel_UID != uh_2->channel_UID) {
		merged_uh->channel_UID = UID_NO_ENTRY_m13; equal = FALSE_m13;
	}
	if (uh_1->segment_UID != uh_2->segment_UID) {
		merged_uh->segment_UID = UID_NO_ENTRY_m13; equal = FALSE_m13;
	}
	if (uh_1->file_UID != uh_2->file_UID) {
		merged_uh->file_UID = UID_NO_ENTRY_m13; equal = FALSE_m13;
	}
	if (uh_1->provenance_UID != uh_2->provenance_UID) {
		merged_uh->provenance_UID = UID_NO_ENTRY_m13; equal = FALSE_m13;
	}
	if (memcmp(uh_1->level_1_password_validation_field, uh_2->level_1_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m13)) {
		memset(merged_uh->level_1_password_validation_field, 0, PASSWORD_VALIDATION_FIELD_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(uh_1->level_2_password_validation_field, uh_2->level_2_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m13)) {
		memset(merged_uh->level_2_password_validation_field, 0, PASSWORD_VALIDATION_FIELD_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(uh_1->level_3_password_validation_field, uh_2->level_3_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m13)) {
		memset(merged_uh->level_3_password_validation_field, 0, PASSWORD_VALIDATION_FIELD_BYTES_m13); equal = FALSE_m13;
	}
	if (uh_1->video_data_file_number != uh_2->video_data_file_number) {
		merged_uh->video_data_file_number = 0; equal = FALSE_m13;
	}
	if (uh_1->ordered != uh_2->ordered) {
		merged_uh->ordered = UNKNOWN_m13; equal = FALSE_m13;
	}
	if (uh_1->encryption_rounds != uh_2->encryption_rounds) {
		merged_uh->encryption_rounds = 0; equal = FALSE_m13;
	}
	if (uh_1->encryption_1 != uh_2->encryption_1) {
		merged_uh->encryption_1 = NO_ENCRYPTION_m13; equal = FALSE_m13;
	}
	if (uh_1->encryption_2 != uh_2->encryption_2) {
		merged_uh->encryption_2 = NO_ENCRYPTION_m13; equal = FALSE_m13;
	}
	if (uh_1->encryption_3 != uh_2->encryption_3) {
		merged_uh->encryption_3 = NO_ENCRYPTION_m13; equal = FALSE_m13;
	}
	if (memcmp(uh_1->protected_region, uh_2->protected_region, UH_PROTECTED_REGION_BYTES_m13)) {
		memset(merged_uh->protected_region, 0, UH_PROTECTED_REGION_BYTES_m13); equal = FALSE_m13;
	}
	if (memcmp(uh_1->discretionary_region, uh_2->discretionary_region, UH_DISCRETIONARY_REGION_BYTES_m13)) {
		memset(merged_uh->discretionary_region, 0, UH_DISCRETIONARY_REGION_BYTES_m13); equal = FALSE_m13;
	}
	
	return_m13(equal);
}


void  G_message_m13(const si1 *fmt, ...)
{
	va_list		v_args;
	ui4		behavior;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// uncolored suppressible text to stdout
	behavior = G_current_behavior_m13();
	if (!(behavior & SUPPRESS_MESSAGE_OUTPUT_m13)) {
		va_start(v_args, fmt);
		vprintf_m13(fmt, v_args);
		va_end(v_args);
		#ifndef MATLAB_m13
		fflush(stdout);
		#endif
	}

	return_void_m13;
}


CHAN_m13	*G_open_channel_m13(CHAN_m13 *chan, SLICE_m13 *slice, si1 *chan_path, LH_m13 *parent, ui8 flags, si1 *password)
{
	tern				free_chan, threading, ret_val;
	si1				tmp_str[PATH_BYTES_m13], num_str[FILE_NUMBERING_DIGITS_m13 + 1], *type_str;
	si4				i, j, k, seg_idx, thread_idx, n_segs, mapped_segs, null_segment_cnt;
	PROC_GLOBS_m13			*proc_globs;
	SEG_m13				*seg;
	UH_m13				*uh;
	PROC_THREAD_INFO_m13		*proc_thread_infos;
	READ_MED_THREAD_INFO_m13	*seg_thread_infos;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// allocate channel
	if (chan == NULL) {
		chan = (CHAN_m13 *) calloc_m13((size_t) 1, -sizeof(CHAN_m13));  // flag as level header
		if (chan == NULL)
			return_m13(NULL);
		chan->path = chan->local_path;
		chan->name = chan->local_name;
		free_chan = TRUE_m13;
	} else {
		free_chan = FALSE_m13;
	}

	// set basic info (path, name, type, flags, parent)
	if (*chan_path)
		chan->type_code = G_MED_path_components_m13(chan_path, chan->path, chan->name);
	if (STR_empty_m13(chan->path) == TRUE_m13) {
		if (free_chan == TRUE_m13)
			G_free_channel_m13(&chan);
		G_set_error_m13(E_MED_m13, "empty channel path");
		return_m13(NULL);
	}
	if (G_exists_m13(chan->path) == FALSE_m13) {
		if (free_chan == TRUE_m13)
			G_free_channel_m13(&chan);
		G_set_error_m13(E_MED_m13, "channel does not exist");
		return_m13(NULL);
	}
	if (CHANNEL_CODE_m13(chan->type_code) == FALSE_m13) {
		if (free_chan == TRUE_m13)
			G_free_channel_m13(&chan);
		G_set_error_m13(E_MED_m13, "unrecognized channel type");
		return_m13(NULL);
	}
	if (slice)  // passed slice supersedes structure slice
		chan->slice = *slice;
	slice = &chan->slice;
	if (G_all_zeros_m13((ui1 *) slice, (si4) sizeof(SLICE_m13)) == TRUE_m13)
		G_init_slice_m13(slice);
	if (flags)
		chan->flags = flags;
	else
		flags = chan->flags;
	chan->parent = parent;

	// set session globals (password, time constants, session directory/name)
	proc_globs = G_proc_globs_m13((LH_m13 *) chan);
	if (proc_globs->time_constants.set != TRUE_m13) {
		if (G_set_session_globals_m13(chan->path, password, (LH_m13 *) chan) == FALSE_m13) {
			if (free_chan == TRUE_m13)
				G_free_channel_m13(&chan);
			return_m13(NULL);
		}
	}
	
	// process time slice (passed slice is not modified)
	if (slice->conditioned == FALSE_m13)
		G_condition_slice_m13(slice, (LH_m13 *) chan);
			
	// get segment range
	if (slice->n_segs == UNKNOWN_m13) {
		if (G_segment_range_m13((LH_m13 *) chan, slice) == 0) {
			if (free_chan == TRUE_m13)
				G_free_channel_m13(&chan);
			return_m13(NULL);
		}
	}
	
	// channel records
	// Note: open records before opening segments because that may be threaded, so preferable to change channel names now
	if (chan->flags & LH_READ_CHAN_RECS_MASK_m13) {
		// open indicies
		if (chan->rec_inds_fps == NULL) {  // may already be read from get_segment_range()
			sprintf_m13(tmp_str, "%s/%s.%s", chan->path, chan->name, REC_INDS_TYPE_STR_m13);
			if (G_exists_m13(tmp_str) == FILE_EXISTS_m13) {
				chan->rec_inds_fps = FPS_read_m13(chan->rec_inds_fps, 0, FPS_FULL_FILE_m13, 0, (LH_m13 *) chan, NULL, tmp_str, "r", NULL, (LH_m13 *) chan);
				if (chan->rec_inds_fps == NULL) {
					if (free_chan == TRUE_m13)
						G_free_channel_m13(&chan);
					return_m13(NULL);
				}
			}
		}
		// open data
		if (chan->rec_data_fps == NULL) {  // may already be read from get_segment_range()
			sprintf_m13(tmp_str, "%s/%s.%s", chan->path, chan->name, REC_DATA_TYPE_STR_m13);
			if (G_exists_m13(tmp_str) == FILE_EXISTS_m13) {
				chan->rec_data_fps = FPS_read_m13(chan->rec_data_fps, 0, FPS_AUTO_BYTES_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) chan);
				if (chan->rec_data_fps == NULL) {
					if (free_chan == TRUE_m13)
						G_free_channel_m13(&chan);
					return_m13(NULL);
				}
			}
		}
		// check for rename
		if (strcmp_m13(chan->name, chan->rec_inds_fps->uh->channel_name))
			G_update_channel_name_m13(chan);
	}
	
	// open segments
	seg_idx = G_segment_index_m13(slice->start_seg_num, (LH_m13 *) chan);
	if (seg_idx == FALSE_m13) {
		if (free_chan == TRUE_m13)
			G_free_channel_m13(&chan);
		return_m13(NULL);
	}
	n_segs = slice->n_segs;
	mapped_segs = proc_globs->current_session.n_mapped_segments;

	if (chan->segs == NULL) {
		chan->segs = (SEG_m13 **) calloc_m13((size_t) mapped_segs, sizeof(SEG_m13 *));  // map segments
		if (chan->segs == NULL) {
			if (free_chan == TRUE_m13)
				G_free_channel_m13(&chan);
			return_m13(NULL);
		}
	}
	
	threading = proc_globs->miscellaneous.threading;
	if (n_segs == 1)  // no sense in overhead for one thread
		threading = FALSE_m13;
	else if (!(flags & LH_THREAD_SEG_READS_m13))
		threading = FALSE_m13;

	// set up thread infos
	proc_thread_infos = (PROC_THREAD_INFO_m13 *) calloc((size_t) n_segs, sizeof(PROC_THREAD_INFO_m13));
	seg_thread_infos = (READ_MED_THREAD_INFO_m13 *) calloc((size_t) n_segs, sizeof(READ_MED_THREAD_INFO_m13));
	
	// start read_segment threads
	null_segment_cnt = 0;
	thread_idx = 0;
	for (i = slice->start_seg_num, j = seg_idx, k = 0; i <= slice->end_seg_num; ++i, ++j, ++k) {
		seg = chan->segs[j];
		if (seg == NULL) {
			STR_fixed_width_int_m13(num_str, FILE_NUMBERING_DIGITS_m13, i);
			if (chan->type_code == TS_CHAN_TYPE_CODE_m13)
				sprintf_m13(seg_thread_infos[k].MED_dir, "%s/%s_s%s.%s", chan->path, chan->name, num_str, TS_SEG_TYPE_STR_m13);
			else  // VID_CHAN_TYPE_CODE_m13
				sprintf_m13(seg_thread_infos[k].MED_dir, "%s/%s_s%s.%s", chan->path, chan->name, num_str, VID_SEG_TYPE_STR_m13);
			if (G_exists_m13(seg_thread_infos[k].MED_dir) != DIR_EXISTS_m13) {
				// not every segment may be present
				++null_segment_cnt;
				continue;
			}
		} else {
			seg_thread_infos[k].MED_struct = (LH_m13 *) seg;
		}
		seg_thread_infos[k].parent = (LH_m13 *) chan;
		seg->slice = *slice;
		proc_thread_infos[thread_idx].thread_f = G_open_segment_thread_m13;
		proc_thread_infos[thread_idx].thread_label = "G_open_segment_thread_m13";
		proc_thread_infos[thread_idx].priority = PROC_HIGH_PRIORITY_m13;
		proc_thread_infos[thread_idx].arg = (void *) (seg_thread_infos + thread_idx);
		++thread_idx;
	}

	// thread out segment opens
	ret_val = PROC_distribute_jobs_m13(proc_thread_infos, n_segs, 0, TRUE_m13, threading);  // no reserved cores, wait for completion

	// check results
	for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
		seg = (SEG_m13 *) seg_thread_infos[i].MED_struct;
		if (seg == NULL)
			ret_val = FALSE_m13;
		else
			chan->segs[j] = seg;
	}
	free((void *) proc_thread_infos);
	free((void *) seg_thread_infos);
	if (ret_val == FALSE_m13) {
		if (free_chan == TRUE_m13)
			G_free_channel_m13(&chan);
		return_m13(NULL);
	}

	// empty slice
	if (null_segment_cnt == n_segs) {
		slice->n_segs = EMPTY_SLICE_m13;
		if (free_chan == TRUE_m13)
			G_free_channel_m13(&chan);
		return_m13(NULL);
	}

	// update slice
	for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
		seg = chan->segs[j];
		if (seg)
			break;
	}
	slice->start_time = seg->slice.start_time;
	slice->start_samp_num = seg->slice.start_samp_num;
	slice->start_seg_num = seg->slice.start_seg_num;
	for (++i, ++j; i < n_segs; ++i, ++j) {
		if (chan->segs[j])
			seg = chan->segs[j];
	}
	slice->end_time = seg->slice.end_time;
	slice->end_samp_num = seg->slice.end_samp_num;
	slice->end_seg_num = seg->slice.end_seg_num;
	slice->n_segs = SLICE_SEG_COUNT_m13(slice);

	// ephemeral data
	if (chan->flags & LH_GENERATE_EPHEMERAL_DATA_m13) {
		if (chan->metadata_fps)
			FPS_free_m13(&chan->metadata_fps);
		for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
			seg = chan->segs[j];
			if (seg)
				break;
		}
		if (chan->type_code == TS_CHAN_TYPE_CODE_m13)
			type_str = TS_METADATA_TYPE_STR_m13;
		else  // VID_CHAN_TYPE_CODE_m13
			type_str = VID_METADATA_TYPE_STR_m13;
		sprintf_m13(tmp_str, "%s/%s.%s", chan->path, chan->name, type_str);
		chan->metadata_fps = FPS_init_m13(NULL, tmp_str, NULL, METADATA_BYTES_m13, (LH_m13 *) chan);
		if (chan->metadata_fps == NULL) {
			if (free_chan == TRUE_m13)
				G_free_channel_m13(&chan);
			return_m13(NULL);
		}
		G_init_metadata_m13(chan->metadata_fps, FALSE_m13);
		// merge segments
		for (++i, ++j; i < n_segs; ++i, ++j) {
			seg = chan->segs[j];
			if (seg == NULL)
				continue;
			G_merge_universal_headers_m13(chan->metadata_fps, seg->metadata_fps, NULL);
			G_merge_metadata_m13(chan->metadata_fps, seg->metadata_fps, NULL);
			if (seg->rec_inds_fps && seg->rec_data_fps)  // record data, not record indices universal header is merged in ephemeral data
				G_merge_universal_headers_m13(chan->metadata_fps, seg->rec_data_fps, NULL);
			seg->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m13;  // clear segment flag
		}
		// merge channel records
		if (chan->rec_inds_fps && chan->rec_data_fps)  // record data, not record indices universal header is merged in ephemeral data
			G_merge_universal_headers_m13(chan->metadata_fps, chan->rec_data_fps, NULL);
		// fix channel ephemeral universl headers (from merge functions)
		uh = chan->metadata_fps->uh;
		if (chan->type_code == TS_CHAN_TYPE_CODE_m13)  // level code
			uh->type_code = TS_METADATA_TYPE_CODE_m13;
		else if (chan->type_code == VID_CHAN_TYPE_CODE_m13)  // level code
			uh->type_code = VID_METADATA_TYPE_CODE_m13;
		uh->segment_number = UH_CHANNEL_LEVEL_CODE_m13;
		uh->session_UID = proc_globs->current_session.UID;
		uh->channel_UID = seg->metadata_fps->uh->channel_UID;;
		uh->segment_UID = UID_NO_ENTRY_m13;
		chan->metadata_fps->params.fp->fd = FPS_FD_EPHEMERAL_m13;
		chan->flags |= LH_UPDATE_EPHEMERAL_DATA_m13;
	}
	
	return_m13(chan);
}


pthread_rval_m13	G_open_channel_thread_m13(void *ptr)
{
	CHAN_m13			*ret_val;
	PROC_THREAD_INFO_m13 		*pi;
	READ_MED_THREAD_INFO_m13 	*rmi;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	pi = (PROC_THREAD_INFO_m13 *) ptr;
	pi->status = PROC_THREAD_RUNNING_m13;  // volatile

	rmi = (READ_MED_THREAD_INFO_m13 *) (pi->arg);
	ret_val = G_open_channel_m13((CHAN_m13 *) rmi->MED_struct, rmi->slice, rmi->MED_dir, rmi->parent, rmi->flags, rmi->password);
	
	G_free_thread_local_storage_m13((LH_m13 *) rmi->MED_struct);

	if (ret_val) {
		rmi->MED_struct = (LH_m13 *) ret_val;
		pi->status = PROC_THREAD_SUCCEEDED_m13;  // volatile
	} else {
		rmi->MED_struct = NULL;
		pi->status = PROC_THREAD_FAILED_m13;  // volatile
	}
	
	thread_return_null_m13;
}


SSR_m13	*G_open_seg_sess_recs_m13(SESS_m13 *sess)
{
	si1			tmp_str[PATH_BYTES_m13], num_str[FILE_NUMBERING_DIGITS_m13 + 1], *name;
	si4			i, de, fe, mapped_segs;
	SSR_m13	*ssr;
	PROC_GLOBS_m13	*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	ssr = sess->ssr;
	if (ssr == NULL) {
		ssr = sess->ssr = (SSR_m13 *) calloc_m13((size_t) 1, -sizeof(SSR_m13));  // flag as level header
		if (ssr == NULL)
			return_m13(ssr);
		ssr->path = ssr->local_path;
		ssr->name = sess->name;
	}
	
	proc_globs = G_proc_globs_m13((LH_m13 *) sess);
	sprintf_m13(tmp_str, "%s/%s.%s", sess->path, sess->name, SSR_TYPE_STR_m13);
	de = G_exists_m13(tmp_str);
	if (de == FALSE_m13) {  // sess->name defaults to fs_name
		if (proc_globs->current_session.names_differ == TRUE_m13) {
			if (sess->name == proc_globs->current_session.fs_name)
				name = proc_globs->current_session.uh_name;
			else
				name = proc_globs->current_session.fs_name;
			sprintf_m13(tmp_str, "%s/%s.%s", sess->path, name, SSR_TYPE_STR_m13);
			de = G_exists_m13(tmp_str);
			if (de == FALSE_m13)
				return_m13(NULL);
		}
	}
	
	strcpy_m13(ssr->path, tmp_str);
	ssr->type_code = SSR_TYPE_CODE_m13;
	ssr->flags = sess->flags;
	ssr->parent = (LH_m13 *) sess;
	mapped_segs = proc_globs->current_session.n_mapped_segments;
	ssr->rec_data_fps = (FPS_m13 **) calloc_m13((size_t) mapped_segs, sizeof(FPS_m13 *));
	ssr->rec_inds_fps = (FPS_m13 **) calloc_m13((size_t) mapped_segs, sizeof(FPS_m13 *));
	for (i = 0; i < mapped_segs; ++i) {
		// record indices
		STR_fixed_width_int_m13(num_str, FILE_NUMBERING_DIGITS_m13, i + 1);
		sprintf_m13(tmp_str, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, REC_INDS_TYPE_STR_m13);
		fe = G_exists_m13(tmp_str);
		if (fe == FALSE_m13) {
			if (proc_globs->current_session.names_differ == TRUE_m13) {
				if (sess->name == proc_globs->current_session.fs_name)
					name = proc_globs->current_session.uh_name;
				else
					name = proc_globs->current_session.fs_name;
				sprintf_m13(tmp_str, "%s/%s_s%s.%s", ssr->path, name, num_str, REC_INDS_TYPE_STR_m13);
				fe = G_exists_m13(tmp_str);
			}
		}
		if (fe == TRUE_m13)
			ssr->rec_inds_fps[i] = FPS_read_m13(NULL, 0, FPS_FULL_FILE_m13, 0, NULL, tmp_str, NULL, (LH_m13 *) ssr, NULL);

		// record data
		fe = G_exists_m13(tmp_str);
		sprintf_m13(tmp_str, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, REC_DATA_TYPE_STR_m13);
		if (fe == FALSE_m13) {  // sess->name defaults to fs_name
			if (proc_globs->current_session.names_differ == TRUE_m13) {
				if (sess->name == proc_globs->current_session.fs_name)
					name = proc_globs->current_session.uh_name;
				else
					name = proc_globs->current_session.fs_name;
				sprintf_m13(tmp_str, "%s/%s_s%s.%s", ssr->path, name, num_str, REC_DATA_TYPE_STR_m13);
				fe = G_exists_m13(tmp_str);
			}
		}
		if (fe == TRUE_m13)
			ssr->rec_data_fps[i] = FPS_read_m13(NULL, 0, FPS_AUTO_BYTES_m13, 0, NULL, tmp_str, NULL, (LH_m13 *) ssr, NULL);
	}
		
	return_m13(ssr);
}


SEG_m13	*G_open_segment_m13(SEG_m13 *seg, SLICE_m13 *slice, si1 *seg_path, LH_m13 *parent, ui8 flags, si1 *password)
{
	tern		free_seg;
	si1		tmp_str[PATH_BYTES_m13], *type_str;
	si8		len;
	PROC_GLOBS_m13	*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// allocate segment
	if (seg == NULL) {
		seg = (SEG_m13 *) calloc_m13((size_t) 1, -sizeof(SEG_m13));  // flag as level header
		if (seg == NULL)
			return_m13(NULL);
		free_seg = TRUE_m13;
		seg->path = seg->local_path;
		seg->name = seg->local_name;
	} else {
		free_seg = FALSE_m13;
	}
	
	// set basic info (path, name, type, flags)
	if (*seg_path)
		seg->type_code = G_MED_path_components_m13(seg_path, seg->path, seg->name);
	if (STR_empty_m13(seg->path) == TRUE_m13) {
		if (free_seg == TRUE_m13)
			G_free_segment_m13((void *) seg);
		G_set_error_m13(E_MED_m13, "empty segment path");
		return_m13(NULL);
	}
	if (G_exists_m13(seg->path) == FALSE_m13) {
		if (free_seg == TRUE_m13)
			G_free_segment_m13((void *) seg);
		G_set_error_m13(E_MED_m13, "segment does not exist");
		return_m13(NULL);
	}
	if (SEGMENT_CODE_m13(seg->type_code) == FALSE_m13) {
		if (free_seg == TRUE_m13)
			G_free_segment_m13(&seg);
		G_set_error_m13(E_MED_m13, "unrecognized segment type");
		return_m13(NULL);
	}
	if (slice)  // passed slice supersedes structure slice
		seg->slice = *slice;
	slice = &seg->slice;
	if (G_all_zeros_m13((ui1 *) slice, (si4) sizeof(SLICE_m13)) == TRUE_m13)
		G_init_slice_m13(slice);
	if (flags)
		seg->flags = flags;
	else
		flags = seg->flags;
	seg->parent = parent;
	
	// set session globals (password, time constants, session directory/name)
	proc_globs = G_proc_globs_m13((LH_m13 *) seg);
	if (proc_globs->time_constants.set != TRUE_m13) {
		if (G_set_session_globals_m13(seg->path, password, (LH_m13 *) seg) == FALSE_m13) {
			if (free_seg == TRUE_m13)
				G_free_segment_m13(&seg);
			return_m13(NULL);
		}
	}

	// process time slice (passed slice is not modified)
	if (slice->conditioned == FALSE_m13)
		G_condition_slice_m13(slice, (LH_m13 *) seg);
		
	// metadata
	if (seg->flags & LH_READ_METADATA_MASK_m13) {
		if (seg->type_code == TS_SEG_TYPE_CODE_m13)
			type_str = TS_METADATA_TYPE_STR_m13;
		else // seg->type_code == VID_SEG_TYPE_CODE_m13
			type_str = VID_METADATA_TYPE_STR_m13;
		sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, type_str);
		if (G_exists_m13(tmp_str) == FILE_EXISTS_m13) {
			seg->metadata_fps = FPS_read_m13(seg->metadata_fps, 0, FPS_FULL_FILE_m13, 1, NULL, tmp_str, "r", NULL, (LH_m13 *) seg);
			if (seg->metadata_fps == NULL) {
				G_free_segment_m13(&seg);
				return_m13(NULL);
			}
			// check for rename
			len = strlen(seg->name);
			seg->name[len - 5] = 0;
			if (strcmp_m13(tmp_str, seg->metadata_fps->uh->channel_name))
				if (seg->parent)  // can be null
					if (CHANNEL_CODE_m13(seg->parent->type_code) == TRUE_m13)  // can be proc_globs
						G_update_channel_name_m13((CHAN_m13 *) seg->parent);
			seg->name[len - 5] = '-';
		}
	}
	
	// segment data
	if (seg->flags & LH_READ_SEG_DATA_MASK_m13) {

		// indices
		if (seg->type_code == TS_SEG_TYPE_CODE_m13)
			type_str = TS_INDS_TYPE_STR_m13;
		else // seg->type_code == VID_SEG_TYPE_CODE_m13
			type_str = VID_INDS_TYPE_STR_m13;
		sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, type_str);
		if (G_exists_m13(tmp_str) == FILE_EXISTS_m13) {  // note seg->vid_inds_fps is the same pointer, so works for either
			seg->ts_inds_fps = FPS_read_m13(seg->ts_inds_fps, 0, FPS_FULL_FILE_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) seg);
			if (seg->ts_inds_fps == NULL) {
				G_free_segment_m13(&seg);
				return_m13(NULL);
			}
		}
		
		// data (time series data only)
		if (seg->type_code == TS_SEG_TYPE_CODE_m13) {
			sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, TS_DATA_TYPE_STR_m13);
			if (G_exists_m13(tmp_str) == FILE_EXISTS_m13) {
				seg->ts_data_fps = FPS_read_m13(seg->ts_data_fps, 0, FPS_AUTO_BYTES_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) seg);
				if (seg->ts_data_fps == NULL) {
					G_free_segment_m13(&seg);
					return_m13(NULL);
				}
			}
		}
	}

	// segment records
	if (seg->flags & LH_READ_SEG_RECS_MASK_m13) {
		sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, REC_INDS_TYPE_STR_m13);
		if (G_exists_m13(tmp_str) == FILE_EXISTS_m13) {
			seg->rec_inds_fps = FPS_read_m13(seg->rec_inds_fps, 0, FPS_FULL_FILE_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) seg);
			if (seg->rec_inds_fps == NULL) {
				G_free_segment_m13(&seg);
				return_m13(NULL);
			}
		}
		sprintf_m13(tmp_str, "%s/%s.%s", seg->path, seg->name, REC_DATA_TYPE_STR_m13);
		if (G_exists_m13(tmp_str) == FILE_EXISTS_m13) {
			seg->rec_data_fps = FPS_read_m13(seg->rec_data_fps, 0, FPS_AUTO_BYTES_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) seg);
			if (seg->rec_data_fps == NULL) {
				G_free_segment_m13(&seg);
				return_m13(NULL);
			}
		}
	}
	
	if (seg->flags & LH_GENERATE_EPHEMERAL_DATA_m13)
		seg->flags |= LH_UPDATE_EPHEMERAL_DATA_m13;

	return_m13(seg);
}


pthread_rval_m13	G_open_segment_thread_m13(void *ptr)
{
	SEG_m13				*ret_val;
	PROC_THREAD_INFO_m13 		*pi;
	READ_MED_THREAD_INFO_m13 	*rmi;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	pi = (PROC_THREAD_INFO_m13 *) ptr;
	pi->status = PROC_THREAD_RUNNING_m13;  // volatile

	rmi = (READ_MED_THREAD_INFO_m13 *) (pi->arg);
	ret_val = G_open_segment_m13((SEG_m13 *) rmi->MED_struct, rmi->slice, rmi->MED_dir, rmi->parent, rmi->flags, rmi->password);
	
	G_free_thread_local_storage_m13((LH_m13 *) rmi->MED_struct);

	if (ret_val) {
		rmi->MED_struct = (LH_m13 *) ret_val;
		pi->status = PROC_THREAD_SUCCEEDED_m13;  // volatile
	} else {
		rmi->MED_struct = NULL;
		pi->status = PROC_THREAD_FAILED_m13;  // volatile
	}
	
	thread_return_null_m13;
}


SESS_m13	*G_open_session_m13(SESS_m13 *sess, SLICE_m13 *slice, void *file_list, si4 list_len, ui8 flags, si1 *password, si1 *index_channel_name)
{
	tern				free_sess, all_channels_selected, include_ts_chans, include_vid_chans, threading, ret_val;
	si1				*sess_dir, **chan_list, **ts_chan_list, **vid_chan_list, tmp_str[PATH_BYTES_m13], *tmp_str_ptr;
	si1				**full_ts_chan_list, **full_vid_chan_list, *regex_str;
	ui4				type_code;
	si4				i, j, n_chans, n_segs, seg_idx, thread_idx;
	si4				n_ts_chans, n_vid_chans, all_ts_chans, all_vid_chans;
	PROC_GLOBS_m13			*proc_globs;
	CHAN_m13			*chan;
	UH_m13				*uh;
	PROC_THREAD_INFO_m13		*proc_thread_infos;
	READ_MED_THREAD_INFO_m13	*read_MED_thread_infos;
	SSR_m13				*ssr;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// if file_list is a pointer to single string, make list_len zero to indicate a one dimensional char array
	// if list_len > 0, assumed to be two dimensional array

	// allocate session
	if (sess == NULL) {
		sess = (SESS_m13 *) calloc_m13((size_t) 1, -sizeof(SESS_m13));  // flag as level header
		if (sess == NULL)
			return_m13(NULL);
		sess->type_code = SESS_TYPE_CODE_m13;
		free_sess = TRUE_m13;
	} else {
		free_sess = FALSE_m13;
	}
	if (slice)  // passed slice supersedes structure slice
		sess->slice = *slice;
	slice = &sess->slice;
	if (G_all_zeros_m13((ui1 *) slice, (si4) sizeof(SLICE_m13)) == TRUE_m13)
		G_init_slice_m13(slice);
	if (flags)
		sess->flags = flags;
	else
		flags = sess->flags;
	proc_globs = G_proc_globs_m13((LH_m13 *) sess);
	sess->path = proc_globs->current_session.directory;
	sess->name = proc_globs->current_session.fs_name;  // default to fs_name
	if (*index_channel_name)
		strcpy(proc_globs->current_session.index_channel_name, index_channel_name);
	
	// generate channel list
	all_channels_selected = FALSE_m13;
	sess_dir = NULL;
	chan_list = NULL;
	if (list_len == 0) {  // single string
		if (STR_contains_regex_m13((si1 *) file_list) == TRUE_m13) {  // regex string passed: make 1 element channel list, NULL session directory
			chan_list = (si1 **) &file_list;
			n_chans = 1;
		} else {  // directory passed: NULL channel list
			type_code = G_MED_type_code_from_string_m13((si1 *) file_list);
			if (type_code == NO_TYPE_CODE_m13)
				type_code = G_add_level_extension_m13((si1 *) file_list);
			switch (type_code) {
				case SESS_TYPE_CODE_m13:  // session directory passed: NULL channel list
					all_channels_selected = TRUE_m13;
					sess_dir = (si1 *) file_list;
					chan_list = NULL;
					n_chans = 0;
					break;
				case TS_CHAN_TYPE_CODE_m13:
				case VID_CHAN_TYPE_CODE_m13:  // channel passed: make 1 element channel list, NULL session directory
					chan_list = (si1 **) &file_list;
					n_chans = 1;
					break;
				case TS_SEG_TYPE_CODE_m13:  // I don't think segments will actually get passed to this function, but you never know
				case VID_SEG_TYPE_CODE_m13:  // segment passed: truncate to channel directory, make 1 element channel list, NULL session directory
					G_path_parts_m13(tmp_str, (si1 *) file_list, NULL, NULL);
					tmp_str_ptr = tmp_str;  // copy pointer so can take address
					chan_list = &tmp_str_ptr;
					n_chans = 1;
					break;
				default:
					G_set_error_m13(E_MED_m13, "invalid file type");
					G_free_session_m13(&sess);
					return_m13(NULL);
			}
		}
	} else {  // channel list passed: NULL session directory
		chan_list = (si1 **) file_list;
		n_chans = list_len;
	}
#if defined MACOS_m13 || defined LINUX_m13
	regex_str = "[tv]icd";  // more specific (than Windows)
#endif
#ifdef WINDOWS_m13
	regex_str = "?icd";  // less specific (than MacOS or Linux)
#endif
	chan_list = G_file_list_m13(chan_list, &n_chans, sess_dir, NULL, regex_str, GFL_FULL_PATH_m13);
	if (n_chans == 0) {
		if (free_sess == TRUE_m13)
			G_free_session_m13(&sess);
		G_set_error_m13(E_UNKN_m13, "no channels in file list");  // list len == 0 is not an error for G_file_list_m13(), so this is causal error
		return_m13(NULL);
	}

	// set session globals (password, time constants, session directory/name)
	if (proc_globs->time_constants.set == FALSE_m13) {
		if (G_set_session_globals_m13(chan_list[0], password, (LH_m13 *) sess) == FALSE_m13) {
			if (free_sess == TRUE_m13)
				G_free_session_m13(&sess);
			return_m13(NULL);
		}
	}

	// divide channel lists
	if (flags & LH_EXCLUDE_TS_CHANS_m13) {
		include_ts_chans = FALSE_m13;
		sess->flags = (flags &= ~LH_MAP_ALL_TS_CHANS_m13);  // exclude flag supercedes map all flag
		ts_chan_list = NULL;
	} else {
		include_ts_chans = TRUE_m13;
		ts_chan_list = (si1 **) calloc_2D_m13((size_t) n_chans, PATH_BYTES_m13, sizeof(si1));
	}
	if (flags & LH_EXCLUDE_VID_CHANS_m13) {
		include_vid_chans = FALSE_m13;
		sess->flags = (flags &= ~LH_MAP_ALL_VID_CHANS_m13);  // exclude flag supercedes map all flag
		vid_chan_list = NULL;
	} else {
		include_vid_chans = TRUE_m13;
		vid_chan_list = (si1 **) calloc_2D_m13((size_t) n_chans, PATH_BYTES_m13, sizeof(si1));
	}
	n_ts_chans = n_vid_chans = 0;
	for (i = 0; i < n_chans; ++i) {
		type_code = G_MED_type_code_from_string_m13(chan_list[i]);
		switch (type_code) {
			case TS_CHAN_TYPE_CODE_m13:
				if (include_ts_chans == TRUE_m13)
					strcpy(ts_chan_list[n_ts_chans++], chan_list[i]);
				break;
			case VID_CHAN_TYPE_CODE_m13:
				if (include_vid_chans == TRUE_m13)
					strcpy(vid_chan_list[n_vid_chans++], chan_list[i]);
				break;
			default:
				if (free_sess == TRUE_m13)
					G_free_session_m13(&sess);
				G_set_error_m13(E_MED_m13, "channels must be MED channel directories");
				return_m13(NULL);
		}
	}
	free_m13((void *) chan_list);

	// set up time series channels
	if (sess->flags & LH_MAP_ALL_TS_CHANS_m13 && all_channels_selected == FALSE_m13) {
		// get lists of all channels, regardless of what was passed in the list
		if (sess_dir == NULL) {
			if (n_ts_chans)
				G_path_parts_m13(ts_chan_list[0], tmp_str, NULL, NULL);
			else
				G_path_parts_m13(vid_chan_list[0], tmp_str, NULL, NULL);
			sess_dir = tmp_str;
		}
		full_ts_chan_list = G_file_list_m13(NULL, &all_ts_chans, sess_dir, NULL, "ticd", GFL_FULL_PATH_m13);
		if (all_ts_chans == 0)
			n_ts_chans = 0;
		if (n_ts_chans) {
			sess->ts_chans = (CHAN_m13 **) calloc_2D_m13((size_t) all_ts_chans, (size_t) 1, -sizeof(CHAN_m13));
			if (sess->ts_chans == NULL) {
				if (free_sess == TRUE_m13)
					G_free_session_m13(&sess);
				return_m13(NULL);
			}
			for (i = 0; i < all_ts_chans; ++i) {
				chan = sess->ts_chans[i];
				chan->path = chan->local_path;
				chan->name = chan->local_name;
				chan->type_code = TS_CHAN_TYPE_CODE_m13;
				chan->flags = flags;
				chan->parent = (LH_m13 *) sess;
				G_MED_path_components_m13(full_ts_chan_list[i], chan->path, chan->name);
			}
			// match passed list to full list to mark as active
			if (all_ts_chans == n_ts_chans) {
				for (i = 0; i < all_ts_chans; ++i) {
					chan = sess->ts_chans[i];
					chan->flags |= LH_CHAN_ACTIVE_m13;
				}
			} else {  // lists are in alphabetical order
				for (i = j = 0; i < n_ts_chans; ++i) {
					for (; strcmp_m13(ts_chan_list[i], full_ts_chan_list[j]); ++j);
					chan = sess->ts_chans[j];
					chan->flags |= LH_CHAN_ACTIVE_m13;
				}
			}
			free_m13((void *) full_ts_chan_list);
			free_m13((void *) ts_chan_list);
			sess->n_ts_chans = all_ts_chans;
		}
	} else if (n_ts_chans) {
		sess->ts_chans = (CHAN_m13 **) calloc_2D_m13((size_t) n_ts_chans, (size_t) 1, -sizeof(CHAN_m13));
		if (sess->ts_chans == NULL) {
			if (free_sess == TRUE_m13)
				G_free_session_m13(&sess);
			return_m13(NULL);
		}
		for (i = 0; i < n_ts_chans; ++i) {
			chan = sess->ts_chans[i];
			chan->path = chan->local_path;
			chan->name = chan->local_name;
			chan->type_code = TS_CHAN_TYPE_CODE_m13;
			chan->flags = flags | LH_CHAN_ACTIVE_m13;
			chan->parent = (LH_m13 *) sess;
			G_MED_path_components_m13(ts_chan_list[i], chan->path, chan->name);
		}
		free_m13((void *) ts_chan_list);
		sess->n_ts_chans = n_ts_chans;
	}

	// set up video channels
	if (sess->flags & LH_MAP_ALL_VID_CHANS_m13 && all_channels_selected == FALSE_m13) {
		// get lists of all channels, regardless of what was passed in the list
		if (sess_dir == NULL) {
			if (n_vid_chans)
				G_path_parts_m13(vid_chan_list[0], tmp_str, NULL, NULL);
			else
				G_path_parts_m13(ts_chan_list[0], tmp_str, NULL, NULL);
			sess_dir = tmp_str;
		}
		full_vid_chan_list = G_file_list_m13(NULL, &all_vid_chans, sess_dir, NULL, "vicd", GFL_FULL_PATH_m13);
		if (all_vid_chans == 0)
			n_vid_chans = 0;
		if (n_vid_chans) {
			sess->vid_chans = (CHAN_m13 **) calloc_2D_m13((size_t) all_vid_chans, (size_t) 1, -sizeof(CHAN_m13));
			if (sess->vid_chans == NULL) {
				if (free_sess == TRUE_m13)
					G_free_session_m13(&sess);
				return_m13(NULL);
			}
			for (i = 0; i < all_vid_chans; ++i) {
				chan = sess->vid_chans[i];
				chan->path = chan->local_path;
				chan->name = chan->local_name;
				chan->type_code = VID_CHAN_TYPE_CODE_m13;
				chan->flags = flags;
				chan->parent = (LH_m13 *) sess;
				G_MED_path_components_m13(full_vid_chan_list[i], chan->path, chan->name);
			}
			// match passed list to full list to mark as active
			if (all_vid_chans == n_vid_chans) {
				for (i = 0; i < all_vid_chans; ++i) {
					chan = sess->vid_chans[i];
					chan->flags |= LH_CHAN_ACTIVE_m13;
				}
			} else {  // lists are in alphbetical order
				for (i = j = 0; i < n_vid_chans; ++i) {
					for (; strcmp_m13(vid_chan_list[i], full_vid_chan_list[j]); ++j);
					chan = sess->vid_chans[j];
					chan->flags |= LH_CHAN_ACTIVE_m13;
				}
			}
			free_m13((void *) full_vid_chan_list);
			free_m13((void *) vid_chan_list);
			sess->n_vid_chans = all_vid_chans;
		}
	} else if (n_vid_chans) {
		sess->vid_chans = (CHAN_m13 **) calloc_2D_m13((size_t) n_vid_chans, (size_t) 1, -sizeof(CHAN_m13));
		if (sess->vid_chans == NULL) {
			if (free_sess == TRUE_m13)
				G_free_session_m13(&sess);
			return_m13(NULL);
		}
		for (i = 0; i < n_vid_chans; ++i) {
			chan = sess->vid_chans[i];
			chan->path = chan->local_path;
			chan->name = chan->local_name;
			chan->type_code = VID_CHAN_TYPE_CODE_m13;
			chan->flags = flags | LH_CHAN_ACTIVE_m13;
			chan->parent = (LH_m13 *) sess;
			G_MED_path_components_m13(vid_chan_list[i], chan->path, chan->name);
		}
		free_m13((void *) vid_chan_list);
		sess->n_vid_chans = n_vid_chans;
	}

	// process time slice (passed slice is not modified)
	if (slice->conditioned == FALSE_m13)
		G_condition_slice_m13(slice, (LH_m13 *) sess);
	
	// set reference channel (before get segment range)
	G_change_index_chan_m13(sess, NULL, NULL, DEFAULT_CHAN_m13);

	// get segment range
	n_segs = slice->n_segs;
	if (n_segs == UNKNOWN_m13) {
		if (G_segment_range_m13((LH_m13 *) sess, slice) == 0) {
			if (free_sess == TRUE_m13)
				G_free_session_m13(&sess);
			return_m13(NULL);
		}
	}

	// thread out channel opens
	threading = proc_globs->miscellaneous.threading;
	if (n_chans == 1)  // no sense in overhead for one thread
		threading = FALSE_m13;
	
	// set up thread infos
	n_chans = n_ts_chans + n_vid_chans;
	proc_thread_infos = (PROC_THREAD_INFO_m13 *) calloc((size_t) n_chans, sizeof(PROC_THREAD_INFO_m13));
	read_MED_thread_infos = (READ_MED_THREAD_INFO_m13 *) calloc((size_t) n_chans, sizeof(READ_MED_THREAD_INFO_m13));
	thread_idx = 0;
	
	// set up time series channels
	for (i = 0; i < n_ts_chans; ++i) {
		chan = sess->ts_chans[i];
		chan->slice = *slice;
		proc_thread_infos[thread_idx].thread_f = G_open_channel_thread_m13;
		proc_thread_infos[thread_idx].thread_label = "G_open_channel_thread_m13";
		proc_thread_infos[thread_idx].priority = PROC_HIGH_PRIORITY_m13;
		proc_thread_infos[thread_idx].arg = (void *) (read_MED_thread_infos + thread_idx);
		read_MED_thread_infos[thread_idx].MED_struct = (LH_m13 *) chan;
		read_MED_thread_infos[thread_idx].parent = (LH_m13 *) sess;
		++thread_idx;
	}
	// set up video channels
	for (i = 0; i < n_vid_chans; ++i) {
		chan = sess->vid_chans[i];
		chan->slice = *slice;
		proc_thread_infos[thread_idx].thread_f = G_open_channel_thread_m13;
		proc_thread_infos[thread_idx].thread_label = "G_open_channel_thread_m13";
		proc_thread_infos[thread_idx].priority = PROC_HIGH_PRIORITY_m13;
		proc_thread_infos[thread_idx].arg = (void *) (read_MED_thread_infos + thread_idx);
		read_MED_thread_infos[thread_idx].MED_struct = (LH_m13 *) chan;
		read_MED_thread_infos[thread_idx].parent = (LH_m13 *) sess;
		++thread_idx;
	}
	
	// thread out channel reads
	ret_val = PROC_distribute_jobs_m13(proc_thread_infos, n_chans, 0, TRUE_m13, threading);  // no reserved cores, wait for completion
	
	// check results
	for (i = 0; i < n_chans; ++i)
		if (read_MED_thread_infos[i].MED_struct == NULL)
			ret_val = FALSE_m13;
	free((void *) proc_thread_infos);
	free((void *) read_MED_thread_infos);
	if (ret_val == FALSE_m13) {
		if (free_sess == TRUE_m13)
			G_free_session_m13(&sess);
		G_set_error_m13(E_UNKN_m13, "error reading session");
		return_m13(NULL);
	}

	// update session slice
	chan = proc_globs->current_session.index_channel;
	if ((chan->flags & LH_CHAN_ACTIVE_m13) == 0)
		chan = G_active_channel_m13(sess, DEFAULT_CHAN_m13);
	slice->start_time = chan->slice.start_time;
	slice->end_time = chan->slice.end_time;
	slice->start_seg_num = chan->slice.start_seg_num;
	slice->end_seg_num = chan->slice.end_seg_num;
	slice->n_segs = SLICE_SEG_COUNT_m13(slice);
		
	// sort channels
	G_sort_channels_by_acq_num_m13(sess);
	
	// session records
	if (sess->flags & LH_READ_SESS_RECS_MASK_m13)
		G_open_session_records_m13(sess);

	// segmented session records level
	if (sess->flags & LH_READ_SEG_SESS_RECS_MASK_m13)
		G_open_seg_sess_recs_m13(sess);
	
	// ephemeral data
	if (sess->flags & LH_GENERATE_EPHEMERAL_DATA_m13) {
		if (sess->n_ts_chans) {
			if (sess->ts_metadata_fps)
				FPS_free_m13(&sess->ts_metadata_fps);
			sprintf_m13(tmp_str, "%s/%s.%s", sess->path, sess->name, TS_METADATA_TYPE_STR_m13);
			chan = sess->ts_chans[0];
			sess->ts_metadata_fps = FPS_init_m13(NULL, tmp_str, NULL, METADATA_BYTES_m13, (LH_m13 *) sess);
			G_init_metadata_m13(sess->ts_metadata_fps, FALSE_m13);
			for (i = 1; i < sess->n_ts_chans; ++i) {
				chan = sess->ts_chans[i];
				if (chan->flags & LH_UPDATE_EPHEMERAL_DATA_m13) {
					G_merge_universal_headers_m13(sess->ts_metadata_fps, chan->metadata_fps, NULL);
					G_merge_metadata_m13(sess->ts_metadata_fps, chan->metadata_fps, NULL);
					chan->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m13;  // clear flag
				}
			}
			// merge session records
			if (sess->rec_inds_fps && sess->rec_data_fps) // record data, not record indices universal header is merged in ephemeral data
				G_merge_universal_headers_m13(sess->ts_metadata_fps, sess->rec_data_fps, NULL);
			ssr = sess->ssr;
			if (ssr) {
				seg_idx = G_segment_index_m13(slice->start_seg_num, (LH_m13 *) sess);
				for (i = 0, j = seg_idx; i < n_segs; ++i, ++j)
					if (ssr->rec_inds_fps[j] && ssr->rec_data_fps[j])
						G_merge_universal_headers_m13(sess->ts_metadata_fps, ssr->rec_data_fps[j], NULL);
			}
			// fix ephemeral universal header
			uh = sess->ts_metadata_fps->uh;
			uh->type_code = TS_METADATA_TYPE_CODE_m13;
			uh->segment_number = UH_SESSION_LEVEL_CODE_m13;
			uh->session_UID = proc_globs->current_session.UID;
			uh->channel_UID = uh->segment_UID = UID_NO_ENTRY_m13;
		}
		if (sess->n_vid_chans) {
			if (sess->vid_metadata_fps)
				FPS_free_m13(&sess->vid_metadata_fps);
			sprintf_m13(tmp_str, "%s/%s.%s", sess->path, sess->name, VID_METADATA_TYPE_STR_m13);
			chan = sess->vid_chans[0];
			sess->vid_metadata_fps = FPS_init_m13(NULL, tmp_str, NULL, METADATA_BYTES_m13, (LH_m13 *) sess);
			G_init_metadata_m13(sess->vid_metadata_fps, FALSE_m13);
			for (i = 1; i < sess->n_vid_chans; ++i) {
				chan = sess->vid_chans[i];
				if (chan->flags & LH_UPDATE_EPHEMERAL_DATA_m13) {
					G_merge_universal_headers_m13(sess->vid_metadata_fps, chan->metadata_fps, NULL);
					G_merge_metadata_m13(sess->vid_metadata_fps, chan->metadata_fps, NULL);
					chan->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m13;  // clear flag
				}
			}
			// merge session records
			if (sess->rec_inds_fps && sess->rec_data_fps)  // record data, not record indices universal header is merged in ephemeral data
				G_merge_universal_headers_m13(sess->vid_metadata_fps, sess->rec_data_fps, NULL);
			if (ssr) {
				for (i = 0, j = seg_idx; i < n_segs; ++i, ++j)
					if (ssr->rec_inds_fps[j] && ssr->rec_data_fps[j])
						G_merge_universal_headers_m13(sess->vid_metadata_fps, ssr->rec_data_fps[j], NULL);
			}
			// fix ephemeral universal header
			uh = sess->vid_metadata_fps->uh;
			uh->type_code = VID_METADATA_TYPE_CODE_m13;
			uh->segment_number = UH_SESSION_LEVEL_CODE_m13;
			uh->session_UID = proc_globs->current_session.UID;
			uh->channel_UID = uh->segment_UID = UID_NO_ENTRY_m13;
		}
	}
	
	return_m13(sess);
}


tern	G_open_session_records_m13(SESS_m13 *sess)
{
	si1			tmp_str[PATH_BYTES_m13], *name;
	si4			fe;
	PROC_GLOBS_m13	*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	proc_globs = G_proc_globs_m13((LH_m13 *) sess);
	
	// record indices
	if (sess->rec_inds_fps == NULL) {
		sprintf_m13(tmp_str, "%s/%s.%s", sess->path, sess->name, REC_INDS_TYPE_STR_m13);
		fe = G_exists_m13(tmp_str);
		if (fe == FALSE_m13) {  // sess->name defaults to fs_name
			if (proc_globs->current_session.names_differ == TRUE_m13) {
				if (sess->name == proc_globs->current_session.fs_name)
					name = proc_globs->current_session.uh_name;
				else
					name = proc_globs->current_session.fs_name;
				sprintf_m13(tmp_str, "%s/%s.%s", sess->path, name, REC_INDS_TYPE_STR_m13);
				fe = G_exists_m13(tmp_str);
			}
		}
		if (fe == TRUE_m13)
			sess->rec_inds_fps = FPS_read_m13(sess->rec_inds_fps, 0, FPS_FULL_FILE_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) sess);
		else
			return_m13(FALSE_m13);
	}
	
	// records data
	if (sess->rec_data_fps == NULL) {
		sprintf_m13(tmp_str, "%s/%s.%s", sess->path, sess->name, REC_DATA_TYPE_STR_m13);
		fe = G_exists_m13(tmp_str);
		if (fe == FALSE_m13) {  // sess->name defaults to fs_name
			if (proc_globs->current_session.names_differ == TRUE_m13) {
				if (sess->name == proc_globs->current_session.fs_name)
					name = proc_globs->current_session.uh_name;
				else
					name = proc_globs->current_session.fs_name;
				sprintf_m13(tmp_str, "%s/%s.%s", sess->path, name, REC_DATA_TYPE_STR_m13);
				fe = G_exists_m13(tmp_str);
			}
		}
		if (fe == TRUE_m13)
			sess->rec_data_fps = FPS_read_m13(sess->rec_data_fps, 0, FPS_AUTO_BYTES_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) sess);
		else
			return_m13(FALSE_m13);
	}
	
	if (sess->rec_inds_fps && sess->rec_data_fps)
		return_m13(TRUE_m13);

	return_m13(FALSE_m13);
}


si8 G_pad_m13(ui1 *buffer, si8 content_len, ui4 alignment)
{
	si8  i, pad_bytes;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	pad_bytes = content_len % (si8) alignment;
	if (pad_bytes) {
		i = pad_bytes = (alignment - pad_bytes);
		buffer += content_len;
		while (i--)
			*buffer++ = PAD_BYTE_VALUE_m13;
	}
	
	return_m13(content_len + pad_bytes);
}


tern	G_path_parts_m13(const si1 *full_file_name, si1 *path, si1 *name, si1 *extension)
{
	si1	*c, *cc, temp_full_file_name[PATH_BYTES_m13];
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// handle bad calls
	if (STR_empty_m13(full_file_name) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "full_file_name is empty");
		return_m13(FALSE_m13);
	}
		
	// get path from root
	G_full_path_m13(full_file_name, temp_full_file_name);

	// move pointer to end of string
	c = temp_full_file_name + strlen(temp_full_file_name) - 1;
	
	// step back to first extension
	cc = c;
	while (*--c != '.') {
		if (*c == DIR_BREAK_m13) {
			c = cc;
			break;
		}
	}

	// copy extension if allocated
	if (extension) {
		if (*c == '.') {
			strcpy(extension, c + 1);
			*c-- = 0;
		} else {
			*extension = 0;
		}
	} else if (*c == '.') {
		*c-- = 0;
	}

	// step back to next directory break
	while (*--c != DIR_BREAK_m13);
	
	// copy name if allocated
	if (name)
		strcpy(name, c + 1);
	*c = 0;
	
	// copy path if allocated
	if (path)
		strcpy_m13(path, temp_full_file_name);
	
	return_m13(TRUE_m13);
}
		
		
#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_pop_behavior_m13(void)
{
	BEHAVIOR_STACK_m13	*stack;
	

	stack = G_behavior_stack_m13();
	if (stack == NULL)
		return;

	if (stack->top_idx >= 0) {
		--stack->top_idx;
		if (stack->top_idx == -1)
			stack->_id = 0;  // release stack (popping stack base); // G_current_behavior_m13 will return default behavior
	}

	return;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_pop_function_exec_m13(const si1 *function)
{
#ifdef FT_DEBUG_m13
	
	FUNCTION_STACK_m13	*stack;
	
	
	stack = G_function_stack_m13(0);
	if (stack == NULL)
		return;

	// causal error set => do not modify stack of causal thread
	if (globals_m13->error.code) {
		if (globals_m13->error.thread_id == gettid_m13()) {
			if (strcmp_m13(stack->functions[0], function) == 0)  // stack at base
				exit_m13(globals_m13->error.code);  // call exit to show error & stack
			return;
		}
	}

	if (stack->top_idx >= 0) {
		--stack->top_idx;
		if (stack->top_idx == -1)
			stack->_id = stack->_pid = 0;  // release stack (popping stack base);
	}
#endif  // FT_DEBUG_m13

	return;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_proc_error_clear_m13(LH_m13 *lh)
{
	PROC_GLOBS_m13	*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// level header can be NULL - will use process / thread ID
	
	proc_globs = G_proc_globs_m13(lh);
	proc_globs->miscellaneous.proc_error_state = FALSE_m13;
	
	return_void_m13;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_proc_error_set_m13(LH_m13 *lh)
{
	PROC_GLOBS_m13	*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// level header can be NULL - will use process / thread ID
	
	proc_globs = G_proc_globs_m13(lh);
	proc_globs->miscellaneous.proc_error_state = TRUE_m13;
	
	return_void_m13;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	G_proc_error_state_m13(LH_m13 *lh)
{
	PROC_GLOBS_m13	*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// level header can be NULL - will use process / thread ID
	
	proc_globs = G_proc_globs_m13(lh);
	
	return_m13(proc_globs->miscellaneous.proc_error_state);
}


PROC_GLOBS_m13	*G_proc_globs_m13(LH_m13 *lh)
{
	si4			i, n_proc_globs;
	pid_t_m13		_id;
	LH_m13			*top_lh;
	PROC_GLOBS_m13		*proc_globs, **proc_globs_ptr, *new_proc_globs;
	PROC_GLOBS_LIST_m13	*list;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// find process globals by local ref or linkage
	if (lh) {
		// found by shortcut
		if (lh->proc_globs)
			return_m13(lh->proc_globs);
		// find by linkage
		top_lh = lh;
		while (top_lh->parent)  // top of hieracrchy
			top_lh = top_lh->parent;
		proc_globs = (PROC_GLOBS_m13 *) top_lh;
		if (proc_globs->type_code == PROC_GLOBS_TYPE_CODE_m13) {
			lh->proc_globs = proc_globs;  // set shortcut
			return_m13((PROC_GLOBS_m13 *) proc_globs);
		}
	}

	// get list mutex
	list = globals_m13->proc_globs_list;
	pthread_mutex_lock_m13(&list->mutex);
			
	// find by thread id
	proc_globs = NULL;
	proc_globs_ptr = list->proc_globs_ptrs;
	n_proc_globs = list->top_idx + 1;
	_id = gettid_m13();
	for (i = n_proc_globs; i--; ++proc_globs_ptr) {
		if ((*proc_globs_ptr)->_id == _id) {
			proc_globs = *proc_globs_ptr;
			pthread_mutex_unlock_m13(&list->mutex);
			if (lh)  // set shortcut
				lh->proc_globs = proc_globs;
			return_m13(proc_globs);
		}
		if (proc_globs)
			continue;
		if ((*proc_globs_ptr)->_id == 0)  // first empty
			proc_globs = *proc_globs_ptr;
	}
	
	// expand list
	if (proc_globs == NULL) {
		n_proc_globs += GLOBALS_PROC_GLOBS_LIST_SIZE_INCREMENT_m13;
		proc_globs_ptr = (PROC_GLOBS_m13 **) realloc((void *) list->proc_globs_ptrs, (size_t) n_proc_globs * sizeof(PROC_GLOBS_m13 *));
		if (proc_globs_ptr == NULL) {
			pthread_mutex_unlock_m13(&list->mutex);
			G_set_error_m13(E_ALLOC_m13, NULL);
			return_m13(NULL);
		}
		
		list->proc_globs_ptrs = proc_globs_ptr;
		list->size = n_proc_globs;
		++list->top_idx;
		
		// allocate & initialize new stacks (note: proc_globs allocated en bloc)
		new_proc_globs = (PROC_GLOBS_m13 *) calloc((size_t) GLOBALS_PROC_GLOBS_LIST_SIZE_INCREMENT_m13, sizeof(PROC_GLOBS_m13));
		if (new_proc_globs == NULL) {
			G_set_error_m13(E_ALLOC_m13, NULL);
			pthread_mutex_unlock_m13(&list->mutex);
			return_m13(NULL);
		}
		proc_globs_ptr = list->proc_globs_ptrs + list->top_idx;  // list->top_idx == old size at this point
		for (i = GLOBALS_BEHAVIOR_STACKS_LIST_SIZE_INCREMENT_m13; i--;)
			*proc_globs_ptr++ = new_proc_globs++;  // assign stack pointer
		proc_globs = *(list->proc_globs_ptrs + list->top_idx);
	}
	
	// relase mutex
	pthread_mutex_unlock_m13(&list->mutex);
	
	// initialize
	G_proc_globs_init_m13(proc_globs);
	proc_globs->_id = gettid_m13();
	
	// set links
	if (lh) {
		lh->proc_globs = proc_globs;  // shortcut
		top_lh->parent = (LH_m13 *) proc_globs;
		proc_globs->child = top_lh;
	}
	
	return_m13(proc_globs);
}
	

#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_proc_globs_delete_m13(LH_m13 *lh)
{
	si4			i;
	PROC_GLOBS_m13		*proc_globs;
	Sgmt_RECS_LIST_m13	*Sgmt_records_list;
	Sgmt_RECS_ENTRY_m13	*Sgmt_records_entry;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	proc_globs = G_proc_globs_m13(lh);
	if (proc_globs == NULL)
		return_void_m13;
	
	// delete proc globals Sgmt_records_list
	Sgmt_records_list = proc_globs->current_session.Sgmt_recs_list;
	Sgmt_records_entry = Sgmt_records_list->entries;
	for (i = Sgmt_records_list->top_idx + 1; i--; ++Sgmt_records_entry)
		free((void *) Sgmt_records_entry->Sgmt_recs);
	free((void *) Sgmt_records_list->entries);
	pthread_mutex_destroy_m13(&proc_globs->current_session.Sgmt_recs_list->mutex);
	free((void *) Sgmt_records_list);
	proc_globs->current_session.Sgmt_recs_list = NULL;

	proc_globs->_id = 0;

	return_void_m13;
}


PROC_GLOBS_m13	*G_proc_globs_init_m13(PROC_GLOBS_m13 *proc_globs)
{
	tern	free_proc_globs;
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// allocate - caller takes ownership
	if (proc_globs == NULL) {
		proc_globs = (PROC_GLOBS_m13 *) calloc((size_t) 1, sizeof(PROC_GLOBS_m13));
		if (proc_globs == NULL) {
			G_set_error_m13(E_ALLOC_m13, NULL);
			return_m13(NULL);
		}
		free_proc_globs = TRUE_m13;
	} else {
		free_proc_globs = FALSE_m13;
	}
	
	// set header
	proc_globs->type_code = PROC_GLOBS_TYPE_CODE_m13;
	
	// password data
	proc_globs->password_data.processed = FALSE_m13;
	
	// current session constants
	proc_globs->current_session.UID = UID_NO_ENTRY_m13;
	*proc_globs->current_session.directory = 0;
	proc_globs->current_session.start_time = GLOBALS_SESSION_START_TIME_DEFAULT_m13;
	proc_globs->current_session.end_time = GLOBALS_SESSION_END_TIME_DEFAULT_m13;
	*proc_globs->current_session.uh_name = 0;
	*proc_globs->current_session.fs_name = 0;
	proc_globs->current_session.names_differ = UNKNOWN_m13;
	proc_globs->current_session.start_time = UUTC_NO_ENTRY_m13;
	proc_globs->current_session.end_time = UUTC_NO_ENTRY_m13;
	proc_globs->current_session.n_segments = SEGMENT_NUMBER_NO_ENTRY_m13;
	proc_globs->current_session.n_mapped_segments = SEGMENT_NUMBER_NO_ENTRY_m13;
	proc_globs->current_session.index_channel = NULL;
	*proc_globs->current_session.index_channel_name = 0;
	
	// active channel constants
	proc_globs->active_channels.sampling_frequencies_vary = UNKNOWN_m13;
	proc_globs->active_channels.minimum_sampling_frequency = RATE_NO_ENTRY_m13;
	proc_globs->active_channels.maximum_sampling_frequency = RATE_NO_ENTRY_m13;
	proc_globs->active_channels.minimum_sampling_frequency_channel = NULL;
	proc_globs->active_channels.maximum_sampling_frequency_channel = NULL;
	proc_globs->active_channels.frame_rates_vary = UNKNOWN_m13;;
	proc_globs->active_channels.minimum_frame_rate = RATE_NO_ENTRY_m13;
	proc_globs->active_channels.maximum_frame_rate = RATE_NO_ENTRY_m13;
	proc_globs->active_channels.minimum_frame_rate_channel = NULL;
	proc_globs->active_channels.maximum_frame_rate_channel = NULL;
	
	// time Constants
	proc_globs->time_constants.set = FALSE_m13;
	proc_globs->time_constants.RTO_known = GLOBALS_RTO_KNOWN_DEFAULT_m13;
	proc_globs->time_constants.observe_DST = GLOBALS_OBSERVE_DST_DEFAULT_m13;
	proc_globs->time_constants.recording_time_offset = GLOBALS_RECORDING_TIME_OFFSET_DEFAULT_m13;
	proc_globs->time_constants.standard_UTC_offset = GLOBALS_STANDARD_UTC_OFFSET_DEFAULT_m13;
	proc_globs->time_constants.daylight_start_code.value = DTCC_VALUE_NO_ENTRY_m13;
	proc_globs->time_constants.daylight_end_code.value = DTCC_VALUE_NO_ENTRY_m13;
	strcpy(proc_globs->time_constants.standard_timezone_acronym, GLOBALS_STANDARD_TIMEZONE_ACRONYM_DEFAULT_m13);
	strcpy(proc_globs->time_constants.standard_timezone_string, GLOBALS_STANDARD_TIMEZONE_STRING_DEFAULT_m13);
	strcpy(proc_globs->time_constants.daylight_timezone_acronym, GLOBALS_DAYLIGHT_TIMEZONE_ACRONYM_DEFAULT_m13);
	strcpy(proc_globs->time_constants.daylight_timezone_string, GLOBALS_DAYLIGHT_TIMEZONE_STRING_DEFAULT_m13);
	
	// set up Sgmt_record_list
	proc_globs->current_session.Sgmt_recs_list = (Sgmt_RECS_LIST_m13 *) calloc((size_t) 1, sizeof(Sgmt_RECS_LIST_m13));
	if (proc_globs->current_session.Sgmt_recs_list == NULL) {
		if (free_proc_globs == TRUE_m13)
			free((void *) proc_globs);
		G_set_error_m13(E_ALLOC_m13, NULL);
		return_m13(NULL);
	}
	proc_globs->current_session.Sgmt_recs_list->entries = (Sgmt_RECS_ENTRY_m13 *) calloc((size_t) GLOBALS_SGMT_LIST_SIZE_INCREMENT_m13, sizeof(Sgmt_RECS_ENTRY_m13));
	if (proc_globs->current_session.Sgmt_recs_list->entries == NULL) {
		if (free_proc_globs == TRUE_m13)
			free((void *) proc_globs);
		G_set_error_m13(E_ALLOC_m13, NULL);
		return_m13(NULL);
	}
	proc_globs->current_session.Sgmt_recs_list->size = GLOBALS_SGMT_LIST_SIZE_INCREMENT_m13;
	proc_globs->current_session.Sgmt_recs_list->top_idx = -1;
	pthread_mutex_init_m13(&proc_globs->current_session.Sgmt_recs_list->mutex, NULL);
	
	// reset miscellaneous globals
	proc_globs->miscellaneous.mmap_block_bytes = GLOBALS_MMAP_BLOCK_BYTES_NO_ENTRY_m13;
	proc_globs->miscellaneous.threading = globals_m13->threading;
	proc_globs->miscellaneous.proc_error_state = FALSE_m13;

	return_m13(proc_globs);
}


PROC_GLOBS_m13	*G_proc_globs_new_m13(LH_m13 *lh)
{
	si4			i, n_proc_globs;
	LH_m13			*top_lh;
	PROC_GLOBS_m13		*proc_globs, **proc_globs_ptr, *new_proc_globs;
	PROC_GLOBS_LIST_m13	*list;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// generate a new set of process globals within same thread
	// e.g. for multiple sessions open in same thread
	
	if (lh == NULL) {
		G_set_error_m13(E_UNKN_m13, "level must be specified");
		return_m13(NULL);
	}
	if (lh->type_code == PROC_GLOBS_TYPE_CODE_m13) {
		G_set_error_m13(E_UNKN_m13, "level must be session or below");
		return_m13(NULL);
	}

	// get mutex
	list = globals_m13->proc_globs_list;
	pthread_mutex_lock_m13(&list->mutex);
			
	// find first empty entry
	proc_globs = NULL;
	proc_globs_ptr = list->proc_globs_ptrs;
	n_proc_globs = list->top_idx + 1;
	for (i = n_proc_globs; i--; ++proc_globs_ptr) {
		if ((*proc_globs_ptr)->_id == 0) {
			proc_globs = *proc_globs_ptr;
			break;
		}
	}
	
	// expand list
	if (proc_globs == NULL) {  // expand list
		n_proc_globs += GLOBALS_PROC_GLOBS_LIST_SIZE_INCREMENT_m13;
		proc_globs_ptr = (PROC_GLOBS_m13 **) realloc((void *) list->proc_globs_ptrs, (size_t) n_proc_globs * sizeof(PROC_GLOBS_m13 *));
		if (proc_globs_ptr == NULL) {
			pthread_mutex_unlock_m13(&list->mutex);
			G_set_error_m13(E_ALLOC_m13, NULL);
			return_m13(NULL);
		}
		
		list->proc_globs_ptrs = proc_globs_ptr;
		list->size = n_proc_globs;
		++list->top_idx;
		
		// allocate & initialize new stacks (note: proc_globs allocated en bloc)
		new_proc_globs = (PROC_GLOBS_m13 *) malloc((size_t) GLOBALS_PROC_GLOBS_LIST_SIZE_INCREMENT_m13 * sizeof(PROC_GLOBS_m13));
		if (new_proc_globs == NULL) {
			G_set_error_m13(E_ALLOC_m13, NULL);
			pthread_mutex_unlock_m13(&list->mutex);
			return(NULL);
		}
		proc_globs_ptr = list->proc_globs_ptrs + list->top_idx;  // list->top_idx == old size at this point
		for (i = GLOBALS_BEHAVIOR_STACKS_LIST_SIZE_INCREMENT_m13; i--; ++new_proc_globs) {
			*proc_globs_ptr++ = new_proc_globs;  // assign stack pointer
			// initialize proc_globs (behaviors allocated as needed)
			new_proc_globs->_id = 0;
		}
		proc_globs = *(list->proc_globs_ptrs + list->top_idx);
	}
	
	// relase mutex
	pthread_mutex_unlock_m13(&list->mutex);
	
	// set links
	lh->proc_globs = proc_globs;  // set shortcut
	for (top_lh = lh; top_lh->parent; top_lh = top_lh->parent);
	proc_globs->child = top_lh;
	top_lh->parent = (LH_m13 *) proc_globs;

	// initialize
	G_proc_globs_init_m13(proc_globs);

	return_m13(proc_globs);
}
	

tern	G_process_password_data_m13(FPS_m13 *fps, si1 *unspecified_pw)
{
	tern			free_md1, LEVEL_1_valid;
	PASSWORD_DATA_m13	*pwd;
	ui1			hash[SHA_HASH_BYTES_m13];
	si1			unspecified_pw_bytes[PASSWORD_BYTES_m13] = {0}, putative_L1_pw_bytes[PASSWORD_BYTES_m13] = {0};
	si1			md_dir[PATH_BYTES_m13], md_file[PATH_BYTES_m13];
	si4			i;
	PROC_GLOBS_m13		*proc_globs;
	METADATA_SECTION_1_m13	*md1;
	UH_m13			*uh;
	FILE_m13		*fp;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Returns FALSE_m13 to indicate no encryption/decryption access.
	// The password structure is set to processed, regardless of access.
	// Unencrypted data can be read without access privileges.
	
	// can't verify passwords without a universal header
	if (fps == NULL) {
		G_set_error_m13(E_UNKN_m13, "fps is NULL");
		return_m13(FALSE_m13);
	}
	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	pwd = &proc_globs->password_data;
	memset((void *) pwd, 0, sizeof(PASSWORD_DATA_m13));
	pwd->processed = TRUE_m13;
	
	// check if password protected (no need to check level 2, since for level 2 to exist, level 1 must exist)
	uh = fps->uh;
	if (G_all_zeros_m13(uh->level_1_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m13) == TRUE_m13) {
		pwd->hints_exist = FALSE_m13;  // no passwords, so no need for hints
		return_m13(TRUE_m13);
	}
	
	// copy password hints from metadata to pwd
	md1 = NULL;
	if (METADATA_CODE_m13(uh->type_code) == TRUE_m13) {
		md1 = &fps->metadata->section_1;
		free_md1 = FALSE_m13;
	} else {  // find a MED metadata file & read in section 1
		G_path_parts_m13(fps->path, md_dir, NULL, NULL);
		if (G_find_metadata_file_m13(md_dir, md_file)) {
			fp = fopen_m13(md_file, "r");
			fseek_m13(fp, UH_BYTES_m13, SEEK_SET);
			md1 = (METADATA_SECTION_1_m13 *) malloc((size_t) METADATA_SECTION_1_BYTES_m13);
			fread_m13((void *) md1, sizeof(ui1), sizeof(METADATA_SECTION_1_BYTES_m13), fp);
			fclose_m13(fp);
			free_md1 = TRUE_m13;
		}
	}
	pwd->hints_exist = FALSE_m13;
	if (md1) {
		if (*md1->level_1_password_hint) {
			strncpy_m13(pwd->level_1_password_hint, md1->level_1_password_hint, PASSWORD_HINT_BYTES_m13);
			pwd->hints_exist = TRUE_m13;
		}
		if (*md1->level_2_password_hint) {
			strncpy_m13(pwd->level_2_password_hint, md1->level_2_password_hint, PASSWORD_HINT_BYTES_m13);
			pwd->hints_exist = TRUE_m13;
		}
		if (free_md1 == TRUE_m13)
			free((void *) md1);
	}
	
	// condition password (check, extract terminal bytes, expand)
	if (G_condition_password_m13(unspecified_pw, unspecified_pw_bytes, uh->expanded_passwords) == FALSE_m13)
		G_show_password_hints_m13(pwd, 0);

	// check if data is encrypted (no need to check level 2, since for level 2 to exist, level 1 must exist)
	if (G_all_zeros_m13(uh->level_1_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m13) == TRUE_m13)
		return_m13(TRUE_m13);
	
	// check for level 1 access
	SHA_hash_m13((ui1 *) unspecified_pw_bytes, PASSWORD_BYTES_m13, hash);  // generate SHA-256 hash of password bytes
	for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m13; ++i)  // compare with stored level 1 hash
		if (hash[i] != uh->level_1_password_validation_field[i])
			break;
	LEVEL_1_valid = FALSE_m13;
	if (i == PASSWORD_BYTES_m13) {  // Level 1 password valid (could be level 2 password also)
		pwd->access_level = LEVEL_1_ACCESS_m13;
		AES_key_expansion_m13(pwd->level_1_encryption_key, unspecified_pw_bytes);  // generate key
		LEVEL_1_valid = TRUE_m13;
	}
	
	// check if level 2 password was set
	if (G_all_zeros_m13(uh->level_2_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m13) == TRUE_m13)
		return_m13(LEVEL_1_valid);

	// generate putative L1 password
	for (i = 0; i < PASSWORD_BYTES_m13; ++i)  // xor with level 2 password validation field
		putative_L1_pw_bytes[i] = hash[i] ^ uh->level_2_password_validation_field[i];
		
	SHA_hash_m13((ui1 *) putative_L1_pw_bytes, PASSWORD_BYTES_m13, hash); // generate SHA-256 hash of putative level 1 password
	for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m13; ++i)  // compare with stored level 1 hash
		if (hash[i] != uh->level_1_password_validation_field[i])
			break;
	
	// Level 2 password valid
	if (i == PASSWORD_VALIDATION_FIELD_BYTES_m13) {
		pwd->access_level = LEVEL_2_ACCESS_m13;
		AES_key_expansion_m13(pwd->level_1_encryption_key, putative_L1_pw_bytes);  // generate level 1 key
		AES_key_expansion_m13(pwd->level_2_encryption_key, unspecified_pw_bytes);  // generate level 2 key
		return_m13(TRUE_m13);
	}
	if (LEVEL_1_valid == TRUE_m13)
		return_m13(TRUE_m13);

	// invalid as both level 1 & 2 password
	return_m13(FALSE_m13);
}


tern	G_propagate_flags_m13(LH_m13 *lh, ui8 new_flags)
{
	si4		i, j, n_ts_chans, n_vid_chans, n_segs;
	ui8		active_status;
	PROC_GLOBS_m13	*proc_globs;
	SEG_m13		*seg;
	CHAN_m13	*chan;
	CHAN_m13	**ts_chans;
	CHAN_m13	**vid_chans;
	SESS_m13	*sess = NULL;
	SSR_m13		*ssr = NULL;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	proc_globs = G_proc_globs_m13(lh);
	switch (lh->type_code) {
		case TS_SEG_TYPE_CODE_m13:
			seg = (SEG_m13 *) lh;
			chan = NULL;
			ts_chans =  &chan;
			n_ts_chans = 1;
			vid_chans =  &chan;
			n_vid_chans = 0;
			n_segs = 1;
			break;
		case VID_SEG_TYPE_CODE_m13:
			seg = (SEG_m13 *) lh;
			chan = NULL;
			ts_chans =  &chan;
			n_ts_chans = 0;
			vid_chans =  &chan;
			n_vid_chans = 1;
			n_segs = 1;
			break;
		case TS_CHAN_TYPE_CODE_m13:
			chan = (CHAN_m13 *) lh;
			ts_chans =  &chan;
			n_ts_chans = 1;
			n_vid_chans = 0;
			n_segs = proc_globs->current_session.n_mapped_segments;
			break;
		case VID_CHAN_TYPE_CODE_m13:
			chan = (CHAN_m13 *) lh;
			vid_chans = &chan;
			n_ts_chans = 0;
			n_vid_chans = 1;
			n_segs = proc_globs->current_session.n_mapped_segments;
			break;
		case SESS_TYPE_CODE_m13:
			sess = (SESS_m13 *) lh;
			ts_chans = sess->ts_chans;
			n_ts_chans = sess->n_ts_chans;
			vid_chans = sess->vid_chans;
			n_vid_chans = sess->n_vid_chans;
			n_segs = proc_globs->current_session.n_mapped_segments;
			break;
		case SSR_TYPE_CODE_m13:
			ssr = (SSR_m13 *) lh;
			n_ts_chans = n_vid_chans = 0;
			n_segs = proc_globs->current_session.n_mapped_segments;
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "invalid level type");
			return_m13(FALSE_m13);
	}
	
	// condition new flags
	new_flags &= ~LH_CHAN_ACTIVE_m13;
	
	// session
	if (sess) {
		sess->flags = new_flags;
		// segmented session records
		ssr = sess->ssr;
		if (ssr)
			ssr->flags = new_flags;
	}
		
	// time series channels
	for (i = 0; i < n_ts_chans; ++i) {
		if (ts_chans[i]) {
			for (j = 0; j < n_segs; ++j) {
				seg = ts_chans[i]->segs[j];
				if (seg)
					seg->flags = new_flags;
			}
			active_status = ts_chans[i]->flags & LH_CHAN_ACTIVE_m13;
			ts_chans[i]->flags = new_flags | active_status;
		}
	}
	
	// video channels
	for (i = 0; i < n_vid_chans; ++i) {
		if (vid_chans[i]) {
			for (j = 0; j < n_segs; ++j) {
				seg = vid_chans[i]->segs[j];
				if (seg)
					seg->flags = new_flags;
			}
			active_status = vid_chans[i]->flags & LH_CHAN_ACTIVE_m13;
			vid_chans[i]->flags = new_flags | active_status;
		}
	}

	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_push_behavior_exec_m13(const si1 *function, const si4 line, ui4 code)
{
	si4			n_behaviors;
	BEHAVIOR_m13		*behavior, *new_behaviors;
	BEHAVIOR_STACK_m13	*stack;
	

	stack = G_behavior_stack_m13();
	if (stack == NULL)
		return;
	
	// expand stack
	n_behaviors = stack->top_idx + 1;
	if (n_behaviors == stack->size) {
		n_behaviors += GLOBALS_BEHAVIOR_STACK_SIZE_INCREMENT_m13;
		new_behaviors = (BEHAVIOR_m13 *) realloc((void *) stack->behaviors, (size_t) n_behaviors * sizeof(BEHAVIOR_m13));
		if (new_behaviors == NULL) {
			G_set_error_m13(E_ALLOC_m13, NULL);
			return;
		}
		stack->behaviors = new_behaviors;
		stack->size = n_behaviors;
	}
	
	behavior = stack->behaviors + (++stack->top_idx);
	behavior->function = function;
	behavior->line = line;
	if (code == DEFAULT_BEHAVIOR_m13)  // set to list default
		behavior->code = globals_m13->behavior_stack_list->default_behavior;
	else
		behavior->code = code;

	return;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_push_function_exec_m13(const si1 *function)
{
#ifdef FT_DEBUG_m13
	
	si4			n_functions;
	const si1		**new_functions;
	FUNCTION_STACK_m13	*stack;
	
	
	// causal error set => do not modify stack of causal thread
	if (globals_m13->error.code)
		if (globals_m13->error.thread_id == gettid_m13())
			return;

	// get function stacks mutex
	stack = G_function_stack_m13(0);
	if (stack == NULL)
		return;
	
	// expand stack
	n_functions = stack->top_idx + 1;
	if (n_functions == stack->size) {
		n_functions += GLOBALS_FUNCTION_STACK_SIZE_INCREMENT_m13;
		new_functions = (const si1 **) realloc((void *) stack->functions, (size_t) n_functions * sizeof(const si1 *));
		if (new_functions == NULL) {
			G_set_error_m13(E_ALLOC_m13, NULL);
			return;
		}
		stack->functions = new_functions;
		stack->size = n_functions;
	}
	
	stack->functions[++stack->top_idx] = function;
#endif  // FT_DEBUG_m13

	return;
}


CHAN_m13	*G_read_channel_m13(CHAN_m13 *chan, SLICE_m13 *slice, ...)  // varargs: si1 *chan_path, LH_m13 *parent, ui8 lh_flags, si1 *password
{
	tern				free_chan, threading, ret_val;
	si1 				*chan_path, *password;
	si1 				num_str[FILE_NUMBERING_DIGITS_m13 + 1];
	ui8 				flags;
	si4 				i, j, k, n_segs, seg_idx, thread_idx, null_segment_cnt;
	va_list				v_args;
	LH_m13				*parent;
	SEG_m13				*seg;
	PROC_GLOBS_m13			*proc_globs;
	PROC_THREAD_INFO_m13		*proc_thread_infos;
	READ_MED_THREAD_INFO_m13	*read_MED_thread_infos;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// open channel
	if (chan == NULL) {
		// get varargs
		va_start(v_args, slice);
		chan_path = va_arg(v_args, si1 *);
		parent = va_arg(v_args, LH_m13 *);
		flags = va_arg(v_args, ui8);
		password = va_arg(v_args, si1 *);
		va_end(v_args);
		// open channel
		chan = G_open_channel_m13(NULL, slice, chan_path, parent, flags, password);
		if (chan == NULL)
			return_m13(NULL);
		free_chan = TRUE_m13;
	} else {
		free_chan = FALSE_m13;
	}
	
	// process time slice (passed slice is not modified)
	if (slice)  // passed slice supersedes structure slice
		chan->slice = *slice;
	slice = &chan->slice;
	if (G_all_zeros_m13((ui1 *) slice, (si4) sizeof(SLICE_m13)) == TRUE_m13)
		G_init_slice_m13(slice);
	if (slice->conditioned == FALSE_m13)
		G_condition_slice_m13(slice, (LH_m13 *) chan);
		
	// get segment range
	if (slice->n_segs == UNKNOWN_m13) {
		n_segs = G_segment_range_m13((LH_m13 *) chan, slice);
		if (n_segs == 0) {
			if (free_chan == TRUE_m13)
				G_free_channel_m13(&chan);
			return_m13(NULL);
		}
	} else {
		n_segs = slice->n_segs;
	}
	seg_idx = G_segment_index_m13(slice->start_seg_num, (LH_m13 *) chan);
	if (seg_idx == FALSE_m13) {
		if (free_chan == TRUE_m13)
			G_free_channel_m13(&chan);
		return_m13(NULL);
	}

	// read segments
	proc_globs = G_proc_globs_m13((LH_m13 *) chan);
	threading = proc_globs->miscellaneous.threading;
	if (n_segs == 1)  // no sense in overhead for one thread
		threading = FALSE_m13;
	else if ((flags & LH_THREAD_SEG_READS_m13) == 0)
		threading = FALSE_m13;

	// set up thread infos
	proc_thread_infos = (PROC_THREAD_INFO_m13 *) calloc((size_t) n_segs, sizeof(PROC_THREAD_INFO_m13));
	read_MED_thread_infos = (READ_MED_THREAD_INFO_m13 *) calloc((size_t) n_segs, sizeof(READ_MED_THREAD_INFO_m13));
	
	// start read_segment threads
	null_segment_cnt = 0;
	thread_idx = 0;
	for (i = slice->start_seg_num, j = seg_idx, k = 0; i <= slice->end_seg_num; ++i, ++j, ++k) {
		seg = chan->segs[j];
		if (seg == NULL) {
			STR_fixed_width_int_m13(num_str, FILE_NUMBERING_DIGITS_m13, i);
			if (chan->type_code == TS_CHAN_TYPE_CODE_m13)
				sprintf_m13(read_MED_thread_infos[k].MED_dir, "%s/%s_s%s.%s", chan->path, chan->name, num_str, TS_SEG_TYPE_STR_m13);
			else  // VID_CHAN_TYPE_CODE_m13
				sprintf_m13(read_MED_thread_infos[k].MED_dir, "%s/%s_s%s.%s", chan->path, chan->name, num_str, VID_SEG_TYPE_STR_m13);
			if (G_exists_m13(read_MED_thread_infos[k].MED_dir) != DIR_EXISTS_m13) {
				// not every segment may be present
				++null_segment_cnt;
				continue;
			}
		} else {
			read_MED_thread_infos[k].MED_struct = (LH_m13 *) seg;
		}
		read_MED_thread_infos[k].parent = (LH_m13 *) chan;
		seg->slice = *slice;
		proc_thread_infos[thread_idx].thread_f = G_read_segment_thread_m13;
		proc_thread_infos[thread_idx].thread_label = "G_read_segment_thread_m13";
		proc_thread_infos[thread_idx].priority = PROC_HIGH_PRIORITY_m13;
		proc_thread_infos[thread_idx].arg = (void *) (read_MED_thread_infos + thread_idx);
		++thread_idx;
	}
	
	// thread out segment reads
	ret_val = PROC_distribute_jobs_m13(proc_thread_infos, n_segs, 0, TRUE_m13, threading);  // no reserved cores, wait for completion
	
	// check results
	if (null_segment_cnt == n_segs)
		ret_val = FALSE_m13;
	for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
		seg = (SEG_m13 *) read_MED_thread_infos[i].MED_struct;
		if (seg == NULL)
			ret_val = FALSE_m13;
		else
			chan->segs[j] = seg;
	}
	free((void *) proc_thread_infos);
	free((void *) read_MED_thread_infos);
	if (ret_val == FALSE_m13) {
		if (free_chan == TRUE_m13)
			G_free_channel_m13(&chan);
		return_m13(NULL);
	}

	// empty slice
	if (null_segment_cnt == n_segs) {
		slice->n_segs = EMPTY_SLICE_m13;
		if (free_chan == TRUE_m13)
			G_free_channel_m13(&chan);
		return_m13(NULL);
	}

	// update slice
	for (i = 0, j = seg_idx; i < n_segs; ++i, ++j) {
		seg = chan->segs[j];
		if (seg)
			break;
	}
	slice->start_time = seg->slice.start_time;
	slice->start_samp_num = seg->slice.start_samp_num;
	slice->start_seg_num = seg->slice.start_seg_num;
	for (++i, ++j; i < n_segs; ++i, ++j) {
		if (chan->segs[j])
			seg = chan->segs[j];
	}
	slice->end_time = seg->slice.end_time;
	slice->end_samp_num = seg->slice.end_samp_num;
	slice->end_seg_num = seg->slice.end_seg_num;
	slice->n_segs = SLICE_SEG_COUNT_m13(slice);

	// channel records
	if (chan->flags & LH_READ_CHAN_RECS_MASK_m13)
		G_read_record_data_m13((LH_m13 *) chan, slice, 0);
	
	// update ephemeral data
	if (chan->flags & LH_GENERATE_EPHEMERAL_DATA_m13) {
		for (i = slice->start_seg_num, j = seg_idx; i <= slice->end_seg_num; ++i, ++j) {
			seg = chan->segs[j];
			if (seg == NULL)
				continue;
			if (seg->flags & LH_UPDATE_EPHEMERAL_DATA_m13) {
				G_merge_universal_headers_m13(chan->metadata_fps, seg->metadata_fps, NULL);
				G_merge_metadata_m13(chan->metadata_fps, seg->metadata_fps, NULL);
				if (seg->rec_inds_fps && seg->rec_data_fps)
					G_merge_universal_headers_m13(chan->metadata_fps, seg->rec_data_fps, NULL);
				seg->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m13;  // clear segment flag
				chan->flags |= LH_UPDATE_EPHEMERAL_DATA_m13;  // set channel flag (for session)
			}
		}
	
		// fix session ephemeral FPS (from merge functions)
		if (chan->type_code == TS_CHAN_TYPE_CODE_m13)
			chan->metadata_fps->uh->type_code = TS_METADATA_TYPE_CODE_m13;
		else if (chan->type_code == VID_CHAN_TYPE_CODE_m13)
			chan->metadata_fps->uh->type_code = VID_METADATA_TYPE_CODE_m13;
		chan->metadata_fps->uh->segment_number = UH_CHANNEL_LEVEL_CODE_m13;
		chan->metadata_fps->uh->segment_UID = UID_NO_ENTRY_m13;
	}
	
	return_m13(chan);
}


si4	G_read_channel_specification_file_m13(si1 *cs_file_name, si4 n_available_channels, si4 **map, si4 **reverse_map, si1 ***names, sf8 **decimation_frequencies, ui4 **block_samples, si1 ***descriptions)
{
	tern		outside_range_warning_given;
	si1		*buffer, *next_line, len, *c1, *c2, *c3, tmp_str[1024], *end_ptr;
	si4		i, row_length, max_row_length, n_rows, n_channels, acq_num, comma_count, n_fields;
	si8		file_bytes;
	FILE_m13	*fp;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// map & reverse_map, names, decimation_frequencies, block_samples, & descriptions are allocated here & filled in
	// number of channels returned
	
	// open channel specification file
	fp = fopen_m13(cs_file_name, "r");
	
	// get file length
	file_bytes = (ui8) flen_m13(fp);
	
	// read in channel specification file
	buffer = (si1 *) malloc((size_t) (file_bytes + 2));
	fread_m13(buffer, sizeof(si1), (size_t) file_bytes, fp);
	fclose_m13(fp);
	if (buffer[file_bytes - 1] != '\n')  // in case no terminal newline
		buffer[file_bytes++] = '\n';
	buffer[file_bytes] = 0;
	
	// remove carriage returns & non-printing characters (courtesy of Excel)
	c1 = c2 = buffer - 1;
	while (*++c1)
		if (*c1 == '\n' || (*c1 >= 32 && *c1 < 127))
			*++c2 = *c1;
	*++c2 = 0;
	
	// count rows (just count newlines, fine to over allocate here)
	max_row_length = 0;
	n_rows = 0;
	c1 = c2 = buffer - 1;
	while (*++c1) {
		if (*c1 == '\n') {
			row_length = c1 - c2;
			++n_rows;
			if (max_row_length < row_length)
				max_row_length = row_length;
			c2 = c1;
		}
	}
	
	// allocate
	*map = (si4 *) calloc_m13(n_available_channels, sizeof(si4));
	*reverse_map = (si4 *) calloc_m13(n_available_channels, sizeof(si4));
	*names = (si1 **) calloc_2D_m13(n_rows, max_row_length, sizeof(si1));
	*decimation_frequencies = (sf8 *) calloc_m13(n_rows, sizeof(si8));
	*block_samples = (ui4 *) calloc_m13(n_rows, sizeof(ui4));
	*descriptions = (si1 **) calloc_2D_m13(n_rows, max_row_length, sizeof(si1));
	
	// initialize maps
	for (i = 0; i < n_available_channels; ++i)
		(*map)[i] = (*reverse_map)[i] = UNMAPPED_CHAN_m13;
	
	// fill arrays
	n_channels = 0;
	c1 = buffer;
	n_fields = 5;
	outside_range_warning_given = FALSE_m13;
	while (*c1) {

		if (n_channels > n_available_channels) {
			G_warning_message_m13("%s(): requested channel count exceeds acquired channels => using all available channels\n\n", __FUNCTION__);
			break;
		}

		// find next line
		next_line = c1 - 1;
		while (*++next_line != '\n');
		*next_line++ = 0;
		
		// replace commas & find end of line
		c2 = c1;
		comma_count = 0;
		while (*c2) {
			if (*c2 == ',')
				if (++comma_count < n_fields)  // allow commas in channel description
					*c2 = 0;
			++c2;
		}

		// acquisition channel number
		len = strcpy_m13(tmp_str, c1) + 1;  // include terminal zero
		acq_num = ((si4) strtol(tmp_str, &end_ptr, 10)) - 1;  // convert to index (-1)
		if (end_ptr == tmp_str) {
			c1 = next_line;  // move to next line
			continue;
		}
		if (acq_num >= n_available_channels) {
			if (outside_range_warning_given == FALSE_m13) {
				G_warning_message_m13("%s(): at least one requested channel number exceeds available range\n", __FUNCTION__);
				outside_range_warning_given = TRUE_m13;
			}
			c1 = next_line;  // move to next row
			continue;
		}
		(*map)[acq_num] = n_channels;
		(*reverse_map)[n_channels] = acq_num;
		if ((c1 += len) == next_line)
			continue;

		// channel name
		len = strcpy_m13(tmp_str, c1) + 1;  // include terminal zero
		if (len == 1)
			continue;
		c1 += len;
		
		// condition name
		// remove leading spaces
		c2 = tmp_str;
		while (*c2 == ' ')
			++c2;
		c3 = tmp_str;
		while (*c2)
			*c3++ = *c2++;
		*c3 = 0;

		// remove trailing spaces
		len = strlen(tmp_str);
		c2 = tmp_str + len - 1;
		while (*c2 == ' ')
			*c2-- = 0;

		// replace multiple spaces within name with single spaces
		c2 = c3 = tmp_str;
		while (*c3) {
			if (*c3 == ' ') {
				if (*(c3 - 1) == ' ') {
					++c3;
					continue;
				}
			}
			*c2++ = *c3++;
		}
		*c2 = 0;

		// replace single spaces within name with underscores
		c2 = tmp_str;
		while (*c2) {
			if (*c2 == ' ')
				*c2 = '_';
			++c2;
		}

		len = strcpy_m13((*names)[n_channels], tmp_str);
		if (len == 0)
			continue;
		if (c1 == next_line) {
			++n_channels;
			continue;
		}

		// decimation frequency
		len = strcpy_m13(tmp_str, c1) + 1;  // include terminal zero
		(*decimation_frequencies)[n_channels] = (sf8) strtod(tmp_str, &end_ptr);
		if (end_ptr == tmp_str || (c1 += len) == next_line) {
			c1 = next_line;  // move to next line
			++n_channels;
			continue;
		}

		// block samples
		len = strcpy_m13(tmp_str, c1) + 1;  // include terminal zero
		(*block_samples)[n_channels] = (ui4) strtoul(tmp_str, &end_ptr, 10);
		if (end_ptr == tmp_str || (c1 += len) == next_line) {
			c1 = next_line;  // move to next line
			++n_channels;
			continue;
		}

		// channel description
		strcpy_m13(tmp_str, c1);
		c1 = next_line;

		// condition channel description
		c2 = tmp_str;
		while (*c2 == ' ')  // remove leading spaces
			++c2;
		len = strlen(c2);
		c3 = c2 + len - 1;
		while (*c3 == ' ')  // remove trailing spaces
			*c3-- = 0;
		strcpy_m13((*descriptions)[n_channels], c2);
		++n_channels;
	}
	free((void *) buffer);

	return_m13(n_channels);
}


pthread_rval_m13	G_read_channel_thread_m13(void *ptr)
{
	CHAN_m13			*ret_val;
	PROC_THREAD_INFO_m13		*pi;
	READ_MED_THREAD_INFO_m13 	*rmi;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	pi = (PROC_THREAD_INFO_m13 *) ptr;
	pi->status = PROC_THREAD_RUNNING_m13;  // volatile

	rmi = (READ_MED_THREAD_INFO_m13 *) (pi->arg);
	ret_val = G_read_channel_m13((CHAN_m13 *) rmi->MED_struct, rmi->slice, rmi->MED_dir, (SESS_m13 *) rmi->parent, rmi->flags, rmi->password);
	
	G_free_thread_local_storage_m13((LH_m13 *) rmi->MED_struct);

	if (ret_val) {
		rmi->MED_struct = (LH_m13 *) ret_val;
		pi->status = PROC_THREAD_SUCCEEDED_m13;  // volatile
	} else {
		rmi->MED_struct = NULL;
		pi->status = PROC_THREAD_FAILED_m13;  // volatile
	}
	
	thread_return_null_m13;
}


LH_m13 	*G_read_data_m13(LH_m13 *lh, SLICE_m13 *slice, ...)  // varargs (level_header == NULL): void *file_list, si4 list_len, ui8 lh_flags, si1 *password, si1 *index_channel_name
{
	void				*file_list;
	si1				*password, *index_channel_name, tmp_str[PATH_BYTES_m13];
	ui4				level_code;
	si4				list_len;
	ui8				flags;
	va_list				v_args;
	SESS_m13			*sess;
	CHAN_m13			*chan;
	SEG_m13			*seg;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (lh == NULL) {
		// get varargs
		va_start(v_args, slice);
		file_list = va_arg(v_args, void *);
		list_len = va_arg(v_args, si4);
		flags = va_arg(v_args, ui8);
		password = va_arg(v_args, si1 *);
		index_channel_name = va_arg(v_args, si1 *);
		va_end(v_args);
		
		// get level
		if (list_len == 0) { // single string
			level_code = G_level_m13((si1 *) file_list, NULL);
		} else {
			G_path_parts_m13((si1 *) *((si1 **) file_list), tmp_str, NULL, NULL);
			level_code = G_level_m13(tmp_str, NULL);
		}
		
		switch (level_code) {
			case SESS_TYPE_CODE_m13:
				sess = G_open_session_m13(NULL, slice, file_list, list_len, flags, password, index_channel_name);
				if (sess == NULL) {
					G_set_error_m13(E_UNKN_m13, "error opening session");
					return_m13(NULL);
				}
				lh = (LH_m13 *) sess;
				break;
			case SSR_TYPE_CODE_m13:
				G_set_error_m13(E_UNKN_m13, "cannot currently process segmented session records as a level");
				return_m13(NULL);
			case TS_CHAN_TYPE_CODE_m13:
			case VID_CHAN_TYPE_CODE_m13:
				chan = G_open_channel_m13(NULL, slice, (si1 *) file_list, NULL, flags, password);
				if (chan == NULL) {
					G_set_error_m13(E_UNKN_m13, "error opening channel");
					return_m13(NULL);
				}
				lh = (LH_m13 *) chan;
			case TS_SEG_TYPE_CODE_m13:
			case VID_SEG_TYPE_CODE_m13:
				seg = G_open_segment_m13(NULL, slice, (si1 *) file_list, NULL, flags, password);
				if (seg == NULL) {
					G_set_error_m13(E_UNKN_m13, "error opening segment");
					return_m13(NULL);
				}
				lh = (LH_m13 *) seg;
				break;
		}
	}

	switch (lh->type_code) {
		case SESS_TYPE_CODE_m13:
			sess = (SESS_m13 *) lh;
			sess = G_read_session_m13(sess, slice);
			if (sess == NULL) {
				G_set_error_m13(E_UNKN_m13, "error reading session");
				return_m13(NULL);
			}
			break;
		case SSR_TYPE_CODE_m13:
			G_set_error_m13(E_UNKN_m13, "can not currently process segmented session records as a level");
			return_m13(NULL);
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
			chan = (CHAN_m13 *) lh;
			chan = G_read_channel_m13(chan, slice);
			if (chan == NULL) {
				G_set_error_m13(E_UNKN_m13, "error reading channel");
				return_m13(NULL);
			}
			break;
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
			seg = (SEG_m13 *) lh;
			seg = G_read_segment_m13(seg, slice);
			if (chan == NULL) {
				G_set_error_m13(E_UNKN_m13, "error reading segment");
				return_m13(NULL);
			}
			break;
	}

	return_m13(lh);
}


si8 G_read_record_data_m13(LH_m13 *lh, SLICE_m13 *slice, ...)  // varags(level->type_code == SSR_TYPE_CODE_m13): si4 seg_num
{
	si4		seg_num;
	si8		start_idx, end_idx, n_recs, bytes_to_read, offset;
	FPS_m13		*ri_fps, *rd_fps;
	REC_IDX_m13	*ri;
	SESS_m13	*sess;
	SSR_m13		*ssr;
	CHAN_m13	*chan;
	SEG_m13		*seg;
	va_list		v_args;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	seg_num = 0;  // seg_num only reqired for segmented session records levels
	switch (lh->type_code) {
		case SESS_TYPE_CODE_m13:
			sess = (SESS_m13 *) lh;
			ri_fps = sess->rec_inds_fps;
			rd_fps = sess->rec_data_fps;
			break;
		case SSR_TYPE_CODE_m13:
			va_start(v_args, slice);
			seg_num = va_arg(v_args, si4);
			va_end(v_args);
			ssr = (SSR_m13 *) lh;
			if (ssr->flags & LH_MAP_ALL_SEGS_m13)
				--seg_num;
			else
				seg_num -= slice->start_seg_num;
			ri_fps = ssr->rec_inds_fps[seg_num];
			rd_fps = ssr->rec_data_fps[seg_num];
			break;
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
			chan = (CHAN_m13 *) lh;
			ri_fps = chan->rec_inds_fps;
			rd_fps = chan->rec_data_fps;
			break;
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
			seg = (SEG_m13 *) lh;
			ri_fps = seg->rec_inds_fps;
			rd_fps = seg->rec_data_fps;
			break;
	}

	// sort records
	if (globals_m13->write_sorted_records == TRUE_m13 && ri_fps->uh->ordered != TRUE_m13)
		G_sort_records_m13(ri_fps, rd_fps);

	start_idx = G_find_record_index_m13(ri_fps, slice->start_time, FIND_FIRST_ON_OR_AFTER_m13, 0);
	if (start_idx == NO_IDX_m13) {  // no records "on or after" slice beginning
		if (rd_fps)
			rd_fps->n_items = 0;;
		return_m13(0);
	}
	ri = ri_fps->rec_inds;
	if (ri[start_idx].start_time > slice->end_time) {  // no records "on or before" slice end
		if (rd_fps)
			rd_fps->n_items = 0;
		return_m13(0);
	}
	end_idx = G_find_record_index_m13(ri_fps, slice->end_time, FIND_FIRST_AFTER_m13, start_idx);
	if (end_idx == NO_IDX_m13) // no records after slice end, but some in slice => use terminal index
		end_idx = ri_fps->uh->n_entries - 1;
	n_recs = end_idx - start_idx;
	offset = ri_fps->rec_inds[start_idx].file_offset;
	bytes_to_read = ri_fps->rec_inds[end_idx].file_offset - offset;
	rd_fps = FPS_read_m13(rd_fps, offset, bytes_to_read, n_recs, NULL);
	if (rd_fps == NULL)
		return_m13((si8) FALSE_m13);
	
	return_m13(n_recs);
}


SEG_m13	*G_read_segment_m13(SEG_m13 *seg, SLICE_m13 *slice, ...)  // varargs: si1 *seg_path, ui8 lh_flags, si1 *password
{
	tern		free_seg, inactive_ref;
	si1		*seg_path, *password;
	si4		search_mode;
	ui8		flags;
	si8		seg_abs_start_samp_num, seg_abs_end_samp_num;
	va_list		v_args;
	CHAN_m13				*chan;
	UH_m13			*uh;
	TS_METADATA_SECTION_2_m13	*tmd2;
	VID_METADATA_SECTION_2_m13		*vmd2;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// open segment
	if (seg == NULL) {
		// get varargs
		va_start(v_args, slice);
		seg_path = va_arg(v_args, si1 *);
		flags = va_arg(v_args, ui8);
		password = va_arg(v_args, si1 *);
		va_end(v_args);
		// open segment
		seg = G_open_segment_m13(NULL, slice, seg_path, NULL, flags, password);
		if (seg == NULL)
			return_m13(NULL);
		free_seg = TRUE_m13;
	} else {
		free_seg = FALSE_m13;
	}

	// process time slice (passed slice is not modified)
	if (slice)  // passed slice supersedes structure slice
		seg->slice = *slice;
	slice = &seg->slice;
	if (G_all_zeros_m13((ui1 *) slice, (si4) sizeof(SLICE_m13)) == TRUE_m13)
		G_init_slice_m13(slice);
	if (slice->conditioned == FALSE_m13)
		G_condition_slice_m13(slice, (LH_m13 *) seg);
	
	// check for valid limit pair (time takes priority)
	if ((search_mode = G_search_mode_m13(slice)) == FALSE_m13) {
		if (free_seg == TRUE_m13)
			G_free_segment_m13(&seg);
		return_m13(NULL);
	}
	uh = seg->metadata_fps->uh;
	if (search_mode == TIME_SEARCH_m13) {
		if (slice->start_time < uh->segment_start_time)
			slice->start_time = uh->segment_start_time;
		if (slice->end_time > uh->segment_end_time)
			slice->end_time = uh->segment_end_time;
	}
			
	// get local indices
	if (seg->type_code == TS_SEG_TYPE_CODE_m13) {
		tmd2 = &seg->metadata_fps->metadata->time_series_section_2;
		seg_abs_start_samp_num = tmd2->session_start_sample_number;
		seg_abs_end_samp_num = seg_abs_start_samp_num + tmd2->number_of_samples - (si8) 1;
	} else {  // seg->type_code == VID_SEG_TYPE_CODE_m13
		vmd2 = &seg->metadata_fps->metadata->video_section_2;
		seg_abs_start_samp_num = vmd2->session_start_frame_number;
		seg_abs_end_samp_num = seg_abs_start_samp_num + (vmd2->number_of_frames - (si8) 1);
	}
	
	// get local indices (sample number == frame number == idx)
	if (search_mode == SAMPLE_SEARCH_m13) {
		if (slice->start_samp_num < seg_abs_start_samp_num)
			slice->start_samp_num = seg_abs_start_samp_num;
		if (slice->end_samp_num > seg_abs_end_samp_num)
			slice->end_samp_num = seg_abs_end_samp_num;
		slice->start_time = G_uutc_for_sample_number_m13((LH_m13 *) seg, slice->start_samp_num, FIND_START_m13);
		slice->end_time = G_uutc_for_sample_number_m13((LH_m13 *) seg, slice->end_samp_num, FIND_END_m13);
	} else {  // search_mode == TIME_SEARCH_m13, convert input times to local indices
		if (slice->start_time < uh->segment_start_time)
			slice->start_time = uh->segment_start_time;
		if (slice->end_time > uh->segment_end_time)
			slice->end_time = uh->segment_end_time;
		if (seg->flags & LH_READ_SEG_DATA_MASK_m13) {  // may only be reading records
			slice->start_samp_num = G_sample_number_for_uutc_m13((LH_m13 *) seg, slice->start_time, FIND_CURRENT_m13);
			slice->end_samp_num = G_sample_number_for_uutc_m13((LH_m13 *) seg, slice->end_time, FIND_CURRENT_m13);
		}
	}
	slice->start_seg_num = slice->end_seg_num = seg->metadata_fps->uh->segment_number;
	slice->n_segs = 1;

	// read segment data
	inactive_ref = FALSE_m13;  // check for inactive reference
	if (seg->flags & LH_READ_SEG_DATA_MASK_m13) {
		switch (seg->type_code) {
			case TS_SEG_TYPE_CODE_m13:
				if (seg->parent) {
					chan = (CHAN_m13 *) seg->parent;
					if (chan->flags & LH_IDX_CHAN_INACTIVE_m13)
						inactive_ref = TRUE_m13;
				}
				if (inactive_ref == TRUE_m13)
					seg->flags &= ~LH_IDX_CHAN_INACTIVE_m13;  // reset segment level flag in case propogated during call
				else  // read data
					G_read_time_series_data_m13(seg, slice);
				break;
			case VID_SEG_TYPE_CODE_m13:
				// nothing for now - video segment data are native video files
				break;
		}
	}
	
	// read segment records
	if (seg->flags & LH_READ_SEG_RECS_MASK_m13)
		if (seg->rec_inds_fps && seg->rec_data_fps)
			if (inactive_ref == FALSE_m13)  // don't read records either
				G_read_record_data_m13((LH_m13 *) seg, slice);

	return_m13(seg);
}


pthread_rval_m13	G_read_segment_thread_m13(void *ptr)
{
	SEG_m13				*ret_val;
	PROC_THREAD_INFO_m13 		*pi;
	READ_MED_THREAD_INFO_m13 	*rmi;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	pi = (PROC_THREAD_INFO_m13 *) ptr;
	pi->status = PROC_THREAD_RUNNING_m13;  // volatile
	
	rmi = (READ_MED_THREAD_INFO_m13 *) (pi->arg);
	ret_val = G_read_segment_m13((SEG_m13 *) rmi->MED_struct, rmi->slice, rmi->MED_dir, (CHAN_m13 *) rmi->parent, rmi->flags, rmi->password);
	
	G_free_thread_local_storage_m13((LH_m13 *) rmi->MED_struct);

	if (ret_val) {
		rmi->MED_struct = (LH_m13 *) ret_val;
		pi->status = PROC_THREAD_SUCCEEDED_m13;  // volatile
	} else {
		rmi->MED_struct = NULL;
		pi->status = PROC_THREAD_FAILED_m13;  // volatile
	}
	
	thread_return_null_m13;
}


SESS_m13	*G_read_session_m13(SESS_m13 *sess, SLICE_m13 *slice, ...)  // varargs(sess == NULL): void *file_list, si4 list_len, ui8 lh_flags, si1 *password, si1 *index_channel_name
{
	tern				free_sess, threading, calculate_channel_indices, ret_val;
	si1 				*password, num_str[FILE_NUMBERING_DIGITS_m13 + 1], *index_channel_name;
	si1				tmp_str[PATH_BYTES_m13];
	ui8 				flags;
	si4 				i, j, list_len, seg_idx, thread_idx, active_chans, active_ts_chans, active_vid_chans, search_mode;
	sf8				ref_sf, sf_ratio;
	void				*file_list;
	va_list				v_args;
	PROC_GLOBS_m13			*proc_globs;
	UH_m13				*uh;
	CHAN_m13			*chan;
	PROC_THREAD_INFO_m13		*proc_thread_infos;
	READ_MED_THREAD_INFO_m13	*read_MED_thread_infos;
	SSR_m13				*ssr;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// open session
	if (sess == NULL) {
		// get varargs
		va_start(v_args, slice);
		file_list = va_arg(v_args, void *);
		list_len = va_arg(v_args, si4);
		flags = va_arg(v_args, ui8);
		password = va_arg(v_args, si1 *);
		index_channel_name = va_arg(v_args, si1 *);
		va_end(v_args);
		
		// open session
		sess = G_open_session_m13(NULL, slice, file_list, list_len, flags, password, index_channel_name);
		if (sess == NULL)
			return_m13(NULL);
		free_sess = TRUE_m13;
	} else {  // process time slice (passed slice is not modified)
		if (slice == NULL) {
			if (G_all_zeros_m13((ui1 *) &sess->slice, (si4) sizeof(SLICE_m13)) == TRUE_m13)
				G_init_slice_m13(&sess->slice);  // read whole session
		} else {  // passed slice supersedes structure slice
			sess->slice = *slice;  // passed slice is not modified
		}
		if (sess->slice.conditioned == FALSE_m13)
			G_condition_slice_m13(slice, (LH_m13 *) sess);
		free_sess = FALSE_m13;
	}

	if (slice)  // passed slice supersedes structure slice
		sess->slice = *slice;
	slice = &sess->slice;
	if (G_all_zeros_m13((ui1 *) slice, (si4) sizeof(SLICE_m13)) == TRUE_m13)
		G_init_slice_m13(slice);
	if (slice->conditioned == FALSE_m13)
		G_condition_slice_m13(slice, (LH_m13 *) sess);


	// get segment range
	if (slice->n_segs == UNKNOWN_m13) {
		if (G_segment_range_m13((LH_m13 *) sess, slice) == 0) {
			if (free_sess == TRUE_m13)
				G_free_session_m13(&sess);
			return_m13(NULL);
		}
	}
	seg_idx = G_check_segment_map_m13(slice, sess);
	if (seg_idx == FALSE_m13) {
		if (free_sess == TRUE_m13)
			G_free_session_m13(&sess);
		return_m13(NULL);
	}

	// set inactive reference flags
	proc_globs = G_proc_globs_m13((LH_m13 *) sess);
	chan = proc_globs->current_session.index_channel;
	if ((chan->flags & LH_CHAN_ACTIVE_m13) == 0) {
		if (chan->flags & LH_READ_SEG_DATA_MASK_m13) {
			chan->flags |= LH_IDX_CHAN_INACTIVE_m13;
			chan = G_read_channel_m13(chan, slice);  // just slice read metadata & time series indices (probably already read)
			chan->flags &= ~LH_IDX_CHAN_INACTIVE_m13;
		}
	}
	
	// update for variable frequencies on active channel set
	G_frequencies_vary_m13(sess);
	
	// count active channels
	active_ts_chans = active_vid_chans = 0;
	for (i = 0; i < sess->n_ts_chans; ++i)
		if (sess->ts_chans[i]->flags & LH_CHAN_ACTIVE_m13)
			++active_ts_chans;
	for (i = 0; i < sess->n_vid_chans; ++i)
		if (sess->vid_chans[i]->flags & LH_CHAN_ACTIVE_m13)
			++active_vid_chans;
	active_chans = active_ts_chans + active_vid_chans;

	// thread out channel reads
	threading = proc_globs->miscellaneous.threading;
	if (active_chans == 1)  // no sense in thread overhead for one channel
		threading = FALSE_m13;

	proc_thread_infos = (PROC_THREAD_INFO_m13 *) calloc((size_t) active_chans, sizeof(PROC_THREAD_INFO_m13));
	read_MED_thread_infos = (READ_MED_THREAD_INFO_m13 *) calloc((size_t) active_ts_chans, sizeof(READ_MED_THREAD_INFO_m13));
	search_mode = G_search_mode_m13(slice);
	thread_idx = 0;
	if (active_ts_chans) {
		calculate_channel_indices = FALSE_m13;
		if (proc_globs->active_channels.sampling_frequencies_vary == TRUE_m13) {
			if (proc_globs->current_session.index_channel->type_code == TS_CHAN_TYPE_m13) {
				if (search_mode == SAMPLE_SEARCH_m13) {
					calculate_channel_indices = TRUE_m13;
					ref_sf = proc_globs->current_session.index_channel->metadata_fps->metadata->time_series_section_2.sampling_frequency;
				}
			}
		}
		for (i = 0; i < sess->n_ts_chans; ++i) {
			chan = sess->ts_chans[i];
			if (chan->flags & LH_CHAN_ACTIVE_m13) {
				if (calculate_channel_indices == TRUE_m13) {
					sf_ratio = chan->metadata_fps->metadata->time_series_section_2.sampling_frequency / ref_sf;
					chan->slice.start_samp_num = (si8) round((sf8) slice->start_samp_num * sf_ratio);
					chan->slice.end_samp_num = (si8) round((sf8) slice->end_samp_num * sf_ratio);
					chan->slice.start_time = chan->slice.end_time = UUTC_NO_ENTRY_m13;
				} else {
					chan->slice = *slice;
				}
				proc_thread_infos[thread_idx].thread_f = G_read_channel_thread_m13;
				proc_thread_infos[thread_idx].thread_label = "G_read_channel_thread_m13";
				proc_thread_infos[thread_idx].priority = PROC_HIGH_PRIORITY_m13;
				proc_thread_infos[thread_idx].arg = (void *) (read_MED_thread_infos + thread_idx);
				read_MED_thread_infos[thread_idx].MED_struct = (LH_m13 *) chan;
				++thread_idx;
			}
		}
	}
	if (active_vid_chans) {
		calculate_channel_indices = FALSE_m13;
		if (proc_globs->active_channels.frame_rates_vary == TRUE_m13) {
			if (proc_globs->current_session.index_channel->type_code == VID_CHAN_TYPE_m13) {
				if (search_mode == SAMPLE_SEARCH_m13) {
					calculate_channel_indices = TRUE_m13;
					ref_sf = proc_globs->current_session.index_channel->metadata_fps->metadata->video_section_2.frame_rate;
				}
			}
		}
		for (i = 0; i < sess->n_vid_chans; ++i) {
			chan = sess->vid_chans[i];
			if (chan->flags & LH_CHAN_ACTIVE_m13) {
				if (calculate_channel_indices == TRUE_m13) {
					sf_ratio = chan->metadata_fps->metadata->video_section_2.frame_rate / ref_sf;
					chan->slice.start_frame_num = (si8) round((sf8) slice->start_frame_num * sf_ratio);
					chan->slice.end_frame_num = (si8) round((sf8) slice->end_frame_num * sf_ratio);
					chan->slice.start_time = chan->slice.end_time = UUTC_NO_ENTRY_m13;
				} else {
					chan->slice = *slice;
				}
				proc_thread_infos[thread_idx].thread_f = G_read_channel_thread_m13;
				proc_thread_infos[thread_idx].thread_label = "G_read_channel_thread_m13";
				proc_thread_infos[thread_idx].priority = PROC_HIGH_PRIORITY_m13;
				proc_thread_infos[thread_idx].arg = (void *) (read_MED_thread_infos + thread_idx);
				read_MED_thread_infos[thread_idx].MED_struct = (LH_m13 *) chan;
				++thread_idx;
			}
		}
	}
	
	// thread out channel reads
	ret_val = PROC_distribute_jobs_m13(proc_thread_infos, active_chans, 0, TRUE_m13, threading);  // no reserved cores, wait for completion
	
	// check results
	for (i = 0; i < active_chans; ++i)
		if (read_MED_thread_infos[i].MED_struct == NULL)
			ret_val = FALSE_m13;
	free((void *) proc_thread_infos);
	free((void *) read_MED_thread_infos);
	if (ret_val == FALSE_m13) {
		if (free_sess == TRUE_m13)
			G_free_session_m13(&sess);
		G_set_error_m13(E_UNKN_m13, "error reading session");
		return_m13(NULL);
	}
 
	// update session slice
	*slice = proc_globs->current_session.index_channel->slice;
	if (proc_globs->active_channels.sampling_frequencies_vary == TRUE_m13 || proc_globs->active_channels.frame_rates_vary == TRUE_m13)
		slice->start_samp_num = slice->end_samp_num = SAMPLE_NUMBER_NO_ENTRY_m13;  // unioned with video fields

	// read session record data
	if (sess->flags & LH_READ_SESS_RECS_MASK_m13) {
		if (sess->rec_inds_fps == NULL || sess->rec_data_fps == NULL)
			G_open_session_records_m13(sess);
		if (sess->rec_inds_fps && sess->rec_data_fps)
			G_read_record_data_m13((LH_m13 *) sess, slice);
	}

	// read segmented session record data
	if (sess->flags & LH_READ_SEG_SESS_RECS_MASK_m13) {
		ssr = sess->ssr;
		if (ssr == NULL)
			ssr = G_open_seg_sess_recs_m13(sess);
		if (ssr) {
			for (i = slice->start_seg_num, j = seg_idx; i <= slice->end_seg_num; ++i, ++j)
				if (ssr->rec_inds_fps[j] && ssr->rec_data_fps[j])
					G_read_record_data_m13((LH_m13 *) ssr, slice, i);
		}
	}

	ssr = sess->ssr;
	seg_idx = G_segment_index_m13(slice->start_seg_num, (LH_m13 *) sess);
	if ((sess->flags & LH_READ_SEG_SESS_RECS_MASK_m13) && ssr) {
		for (i = slice->start_seg_num, j = seg_idx; i <= slice->end_seg_num; ++i, ++j) {
			// allocate new segment records
			if (ssr->rec_inds_fps[j] == NULL && ssr->rec_data_fps[j] == NULL) {
				STR_fixed_width_int_m13(num_str, FILE_NUMBERING_DIGITS_m13, i);
				sprintf_m13(tmp_str, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, REC_INDS_TYPE_STR_m13);
				if (G_exists_m13(tmp_str) == FILE_EXISTS_m13)
					ssr->rec_inds_fps[j] = FPS_read_m13(ssr->rec_inds_fps[j], 0, FPS_FULL_FILE_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) ssr);
				sprintf_m13(tmp_str, "%s/%s_s%s.%s", ssr->path, ssr->name, num_str, REC_DATA_TYPE_STR_m13);
				if (G_exists_m13(tmp_str) == FILE_EXISTS_m13)
					ssr->rec_data_fps[j] = FPS_read_m13(ssr->rec_data_fps[j], 0, FPS_AUTO_BYTES_m13, 0, NULL, tmp_str, "r", NULL, (LH_m13 *) ssr);
			}
			if (ssr->rec_inds_fps[j] && ssr->rec_data_fps[j])
				G_read_record_data_m13((LH_m13 *) ssr, slice, i);
		}
	}
	
	// update ephemeral data  (session record ephemeral data updated on session / segment open)
	if (sess->flags & LH_GENERATE_EPHEMERAL_DATA_m13) {
		// time series ephemeral data
		for (i = 0; i < sess->n_ts_chans; ++i) {
			chan = sess->ts_chans[i];
			if (chan->flags & LH_CHAN_ACTIVE_m13) {
				G_merge_universal_headers_m13(sess->ts_metadata_fps, chan->metadata_fps, NULL);
				G_merge_metadata_m13(sess->ts_metadata_fps, chan->metadata_fps, NULL);
				chan->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m13;  // clear flag
			}
		}
		// video ephemeral data
		for (i = 0; i < sess->n_vid_chans; ++i) {
			chan = sess->vid_chans[i];
			if (chan->flags & LH_CHAN_ACTIVE_m13) {
				G_merge_universal_headers_m13(sess->vid_metadata_fps, chan->metadata_fps, NULL);
				G_merge_metadata_m13(sess->vid_metadata_fps, chan->metadata_fps, NULL);
				chan->flags &= ~LH_UPDATE_EPHEMERAL_DATA_m13;  // clear flag
			}
		}
		// fix session ephemeral universal header (from merge functions)
		if (sess->n_ts_chans) {
			uh = sess->ts_metadata_fps->uh;
			uh->type_code = TS_METADATA_TYPE_CODE_m13;
			uh->segment_number = UH_SESSION_LEVEL_CODE_m13;
			uh->session_UID = proc_globs->current_session.UID;
			uh->channel_UID = uh->segment_UID = UID_NO_ENTRY_m13;
		}
		if (sess->n_vid_chans) {
			uh = sess->vid_metadata_fps->uh;
			uh->type_code = VID_METADATA_TYPE_CODE_m13;
			uh->segment_number = UH_SESSION_LEVEL_CODE_m13;
			uh->session_UID = proc_globs->current_session.UID;
			uh->channel_UID = uh->segment_UID = UID_NO_ENTRY_m13;
		}
	}
	
	return_m13(sess);
}


si8 G_read_time_series_data_m13(SEG_m13 *seg, SLICE_m13 *slice)
{
	tern				cps_caching, scale;
	ui4				cached_block_samples;
	si4				cached_block_cnt, *to_ptr, *from_ptr, *si4_p, to_idx, from_idx;
	si4				first_cached_block, first_cached_block_idx, last_cached_block, last_cached_block_idx;
	si8				i, j, terminal_ts_ind, n_samps, n_blocks, start_offset;
	si8				start_block, end_block, read_start_block, read_end_block, read_n_blocks, compressed_data_bytes;
	si8				local_start_idx, local_end_idx, seg_start_samp_num, n_cached_samples, cache_offset;
	sf8				scale_factor;
	CMP_CACHE_BLOCK_INFO_m13	*cached_blocks;
	FPS_m13				*tsd_fps, *tsi_fps;
	TS_IDX_m13			*tsi;
	TS_METADATA_SECTION_2_m13	*tmd2;
	CPS_m13				*cps;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (seg == NULL) {
		G_set_error_m13(E_UNKN_m13, "segment structure is NULL");
		return_m13(-1);
	}
	if ((tsd_fps = seg->ts_data_fps) == NULL) {
		G_set_error_m13(E_UNKN_m13, "time series data fps is NULL");
		return_m13(-1);
	}
	if ((tsi_fps = seg->ts_inds_fps) == NULL) {
		G_set_error_m13(E_UNKN_m13, "time series indices fps is NULL");
		return_m13(-1);
	}
	if (seg->flags & LH_NO_CPS_PTR_RESET_m13){
		G_set_error_m13(E_UNKN_m13, "cps pointer resets are required for this function");
		return_m13(-1);
	}
	
	// find start and end blocks (block index is for block containing sample index)
	tsi = tsi_fps->ts_inds;
	seg_start_samp_num = seg->metadata_fps->metadata->time_series_section_2.session_start_sample_number;
	start_block = G_find_index_m13(seg, slice->start_samp_num, SAMPLE_SEARCH_m13);
	if (start_block < 0) {  // before first block
		start_block = 0;
		local_start_idx = 0;
	} else {
		local_start_idx = slice->start_samp_num - seg_start_samp_num;
	}
	terminal_ts_ind = tsi_fps->uh->n_entries - 1;
	end_block = G_find_index_m13(seg, slice->end_samp_num, SAMPLE_SEARCH_m13);
	if (end_block == terminal_ts_ind) {  // after last block (points to terminal index)
		local_end_idx = tsi[end_block].start_samp_num - 1;  // terminal index start_sample_number (== total samples in segment)
		end_block = terminal_ts_ind - 1;  // index of last true block
	} else {
		local_end_idx = slice->end_samp_num - seg_start_samp_num;
	}
	n_blocks = (end_block - start_block) + 1;

	// allocate cps
	n_samps = tsi[end_block + 1].start_samp_num - tsi[start_block].start_samp_num;
	start_offset = REMOVE_DISCONT_m13(tsi[start_block].file_offset);
	tmd2 = &seg->metadata_fps->metadata->time_series_section_2;
	cached_block_cnt = 0;
	read_start_block = start_block;
	read_end_block = end_block;
	if (tsd_fps->params.cps == NULL) {
		compressed_data_bytes = REMOVE_DISCONT_m13(tsi[end_block + 1].file_offset) - start_offset;
		cps = CMP_allocate_CPS_m13(tsd_fps, CMP_DECOMPRESSION_MODE_m13, n_samps, compressed_data_bytes, tmd2->maximum_block_keysample_bytes, tmd2->maximum_block_samples, NULL, NULL);
		cps_caching = (cps->direcs.flags & CPS_DF_CPS_CACHING_m13) ? TRUE_m13 : FALSE_m13;
		if (cps_caching == TRUE_m13) {
			cached_blocks = cps->params.cached_blocks = (CMP_CACHE_BLOCK_INFO_m13 *) calloc_m13((size_t) n_blocks, sizeof(CMP_CACHE_BLOCK_INFO_m13));
			cps->params.cached_block_list_len = n_blocks;
		}
	} else {
		cps = tsd_fps->params.cps;
		cps_caching = (cps->direcs.flags & CPS_DF_CPS_CACHING_m13) ? TRUE_m13 : FALSE_m13;
		if (cps_caching == TRUE_m13) {
			if (cps->params.cached_block_list_len < n_blocks) {
				cps->params.cached_blocks = (CMP_CACHE_BLOCK_INFO_m13 *) realloc_m13((void *) cps->params.cached_blocks, (size_t) n_blocks * sizeof(CMP_CACHE_BLOCK_INFO_m13));
				cps->params.cached_block_list_len = n_blocks;
			}
			cached_blocks = cps->params.cached_blocks;
			cached_block_cnt = cps->params.cached_block_cnt;
			if (cached_block_cnt) {
				// reallocate cache manually so CMP_realloc_cps_m13() does not free
				if (n_samps > cps->params.allocated_decompressed_samples) {
					cps->decompressed_data = cps->params.cache = (si4 *) realloc_m13((void *) cps->params.cache, n_samps * sizeof(si4));
					cps->params.allocated_decompressed_samples = n_samps;
				}
				first_cached_block = cached_blocks[0].block_number;
				last_cached_block = cached_blocks[cached_block_cnt - 1].block_number;
				if (first_cached_block <= end_block && last_cached_block >= start_block) {
					last_cached_block_idx = end_block - first_cached_block;
					if (last_cached_block_idx >= cached_block_cnt)
						last_cached_block_idx = cached_block_cnt - 1;
					last_cached_block = cached_blocks[last_cached_block_idx].block_number;
					first_cached_block_idx = start_block - first_cached_block;
					if (first_cached_block_idx < 0)
						first_cached_block_idx = 0;
					first_cached_block = cached_blocks[first_cached_block_idx].block_number;
					cached_block_cnt = (last_cached_block - first_cached_block) + 1;
					// full request is cached (don't update cache until there's at least one uncached block)
					if (first_cached_block <= start_block && last_cached_block >= end_block) {  // full request is cached
						cache_offset = cached_blocks[first_cached_block_idx].cache_offset + (local_start_idx - tsi[start_block].start_samp_num);
						cps->decompressed_ptr = cps->decompressed_data = cps->params.cache + cache_offset;
						n_samps = (local_end_idx - local_start_idx) + 1;
						return_m13(n_samps);
					}
					// shift samples
					to_ptr = cps->params.cache + (tsi[first_cached_block].start_samp_num - tsi[start_block].start_samp_num);
					from_ptr = cps->params.cache + cached_blocks[first_cached_block_idx].cache_offset;
					n_cached_samples = (cached_blocks[last_cached_block_idx].cache_offset + (si8) cached_blocks[last_cached_block_idx].block_samples) - cached_blocks[first_cached_block_idx].cache_offset;
					if (to_ptr > from_ptr) {  // right shift (move backwards)
						to_ptr += n_cached_samples;
						from_ptr += n_cached_samples;
						for (i = n_cached_samples; i--;)
							*--to_ptr = *--from_ptr;
					} else if (to_ptr < from_ptr) {  // left shift (move forwards)
						for (i = n_cached_samples; i--;)
							*to_ptr++ = *from_ptr++;
					}  // else don't move anything
					// shift cached block infos
					to_idx = first_cached_block - start_block;
					from_idx = first_cached_block_idx;
					first_cached_block_idx = to_idx;
					last_cached_block_idx = (first_cached_block_idx + cached_block_cnt) - 1;
					if (to_idx > from_idx) {  // right shift (move backwards)
						to_idx += cached_block_cnt;
						from_idx += cached_block_cnt;
						for (i = 0; i < cached_block_cnt; ++i)
							cached_blocks[--to_idx] = cached_blocks[--from_idx];
					} else if (to_idx < from_idx) {  // left shift (move forwards)
						for (i = 0; i < cached_block_cnt; ++i)
							cached_blocks[to_idx++] = cached_blocks[from_idx++];
					}  // else don't move anything
					// set uncached blocks to zero samples (used as flag to cache)
					for (i = 0; i < first_cached_block_idx; ++i)
						cached_blocks[i].block_samples = 0;
					for (i = last_cached_block_idx + 1; i < n_blocks; ++i)
						cached_blocks[i].block_samples = 0;
					// full request is cached (cache updated here)
				} else {
					cached_block_cnt = 0;  // none of requested blocks in requested range
				}
			}
		}
		// limit read, if possible (if cached blocks are in middle, they are read - but this should be uncommon)
		if (cached_block_cnt) {
			if (first_cached_block == start_block) {
				read_start_block = last_cached_block + 1;
				for (i = 0; i <= last_cached_block_idx; ++i)
					cached_blocks[i].data_read = FALSE_m13;
				for (; i < n_blocks; ++i)
					cached_blocks[i].data_read = TRUE_m13;
			} else if (last_cached_block == end_block) {
				read_end_block = first_cached_block - 1;
				for (i = 0; i < first_cached_block_idx; ++i)
					cached_blocks[i].data_read = TRUE_m13;
				for (; i < n_blocks; ++i)
					cached_blocks[i].data_read = FALSE_m13;
			} else {
				for (i = 0; i < n_blocks; ++i)
					cached_blocks[i].data_read = FALSE_m13;
			}
			start_offset = REMOVE_DISCONT_m13(tsi[read_start_block].file_offset);
			compressed_data_bytes = REMOVE_DISCONT_m13(tsi[read_end_block + 1].file_offset) - start_offset;
		} else {
			start_offset = REMOVE_DISCONT_m13(tsi[start_block].file_offset);
			compressed_data_bytes = REMOVE_DISCONT_m13(tsi[end_block + 1].file_offset) - start_offset;
		}
		CMP_update_CPS_pointers_m13(tsd_fps, CMP_RESET_DECOMPRESSED_PTR_m13 | CMP_RESET_BLOCK_HDR_PTR_m13);
		cps = CMP_realloc_cps_m13(tsd_fps, CMP_DECOMPRESSION_MODE_m13, n_samps, tmd2->maximum_block_samples);
	}

	// read in compressed data
	read_n_blocks = (read_end_block - read_start_block) + 1;
	FPS_read_m13(tsd_fps, start_offset, compressed_data_bytes, read_n_blocks, NULL);

	// set limit on first block
	cps->params.block_start_index = local_start_idx - tsi[start_block].start_samp_num;
	
	scale = FALSE_m13;
	if (cps->direcs.flags & CPS_DF_CONVERT_TO_NATIVE_UNITS_m13) {
		scale_factor = tmd2->amplitude_units_conversion_factor;
		if (scale_factor != 1.0 && scale_factor != TS_METADATA_AMPLITUDE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m13)
			scale = TRUE_m13;
	}
		
	// loop over blocks
	cache_offset = 0;
	cps->decompressed_ptr = cps->params.cache;
	for (i = 0, j = start_block; i < n_blocks; ++i, ++j) {
		if (cached_block_cnt) {
			if ((cached_block_samples = cached_blocks[i].block_samples)) {
				cps->decompressed_ptr += cached_block_samples;
				if (cached_blocks[i].data_read == TRUE_m13)  // data read because in middle, but block is still cached
					CMP_update_CPS_pointers_m13(tsd_fps, CMP_UPDATE_BLOCK_HDR_PTR_m13);
				cached_blocks[i].cache_offset = cache_offset;
				cache_offset += cached_block_samples;
				continue;
			}
		}
		// set limit on last block
		if (j == end_block)
			cps->params.block_end_index = local_end_idx - tsi[j].start_samp_num;
		CMP_decode_m13(tsd_fps);

		if (cps_caching == TRUE_m13) {
			cached_blocks[i].cache_offset = cache_offset;
			cached_blocks[i].block_samples = cps->block_header->number_of_samples;
			cache_offset += cached_blocks[i].block_samples;
			cached_blocks[i].block_number = j;
		}
		if (scale == TRUE_m13) {  // scale to native units
			i = cps->block_header->number_of_samples;
			si4_p = cps->decompressed_ptr;
			while (i--) {
				*si4_p = CMP_round_si4_m13((sf8) *si4_p * scale_factor);
				++si4_p;
			}
		}
		CMP_update_CPS_pointers_m13(tsd_fps, CMP_UPDATE_BLOCK_HDR_PTR_m13 | CMP_UPDATE_DECOMPRESSED_PTR_m13);
	}
	if (cps_caching == TRUE_m13)
		cps->params.cached_block_cnt = n_blocks;  // all blocks now cached
		
	n_samps = (local_end_idx - local_start_idx) + 1;  // trim (it did contain total samps in blocks)
	return_m13(n_samps);
}


tern  G_recover_passwords_m13(si1 *L3_password, UH_m13 *universal_header)
{
	tern	level_1_valid;
	ui1 	hash[SHA_HASH_BYTES_m13], L3_hash[SHA_HASH_BYTES_m13];
	si1 	L3_password_bytes[PASSWORD_BYTES_m13], hex_str[HEX_STR_BYTES_m13(PASSWORD_BYTES_m13, 1)];
	si1 	saved_L1_password_bytes[PASSWORD_BYTES_m13], putative_L1_password_bytes[PASSWORD_BYTES_m13], putative_L2_password_bytes[PASSWORD_BYTES_m13];
	si4 	i;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (G_check_password_m13(L3_password) == FALSE_m13)
		return_m13(FALSE_m13);
	
	// get terminal bytes
	G_terminal_password_bytes_m13(L3_password, L3_password_bytes);
	
	// get level 3 password hash
	SHA_hash_m13((ui1 *) L3_password_bytes, PASSWORD_BYTES_m13, L3_hash);  // generate SHA-256 hash of level 3 password bytes
	
	// check for level 1 access
	for (i = 0; i < PASSWORD_BYTES_m13; ++i)  // xor with level 3 password validation field
		putative_L1_password_bytes[i] = L3_hash[i] ^ universal_header->level_3_password_validation_field[i];
	
	SHA_hash_m13((ui1 *) putative_L1_password_bytes, PASSWORD_BYTES_m13, hash); // generate SHA-256 hash of putative level 1 password
	
	for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m13; ++i)  // compare with stored level 1 hash
		if (hash[i] != universal_header->level_1_password_validation_field[i])
			break;
	level_1_valid = FALSE_m13;
	if (i == PASSWORD_VALIDATION_FIELD_BYTES_m13) {  // Level 1 password recovered
		memcpy(saved_L1_password_bytes, putative_L1_password_bytes, PASSWORD_BYTES_m13);
		level_1_valid = TRUE_m13;
	}
	
	// check for level 2 password (may be same password for both levels)
	memcpy(putative_L2_password_bytes, putative_L1_password_bytes, PASSWORD_BYTES_m13);
	for (i = 0; i < PASSWORD_BYTES_m13; ++i)  // xor with level 2 password validation field
		putative_L1_password_bytes[i] = hash[i] ^ universal_header->level_2_password_validation_field[i];
	
	SHA_hash_m13((ui1 *) putative_L1_password_bytes, PASSWORD_BYTES_m13, hash); // generate SHA-256 hash of putative level 1 password
	
	for (i = 0; i < PASSWORD_VALIDATION_FIELD_BYTES_m13; ++i)  // compare with stored level 1 hash
		if (hash[i] != universal_header->level_1_password_validation_field[i])
			break;
	
	// Level 2 password valid
	if (i == PASSWORD_VALIDATION_FIELD_BYTES_m13) {
		STR_hex_m13(hex_str, (ui1 *) putative_L1_password_bytes, PASSWORD_BYTES_m13, "-", FALSE_m13);
		G_message_m13("Level 1 password (bytes): '%s' (%s)\n", putative_L1_password_bytes, hex_str);
		STR_hex_m13(hex_str, (ui1 *) putative_L2_password_bytes, PASSWORD_BYTES_m13, "-", FALSE_m13);
		G_message_m13("Level 2 password (bytes): '%s' (%s)\n", putative_L2_password_bytes, hex_str);
	} else if (level_1_valid == TRUE_m13) {
		STR_hex_m13(hex_str, (ui1 *) saved_L1_password_bytes, PASSWORD_BYTES_m13, "-", FALSE_m13);
		G_message_m13("Level 1 password (bytes): '%s' (%s)\n", saved_L1_password_bytes, hex_str);
		G_message_m13("No Level 2 password\n");
	} else {
		G_set_error_m13(E_UNKN_m13, "the level 3 password is not valid for recovery");
		return_m13(FALSE_m13);
	}
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_remove_behavior_exec_m13(const si1 *function, const si4 line, ui4 code)
{
	si4			n_behaviors;
	BEHAVIOR_m13		*behavior, *new_behaviors;
	BEHAVIOR_STACK_m13	*stack;
	

	// not ands to current behavior & pushes to stack as new entry
	
	stack = G_behavior_stack_m13();
	if (stack == NULL)
		return;
	
	// expand stack
	n_behaviors = stack->top_idx + 1;
	if (n_behaviors == stack->size) {
		n_behaviors += GLOBALS_BEHAVIOR_STACK_SIZE_INCREMENT_m13;
		new_behaviors = (BEHAVIOR_m13 *) realloc((void *) stack->behaviors, (size_t) n_behaviors * sizeof(BEHAVIOR_m13));
		if (new_behaviors == NULL) {
			G_set_error_m13(E_ALLOC_m13, NULL);
			return;
		}
		stack->behaviors = new_behaviors;
		stack->size = n_behaviors;
	}
	
	behavior = stack->behaviors + (++stack->top_idx);
	behavior->function = function;
	behavior->line = line;
	if (stack->top_idx)
		behavior->code = (behavior - 1)->code  & ~code;
	else
		behavior->code = globals_m13->behavior_stack_list->default_behavior & ~code;
	
	return;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_remove_recording_time_offset_m13(si8 *time, si8 recording_time_offset)
{
	if (*time != UUTC_NO_ENTRY_m13)
		*time += recording_time_offset;
	
	return;
}


tern  G_reset_metadata_for_update_m13(FPS_m13 *fps)
{
	TS_METADATA_SECTION_2_m13	*tmd2;
	VID_METADATA_SECTION_2_m13		*vmd2;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// section 2 fields
	switch (fps->uh->type_code) {
		case TS_METADATA_TYPE_CODE_m13:
			tmd2 = &fps->metadata->time_series_section_2;
			tmd2->number_of_samples = 0;
			tmd2->number_of_blocks = 0;
			tmd2->maximum_block_bytes = 0;
			tmd2->maximum_block_samples = 0;
			tmd2->maximum_block_keysample_bytes = 0;
			tmd2->maximum_block_duration = 0;
			tmd2->number_of_discontinuities = 0;
			tmd2->maximum_contiguous_blocks = 0;
			tmd2->maximum_contiguous_block_bytes = 0;
			tmd2->maximum_contiguous_samples = 0;
			break;
		case VID_METADATA_TYPE_CODE_m13:
			vmd2 = &fps->metadata->video_section_2;
			vmd2->number_of_frames = 0;
			vmd2->number_of_clips = 0;
			vmd2->maximum_clip_bytes = 0;
			vmd2->maximum_clip_frames = 0;
			vmd2->number_of_video_files = 0;
			vmd2->maximum_clip_duration = 0.0;
			vmd2->number_of_discontinuities = 0;
			vmd2->maximum_contiguous_clips = 0;
			vmd2->maximum_contiguous_clip_bytes = 0;
			vmd2->maximum_contiguous_frames = 0;
			break;
		default:
			G_set_error_m13(E_MED_m13, "unrecognized metadata type in file \"%s\"", fps->path);
			break;
	}
	
	return_m13(TRUE_m13);
}


si8 G_sample_number_for_uutc_m13(LH_m13 *lh, si8 target_uutc, ui4 mode, ...)  // varargs: si8 ref_sample_number, si8 ref_uutc, sf8 sampling_frequency
{
	tern			terminal_index;
	si1			tmp_str[PATH_BYTES_m13], num_str[FILE_NUMBERING_DIGITS_m13 + 1];
	si4			seg_num, seg_idx;
	si8			n_inds, i, absolute_numbering_offset;
	si8			ref_sample_number, ref_uutc, test_time;
	sf8			tmp_sf8, sampling_frequency, rounded_samp_num, samp_num_eps;
	ui4			mask;
	va_list			v_args;
	PROC_GLOBS_m13		*proc_globs;
	TS_IDX_m13		*tsi;
	SEG_m13			*seg;
	CHAN_m13		*chan;
	SESS_m13		*sess;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// G_sample_number_for_uutc_m13(NULL, si8 target_uutc, ui4 mode, si8 ref_index, si8 ref_uutc, sf8 sampling_frequency);
	// returns sample number extrapolated from ref_index (relative / absolute is determined by magnitude of reference values)
	
	// G_sample_number_for_uutc_m13(seg, target_uutc, mode);
	// returns sample number extrapolated from closest time series index in reference frame specified by mode
	
	// mode FIND_ABSOLUTE_m13 (default): session (or reference) relative sample numbering
	// mode FIND_RELATIVE_m13: segment relative sample numbering
	// mode FIND_CURRENT_m13 (default): sample period within which the target_uutc falls
	// mode FIND_CLOSEST_m13: sample number closest to the target_uutc
	// mode FIND_NEXT_m13: sample number following the sample period within which the target_uutc falls ( == FIND_CURRENT_m13 + 1)
	// mode FIND_PREVIOUS_m13: sample number preceding the sample period within which the target_uutc falls ( == FIND_CURRENT_m13 - 1)

	if (lh == NULL) {  // reference points passed
		va_start(v_args, mode);
		ref_sample_number = va_arg(v_args, si8);
		ref_uutc = va_arg(v_args, si8);
		sampling_frequency = va_arg(v_args, sf8);
		va_end(v_args);
		absolute_numbering_offset = 0;
		tsi = NULL;
	} else {  // level header passed
		proc_globs = G_proc_globs_m13(lh);
		switch (lh->type_code) {
			case TS_SEG_TYPE_CODE_m13:
				seg = (SEG_m13 *) lh;
				break;
			case TS_CHAN_TYPE_CODE_m13:
			case SESS_TYPE_CODE_m13:
				seg_num = G_segment_for_uutc_m13(lh, target_uutc);
				seg_idx = G_segment_index_m13(seg_num, lh);
				if (seg_idx == FALSE_m13)
					return_m13(SAMPLE_NUMBER_NO_ENTRY_m13);
				if (lh->type_code == TS_CHAN_TYPE_CODE_m13) {
					chan = (CHAN_m13 *) lh;
				} else {  // SESS_m13
					chan = proc_globs->current_session.index_channel;
					if (chan->type_code != TS_CHAN_TYPE_CODE_m13) {
						sess = (SESS_m13 *) lh;
						chan = sess->ts_chans[0];
					}
				}
				seg = chan->segs[seg_idx];
				break;
			case VID_CHAN_TYPE_CODE_m13:
			case VID_SEG_TYPE_CODE_m13:
				return_m13(G_frame_number_for_uutc_m13(lh, target_uutc, mode));
			default:
				G_set_error_m13(E_UNKN_m13, "invalid level type");
				return_m13(SAMPLE_NUMBER_NO_ENTRY_m13);
		}
		
		if (seg == NULL) {  // channel or session
			STR_fixed_width_int_m13(num_str, FILE_NUMBERING_DIGITS_m13, seg_num);
			sprintf_m13(tmp_str, "%s/%s_s%s.%s", chan->path, chan->name, num_str, TS_SEG_TYPE_STR_m13);
			seg = chan->segs[seg_idx] = G_open_segment_m13(NULL, NULL, tmp_str, (LH_m13 *) chan, chan->flags, NULL);
			if (seg == NULL)
				return_m13(SAMPLE_NUMBER_NO_ENTRY_m13);
		}

		tsi = seg->ts_inds_fps->ts_inds;
		if (tsi == NULL)
			return_m13(SAMPLE_NUMBER_NO_ENTRY_m13);
		n_inds = seg->ts_inds_fps->uh->n_entries;
		if (seg->ts_inds_fps->uh->segment_end_time > 0) {
			--n_inds;  // account for terminal index here - cleaner code below
			terminal_index = TRUE_m13;
		} else {
			terminal_index = FALSE_m13;
		}
		if (mode & FIND_RELATIVE_m13)
			absolute_numbering_offset = 0;
		else  // FIND_ABSOLUTE_m13 (default)
			absolute_numbering_offset = seg->metadata_fps->metadata->time_series_section_2.session_start_sample_number;
		
		// condition target
		if (target_uutc < 0)  // relative time
			target_uutc = proc_globs->current_session.start_time - target_uutc;
		test_time = target_uutc - proc_globs->time_constants.recording_time_offset;
		if (test_time > 0 && target_uutc != END_OF_TIME_m13)  // END_OF_TIME_m13 is not offset
			target_uutc = test_time;

		// get index
		i = G_find_index_m13(seg, target_uutc, TIME_SEARCH_m13);
		if (i == -1)  // target time earlier than segment start => return segment start sample
			return_m13(absolute_numbering_offset);

		tsi += i;
		if (i == n_inds) {  // target time later than segment end => return segment end sample number
			--tsi;
			if (terminal_index == TRUE_m13)
				return_m13((tsi->start_samp_num - 1) + absolute_numbering_offset);
		}
		ref_sample_number = tsi->start_samp_num;
		ref_uutc = tsi->start_time;
		if (terminal_index == FALSE_m13 && i == n_inds) {
			sampling_frequency = seg->metadata_fps->metadata->time_series_section_2.sampling_frequency / (sf8) 1e6;
		} else {
			++tsi;
			sampling_frequency = (sf8) (tsi->start_samp_num - ref_sample_number) / (sf8) (tsi->start_time - ref_uutc);  // samples per microsecond
		}
	}
	
	// round up if very close to next sample
	tmp_sf8 = (sf8) (target_uutc - ref_uutc) * sampling_frequency;
	rounded_samp_num = (sf8) ((si8) (tmp_sf8 + (sf8) 0.5));
	samp_num_eps = rounded_samp_num - tmp_sf8;
	if (samp_num_eps > (sf8) 0.0)
		if (samp_num_eps < SAMPLE_NUMBER_EPS_m13)
			tmp_sf8 = rounded_samp_num;
	
	mask = (ui4) (FIND_CLOSEST_m13 | FIND_NEXT_m13 | FIND_CURRENT_m13 | FIND_PREVIOUS_m13);
	switch (mode & mask) {
		case FIND_CLOSEST_m13:
			tmp_sf8 += (sf8) 0.5;
			break;
		case FIND_NEXT_m13:
			tmp_sf8 += (sf8) 1.0;
			break;
		case FIND_PREVIOUS_m13:
			if (tmp_sf8 >= (sf8) 1.0)
				tmp_sf8 -= (sf8) 1.0;
			break;
		case FIND_CURRENT_m13:
		default:
			break;
	}

	return_m13(ref_sample_number + (si8) tmp_sf8 + absolute_numbering_offset);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	G_search_mode_m13(SLICE_m13 *slice)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// time takes priority
	if (slice->start_time != UUTC_NO_ENTRY_m13 && slice->end_time != UUTC_NO_ENTRY_m13)
		return_m13(TIME_SEARCH_m13);
	
	if (slice->start_samp_num != SAMPLE_NUMBER_NO_ENTRY_m13 && slice->end_samp_num != SAMPLE_NUMBER_NO_ENTRY_m13)
		return_m13(SAMPLE_SEARCH_m13);
	
	G_set_error_m13(E_UNKN_m13, "no valid limit pair");
	
	return_m13(FALSE_m13);
}


si4	G_search_Sgmt_records_m13(Sgmt_REC_m13 *Sgmt_records, SLICE_m13 *slice, ui4 search_mode)
{
	si1				seg_name[SEG_NAME_BYTES_m13], md_file[PATH_BYTES_m13], num_str[FILE_NUMBERING_DIGITS_m13 + 1];
	si4				i, idx, low_idx, high_idx;
	si8				target;
	PROC_GLOBS_m13			*proc_globs;
	TS_METADATA_SECTION_2_m13	*md2;
	CHAN_m13			*chan;
	FPS_m13				*md_fps;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Note: this may seem like overkill, that a simple forward linear search would suffice,
	// but in theory there can be a large number of non-uniformly spaced segments.
	
	proc_globs = G_proc_globs_m13(NULL);  // use proc_globs from current thread
	
	if (search_mode == TIME_SEARCH_m13) {
		// start segment
		target = slice->start_time;
		low_idx = 0;
		high_idx = proc_globs->current_session.n_segments - 1;
		if (target > Sgmt_records[high_idx].end_time) {
			slice->start_seg_num = SEGMENT_NUMBER_NO_ENTRY_m13;
			G_warning_message_m13("%s(): requested start time is after session end\n", __FUNCTION__);
			idx = 0;
		} else {
			if (target < Sgmt_records[0].start_time) {
				idx = 0;
			} else {
				do {  // binary search
					idx = (low_idx + high_idx) >> 1;
					if (Sgmt_records[idx].start_time > target)
						high_idx = idx;
					else
						low_idx = idx;
				} while ((high_idx - low_idx) > 1);
				if (target > Sgmt_records[low_idx].end_time)
				  idx = high_idx;
				else if (target < Sgmt_records[high_idx].start_time)
				  idx = low_idx;
			}
			slice->start_seg_num = idx + 1;
		}
		
		// end segment
		target = slice->end_time;
		low_idx = idx;
		high_idx = proc_globs->current_session.n_segments - 1;
		if (target < Sgmt_records[low_idx].start_time) {
			slice->end_seg_num = SEGMENT_NUMBER_NO_ENTRY_m13;
			G_warning_message_m13("%s(): requested end time precedes requested start time\n", __FUNCTION__);
		} else {
			if (target >= Sgmt_records[high_idx].end_time) {
				idx = high_idx;
			} else {
				do {  // binary search
					idx = (low_idx + high_idx) >> 1;
					if (Sgmt_records[idx].start_time > target)
						high_idx = idx;
					else
						low_idx = idx;
				} while ((high_idx - low_idx) > 1);
				if (target > Sgmt_records[low_idx].end_time)
				  idx = high_idx;
				else if (target < Sgmt_records[high_idx].start_time)
				  idx = low_idx;
			}
			slice->end_seg_num = idx + 1;
		}
	}
	else {  // search_mode == SAMPLE_SEARCH_m13
		
		// sample search required, but no sample data in Sgmt_records => fill it in (e.g from session records in variable frequency session)
		if (Sgmt_records[0].start_samp_num == SAMPLE_NUMBER_NO_ENTRY_m13) {
			chan = proc_globs->current_session.index_channel;
			for (i = 0; i < proc_globs->current_session.n_segments; ++i) {
				STR_fixed_width_int_m13(num_str, FILE_NUMBERING_DIGITS_m13, Sgmt_records[i].seg_num);
				sprintf_m13(seg_name, "%s_s%s", chan->name, num_str);
				sprintf_m13(md_file, "%s/%s.%s/%s.%s", chan->path, seg_name, TS_SEG_TYPE_STR_m13, seg_name, TS_METADATA_TYPE_STR_m13);
				md_fps = FPS_read_m13(NULL, 0, FPS_FULL_FILE_m13, 1, NULL, md_file, "r", NULL, NULL);
				if (md_fps == NULL)
					continue;
				md2 = &md_fps->metadata->time_series_section_2;
				Sgmt_records[i].end_samp_num = Sgmt_records[i].start_samp_num = md2->session_start_sample_number;
				Sgmt_records[i].end_samp_num += (md2->number_of_samples - 1);
				FPS_free_m13(&md_fps);
			}
		}

		// start segment
		target = slice->start_samp_num;
		low_idx = 0;
		high_idx = proc_globs->current_session.n_segments - 1;
		if (target > Sgmt_records[high_idx].end_samp_num) {
			slice->start_seg_num = SEGMENT_NUMBER_NO_ENTRY_m13;
			G_warning_message_m13("%s(): requested start sample is after session end\n", __FUNCTION__);
			idx = 0;
		} else {
			if (target < Sgmt_records[0].start_samp_num) {
				idx = 0;
			} else {
				do {  // binary search
					idx = (low_idx + high_idx) >> 1;
					if (Sgmt_records[idx].start_samp_num > target)
						high_idx = idx;
					else
						low_idx = idx;
				} while ((high_idx - low_idx) > 1);
				if (target > Sgmt_records[low_idx].end_samp_num)
				  idx = high_idx;
				else if (target < Sgmt_records[high_idx].start_samp_num)
				  idx = low_idx;
			}
			slice->start_seg_num = idx + 1;
		}
		
		// end segment
		target = slice->end_samp_num;
		low_idx = idx;
		high_idx = proc_globs->current_session.n_segments - 1;
		if (target < Sgmt_records[low_idx].start_samp_num) {
			slice->end_seg_num = SEGMENT_NUMBER_NO_ENTRY_m13;
			G_warning_message_m13("%s(): requested end sample precedes requested start sample\n", __FUNCTION__);
		} else {
			if (target >= Sgmt_records[high_idx].end_samp_num) {
				idx = high_idx;
			} else {
				do {  // binary search
					idx = (low_idx + high_idx) >> 1;
					if (Sgmt_records[idx].start_samp_num > target)
						high_idx = idx;
					else
						low_idx = idx;
				} while ((high_idx - low_idx) > 1);
				if (target > Sgmt_records[low_idx].end_samp_num)
				  idx = high_idx;
				else if (target < Sgmt_records[high_idx].start_samp_num)
				  idx = low_idx;
			}
			slice->end_seg_num = idx + 1;
		}
	}

	// return number of segments
	if (slice->start_seg_num == SEGMENT_NUMBER_NO_ENTRY_m13 || slice->end_seg_num == SEGMENT_NUMBER_NO_ENTRY_m13)
		return_m13(0);
	else
		return_m13(SLICE_SEG_COUNT_m13(slice));
}

		
si4	G_segment_for_frame_number_m13(LH_m13 *lh, si8 target_frame)
{
	si4			idx, low_idx, high_idx;
	PROC_GLOBS_m13	*proc_globs;
	Sgmt_REC_m13		*Sgmt_records;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Note: this may seem like overkill, that a simple forward linear search would suffice,
	// but in theory there can be a large number of non-uniformly spaced segments.
	
	proc_globs = G_proc_globs_m13(lh);
	
	switch (lh->type_code) {
		case TS_CHAN_TYPE_CODE_m13:
			return_m13(G_segment_for_sample_number_m13(lh, target_frame));
			break;
		case VID_CHAN_TYPE_CODE_m13:
		case SESS_TYPE_CODE_m13:
			Sgmt_records = G_Sgmt_records_m13(lh, FRAME_SEARCH_m13);
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "invalid level type");
			return_m13(SEGMENT_NUMBER_NO_ENTRY_m13);
	}

	low_idx = 0;
	high_idx = proc_globs->current_session.n_segments - 1;
	if (target_frame <= Sgmt_records[0].start_frame_num)
		return_m13(1);  // return first segment if requested frame number <= session start
	if (target_frame >= Sgmt_records[high_idx].end_frame_num)
		return_m13(high_idx + 1);  // return last segment if requested frame number <= session start
		
	do {  // binary search
		idx = (low_idx + high_idx) >> 1;
		if (Sgmt_records[idx].start_frame_num > target_frame)
			high_idx = idx;
		else
			low_idx = idx;
	} while ((high_idx - low_idx) > 1);
	
	if (target_frame > Sgmt_records[low_idx].end_frame_num)
	  idx = high_idx;
	else if (target_frame < Sgmt_records[high_idx].start_frame_num)
	  idx = low_idx;

	return_m13(idx + 1);
}


si4	G_segment_for_path_m13(si1 *path)
{
	tern	video_data;
	si1	*c, name[VID_NAME_BYTES_m13];
	ui4	level_code, type_code;
	si4	seg_num;
	si8	len;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	level_code = G_level_m13(path, &type_code);
	video_data = FALSE_m13;
	switch (type_code) {
		case REC_INDS_TYPE_CODE_m13:
		case REC_DATA_TYPE_CODE_m13:
			switch (level_code) {
				case VID_CHAN_TYPE_CODE_m13:
				case TS_CHAN_TYPE_CODE_m13:
				case SESS_TYPE_CODE_m13:
					return_m13((si4) FALSE_m13);
				case SSR_TYPE_CODE_m13:
				case TS_SEG_TYPE_CODE_m13:
				case VID_SEG_TYPE_CODE_m13:
					break;
			}
			break;
		case TS_METADATA_TYPE_CODE_m13:
		case TS_DATA_TYPE_CODE_m13:
		case TS_INDS_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
			break;
		case VID_DATA_TYPE_CODE_m13:
			video_data = TRUE_m13;
			break;
	}

	G_path_parts_m13(path, NULL, name, NULL);
	len = strlen(name);
	if (video_data == TRUE_m13)
		c = name + len - 10;
	else
		c = name + len - 4;
	
	seg_num = (si4) strtol(c, NULL, 10);

	return_m13(seg_num);
}


si4	G_segment_for_sample_number_m13(LH_m13 *lh, si8 target_sample)
{
	si4			idx, low_idx, high_idx;
	PROC_GLOBS_m13	*proc_globs;
	Sgmt_REC_m13		*Sgmt_records;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Note: this may seem like overkill, that a simple forward linear search would suffice,
	// but in theory there can be a large number of non-uniformly spaced segments.
	
	proc_globs = G_proc_globs_m13(lh);
	
	switch (lh->type_code) {
		case VID_CHAN_TYPE_CODE_m13:
			return_m13(G_segment_for_frame_number_m13(lh, target_sample));
			break;
		case TS_CHAN_TYPE_CODE_m13:
		case SESS_TYPE_CODE_m13:
			Sgmt_records = G_Sgmt_records_m13(lh, SAMPLE_SEARCH_m13);
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "invalid level type");
			return_m13(SEGMENT_NUMBER_NO_ENTRY_m13);
	}
	
	low_idx = 0;
	high_idx = proc_globs->current_session.n_segments - 1;
	if (target_sample <= Sgmt_records[0].start_samp_num)
		return_m13(1);  // return first segment if requested sample number <= session start
	if (target_sample >= Sgmt_records[high_idx].end_samp_num)
		return_m13(high_idx + 1);  // return last segment if requested sample number >= session end
		
	do {  // binary search
		idx = (low_idx + high_idx) >> 1;
		if (Sgmt_records[idx].start_samp_num > target_sample)
			high_idx = idx;
		else
			low_idx = idx;
	} while ((high_idx - low_idx) > 1);
	
	if (target_sample > Sgmt_records[low_idx].end_samp_num)
	  idx = high_idx;
	else if (target_sample < Sgmt_records[high_idx].start_samp_num)
	  idx = low_idx;

	return_m13(idx + 1);
}

		
si4	G_segment_for_uutc_m13(LH_m13 *lh, si8 target_time)
{
	si4			idx, low_idx, high_idx;
	PROC_GLOBS_m13	*proc_globs;
	Sgmt_REC_m13		*Sgmt_records;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Note: this may seem like overkill, that a simple forward linear search would suffice,
	// but in theory there can be a large number of non-uniformly spaced segments.
	
	proc_globs = G_proc_globs_m13(lh);
	
	switch (lh->type_code) {
		case VID_CHAN_TYPE_CODE_m13:
		case TS_CHAN_TYPE_CODE_m13:
		case SESS_TYPE_CODE_m13:
			Sgmt_records = G_Sgmt_records_m13(lh, TIME_SEARCH_m13);
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "invalid level type");
			return_m13(SEGMENT_NUMBER_NO_ENTRY_m13);
	}
	
	low_idx = 0;
	high_idx = proc_globs->current_session.n_segments - 1;
	if (target_time <= Sgmt_records[0].start_time)
		return_m13(1);  // return first segment if requested time <= session start
	if (target_time >= Sgmt_records[high_idx].end_time)
		return_m13(high_idx + 1); // return last segment if requested time >= session end
		
	do {  // binary search
		idx = (low_idx + high_idx) >> 1;
		if (Sgmt_records[idx].start_time > target_time)
			high_idx = idx;
		else
			low_idx = idx;
	} while ((high_idx - low_idx) > 1);
	
	if (target_time > Sgmt_records[low_idx].end_time)
	  idx = high_idx;
	else if (target_time < Sgmt_records[high_idx].start_time)
	  idx = low_idx;

	return_m13(idx + 1);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	G_segment_index_m13(si4 segment_number, LH_m13 *lh)
{
	si4		i, mapped_segs, sess_segs, first_seg, seg_idx;
	PROC_GLOBS_m13	*proc_globs;
	CHAN_m13	*chan;
	SEG_m13		*seg;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns offset of segment_number into segments array
	// FIRST_OPEN_SEG_m13 returns the first open segment in the reference channel
	// pass NULL for level header to get main process proc_globs
	// returns FALSE_m13 on error
	
	proc_globs = G_proc_globs_m13(lh);

	mapped_segs = proc_globs->current_session.n_mapped_segments;
	if (mapped_segs == 0) {
		G_set_error_m13(E_UNKN_m13, "no mapped segments");
		return_m13((si4) FALSE_m13);
	}

	if (segment_number == FIRST_OPEN_SEG_m13 || segment_number == SEGMENT_NUMBER_NO_ENTRY_m13) {
		chan = proc_globs->current_session.index_channel;
		if (chan == NULL) {
			G_set_error_m13(E_UNKN_m13, "reference channel not set");
			return_m13((si4) FALSE_m13);
		}
		for (i = 0; i < mapped_segs; ++i) {
			seg = chan->segs[i];
			if (seg)
				break;
					
		}
		if (i == mapped_segs) {
			G_set_error_m13(E_UNKN_m13, "no open segments");
			return_m13((si4) FALSE_m13);
		}
		if (segment_number == SEGMENT_NUMBER_NO_ENTRY_m13)
			G_warning_message_m13("%s(): segment not specified => returning first open segment from reference channel\n", __FUNCTION__);
		return_m13(i);
	}
	
	sess_segs = proc_globs->current_session.n_segments;
	
	// all segments mapped
	if (mapped_segs == sess_segs) {
		if (segment_number >= 1 && segment_number <= mapped_segs) {
			return_m13(segment_number - 1);
		} else {
			G_set_error_m13(E_UNKN_m13, "invalid segment number");
			return_m13((si4) FALSE_m13);
		}
	}
	
	// slice segments mapped
	first_seg = proc_globs->current_session.first_mapped_segment_number;
	seg_idx = segment_number - first_seg;
	if (seg_idx < 0 || seg_idx >= mapped_segs) {
		G_set_error_m13(E_UNKN_m13, "unmapped segment");
		return_m13((si4) FALSE_m13);
	}
	
	return_m13(seg_idx);
}


si4 G_segment_range_m13(LH_m13 *lh, SLICE_m13 *slice)
{
	si4			search_mode, n_segs;
	si8			start_time, end_time, last_seg_idx;
	PROC_GLOBS_m13		*proc_globs;
	Sgmt_REC_m13		*Sgmt_records;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// returns UNKNOWN_m13 on failure

	// reset slice seg fields
	if (slice->conditioned == FALSE_m13)
		G_condition_slice_m13(slice, lh);
	slice->start_seg_num = slice->end_seg_num = SEGMENT_NUMBER_NO_ENTRY_m13;
	slice->n_segs = UNKNOWN_m13;

	// check for valid limit pair (time takes priority if all parameters set)
	if ((search_mode = G_search_mode_m13(slice)) == FALSE_m13)
		return_m13(0);
	
	// get Sgmt records array
	Sgmt_records = G_Sgmt_records_m13(lh, search_mode);
	if (Sgmt_records == NULL)
		return_m13(0);
	
	// search Sgmt_records array
	n_segs = G_search_Sgmt_records_m13(Sgmt_records, slice, search_mode);
	
	// set process globals
	proc_globs = G_proc_globs_m13(lh);
	if (n_segs) {
		slice->n_segs = n_segs;
		if (lh->flags & LH_MAP_ALL_SEGS_m13) {
			proc_globs->current_session.n_mapped_segments = proc_globs->current_session.n_segments;
			proc_globs->current_session.first_mapped_segment_number = 1;
		} else {
			proc_globs->current_session.n_mapped_segments = n_segs;
			proc_globs->current_session.first_mapped_segment_number = slice->start_seg_num;
		}
	} else {
		slice->n_segs = UNKNOWN_m13;
		proc_globs->current_session.n_mapped_segments = 0;
		proc_globs->current_session.first_mapped_segment_number = SEGMENT_NUMBER_NO_ENTRY_m13;  // 0
	}

	start_time = Sgmt_records->start_time;
	if (slice->start_time == BEGINNING_OF_TIME_m13)
		slice->start_time = start_time;
	if (slice->start_time == start_time)
		slice->start_samp_num = Sgmt_records[0].start_samp_num;
	last_seg_idx = proc_globs->current_session.n_segments - 1;
	end_time = Sgmt_records[last_seg_idx].end_time;
	if (slice->end_time == END_OF_TIME_m13)
		slice->end_time = end_time;
	if (slice->end_time == end_time)
		slice->end_samp_num = Sgmt_records[last_seg_idx].end_samp_num;

	return_m13(n_segs);
}


ui4	*G_segment_video_start_frames_m13(FPS_m13 *vid_inds_fps, ui4 *n_video_files)
{
	ui4			j, *start_frames, local_n_video_files;
	si8			i, n_inds;
	VID_IDX_m13		*vidx;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// NOTE: start frame numbers are inserted into array at their video file number offset, so array can be used as start_frames[vidx->video_file_number], rather than subtracting 1
	// So start_frames[0] == start_frames[1] == 0
	// pass NULL for n_video_files if you don't need the value
	// to get global frame numbers add segment metadata session_start_frame_number to these numbers
	
	if (n_video_files == NULL)
		n_video_files = &local_n_video_files;
	vidx = vid_inds_fps->vid_inds;
	n_inds = vid_inds_fps->uh->n_entries - 1;
	*n_video_files = vidx[n_inds].vid_file_num - 1;  // terminal index video file number is number of imaginary next file
	start_frames = (ui4 *) calloc_m13((size_t) (*n_video_files + 1), sizeof(ui4));  // indexing from 1
	if (start_frames == NULL)
		return_m13(NULL);
	
	for (i = n_inds, j = 1; i--; ++vidx)
		if (vidx->vid_file_num == j)
			start_frames[j++] = vidx->start_frame_num;
			
	return_m13(start_frames);
}


tern  G_sendgrid_email_m13(si1 *sendgrid_key, si1 *to_email, si1 *cc_email, si1 *to_name, si1 *subject, si1 *content, si1 *from_email, si1 *from_name, si1 *reply_to_email, si1 *reply_to_name)
{
	tern	exclude_cc;
	si1 	command[2048], escaped_content[2048];
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (STR_empty_m13(sendgrid_key) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "key is empty");
		return_m13(FALSE_m13);
	}
	if (STR_empty_m13(to_email) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "to_email is empty");
		return_m13(FALSE_m13);
	}
	exclude_cc = STR_empty_m13(cc_email);
	if (to_name == NULL)
		to_name = "";
	if (subject == NULL)
		subject = "";
	if (content == NULL)
		content = "";
	if (*content)
		STR_re_escape_m13(content, escaped_content);
	else
		content = " ";  // sendgrid requires at least one character
	if (from_email == NULL)
		from_email = "";
	if (from_name == NULL)
		from_name = "";
	if (reply_to_email == NULL)
		reply_to_email = "";
	if (reply_to_name == NULL)
		reply_to_name = "";


#if defined MACOS_m13 || defined LINUX_m13
	if (exclude_cc == TRUE_m13)
		sprintf(command, "/usr/bin/curl --connect-timeout 5.0 --request POST --url https://api.sendgrid.com/v3/mail/send --header 'authorization: Bearer %s' --header 'content-type: application/json' --data '{\"personalizations\":[{\"to\": [{\"email\": \"%s\", \"name\": \"%s\"}], \"subject\": \"%s\"}], \"content\": [{\"type\": \"text/plain\", \"value\": \"%s\"}], \"from\": {\"email\": \"%s\", \"name\": \"%s\"}, \"reply_to\": {\"email\": \"%s\", \"name\": \"%s\"}}' > %s 2>&1", sendgrid_key, to_email, to_name, subject, escaped_content, from_email, from_name, reply_to_email, reply_to_name, NULL_DEVICE_m13);
	else
		sprintf(command, "/usr/bin/curl --connect-timeout 5.0 --request POST --url https://api.sendgrid.com/v3/mail/send --header 'authorization: Bearer %s' --header 'content-type: application/json' --data '{\"personalizations\":[{\"to\": [{\"email\": \"%s\", \"name\": \"%s\"}], \"cc\": [{\"email\": \"%s\"}], \"subject\": \"%s\"}], \"content\": [{\"type\": \"text/plain\", \"value\": \"%s\"}], \"from\": {\"email\": \"%s\", \"name\": \"%s\"}, \"reply_to\": {\"email\": \"%s\", \"name\": \"%s\"}}' > %s 2>&1", sendgrid_key, to_email, to_name, cc_email, subject, escaped_content, from_email, from_name, reply_to_email, reply_to_name, NULL_DEVICE_m13);
	system(command);
#endif
	
#ifdef WINDOWS_m13
	if (exclude_cc == TRUE_m13)
		sprintf(command, "curl.exe --connect-timeout 5.0 --request POST --url https://api.sendgrid.com/v3/mail/send --header \"authorization: Bearer %s\" --header \"content-type: application/json\" --data \"{\\\"personalizations\\\":[{\\\"to\\\": [{\\\"email\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\"}], \\\"subject\\\": \\\"%s\\\"}], \\\"content\\\": [{\\\"type\\\": \\\"text/plain\\\", \\\"value\\\": \\\"%s\\\"}], \\\"from\\\": {\\\"email\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\"}, \\\"reply_to\\\": {\\\"email\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\"}}\" > %s 2>&1", sendgrid_key, to_email, to_name, subject, escaped_content, from_email, from_name, reply_to_email, reply_to_name, NULL_DEVICE_m13);
	else
		sprintf(command, "curl.exe --connect-timeout 5.0 --request POST --url https://api.sendgrid.com/v3/mail/send --header \"authorization: Bearer %s\" --header \"content-type: application/json\" --data \"{\\\"personalizations\\\":[{\\\"to\\\": [{\\\"email\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\"}], \\\"cc\\\": [{\\\"email\\\": \\\"%s\\\"}], \\\"subject\\\": \\\"%s\\\"}], \\\"content\\\": [{\\\"type\\\": \\\"text/plain\\\", \\\"value\\\": \\\"%s\\\"}], \\\"from\\\": {\\\"email\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\"}, \\\"reply_to\\\": {\\\"email\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\"}}\" > %s 2>&1", sendgrid_key, to_email, to_name, cc_email, subject, escaped_content, from_email, from_name, reply_to_email, reply_to_name, NULL_DEVICE_m13);
	WN_system_m13(command);
#endif

	return_m13(TRUE_m13);
}


tern	G_session_directory_m13(FPS_m13 *fps)
{
	si1		*pg_sess_dir;
	PROC_GLOBS_m13	*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// fills in proc_globs session directory info
	// if universal header name differs from file system name,
	// the name difference will be registered in the proc_globals
	
	if (fps == NULL) {
		G_set_error_m13(E_UNKN_m13, "FPS is null");
		return_m13(FALSE_m13);
	}
	if (STR_empty_m13(fps->path) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "FPS path is empty");
		return_m13(FALSE_m13);
	}

	proc_globs = G_proc_globs_m13((LH_m13 *) fps);

	// set session path & names
	pg_sess_dir = proc_globs->current_session.directory;
	G_session_path_for_path_m13(fps->path, pg_sess_dir);
	G_path_parts_m13(pg_sess_dir, NULL, proc_globs->current_session.fs_name, NULL);  // set proc_globs fs_name
	strcpy(proc_globs->current_session.uh_name, fps->uh->session_name);

	// check for fs / uh name mismatch
	if (strcmp_m13(proc_globs->current_session.fs_name, proc_globs->current_session.uh_name))
		proc_globs->current_session.names_differ = TRUE_m13;
	else
		proc_globs->current_session.names_differ = FALSE_m13;

	// set other proc_globs
	proc_globs->current_session.UID = fps->uh->session_UID;
	proc_globs->current_session.start_time = fps->uh->session_start_time;

	
	return_m13(TRUE_m13);
}


si1	*G_session_path_for_path_m13(si1 *path, si1 *sess_path)
{
	si1		tmp_path[PATH_BYTES_m13];
	EXT_CODE_m13	type;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// can be done in place
	
	if (sess_path == NULL)  // call responsible for freeing
		sess_path = (si1 *) calloc_m13((size_t) PATH_BYTES_m13, sizeof(si1));

	G_full_path_m13(path, sess_path);
	G_path_parts_m13(sess_path, tmp_path, NULL, type.ext);
	while (type.code != SESS_TYPE_CODE_m13) {
		strcpy(sess_path, tmp_path);
		G_path_parts_m13(sess_path, tmp_path, NULL, type.ext);
	}
					 
	return_m13(sess_path);
}


si8	G_session_samples_m13(LH_m13 *lh, sf8 rate)
{
	si4			i;
	sf4			sf4_rate;
	si8			n_samps;
	PROC_GLOBS_m13		*proc_globs;
	Sgmt_RECS_LIST_m13	*list;
	Sgmt_RECS_ENTRY_m13 	*rec_entry;
	Sgmt_REC_m13		*Sgmt_rec;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	proc_globs = G_proc_globs_m13(lh);
	list = proc_globs->current_session.Sgmt_recs_list;
	
	// search for matching entry
	pthread_mutex_lock_m13(&list->mutex);
	rec_entry = list->entries;
	sf4_rate = (sf4) rate;
	for (i = list->top_idx + 1; i--; ++rec_entry) {
		Sgmt_rec = (Sgmt_REC_m13 *) rec_entry->Sgmt_recs;
		if (Sgmt_rec->rate == sf4_rate)
			break;
	}
	
	if (i == -1)
		n_samps = SAMPLE_NUMBER_NO_ENTRY_m13;
	else
		n_samps = rec_entry->n_session_samples;

	pthread_mutex_unlock_m13(&list->mutex);
	
	return_m13(n_samps);
}


void	G_set_error_exec_m13(const si1 *function, si4 line, si4 code, si1 *message, ...)
{
	tern			exit_on_fail;
	ERR_m13			*err;
	PROC_GLOBS_m13		*proc_globs;
	pid_t_m13		_id;
	pthread_t_m13		thread;
	

	// Call set_error for causal errors only.
	// Return error local error condition for errors returned from functions, no messages necessary
	

	// no error specified in code or message
	if (code == E_NONE_m13)
		if (STR_empty_m13(message) == TRUE_m13)
			return;
	
	// get behavior
	exit_on_fail = (G_current_behavior_m13() & RETURN_ON_FAIL_m13) ? FALSE_m13 : TRUE_m13;
	_id = gettid_m13();

	// get mutex
	err = &globals_m13->error;
	pthread_mutex_lock_m13(&err->mutex);
	
	// error already set
	if (err->code) {  // != E_NONE_m13
		pthread_mutex_unlock_m13(&err->mutex);
		if (_id != globals_m13->main_id) {  // main process always proceeds to exit
			if (exit_on_fail == TRUE_m13) {  // kill thread
				thread = PROC_thread_for_id_m13(0);  // zero gets current thread
				pthread_kill_m13(thread, 0);  // zero kills without signal
			}
		}
		return;
	}
	
	// set error
	proc_globs = G_proc_globs_m13(NULL);  // use thread ID
	proc_globs->miscellaneous.proc_error_state = TRUE_m13;  // set process globals error_state (for void functions)

	// message
	if (STR_empty_m13(message) == TRUE_m13) {
		if (code >= E_NONE_m13 && code < E_NUM_CODES_m13)  // use table message
			strcpy_m13(err->message, globals_m13->tables->E_strings_table[code]);
		else  // unspecified message, custom code
			strcpy_m13(err->message, globals_m13->tables->E_strings_table[E_UNKN_m13]);
	} else {
		va_list		v_args;

		va_start(v_args, message);
		vsnprintf_m13(err->message, E_MESSAGE_LEN_m13, message, v_args);
		va_end(v_args);
		
		if (code == E_NONE_m13)  // caller passed an error message, but did not set code
			code = E_UNKN_m13;
	}

	// error parameters
	err->code = code;
	err->line = line;
	err->function = function;
	pthread_getname_m13(0, err->thread_name, (size_t) PROC_THREAD_NAME_LEN_DEFAULT_m13);
	err->thread_id = _id;
	
	// release mutex
	pthread_mutex_unlock_m13(&err->mutex);
	
	// exit
	if (exit_on_fail == TRUE_m13)
		exit_m13((si4) code);

	return;
}


tern	G_set_session_globals_m13(si1 *MED_path, si1 *password, LH_m13 *lh)
{
	si1			md_file[PATH_BYTES_m13];
	FPS_m13			*fps;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// finds & reads a metadata file to set session globals
	// call this function as soon as a a MED path +/- a level is/are available
	
	// find metadata file from path
	if (G_find_metadata_file_m13(MED_path, md_file) == NULL)
		return_m13(FALSE_m13);

	fps = FPS_read_m13(NULL, 0, METADATA_BYTES_m13, 1, NULL, md_file, "r+", password, lh);
	if (fps == NULL)
		return_m13(FALSE_m13);
	
	FPS_free_m13(&fps);
	
	eprintf_m13("\nElective exit ...\n");
	G_show_proc_globs_m13(lh);
	exit_m13(0);
	
	return_m13(TRUE_m13);
}


tern  G_set_time_constants_m13(TIMEZONE_INFO_m13 *timezone_info, si8 session_start_time, tern prompt)
{
	si4 n_potential_timezones, potential_timezone_entries[TZ_TABLE_ENTRIES_m13];
	si4 i, j, response_num, items;
	PROC_GLOBS_m13	*proc_globs;
	TIMEZONE_INFO_m13	*tz_table;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (globals_m13->tables->timezone_table == NULL)
		G_init_timezone_tables_m13();
	
	proc_globs = G_proc_globs_m13(NULL);
	
	// reset
	proc_globs->time_constants.set = FALSE_m13;
	
	// capitalize & check aliases
	G_condition_timezone_info_m13(timezone_info);  // modified if alias found
	
	// start search
	n_potential_timezones = TZ_TABLE_ENTRIES_m13;
	tz_table = globals_m13->tables->timezone_table;
	for (i = 0; i < n_potential_timezones; ++i)
		potential_timezone_entries[i] = i;
	
	// match country
	j = 0;
	if (*timezone_info->country) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp_m13(timezone_info->country, tz_table[potential_timezone_entries[i]].country) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m13;
		n_potential_timezones = j;
	}
	
	// match country_acronym_2_letter
	j = 0;
	if (*timezone_info->country_acronym_2_letter) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp_m13(timezone_info->country_acronym_2_letter, tz_table[potential_timezone_entries[i]].country_acronym_2_letter) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m13;
		n_potential_timezones = j;
	}
	
	// match country_acronym_3_letter
	j = 0;
	if (*timezone_info->country_acronym_3_letter) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp_m13(timezone_info->country_acronym_3_letter, tz_table[potential_timezone_entries[i]].country_acronym_3_letter) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m13;
		n_potential_timezones = j;
	}
	
	// match standard_timezone_acronym
	j = 0;
	if (*timezone_info->standard_timezone_acronym) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp_m13(timezone_info->standard_timezone_acronym, tz_table[potential_timezone_entries[i]].standard_timezone_acronym) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m13;
		n_potential_timezones = j;
	}

	// match standard_timezone
	j = 0;
	if (*timezone_info->standard_timezone) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp_m13(timezone_info->standard_timezone, tz_table[potential_timezone_entries[i]].standard_timezone) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m13;
		n_potential_timezones = j;
	}

	// match daylight_timezone_acronym
	j = 0;
	if (*timezone_info->daylight_timezone_acronym) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp_m13(timezone_info->daylight_timezone_acronym, tz_table[potential_timezone_entries[i]].daylight_timezone_acronym) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m13;
		n_potential_timezones = j;
	}

	// match daylight_timezone
	j = 0;
	if (*timezone_info->daylight_timezone) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp_m13(timezone_info->daylight_timezone, tz_table[potential_timezone_entries[i]].daylight_timezone) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m13;
		n_potential_timezones = j;
	}

	// match standard_UTC_offset
	j = 0;
	if (timezone_info->standard_UTC_offset) {  // zero is a valid offset, but also could be zero from calloc() - can't use it to exclude
		for (i = 0; i < n_potential_timezones; ++i)
			if (timezone_info->standard_UTC_offset == tz_table[potential_timezone_entries[i]].standard_UTC_offset)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m13;
		n_potential_timezones = j;
	}

	// match territory
	j = 0;
	if (*timezone_info->territory) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp_m13(timezone_info->territory, tz_table[potential_timezone_entries[i]].territory) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m13;
		n_potential_timezones = j;
	}
	
	// match territory_acronym
	j = 0;
	if (*timezone_info->territory_acronym) {
		for (i = 0; i < n_potential_timezones; ++i)
			if (strcmp_m13(timezone_info->territory_acronym, tz_table[potential_timezone_entries[i]].territory_acronym) == 0)
				potential_timezone_entries[j++] = potential_timezone_entries[i];
	}
	if (j) {
		if (j == 1)
			goto SET_GTC_TIMEZONE_MATCH_m13;
		n_potential_timezones = j;
	}

	// still multiple: doesn't matter if UTC offset, daylight change info, & timezone names all match
	for (i = 1; i < n_potential_timezones; ++i) {
		if (tz_table[potential_timezone_entries[i]].standard_UTC_offset != tz_table[potential_timezone_entries[0]].standard_UTC_offset)
			break;
		if (tz_table[potential_timezone_entries[i]].daylight_time_start_code != tz_table[potential_timezone_entries[0]].daylight_time_start_code)
			break;
		if (tz_table[potential_timezone_entries[i]].daylight_time_end_code != tz_table[potential_timezone_entries[0]].daylight_time_end_code)
			break;
		if (strcmp_m13(tz_table[potential_timezone_entries[i]].standard_timezone, tz_table[potential_timezone_entries[0]].standard_timezone))
			break;
	}
	if (i == n_potential_timezones)
		goto SET_GTC_TIMEZONE_MATCH_m13;

	// still multiple: ask user
	if (prompt == TRUE_m13) {
		fprintf_m13(stderr_m13, "\nMultiple potential timezone entries:\n\n");
		for (i = 0; i < n_potential_timezones; ++i) {
			fprintf_m13(stderr_m13, "%d)\n", i + 1);
			G_show_timezone_info_m13(&tz_table[potential_timezone_entries[i]], FALSE_m13);
			fputc_m13('\n', stderr_m13);
		}
		fprintf_m13(stderr_m13, "Select one (by number): ");
		items = scanf("%d", &response_num);
		if (items != 1 || response_num < 1 || response_num > n_potential_timezones) {
			G_set_error_m13(E_UNKN_m13, "invalid choice");
			return_m13(FALSE_m13);
		}
		potential_timezone_entries[0] = potential_timezone_entries[--response_num];
	} else {
		return_m13(FALSE_m13);
	}
	
SET_GTC_TIMEZONE_MATCH_m13:
	*timezone_info = tz_table[potential_timezone_entries[0]];
	proc_globs->time_constants.standard_UTC_offset = timezone_info->standard_UTC_offset;
	strncpy_m13(proc_globs->time_constants.standard_timezone_acronym, timezone_info->standard_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m13);
	strncpy_m13(proc_globs->time_constants.standard_timezone_string, timezone_info->standard_timezone, TIMEZONE_STRING_BYTES_m13);
	STR_to_title_m13(proc_globs->time_constants.standard_timezone_string);  // beautify
	if (timezone_info->daylight_time_start_code) {
		if (timezone_info->daylight_time_start_code == DTCC_VALUE_NO_ENTRY_m13) {
			proc_globs->time_constants.observe_DST = UNKNOWN_m13;
		} else {
			proc_globs->time_constants.observe_DST = TRUE_m13;
			strncpy_m13(proc_globs->time_constants.daylight_timezone_acronym, timezone_info->daylight_timezone_acronym, TIMEZONE_ACRONYM_BYTES_m13);
			strncpy_m13(proc_globs->time_constants.daylight_timezone_string, timezone_info->daylight_timezone, TIMEZONE_STRING_BYTES_m13);
			STR_to_title_m13(proc_globs->time_constants.daylight_timezone_string);  // beautify
			proc_globs->time_constants.daylight_start_code.value = timezone_info->daylight_time_start_code;
			proc_globs->time_constants.daylight_end_code.value = timezone_info->daylight_time_end_code;
		}
	} else {
		proc_globs->time_constants.observe_DST = FALSE_m13;
	}
	proc_globs->time_constants.set = TRUE_m13;

	if (session_start_time)  // pass CURRENT_TIME_m13 for session starting now; pass zero if just need to get timezone_info for a locale
		G_generate_recording_time_offset_m13(session_start_time);

	return_m13(TRUE_m13);
}


Sgmt_REC_m13	*G_Sgmt_records_m13(LH_m13 *lh, si4 search_mode)
{
	si1			md_path[PATH_BYTES_m13];
	ui4 			source_type;
	si4			i, seg_idx, n_segs;
	sf4			rate;
	PROC_GLOBS_m13		*proc_globs;
	SESS_m13		*sess;
	SSR_m13			*ssr;
	CHAN_m13		*chan;
	SEG_m13			*seg;
	FPS_m13			*md_fps;
	Sgmt_RECS_LIST_m13	*list;
	Sgmt_RECS_ENTRY_m13 	*rec_entry, *new_entries;
	Sgmt_REC_m13		*Sgmt_recs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	proc_globs = G_proc_globs_m13(lh);
	list = proc_globs->current_session.Sgmt_recs_list;
	sess = NULL;
	ssr = NULL;
	chan = NULL;
	
	if (search_mode == TIME_SEARCH_m13) {  // any Sgmt records will suffice
		pthread_mutex_lock_m13(&list->mutex);
		if (list->top_idx >= 0) {
			Sgmt_recs = (Sgmt_REC_m13 *) list->entries->Sgmt_recs;
			pthread_mutex_unlock_m13(&list->mutex);
			return_m13(Sgmt_recs);
		}
		chan = proc_globs->current_session.index_channel;
		i = -1;  // no entries => create new entry
	} else {  // SAMPLE_SEARCH_m13 - find by rate
		switch (lh->type_code) {
			case SESS_TYPE_CODE_m13:
				sess = (SESS_m13 *) lh;
				if (sess->Sgmt_recs)
					if (sess->Sgmt_recs->rate != (sf4) RATE_NO_ENTRY_m13)
						return_m13(sess->Sgmt_recs);
				chan = proc_globs->current_session.index_channel;
				break;
			case SSR_TYPE_CODE_m13:
				ssr = (SSR_m13 *) lh;
				if (ssr->Sgmt_recs)
					if (ssr->Sgmt_recs->rate != (sf4) RATE_NO_ENTRY_m13)
						return_m13(ssr->Sgmt_recs);
				sess = (SESS_m13 *) ssr->parent;
				chan = proc_globs->current_session.index_channel;
				break;
			case TS_CHAN_TYPE_CODE_m13:
			case VID_CHAN_TYPE_CODE_m13:
				chan = (CHAN_m13 *) lh;
				if (chan->Sgmt_recs)
					return_m13(chan->Sgmt_recs);
				break;
			case TS_SEG_TYPE_CODE_m13:  // unusual to call with segment, but possible
			case VID_SEG_TYPE_CODE_m13:
				if (CHANNEL_CODE_m13(lh->parent->type_code) == TRUE_m13)
					chan = (CHAN_m13 *) (lh->parent);
				else
					return_m13(NULL);
				if (chan->Sgmt_recs)
					return_m13(chan->Sgmt_recs);
				break;
			default:
				G_warning_message_m13("%s(): invalid level\n", __FUNCTION__);
				return_m13(NULL);
		}
		
		rate = RATE_NO_ENTRY_m13;
		if (chan) {
			if (chan->segs) {
				seg_idx = G_segment_index_m13(FIRST_OPEN_SEG_m13, (LH_m13 *) chan);
				seg = chan->segs[seg_idx];
				if (seg) {
					if (seg->metadata_fps) {
						if (chan->type_code == TS_CHAN_TYPE_CODE_m13)
							rate = (sf4) seg->metadata_fps->metadata->time_series_section_2.sampling_frequency;
						else  // VID_CHAN_TYPE_CODE_m13
							rate = (sf4) seg->metadata_fps->metadata->video_section_2.frame_rate;
					}
				}
			}
		}
		if (rate == RATE_NO_ENTRY_m13) {
			G_find_metadata_file_m13(chan->path, md_path);
			md_fps = FPS_read_m13(NULL, 0, FPS_UH_ONLY_m13, 0, NULL, md_path, "r", NULL, (LH_m13 *) chan);
			if (md_fps == NULL)
				return_m13(NULL);
			if (chan->type_code == TS_CHAN_TYPE_CODE_m13)
				rate = (sf4) seg->metadata_fps->metadata->time_series_section_2.sampling_frequency;
			else  // VID_CHAN_TYPE_CODE_m13
				rate = (sf4) seg->metadata_fps->metadata->video_section_2.frame_rate;
			FPS_free_m13(&md_fps);
		}
		
		// search for matching entry
		pthread_mutex_lock_m13(&list->mutex);
		rec_entry = list->entries;
		for (i = list->top_idx + 1; i--; ++rec_entry)
			if (rec_entry->rate == rate)
				break;
	}

	// add new entry
	if (i == -1) {
		Sgmt_recs = G_build_Sgmt_records_m13((LH_m13 *) lh, search_mode, &source_type);
		if (++list->top_idx == list->size) {
			list->size += GLOBALS_SGMT_LIST_SIZE_INCREMENT_m13;
			new_entries = (Sgmt_RECS_ENTRY_m13 *) realloc((void *) list->entries, (size_t) list->size * sizeof(Sgmt_RECS_ENTRY_m13 *));
			if (new_entries == NULL) {
				--list->top_idx;
				list->size -= GLOBALS_SGMT_LIST_SIZE_INCREMENT_m13;
				pthread_mutex_unlock_m13(&list->mutex);
				G_set_error_m13(E_ALLOC_m13, NULL);
				return_m13(NULL);
			}
			
			list->entries = new_entries;
			memset((void *) rec_entry, (si4) 0, (size_t) GLOBALS_SGMT_LIST_SIZE_INCREMENT_m13 * sizeof(Sgmt_RECS_ENTRY_m13 *));  // realloc() does not zero
		}
		// fill new entry
		rec_entry = list->entries + list->top_idx;
		rec_entry->source_type = source_type;
		n_segs = proc_globs->current_session.n_segments;
		rec_entry->n_session_samples = Sgmt_recs[n_segs - 1].end_num + 1;  // unioned with n_session_frames
		rec_entry->rate = rate;
		rec_entry->source_type = source_type;
		rec_entry->Sgmt_recs = (struct Sgmt_REC_m13 *) Sgmt_recs;
	} else {
		Sgmt_recs = (Sgmt_REC_m13 *) rec_entry->Sgmt_recs;
	}

	pthread_mutex_unlock_m13(&list->mutex);  // unlock
	
	// set shortcuts
	chan->Sgmt_recs = Sgmt_recs;
	if (sess)
		sess->Sgmt_recs = Sgmt_recs;
	if (ssr)
		ssr->Sgmt_recs = Sgmt_recs;

	return_m13(Sgmt_recs);
}


ui4	G_Sgmt_records_source_m13(LH_m13 *lh, Sgmt_REC_m13 *Sgmt_recs)
{
	ui4			source;
	si4			i;
	PROC_GLOBS_m13		*proc_globs;
	Sgmt_RECS_LIST_m13	*list;
	Sgmt_RECS_ENTRY_m13 	*rec_entry;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	proc_globs = G_proc_globs_m13(lh);
	list = proc_globs->current_session.Sgmt_recs_list;
	
	// search for matching entry
	pthread_mutex_lock_m13(&list->mutex);
	rec_entry = list->entries;
	for (i = list->top_idx + 1; i--; ++rec_entry)
		if (rec_entry->Sgmt_recs == (struct Sgmt_REC_m13 *) Sgmt_recs)
			break;
	
	if (i == -1)
		source = NO_TYPE_CODE_m13;
	else
		source = rec_entry->source_type;

	pthread_mutex_unlock_m13(&list->mutex);
	
	return_m13(source);
}


tern	G_show_behavior_m13(ui4 mode)
{
	si1			behavior_string[256];
	BEHAVIOR_m13		*behavior;
	si4			i;
	BEHAVIOR_STACK_m13	*stack;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// mode == SHOW_CURRENT_BEHAVIOR_m13, or SHOW_BEHAVIOR_STACK_m13, or (SHOW_CURRENT_BEHAVIOR_m13 | SHOW_BEHAVIOR_STACK_m13) for both
	
	stack = G_behavior_stack_m13();  // gets mutex
	
	if (mode & SHOW_CURRENT_BEHAVIOR_m13) {
		printf_m13("\nCurrent Process Behavior:\n------------------------\n");
		behavior = stack->behaviors + stack->top_idx;
		G_behavior_string_m13(behavior->code, behavior_string);
		printf_m13("%s%s%s (code %u)%s  [set in %s(), line %d]\n\n",  TC_RED_m13, behavior_string, TC_BLUE_m13, behavior->code, TC_RESET_m13, behavior->function, behavior->line);
	}
	
	if (mode & SHOW_BEHAVIOR_STACK_m13) {
		printf_m13("Current Process Behavior Stack:\n-----------------------\n");
		behavior = stack->behaviors;
		for (i = 0; i <= stack->top_idx; ++i, ++behavior) {
			G_behavior_string_m13(behavior->code, behavior_string);
			printf_m13("%d) %s%s%s (code %u)%s  [set in %s(), line %d]\n", i, TC_RED_m13, behavior_string, TC_BLUE_m13, behavior->code, TC_RESET_m13, behavior->function, behavior->line);
		}
		printf_m13("\n");
	}
	
	// release mutex
	pthread_mutex_unlock_m13(&globals_m13->behavior_stack_list->mutex);

	return_m13(TRUE_m13);
}


tern	G_show_contigua_m13(LH_m13 *lh)
{
	si8		i, n_contigua;
	CONTIGUON_m13	*contigua;
	SEG_m13	*seg;
	CHAN_m13	*chan;
	SESS_m13	*sess;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// find contigua in current time slice, and set in level
	
	if (lh == NULL) {
		G_set_error_m13(E_UNKN_m13, "level is not open");
		return_m13(FALSE_m13);
	}
	
	n_contigua = 0;
	contigua = NULL;
	switch (lh->type_code) {
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
			seg = (SEG_m13 *) lh;
			if (seg == NULL) {
				G_set_error_m13(E_UNKN_m13, "segment is not open");
				return_m13(FALSE_m13);
			}
			contigua = seg->contigua;
			n_contigua = seg->n_contigua;
			break;
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
			chan = (CHAN_m13 *) lh;
			if (chan == NULL) {
				G_set_error_m13(E_UNKN_m13, "channel is not open");
				return_m13(FALSE_m13);
			}
			contigua = chan->contigua;
			n_contigua = chan->n_contigua;
			break;
		case SESS_TYPE_CODE_m13:
			sess = (SESS_m13 *) lh;
			if (sess == NULL) {
				G_set_error_m13(E_UNKN_m13, "session is not open");
				return_m13(FALSE_m13);
			}
			contigua = sess->contigua;
			n_contigua = sess->n_contigua;
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "invalid level type");
			return_m13(FALSE_m13);
	}
	
	if (n_contigua == 0 || contigua == NULL) {
		G_set_error_m13(E_UNKN_m13, "no contigua for level");
		return_m13(FALSE_m13);
	}
	
	printf_m13("Level Contigua:\n");
	for (i = 0; i < n_contigua; ++i) {
		printf_m13("%ld)\n", i + 1);
		printf_m13("\tstart time: %ld\n", contigua[i].start_time);
		printf_m13("\tend time: %ld\n", contigua[i].end_time);
		printf_m13("\tstart sample/frame number: %ld\n", contigua[i].start_samp_num);
		printf_m13("\tend sample/frame number: %ld\n", contigua[i].end_samp_num);
		printf_m13("\tstart segment number: %ld\n", contigua[i].start_seg_num);
		printf_m13("\tend segment number: %ld\n\n", contigua[i].end_seg_num);
	}

	return_m13(TRUE_m13);
}


tern  G_show_daylight_change_code_m13(DAYLIGHT_TIME_CHANGE_CODE_m13 *code, si1 *prefix)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	static si1	*relative_days[7] = { "", "First", "Second", "Third", "Fourth", "Fifth", "Last"};
	static si1	*weekdays[8] = { "", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
	static si1	*months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
	static si1	*mday_num_sufs[32] = { 	"", "st", "nd", "rd", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", \
						"th", "th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th", "th", "st" };
	
	
	if (prefix == NULL)
		prefix = "";
	printf_m13("%sStructure Content:\n", prefix);
	printf_m13("%sCode Type (DST end / DST Not Observed / DST start) ==  (-1 / 0 / +1): %hhd\n", prefix, code->code_type);
	printf_m13("%sDay of Week (No Entry / [Sunday : Saturday]) ==  (0 / [1 : 7]): %hhd\n", prefix, code->day_of_week);
	printf_m13("%sRelative Weekday of Month (No Entry / [First : Fifth] / Last) ==  (0 / [1 : 5] / 6): %hhd\n", prefix, code->relative_weekday_of_month);
	printf_m13("%sDay of Month (No Entry / [1 : 31]) ==  (0 / [1 : 31]): %hhd\n", prefix, code->day_of_month);
	printf_m13("%sMonth (No Entry / [January : December]) ==  (-1 / [0 : 11]): %hhd\n", prefix, code->month);
	printf_m13("%sHours of Day [-128 : +127] hours relative to 00:00 (midnight): %hhd\n", prefix, code->hours_of_day);
	printf_m13("%sReference Time (Local / UTC) ==  (0 / 1): %hhd\n", prefix, code->reference_time);
	printf_m13("%sShift Minutes [-120 : +120] minutes: %hhd\n", prefix, code->shift_minutes);
	printf_m13("%sValue: 0x%lX\n\n", prefix, code->value);

	// human readable
	printf_m13("%sTranslated Content: ", prefix);
	switch (code->value) {
		case DTCC_VALUE_NO_ENTRY_m13:
			printf_m13("daylight saving change information not entered\n\n");
			return_m13(TRUE_m13);
		case DTCC_VALUE_NOT_OBSERVED_m13:
			printf_m13("daylight saving not observed\n\n");
			return_m13(TRUE_m13);
	}
	switch (code->code_type) {
		case -1:
			printf_m13("daylight saving END\n");
			break;
		case 1:
			printf_m13("daylight saving START\n");
			break;
	}

	printf_m13("%s", prefix);
	if (code->relative_weekday_of_month) {
		printf_m13("%s ", relative_days[(si4) code->relative_weekday_of_month]);
		printf_m13("%s ", weekdays[(si4) (code->day_of_week + 1)]);
		printf_m13("in %s ", months[(si4) code->month]);
	} else if (code->day_of_month) {
		printf_m13("%s ", months[(si4) code->month]);
		printf_m13("%hhd%s ", code->day_of_month, mday_num_sufs[(si4) code->day_of_month]);
	}

	printf_m13("at %hhd:00 ", code->hours_of_day);
	switch (code->reference_time) {
		case 0:
			printf_m13("local ");
			break;
		case 1:
			printf_m13("UTC ");
			break;
	}
	if (code->shift_minutes < 0)
		printf_m13(" (shift back by %hhd minutes)\n\n", -(code->shift_minutes));
	else
		printf_m13(" (shift forward by %hhd minutes)\n\n", code->shift_minutes);

	return_m13(TRUE_m13);
}


tern	G_show_error_m13(void)
{
	const si1	*func;
	si1		*mess, *name;
	si4		line;
	ui8		_id;
	ERR_m13		*err;
	

	err = &globals_m13->error;
	_id = (ui8) err->thread_id;
	mess = err->message;
	name = err->thread_name;
	func = err->function;
	line = err->line;
	
	if (err->code == E_NONE_m13) {
		#ifdef MATLAB_m13
		mexPrintf("\nError:\tno error set\n\n");
		#else
		fprintf(stderr, "\n%sError%s:\tno error set\n\n", TC_RED_m13, TC_RESET_m13);
		#endif
		return(TRUE_m13);
	}

#ifdef MATLAB_m13
	if (*err->thread_name == '<') {
		if (err->line == E_UNKNOWN_LINE_m13)
			mexPrintf("\n\nError:\t%s\n\t[set in %s(); in thread %lu]\n", mess, func, _id);
		else
			mexPrintf("\n\nError:\t%s\n\t[set in %s(); at line %d; in thread %lu]\n", mess, func, line, _id);
	} else if (_id == globals_m13->main_id) {
		if (err->line == E_UNKNOWN_LINE_m13)
			mexPrintf("\n\nError:\t%s\n\t[set in %s(); in \"%s\" (id %lu)]\n", mess, func, name, _id);
		else
			mexPrintf("\n\nError:\t%s\n\t[set in %s(); at line %d; in \"%s\" (id %lu)]\n", mess, func, line, name, _id);
	} else {
		if (err->line == E_UNKNOWN_LINE_m13)
			mexPrintf("\n\nError:\t%s\n\t[set in %s(); in thread \"%s\" (id %lu)]\n", mess, func, name, _id);
		else
			mexPrintf("\n\nError:\t%s\n\t[set in %s(); at line %d; in thread \"%s\" (id %lu)]\n", mess, func, line, name, _id);
	}
#else
	if (*err->thread_name == '<') {
		if (err->line == E_UNKNOWN_LINE_m13)
			printf_m13("\n\n%c%sError:%s\t%s\n\t%s[set in %s(); in thread %lu]%s\n", 7, TC_RED_m13, TC_RESET_m13, mess, TC_BLUE_m13, func, _id, TC_RESET_m13);
		else
			printf_m13("\n\n%c%sError:%s\t%s\n\t%s[set in %s(); at line %d; in thread %lu]%s\n", 7, TC_RED_m13, TC_RESET_m13, mess, TC_BLUE_m13, func, line, _id, TC_RESET_m13);
	} else if (_id == globals_m13->main_id){
		if (err->line == E_UNKNOWN_LINE_m13)
			printf_m13("\n\n%c%sError:%s\t%s\n\t%s[set in %s(); in \"%s\" (id %lu)]%s\n", 7, TC_RED_m13, TC_RESET_m13, mess, TC_BLUE_m13, func, name, (ui8) _id, TC_RESET_m13);
		else
			printf_m13("\n\n%c%sError:%s\t%s\n\t%s[set in %s(); at line %d; in \"%s\" (id %lu)]%s\n", 7, TC_RED_m13, TC_RESET_m13, mess, TC_BLUE_m13, func, line, name, _id, TC_RESET_m13);
	} else {
		if (err->line == E_UNKNOWN_LINE_m13)
			printf_m13("\n\n%c%sError:%s\t%s\n\t%s[set in %s(); in thread \"%s\" (id %lu)]\n", 7, TC_RED_m13, TC_RESET_m13, mess, TC_BLUE_m13, func, name, (ui8) _id, TC_RESET_m13);
		else
			printf_m13("\n\n%c%sError:%s\t%s\n\t%s[set in %s(); at line %d; in thread \"%s\" (id %lu)]%s\n", 7, TC_RED_m13, TC_RESET_m13, mess, TC_BLUE_m13, func, line, name, _id, TC_RESET_m13);
	}
#endif
	
	if (err->signal == SIGTRAP) {
		#ifdef MATLAB_m13
		mexPrintf("\t(it is possible this signal was triggered by another thread or a code breakpoint)\n");
		#else
		printf("\t%s(it is possible this signal was triggered by another thread or a code breakpoint)%s\n", TC_GREEN_m13, TC_RESET_m13);
		#endif
	}
	putchar_m13('\n');

	return(TRUE_m13);
}


tern	G_show_file_times_m13(FILE_TIMES_m13 *ft)
{
	si1	time_str[TIME_STRING_BYTES_m13];
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	printf_m13("Creation Time: ");
	if (ft->creation == UUTC_NO_ENTRY_m13) {
		printf_m13("no entry\n");
	} else {
		STR_time_m13(NULL, ft->creation, time_str, TRUE_m13, FALSE_m13, FALSE_m13);
		printf_m13("%ld (oUTC), %s\n", ft->creation, time_str);
	}
	
	printf_m13("Access Time: ");
	if (ft->access == UUTC_NO_ENTRY_m13) {
		printf_m13("no entry\n");
	} else {
		STR_time_m13(NULL, ft->access, time_str, TRUE_m13, FALSE_m13, FALSE_m13);
		printf_m13("%ld (oUTC), %s\n", ft->access, time_str);
	}

	printf_m13("Modification Time: ");
	if (ft->creation == UUTC_NO_ENTRY_m13) {
		printf_m13("no entry\n");
	} else {
		STR_time_m13(NULL, ft->modification, time_str, TRUE_m13, FALSE_m13, FALSE_m13);
		printf_m13("%ld (oUTC), %s\n", ft->modification, time_str);
	}

	return_m13(TRUE_m13);
}


void	G_show_function_stack_m13(si4 recursed, ...)  // vararg(recursed [tern as si4] == TRUE_m13): pid_t_m13 _id
{
#ifdef FT_DEBUG_m13
	
	si1			*c, thread_name[PROC_THREAD_NAME_LEN_DEFAULT_m13];
	si4			i;
	pid_t_m13		_id;
	FUNCTION_STACK_m13	*stack;
	va_list			v_arg;

	
	// pass recursed_call == FALSE_m13 for initial call
	
	if (recursed == TRUE_m13) {
		va_start(v_arg, recursed);
		_id = va_arg(v_arg, pid_t_m13);
		va_end(v_arg);
	} else if (globals_m13->error.code) {
		_id = globals_m13->error.thread_id;
	} else {
		_id = gettid_m13();
	}
	
	stack = G_function_stack_m13(_id);
	if (stack == NULL)
		return;
	
	// recurse
	if (stack->_pid)
		G_show_function_stack_m13(TRUE_m13, stack->_pid);

	// print thread name
	pthread_getname_m13(0, thread_name, (size_t) PROC_THREAD_NAME_LEN_DEFAULT_m13);
	if (*thread_name == '<')  // "<unnamed>"
		sprintf_m13(thread_name, "Function Stack for Thread %lu:", _id);
	else if (_id == globals_m13->main_id)  // "main process"
		sprintf_m13(thread_name, "Function Stack for \"%s\" (id %lu):", thread_name, _id);
	else
		sprintf_m13(thread_name, "Function Stack for Thread \"%s\" (id %lu):", thread_name, _id);
	printf_m13("%s\n", thread_name);

	// replace string characters with '-' (terminal zero preserved)
	c = thread_name - 1;
	while (*++c)
		*c = '-';
	printf_m13("%s\n", thread_name);
	
	// print stack
	for (i = 0; i <= stack->top_idx; ++i)
		printf_m13("%d)\t%s()\n", i, stack->functions[i]);
	putchar_m13('\n');

#endif  // FT_DEBUG_m13
	
	return;
}


void  G_show_globals_m13(void)
{
	si4	i;
	

	printf_m13("\nGlobals\n-----------\n-----------\n");

	printf_m13("\nRecord Filters\n--------------\n");
	if (globals_m13->record_filters == NULL) {
		printf_m13("no entry\n");
	} else if (globals_m13->record_filters[0] == NO_TYPE_CODE_m13) {
		printf_m13("no entry\n");
	} else {
		printf_m13("0x%08x", globals_m13->record_filters[0]);
		for (i = 1; globals_m13->record_filters[i] != NO_TYPE_CODE_m13; ++i)
			printf_m13(", 0x%08x", globals_m13->record_filters[i]);
		printf_m13("\n");
	}

	printf_m13("\nError\n--------------\n");
	G_show_error_m13();

	printf_m13("\nMiscellaneous\n-------------\n");
	if (*globals_m13->temp_dir)
		printf_m13("Temporary File Directory: \"%s\"\n", globals_m13->temp_dir);
	else
		printf_m13("Temporary File Directory: no entry\n");
	if (*globals_m13->temp_file)
		printf_m13("Temporary File: \"%s\"\n", globals_m13->temp_file);
	else
		printf_m13("Temporary File: no entry\n");
	printf_m13("File Creation umask: %u\n", globals_m13->file_creation_umask);
	if (globals_m13->file_lock_mode == FLOCK_MODE_NONE_m13)
		printf_m13("File Lock Mode: none\n");
	else if (globals_m13->file_lock_mode == FLOCK_MODE_MED_m13)
		printf_m13("File Lock Mode: MED files only\n");
	else if (globals_m13->file_lock_mode == FLOCK_MODE_ALL_m13)
		printf_m13("File Lock Mode: all files\n");
	else
		printf_m13("File Lock Mode: unrecognized (%hhd)\n", globals_m13->file_lock_mode);
	printf_m13("Threading: %s\n", STR_tern_m13(globals_m13->threading));
	printf_m13("CRC Mode: %u\n", globals_m13->CRC_mode);
	printf_m13("Write Sorted Records: %s\n", STR_tern_m13(globals_m13->write_sorted_records));
	printf_m13("Update Header Names: %s\n", STR_tern_m13(globals_m13->update_header_names));
	printf_m13("Update MED Version: %s\n", STR_tern_m13(globals_m13->update_MED_version));

	printf_m13("\n");
	
	return;
}


tern	G_show_level_header_m13(LH_m13 *lh)
{
	si1	hex_str[HEX_STR_BYTES_m13(sizeof(ui8), 0)];
	si1	bin_str[BIN_STR_BYTES_m13(sizeof(ui8), 1)];
	si1	tim_str[TIME_STRING_BYTES_m13];
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	printf_m13("---------------- Level Header - START ----------------\n");
	STR_hex_m13(hex_str, (ui1 *) lh->type_string, sizeof(ui4), NULL, TRUE_m13);
	printf_m13("Type String: \"%s\"  (code: 0x%s)\n", lh->type_string, hex_str);
	if (lh->parent)
		printf_m13("Parent: %lu\n", (ui8) lh->parent);
	else
		printf_m13("Parent: null\n");
	if (lh->proc_globs)
		printf_m13("Process Globals: %lu\n", (ui8) lh->proc_globs);
	else
		printf_m13("Process Globals: null\n");
	if (lh->flags) {
		STR_bin_m13(bin_str, (ui1 *) &lh->flags, sizeof(ui8), " ", TRUE_m13);
		STR_hex_m13(hex_str, (void *) &lh->flags, sizeof(ui8), NULL, TRUE_m13);
		printf_m13("Flags: 0b %s  (0x%s)\n", bin_str, hex_str);
	} else {
		printf_m13("Flags: none set\n");
	}
	printf_m13("Access Time: ");
	if (lh->access_time <= 0) {
		printf_m13("no entry\n");
	} else {
		STR_time_m13(NULL, lh->access_time, tim_str, TRUE_m13, FALSE_m13, FALSE_m13);
		printf_m13("%ld (oUTC), %s\n", lh->access_time, tim_str);
	}
	printf_m13("----------------- Level Header - END -----------------\n");

	return_m13(TRUE_m13);
}


tern	G_show_level_header_flags_m13(ui8 flags)
{
	si1	bin_str[BIN_STR_BYTES_m13(sizeof(ui8), 3)];
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	printf_m13("\nLevel Header Flags:\n------------------\n");
	if (flags == LH_NO_FLAGS_m13) {
		printf_m13("no level header flags set\n");
		return_m13(FALSE_m13);
	}
	if (flags & LH_GENERATE_EPHEMERAL_DATA_m13)
		printf_m13("LH_GENERATE_EPHEMERAL_DATA_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_GENERATE_EPHEMERAL_DATA_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_UPDATE_EPHEMERAL_DATA_m13)
		printf_m13("LH_UPDATE_EPHEMERAL_DATA_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_UPDATE_EPHEMERAL_DATA_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_EXCLUDE_TS_CHANS_m13)
		printf_m13("LH_EXCLUDE_TS_CHANS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_EXCLUDE_TS_CHANS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_EXCLUDE_VID_CHANS_m13)
		printf_m13("LH_EXCLUDE_VID_CHANS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_EXCLUDE_VID_CHANS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_MAP_ALL_TS_CHANS_m13)
		printf_m13("LH_MAP_ALL_TS_CHANS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_MAP_ALL_TS_CHANS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_MAP_ALL_VID_CHANS_m13)
		printf_m13("LH_MAP_ALL_VID_CHANS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_MAP_ALL_VID_CHANS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_READ_SLICE_SESS_RECS_m13)
		printf_m13("LH_READ_SLICE_SESS_RECS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_READ_SLICE_SESS_RECS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_READ_FULL_SESS_RECS_m13)
		printf_m13("LH_READ_FULL_SESS_RECS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_READ_FULL_SESS_RECS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_MMAP_SESS_RECS_m13)
		printf_m13("LH_MMAP_SESS_RECS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_MMAP_SESS_RECS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_READ_SLICE_SEG_SESS_RECS_m13)
		printf_m13("LH_READ_SLICE_SEG_SESS_RECS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_READ_SLICE_SEG_SESS_RECS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_READ_FULL_SEG_SESS_RECS_m13)
		printf_m13("LH_READ_FULL_SEG_SESS_RECS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_READ_FULL_SEG_SESS_RECS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_MMAP_SEG_SESS_RECS_m13)
		printf_m13("LH_MMAP_SEG_SESS_RECS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_MMAP_SEG_SESS_RECS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_CHAN_ACTIVE_m13)
		printf_m13("LH_CHAN_ACTIVE_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_CHAN_ACTIVE_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_MAP_ALL_SEGS_m13)
		printf_m13("LH_MAP_ALL_SEGS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_MAP_ALL_SEGS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_THREAD_SEG_READS_m13)
		printf_m13("LH_THREAD_SEG_READS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_THREAD_SEG_READS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_READ_SLICE_CHAN_RECS_m13)
		printf_m13("LH_READ_SLICE_CHAN_RECS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_READ_SLICE_CHAN_RECS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_READ_FULL_CHAN_RECS_m13)
		printf_m13("LH_READ_FULL_CHAN_RECS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_READ_FULL_CHAN_RECS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_MMAP_CHAN_RECS_m13)
		printf_m13("LH_MMAP_CHAN_RECS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_MMAP_CHAN_RECS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_NO_CPS_PTR_RESET_m13)
		printf_m13("LH_NO_CPS_PTR_RESET_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_NO_CPS_PTR_RESET_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_NO_CPS_CACHING_m13)
		printf_m13("LH_NO_CPS_CACHING_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_NO_CPS_CACHING_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_READ_SLICE_SEG_DATA_m13)
		printf_m13("LH_READ_SLICE_SEG_DATA_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_READ_SLICE_SEG_DATA_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_READ_FULL_SEG_DATA_m13)
		printf_m13("LH_READ_FULL_SEG_DATA_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_READ_FULL_SEG_DATA_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_MMAP_SEG_DATA_m13)
		printf_m13("LH_MMAP_SEG_DATA_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_MMAP_SEG_DATA_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_READ_SEG_METADATA_m13)
		printf_m13("LH_READ_SEG_METADATA_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_READ_SEG_METADATA_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_READ_SLICE_SEG_RECS_m13)
		printf_m13("LH_READ_SLICE_SEG_RECS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_READ_SLICE_SEG_RECS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_READ_FULL_SEG_RECS_m13)
		printf_m13("LH_READ_FULL_SEG_RECS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_READ_FULL_SEG_RECS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & LH_MMAP_SEG_RECS_m13)
		printf_m13("LH_MMAP_SEG_RECS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("LH_MMAP_SEG_RECS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	
	STR_bin_m13(bin_str, (void *) &flags, sizeof(ui8), " - ", TRUE_m13);
	printf_m13("\n(value: %s)\n\n", bin_str);
	
	return_m13(TRUE_m13);
}


tern  G_show_location_info_m13(LOCATION_INFO_m13 *li)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	G_show_timezone_info_m13(&li->timezone_info, TRUE_m13);
	printf_m13("Locality: %s\n", li->locality);
	printf_m13("Postal Code: %s\n", li->postal_code);
	printf_m13("Timezone Description: %s\n", li->timezone_description);
	printf_m13("Latitude: %lf\n", li->latitude);
	printf_m13("Longitude: %lf\n", li->longitude);
	printf_m13("WAN_IPv4 Address: %s\n", li->WAN_IPv4_address);
	
	return_m13(TRUE_m13);
}


tern	G_show_metadata_m13(FPS_m13 *fps, METADATA_m13 *md, ui4 type_code)
{
	ui1					MED_version_major, MED_version_minor;
	si1					hex_str[HEX_STR_BYTES_m13(sizeof(ui8), 1)];
	METADATA_SECTION_1_m13			*md1;
	TS_METADATA_SECTION_2_m13	*tmd2, *gmd2;
	VID_METADATA_SECTION_2_m13		*vmd2;
	METADATA_SECTION_3_m13			*md3;
	UH_m13			*uh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// if passing metadata pointer, also pass type code
	
	// assign
	if (fps) {
		MED_version_major = fps->uh->MED_version_major;
		MED_version_minor = fps->uh->MED_version_minor;
		md = fps->metadata;
		uh = fps->uh;
		type_code = fps->uh->type_code;
	} else {
		MED_version_major = MED_version_minor = 0;
		uh = NULL;
	}
	
	if (md) {
		md1 = &md->section_1;
		if (type_code == TS_METADATA_TYPE_CODE_m13) {
			tmd2 = &md->time_series_section_2;
			vmd2 = NULL;
		} else {  // type_code == VID_METADATA_TYPE_CODE_m13
			vmd2 = &md->video_section_2;
			tmd2 = NULL;
		}
		md3 = &md->section_3;
	} else {
		G_set_error_m13(E_UNKN_m13, "invalid input");
		return_m13(FALSE_m13);
	}
	
	// show
	printf_m13("------------------- Metadata - START -------------------\n");
	
	printf_m13("------------------ Section 1 - START -------------------\n");
	if (*md1->level_1_password_hint)
		printf_m13("Level 1 Password Hint: %s\n", md1->level_1_password_hint);
	if (*md1->level_2_password_hint)
		printf_m13("Level 2 Password Hint: %s\n", md1->level_2_password_hint);
	if (MED_version_major > 1 || MED_version_minor >= 1) {  // MED 1.1 & above
		if (*md1->anonymized_subject_ID)
			printf_m13("Anonymized Subject ID: %s\n", md1->anonymized_subject_ID);
		else
			printf_m13("Anonymized Subject ID: no entry\n");
	}
	printf_m13("------------------- Section 1 - END --------------------\n");
	
	// decrypt if needed
	if (uh) {
		if (uh->encryption_2 > NO_ENCRYPTION_m13 || uh->encryption_3 > NO_ENCRYPTION_m13)
			G_decrypt_metadata_m13(fps);
	}
	
	if (uh) {
		printf_m13("------------------ Section 2 - START -------------------\n");
		if (uh->encryption_2 <= NO_ENCRYPTION_m13) {
			
			// type-independent fields
			gmd2 = tmd2;
			if (*gmd2->session_description)
				printf_m13("Session Description: %s\n", gmd2->session_description);
			else
				printf_m13("Session Description: no entry\n");
			if (*gmd2->channel_description)
				printf_m13("Channel Description: %s\n", gmd2->channel_description);
			else
				printf_m13("Channel Description: no entry\n");
			if (*gmd2->segment_description)
				printf_m13("Segment Description: %s\n", gmd2->segment_description);
			else
				printf_m13("Segment Description: no entry\n");
			if (*gmd2->equipment_description)
				printf_m13("Equipment Description: %s\n", gmd2->equipment_description);
			else
				printf_m13("Equipment Description: no entry\n");
			if (gmd2->acquisition_channel_number == METADATA_ACQUISITION_CHANNEL_NUMBER_NO_ENTRY_m13)
				printf_m13("Acquisition Channel Number: no entry\n");
			else
				printf_m13("Acquisition Channel Number: %d\n", gmd2->acquisition_channel_number);
			
			// type-specific fields
			if (tmd2) {
				if (*tmd2->reference_description)
					printf_m13("Reference Description: %s\n", tmd2->reference_description);
				else
					printf_m13("Reference Description: no entry\n");
				if (tmd2->sampling_frequency == RATE_NO_ENTRY_m13)
					printf_m13("Sampling Frequency: no entry\n");
				else if (tmd2->sampling_frequency == RATE_VARIABLE_m13)
					printf_m13("Sampling Frequency: variable\n");
				else
					printf_m13("Sampling Frequency: %lf\n", tmd2->sampling_frequency);
				if (tmd2->low_frequency_filter_setting == RATE_NO_ENTRY_m13)
					printf_m13("Low Frequency Filter Setting: no entry\n");
				else if (tmd2->low_frequency_filter_setting == RATE_VARIABLE_m13)
					printf_m13("Low Frequency Filter Setting: variable\n");
				else
					printf_m13("Low Frequency Filter Setting (Hz): %lf\n", tmd2->low_frequency_filter_setting);
				if (tmd2->high_frequency_filter_setting == RATE_NO_ENTRY_m13)
					printf_m13("High Frequency Filter Setting: no entry\n");
				else if (tmd2->high_frequency_filter_setting == RATE_VARIABLE_m13)
					printf_m13("High Frequency Filter Setting: variable\n");
				else
					printf_m13("High Frequency Filter Setting (Hz): %lf\n", tmd2->high_frequency_filter_setting);
				if (tmd2->notch_filter_frequency_setting == RATE_NO_ENTRY_m13)
					printf_m13("Notch Filter Frequency Setting: no entry\n");
				else if (tmd2->notch_filter_frequency_setting == RATE_VARIABLE_m13)
					printf_m13("Notch Filter Frequency Setting: variable\n");
				else
					printf_m13("Notch Filter Frequency Setting (Hz): %lf\n", tmd2->notch_filter_frequency_setting);
				if (tmd2->AC_line_frequency == RATE_NO_ENTRY_m13)
					printf_m13("AC Line Frequency: no entry\n");
				else
					printf_m13("AC Line Frequency (Hz): %lf\n", tmd2->AC_line_frequency);
				if (tmd2->amplitude_units_conversion_factor == TS_METADATA_AMPLITUDE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m13)
					printf_m13("Amplitiude Units Conversion Factor: no entry\n");
				else
					printf_m13("Amplitude Units Conversion Factor: %lf\n", tmd2->amplitude_units_conversion_factor);
				if (*tmd2->amplitude_units_description)
					printf_m13("Amplitude Units Description: %s\n", tmd2->amplitude_units_description);
				else
					printf_m13("Amplitude Units Description: no entry\n");
				if (tmd2->time_base_units_conversion_factor == TS_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m13)
					printf_m13("Time Base Units Conversion Factor: no entry\n");
				else
					printf_m13("Time Base Units Conversion Factor: %lf\n", tmd2->time_base_units_conversion_factor);
				if (*tmd2->time_base_units_description)
					printf_m13("Time Base Units Description: %s\n", tmd2->time_base_units_description);
				else
					printf_m13("Time Base Units Description: no entry\n");
				if (tmd2->session_start_sample_number == TS_METADATA_SESSION_START_SAMPLE_NUMBER_NO_ENTRY_m13)
					printf_m13("Session Start Sample Number: no entry\n");
				else
					printf_m13("Session Start Sample Number: %ld\n", tmd2->session_start_sample_number);
				if (tmd2->number_of_samples == TS_METADATA_NUMBER_OF_SAMPLES_NO_ENTRY_m13)
					printf_m13("Number of Samples: no entry\n");
				else
					printf_m13("Number of Samples: %ld\n", tmd2->number_of_samples);
				if (tmd2->number_of_blocks == TS_METADATA_NUMBER_OF_BLOCKS_NO_ENTRY_m13)
					printf_m13("Number of Blocks: no entry\n");
				else
					printf_m13("Number of Blocks: %ld\n", tmd2->number_of_blocks);
				if (tmd2->maximum_block_bytes == TS_METADATA_MAXIMUM_BLOCK_BYTES_NO_ENTRY_m13)
					printf_m13("Maximum Block Bytes: no entry\n");
				else
					printf_m13("Maximum Block Bytes: %ld\n", tmd2->maximum_block_bytes);
				if (tmd2->maximum_block_samples == TS_METADATA_MAXIMUM_BLOCK_SAMPLES_NO_ENTRY_m13)
					printf_m13("Maximum Block Samples: no entry\n");
				else
					printf_m13("Maximum Block Samples: %u\n", tmd2->maximum_block_samples);
				if (tmd2->maximum_block_keysample_bytes == TS_METADATA_MAXIMUM_BLOCK_KEYSAMPLE_BYTES_NO_ENTRY_m13)
					printf_m13("Maximum Block Difference Bytes: no entry\n");
				else
					printf_m13("Maximum Block Keysample Bytes: %u\n", tmd2->maximum_block_keysample_bytes);
				if (tmd2->maximum_block_duration == TS_METADATA_MAXIMUM_BLOCK_DURATION_NO_ENTRY_m13)
					printf_m13("Maximum Block Duration: no entry\n");
				else
					printf_m13("Maximum Block Duration: %lf %s\n", tmd2->maximum_block_duration, tmd2->time_base_units_description);
				if (tmd2->number_of_discontinuities == TS_METADATA_NUMBER_OF_DISCONTINUITIES_NO_ENTRY_m13)
					printf_m13("Number of Discontinuities: no entry\n");
				else
					printf_m13("Number of Discontinuities: %ld\n", tmd2->number_of_discontinuities);
				if (tmd2->maximum_contiguous_blocks == TS_METADATA_MAXIMUM_CONTIGUOUS_BLOCKS_NO_ENTRY_m13)
					printf_m13("Maximum Contiguous Blocks: no entry\n");
				else
					printf_m13("Maximum Contiguous Blocks: %ld\n", tmd2->maximum_contiguous_blocks);
				if (tmd2->maximum_contiguous_block_bytes == TS_METADATA_MAXIMUM_CONTIGUOUS_BLOCK_BYTES_NO_ENTRY_m13)
					printf_m13("Maximum Contiguous Block Bytes: no entry\n");
				else
					printf_m13("Maximum Contiguous Block Bytes: %ld\n", tmd2->maximum_contiguous_block_bytes);
				if (tmd2->maximum_contiguous_samples == TS_METADATA_MAXIMUM_CONTIGUOUS_SAMPLES_NO_ENTRY_m13)
					printf_m13("Maximum Contiguous Samples: no entry\n");
				else
					printf_m13("Maximum Contiguous Samples: %ld\n", tmd2->maximum_contiguous_samples);
			} else if (vmd2) {
				if (vmd2->time_base_units_conversion_factor == VID_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_NO_ENTRY_m13)
					printf_m13("Time Base Units Conversion Factor: no entry\n");
				else
					printf_m13("Time Base Units Conversion Factor: %lf\n", vmd2->time_base_units_conversion_factor);
				if (*vmd2->time_base_units_description)
					printf_m13("Time Base Units Description: %s\n", vmd2->time_base_units_description);
				else
					printf_m13("Time Base Units Description: no entry\n");
				if (vmd2->session_start_frame_number == VID_METADATA_SESSION_START_FRAME_NUMBER_NO_ENTRY_m13)
					printf_m13("Session Start Frame Number: no entry\n");
				else
					printf_m13("Session Start Frame Number: %ld\n", vmd2->session_start_frame_number);
				if (vmd2->number_of_frames == VID_METADATA_NUMBER_OF_FRAMES_NO_ENTRY_m13)
					printf_m13("Number of Frames: no entry\n");
				else
					printf_m13("Number of Frames: %ld\n", vmd2->number_of_frames);
				if (vmd2->frame_rate == VID_METADATA_FRAME_RATE_NO_ENTRY_m13)
					printf_m13("Frame Rate: no entry\n");
				else if (vmd2->frame_rate == VID_METADATA_FRAME_RATE_VARIABLE_m13)
					printf_m13("Frame Rate: variable\n");
				else
					printf_m13("Frame Rate: %lf (frames per second)\n", vmd2->frame_rate);
				if (vmd2->number_of_clips == VID_METADATA_NUMBER_OF_CLIPS_NO_ENTRY_m13)
					printf_m13("Number of Clips: no entry\n");
				else
					printf_m13("Number of Clips: %ld (~= number of video indices)\n", vmd2->number_of_clips);
				if (vmd2->maximum_clip_bytes == VID_METADATA_MAXIMUM_CLIP_BYTES_NO_ENTRY_m13)
					printf_m13("Maximum Clip Bytes: no entry\n");
				else
					printf_m13("Maximum Clip Bytes: %ld\n", vmd2->maximum_clip_bytes);
				if (vmd2->maximum_clip_frames == VID_METADATA_MAXIMUM_CLIP_FRAMES_NO_ENTRY_m13)
					printf_m13("Maximum Clip Frames: no entry\n");
				else
					printf_m13("Maximum Clip Frames: %ld\n", vmd2->maximum_clip_frames);
				if (vmd2->number_of_video_files == VID_METADATA_NUMBER_OF_VIDEO_FILES_NO_ENTRY_m13)
					printf_m13("Number of Video Files: no entry\n");
				else
					printf_m13("Number of Video Files: %d\n", vmd2->number_of_video_files);
				if (vmd2->maximum_clip_duration == VID_METADATA_MAXIMUM_CLIP_DURATION_NO_ENTRY_m13)
					printf_m13("Maximum Clip Duration: no entry\n");
				else
					printf_m13("Maximum Clip Duration: %lf %s\n", vmd2->maximum_clip_duration, vmd2->time_base_units_description);
				if (vmd2->number_of_discontinuities == VID_METADATA_NUMBER_OF_DISCONTINUITIES_NO_ENTRY_m13)
					printf_m13("Number of Discontinuities: no entry\n");
				else
					printf_m13("Number of Discontinuities: %ld\n", vmd2->number_of_discontinuities);
				if (vmd2->maximum_contiguous_clips == VID_METADATA_MAXIMUM_CONTIGUOUS_CLIPS_NO_ENTRY_m13)
					printf_m13("Maximum Contiguous Clips: no entry\n");
				else
					printf_m13("Maximum Contiguous Clips: %ld\n", vmd2->maximum_contiguous_clips);
				if (vmd2->maximum_contiguous_clip_bytes == VID_METADATA_MAXIMUM_CONTIGUOUS_CLIP_BYTES_NO_ENTRY_m13)
					printf_m13("Maximum Contiguous Clip Bytes: no entry\n");
				else
					printf_m13("Maximum Contiguous Clip Bytes: %ld\n", vmd2->maximum_contiguous_clip_bytes);
				if (vmd2->maximum_contiguous_frames == VID_METADATA_MAXIMUM_CONTIGUOUS_FRAMES_NO_ENTRY_m13)
					printf_m13("Maximum Contiguous Frames: no entry\n");
				else
					printf_m13("Maximum Contiguous Frames: %ld\n", vmd2->maximum_contiguous_frames);
				if (vmd2->horizontal_pixels == VID_METADATA_HORIZONTAL_PIXELS_NO_ENTRY_m13)
					printf_m13("Horizontal Pixels: no entry\n");
				else
					printf_m13("Horizontal Pixels: %u\n", vmd2->horizontal_pixels);
				if (vmd2->vertical_pixels == VID_METADATA_VERTICAL_PIXELS_NO_ENTRY_m13)
					printf_m13("Vertical Pixels: no entry\n");
				else
					printf_m13("Vertical Pixels: %u\n", vmd2->vertical_pixels);
				if (*vmd2->video_format)
					printf_m13("Video Format: %s\n", vmd2->video_format);
				else
					printf_m13("Video Format: no entry\n");
			} else {
				printf_m13("(unrecognized metadata section 2 type)\n");
			}
		} else {
			printf_m13("No access to section 2\n");
		}
		printf_m13("------------------- Section 2 - END --------------------\n");
	}
	
	if (uh) {
		printf_m13("------------------ Section 3 - START -------------------\n");
		if (uh->encryption_3 <= NO_ENCRYPTION_m13) {
			if (md3->recording_time_offset == UUTC_NO_ENTRY_m13)
				printf_m13("Recording Time Offset: no entry\n");
			else
				printf_m13("Recording Time Offset: %ld\n", md3->recording_time_offset);
			if (md3->daylight_time_start_code.value == DTCC_VALUE_NO_ENTRY_m13) {
				printf_m13("Daylight Time Start Code: no entry\n");
			} else {
				STR_hex_m13(hex_str, (ui1 *) &md3->daylight_time_start_code.value, sizeof(ui8), "-", FALSE_m13);
				printf_m13("Daylight Time Start Code: %s\n", hex_str);
			}
			if (md3->daylight_time_end_code.value == DTCC_VALUE_NO_ENTRY_m13) {
				printf_m13("Daylight Time End Code: no entry\n");
			} else {
				STR_hex_m13(hex_str, (ui1 *) &md3->daylight_time_end_code.value, sizeof(ui8), "-", FALSE_m13);
				printf_m13("Daylight Time End Code: %s\n", hex_str);
			}
			if (*md3->standard_timezone_acronym)
				printf_m13("Standard Timezone Acronym: %s\n", md3->standard_timezone_acronym);
			else
				printf_m13("Standard Timezone Acronym: no entry\n");
			if (*md3->standard_timezone_string)
				printf_m13("Standard Timezone String: %s\n", md3->standard_timezone_string);
			else
				printf_m13("Standard Timezone String: no entry\n");
			if (*md3->daylight_timezone_acronym)
				printf_m13("Daylight Timezone Acronym: %s\n", md3->daylight_timezone_acronym);
			else
				printf_m13("Daylight Timezone Acronym: no entry\n");
			if (*md3->daylight_timezone_string)
				printf_m13("Daylight Timezone String: %s\n", md3->daylight_timezone_string);
			else
				printf_m13("Daylight Timezone String: no entry\n");
			if (*md3->subject_name_1)
				printf_m13("Subject Name 1: %s\n", md3->subject_name_1);
			else
				printf_m13("Subject Name 1: no entry\n");
			if (*md3->subject_name_2)
				printf_m13("Subject Name 2: %s\n", md3->subject_name_2);
			else
				printf_m13("Subject Name 2: no entry\n");
			if (*md3->subject_name_3)
				printf_m13("Subject Name 3: %s\n", md3->subject_name_3);
			else
				printf_m13("Subject Name 3: no entry\n");
			if (*md3->subject_ID)
				printf_m13("Subject ID: %s\n", md3->subject_ID);
			else
				printf_m13("Subject ID: no entry\n");
			if (*md3->recording_country)
				printf_m13("Recording Country: %s\n", md3->recording_country);
			else
				printf_m13("Recording Country: no entry\n");
			if (*md3->recording_territory)
				printf_m13("Recording Territory: %s\n", md3->recording_territory);
			else
				printf_m13("Recording Territory: no entry\n");
			if (*md3->recording_locality)
				printf_m13("Recording Locality: %s\n", md3->recording_locality);
			else
				printf_m13("Recording Locality: no entry\n");
			if (*md3->recording_institution)
				printf_m13("Recording Institution: %s\n", md3->recording_institution);
			else
				printf_m13("Recording Institution: no entry\n");
			if (*md3->geotag_format)
				printf_m13("GeoTag Format: %s\n", md3->geotag_format);
			else
				printf_m13("GeoTag Format: no entry\n");
			if (*md3->geotag_data)
				printf_m13("GeoTag Data: %s\n", md3->geotag_data);
			else
				printf_m13("GeoTag Data: no entry\n");
			if (md3->standard_UTC_offset == STANDARD_UTC_OFFSET_NO_ENTRY_m13)
				printf_m13("Standard UTC Offset: no entry\n");
			else
				printf_m13("Standard UTC Offset: %d\n", md3->standard_UTC_offset);
		} else {
			printf_m13("No access to section 3\n");
		}
		printf_m13("------------------- Section 3 - END --------------------\n");
	}
	
	printf_m13("-------------------- Metadata - END --------------------\n\n");
	
	return_m13(TRUE_m13);
}


tern	G_show_password_data_m13(PASSWORD_DATA_m13 *pwd, si1 pw_level)
{
	si1			hex_str[HEX_STR_BYTES_m13(ENCRYPTION_KEY_BYTES_m13, 1)];
	PROC_GLOBS_m13	*proc_globs;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// use G_message_m13() because show_password_data_m13() is used in normal (no programming) functions => so allow output to be suppressed easily
	if (pwd == NULL) {
		proc_globs = G_proc_globs_m13(NULL);
		pwd = &proc_globs->password_data;
	}
	
	G_message_m13("\n------------------ Password Data - START -----------------\n");
	if (pwd->access_level >= LEVEL_1_ACCESS_m13) {
		STR_hex_m13(hex_str, pwd->level_1_encryption_key, ENCRYPTION_KEY_BYTES_m13, "-", FALSE_m13);
		G_message_m13("Level 1 Encryption Key: %s\n", hex_str);
	}
	if (pwd->access_level == LEVEL_2_ACCESS_m13) {
		STR_hex_m13(hex_str, pwd->level_2_encryption_key, ENCRYPTION_KEY_BYTES_m13, "-", FALSE_m13);
		G_message_m13("Level 2 Encryption Key: %s\n", hex_str);
	}
	if (pwd->hints_exist == TRUE_m13)
		G_show_password_hints_m13(pwd, 0);
	G_message_m13("Access Level: %hhu\n", pwd->access_level);
	G_message_m13("Processed: %s\n", STR_tern_m13(BOOL_TO_TERN_m13(pwd->processed)));  // "processed" often treated as boolean in this structure
	G_message_m13("Hints Exist: %s\n", STR_tern_m13(pwd->hints_exist));
	G_message_m13("------------------- Password Data - END ------------------\n\n");
	
	return_m13(TRUE_m13);
}


tern	G_show_password_hints_m13(PASSWORD_DATA_m13 *pwd, si1 pw_level)
{
	PROC_GLOBS_m13	*proc_globs;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// pass level 0 to show all hints
	// use G_message_m13() because show_password_data_m13() is used in normal (not programming) functions => so allow output to be suppressed easily
	
	if (pwd == NULL) {
		proc_globs = G_proc_globs_m13(NULL);
		pwd = &proc_globs->password_data;
	}

	if (pw_level == 1 || pw_level == 0) {
		if (*pwd->level_1_password_hint)
			G_message_m13("Level 1 Password Hint: %s\n", pwd->level_1_password_hint);
		else
			G_message_m13("Level 1 Password Hint: none provided\n");
	}
	if (pw_level == 2 || pw_level == 0) {
		if (*pwd->level_2_password_hint)
			G_message_m13("Level 2 Password Hint: %s\n", pwd->level_2_password_hint);
		else
			G_message_m13("Level 2 Password Hint: none provided\n");
	}

	return_m13(TRUE_m13);
}


tern	G_show_proc_globs_m13(LH_m13 *lh)
{
	si1 		tim_str[TIME_STRING_BYTES_m13], hex_str[HEX_STR_BYTES_m13(sizeof(si8), 1)];
	PROC_GLOBS_m13	*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	proc_globs = G_proc_globs_m13(lh);
	
	printf_m13("\nProcess Globals\n===============\n");
	printf_m13("\n_id: ");
	if (proc_globs->_id == 0) {
		printf_m13("no entry\n");
	} else {
		STR_hex_m13(hex_str, (ui1 *) &proc_globs->_id, sizeof(ui8), NULL, TRUE_m13);
		printf_m13("%lu  (0x%s)\n", proc_globs->_id, hex_str);
	}
	
	printf_m13("\nCurrent Session\n---------------\n");
	STR_hex_m13(hex_str, (ui1 *) &proc_globs->current_session.UID, sizeof(ui8), NULL, TRUE_m13);
	printf_m13("UID: 0x%s  (%lu)\n", hex_str, proc_globs->current_session.UID);
	if (*proc_globs->current_session.directory)
		printf_m13("Directory: \"%s\"\n", proc_globs->current_session.directory);
	else
		printf_m13("Directory: not set\n");
	printf_m13("Start Time: ");
	if (proc_globs->current_session.start_time == UUTC_NO_ENTRY_m13) {
		printf_m13("no entry\n");
	} else if (proc_globs->current_session.start_time == BEGINNING_OF_TIME_m13) {
		printf_m13("beginning of time\n");
	} else if (proc_globs->current_session.start_time == END_OF_TIME_m13) {
		printf_m13("end of time\n");
	} else {
		G_add_behavior_m13(SUPPRESS_WARNING_OUTPUT_m13);
		STR_time_m13(NULL, proc_globs->current_session.start_time, tim_str, TRUE_m13, FALSE_m13, FALSE_m13);
		G_pop_behavior_m13();
		printf_m13("%ld (oUTC)  [%s]\n", proc_globs->current_session.start_time, tim_str);
	}
	printf_m13("End Time: ");
	if (proc_globs->current_session.end_time == UUTC_NO_ENTRY_m13) {
		printf_m13("no entry\n");
	} else if (proc_globs->current_session.end_time == BEGINNING_OF_TIME_m13) {
		printf_m13("beginning of time\n");
	} else if (proc_globs->current_session.end_time == END_OF_TIME_m13) {
		printf_m13("end of time\n");
	} else {
		G_add_behavior_m13(SUPPRESS_WARNING_OUTPUT_m13);
		STR_time_m13(NULL, proc_globs->current_session.end_time, tim_str, TRUE_m13, FALSE_m13, FALSE_m13);
		G_pop_behavior_m13();
		printf_m13("%ld (oUTC)  [%s]\n", proc_globs->current_session.end_time, tim_str);
	}
	if (*proc_globs->current_session.fs_name)
		printf_m13("File System Name: \"%s\"\n", proc_globs->current_session.fs_name);  // from file system
	else
		printf_m13("File System Name: no entry\n");  // from file system
	if (*proc_globs->current_session.uh_name)
		printf_m13("Universal Header Name: \"%s\"\n", proc_globs->current_session.uh_name);  // from file system
	else
		printf_m13("Universal Header Name: no entry\n");  // from file system
	printf_m13("Names Differ: %s\n", STR_tern_m13(proc_globs->current_session.names_differ));
	printf_m13("Number of Segments: ");
	if (proc_globs->current_session.n_segments == 0)
		printf_m13("no entry\n");
	else
		printf_m13("%d\n", proc_globs->current_session.n_segments);
	printf_m13("Number of Mapped Segments: ");
	if (proc_globs->current_session.n_mapped_segments == 0)
		printf_m13("no entry\n");
	else
		printf_m13("%d\n", proc_globs->current_session.n_mapped_segments);
	printf_m13("Index Channel: ");
	if (proc_globs->current_session.index_channel == NULL)
		printf_m13("not set\n");
	else
		printf_m13("set\n");
	printf_m13("Index Channel Name: ");
	if (*proc_globs->current_session.index_channel_name == 0)
		printf_m13("no entry\n");
	else
		printf_m13("\"%s\"\n", proc_globs->current_session.index_channel_name);
	
	printf_m13("\nActive Channels\n---------------\n");
	printf_m13("Time Series:\n");
	printf_m13("\tSampling Frequencies Vary: %s\n", STR_tern_m13(proc_globs->active_channels.sampling_frequencies_vary));
	if (proc_globs->active_channels.minimum_sampling_frequency == RATE_NO_ENTRY_m13)
		printf_m13("\tMinimum Sampling Frequency: no entry\n");
	else
		printf_m13("\tMinimum Sampling Frequency: %0.2lf Hz\n", proc_globs->active_channels.minimum_sampling_frequency);
	if (proc_globs->active_channels.maximum_sampling_frequency == RATE_NO_ENTRY_m13)
		printf_m13("\tMaximum Sampling Frequency: no entry\n");
	else
		printf_m13("\tMaximum Sampling Frequency: %0.2lf Hz\n", proc_globs->active_channels.maximum_sampling_frequency);
	if (proc_globs->active_channels.minimum_sampling_frequency_channel == NULL)
		printf_m13("\tMinimum Sampling Frequency Channel: not set\n");
	else
		printf_m13("\tMinimum Sampling Frequency Channel Name: \"%s\"\n", proc_globs->active_channels.minimum_sampling_frequency_channel->name);
	if (proc_globs->active_channels.maximum_sampling_frequency_channel == NULL)
		printf_m13("\tMaximum Sampling Frequency Channel: not set\n");
	else
		printf_m13("\tMaximum Sampling Frequency Channel Name: \"%s\"\n", proc_globs->active_channels.maximum_sampling_frequency_channel->name);
	printf_m13("Video:\n");
	printf_m13("\tFrame Rates Vary: %s\n", STR_tern_m13(proc_globs->active_channels.frame_rates_vary));
	if (proc_globs->active_channels.minimum_frame_rate == RATE_NO_ENTRY_m13)
		printf_m13("\tMinimum Frame Rate: no entry\n");
	else
		printf_m13("\tMinimum Frame Rate: %0.2lf fps\n", proc_globs->active_channels.minimum_frame_rate);
	if (proc_globs->active_channels.maximum_frame_rate == RATE_NO_ENTRY_m13)
		printf_m13("\tMaximum Frame Rate: no entry\n");
	else
		printf_m13("\tMinimum Frame Rate: %0.2lf fps\n", proc_globs->active_channels.maximum_frame_rate);
	if (proc_globs->active_channels.minimum_frame_rate_channel == NULL)
		printf_m13("\tMinimum Frame Rate Channel: not set\n");
	else
		printf_m13("\tMinimum Frame Rate Channel Name: \"%s\"\n", proc_globs->active_channels.minimum_frame_rate_channel->name);
	if (proc_globs->active_channels.maximum_frame_rate_channel == NULL)
		printf_m13("\tMaximum Frame Rate Channel: not set\n");
	else
		printf_m13("\tMaximum Frame Rate Channel Name: \"%s\"\n", proc_globs->active_channels.maximum_frame_rate_channel->name);

	printf_m13("\nTime Constants\n--------------\n");
	printf_m13("Time Constants Set: %s\n", STR_tern_m13(proc_globs->time_constants.set));
	printf_m13("Recording Time Offset Known: %s\n", STR_tern_m13(proc_globs->time_constants.RTO_known));
	printf_m13("Recording Time Offset: %ld (usecs)\n", proc_globs->time_constants.recording_time_offset);
	printf_m13("Standard UTC Offset: %d (secs)\n", proc_globs->time_constants.standard_UTC_offset);
	printf_m13("Standard Timezone Acronym: %s\n", proc_globs->time_constants.standard_timezone_acronym);
	printf_m13("Standard Timezone String: %s\n", proc_globs->time_constants.standard_timezone_string);
	printf_m13("Daylight Timezone Acronym: %s\n", proc_globs->time_constants.daylight_timezone_acronym);
	printf_m13("Daylight Timezone String: %s\n", proc_globs->time_constants.daylight_timezone_string);
	printf_m13("Observe Daylight Saving Time: %s\n", STR_tern_m13(proc_globs->time_constants.observe_DST));
	STR_hex_m13(hex_str, (ui1 *) &proc_globs->time_constants.daylight_start_code.value, sizeof(si8), "-", FALSE_m13);
	printf_m13("Daylight Time Start Code: 0x %s  (%ld)\n", hex_str, proc_globs->time_constants.daylight_start_code.value);
	STR_hex_m13(hex_str, (ui1 *) &proc_globs->time_constants.daylight_end_code.value, sizeof(si8), "-", FALSE_m13);
	printf_m13("Daylight Time End Code: 0x %s  (%ld)\n", hex_str, proc_globs->time_constants.daylight_end_code.value);
		
	printf_m13("\nMiscellaneous\n---------------\n");
	printf_m13("Memory Map Block Bytes: ");
	if (proc_globs->miscellaneous.mmap_block_bytes == GLOBALS_MMAP_BLOCK_BYTES_NO_ENTRY_m13)
		printf_m13("no entry\n");
	else
		printf_m13("%d\n", proc_globs->miscellaneous.mmap_block_bytes);
	printf_m13("Threading: %s\n", STR_tern_m13(proc_globs->miscellaneous.threading));
	printf_m13("Process Error State: %s\n", STR_tern_m13(proc_globs->miscellaneous.proc_error_state));

	printf_m13("\n");
	
	return_m13(TRUE_m13);
}


tern	G_show_records_m13(FPS_m13 *rec_data_fps, si4 *record_filters)
{
	ui1			*ui1_p;
	si8			i, n_recs, r_cnt;
	REC_HDR_m13	*rh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// record_filters is a signed, "NULL terminated" array version of MED record type codes to include or exclude when reading records.
	// The terminal entry is NO_TYPE_CODE_m13 (== zero). NULL or no filter codes includes all records (== no filters).
	// filter modes: match positive: include
	//		 match negative: exclude
	//		 no match:
	//			all filters positive: exclude
	//			else: include
	// Note: as type codes are composed of ascii bytes values (< 0x80), it is always possible to make them negative without promotion.
	//
	// Example usage: si4	my_rec_filters[] = { REC_Sgmt_TYPE_CODE_m13, REC_Note_TYPE_CODE_m13, NO_TYPE_CODE_m13 };
	//
	// If the passed record_filters is null, the global record_filters will be used.
	// If the global record_filters are NULL, all records will be accepted.
	// If record_filters is a "zero-length" array (i.e. record_filters = { NO_TYPE_CODE_m13 }), all records will be accepted.
	// record_filters
	
	
	if (record_filters == NULL)
		record_filters = globals_m13->record_filters;	// if these too are NULL, no filters applied
	else if (*record_filters == NO_TYPE_CODE_m13)	// Note: if G_read_record_data_m13() with these filters was used to get records, filtering is already done
		record_filters = NULL;			// show all types, even if global filters are not NULL

	
	// show records
	n_recs = rec_data_fps->n_items;
	ui1_p = (void *) rec_data_fps->rec_data;
	for (i = r_cnt = 0; i < n_recs; ++i) {
		rh = (REC_HDR_m13 *) ui1_p;
		if (G_include_record_m13(rh->type_code, record_filters) == TRUE_m13)
			REC_show_record_m13(rec_data_fps, rh, ++r_cnt);
		ui1_p += rh->total_record_bytes;
	}
	
	return_m13(TRUE_m13);
}


tern	G_show_Sgmt_records_m13(LH_m13 *lh, Sgmt_REC_m13 *Sgmt_recs)
{
	si1	  		tim_str[TIME_STRING_BYTES_m13];
	ui4			source;
	si4			n_segs;
	si8			i;
	PROC_GLOBS_m13		*proc_globs;
	Sgmt_REC_m13		*Sgmt;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (Sgmt_recs == NULL) {
		Sgmt_recs = G_Sgmt_records_m13(lh, SAMPLE_SEARCH_m13);
		if (Sgmt_recs == NULL) {
			G_set_error_m13(E_UNKN_m13, "cannot get Sgmt records array");
			return_m13(FALSE_m13);
		}
	}
	source = G_Sgmt_records_source_m13(lh, Sgmt_recs);

	proc_globs = G_proc_globs_m13(lh);
	n_segs = proc_globs->current_session.n_segments;
	if (n_segs == SEGMENT_NUMBER_NO_ENTRY_m13) {  // == 0
		G_set_error_m13(E_UNKN_m13, "empty Sgmt records array");
		return_m13(FALSE_m13);
	}

	Sgmt = Sgmt_recs;
	for (i = 0; i < n_segs; ++i, ++Sgmt) {
		printf_m13("%sRecord number: %ld%s\n", TC_RED_m13, i + 1, TC_RESET_m13);
		if (source == TS_CHAN_TYPE_m13)
			printf_m13("Source: time series channel\n");
		else if (source == VID_CHAN_TYPE_m13)
			printf_m13("Source: video channel\n");
		else
			printf_m13("Source: not specified\n");
		if (Sgmt->start_time == UUTC_NO_ENTRY_m13) {
			printf_m13("Start Time: no entry\n");
		}else {
			G_add_behavior_m13(SUPPRESS_WARNING_OUTPUT_m13);
			STR_time_m13(lh, Sgmt->start_time, tim_str, TRUE_m13, FALSE_m13, FALSE_m13);
			G_pop_behavior_m13();
			printf_m13("Start Time: %ld (oUTC)  [%s]\n", Sgmt->start_time, tim_str);
		}
		if (Sgmt->end_time == UUTC_NO_ENTRY_m13) {
			printf_m13("End Time: no entry\n");
		} else {
			G_add_behavior_m13(SUPPRESS_WARNING_OUTPUT_m13);
			STR_time_m13(lh, Sgmt->end_time, tim_str, TRUE_m13, FALSE_m13, FALSE_m13);
			printf_m13("End Time: %ld (oUTC)  [%s]\n", Sgmt->end_time, tim_str);
			G_pop_behavior_m13();
		}
		if (source == TS_CHAN_TYPE_m13)
			printf_m13("Start Sample Number:");
		else if (source == VID_CHAN_TYPE_m13)
			printf_m13("Start Frame Number:");
		else
			printf_m13("Start Number:");
		if (Sgmt->start_num == REC_Sgmt_v11_START_NUM_NO_ENTRY_m13)
			printf_m13(" no entry\n");
		else
			printf_m13(" %ld\n", Sgmt->start_num);
		if (source == TS_CHAN_TYPE_m13)
			printf_m13("End Sample Number:");
		else if (source == VID_CHAN_TYPE_m13)
			printf_m13("End Frame Number:");
		else
			printf_m13("End Number:");
		if (Sgmt->end_num == REC_Sgmt_v11_START_NUM_NO_ENTRY_m13)
			printf_m13(" no entry\n");
		else
			printf_m13(" %ld\n", Sgmt->end_num);
		if (Sgmt->seg_num == REC_Sgmt_v11_SEG_NUM_NO_ENTRY_m13)
			printf_m13("Segment Number: no entry\n");
		else
			printf_m13("Segment Number: %d\n", Sgmt->seg_num);
		if (source == TS_CHAN_TYPE_m13)
			printf_m13("Sampling Frequency:");
		else if (source == VID_CHAN_TYPE_m13)
			printf_m13("Frame Rate:");
		else
			printf_m13("Rate:");
		if (Sgmt->rate == REC_Sgmt_v11_RATE_NO_ENTRY_m13) {
			printf_m13(" no entry\n");
		} else if (Sgmt->rate == REC_Sgmt_v11_RATE_VARIABLE_m13) {
			printf_m13(" variable\n");
		} else {
			printf_m13(" %0.0f", Sgmt->rate);
			if (source == TS_CHAN_TYPE_m13)
				printf_m13(" Hz\n");
			else if (source == VID_CHAN_TYPE_m13)
				printf_m13(" fps\n");
			else
				printf_m13("\n");
		}
	}
	
	return_m13(TRUE_m13);
}


tern  G_show_slice_m13(SLICE_m13 *slice)
{	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	printf_m13("Conditioned: %s\n", STR_tern_m13(slice->conditioned));
	
	if (slice->n_segs == UNKNOWN_m13)
		printf_m13("Number of Segments: unknown\n");
	else if (slice->n_segs == EMPTY_SLICE_m13)
		printf_m13("Number of Segments: empty slice (segments missing)\n");
	else
		printf_m13("Number of Segments: %d\n", slice->n_segs);

	printf_m13("Start Time: ");
	if (slice->start_time == UUTC_NO_ENTRY_m13)
		printf_m13("no entry\n");
	else if (slice->start_time == BEGINNING_OF_TIME_m13)
		printf_m13("beginning of time\n");
	else if (slice->start_time == END_OF_TIME_m13)
		printf_m13("end of time\n");
	else
		printf_m13("%ld\n", slice->start_time);
	
	printf_m13("End Time: ");
	if (slice->end_time == UUTC_NO_ENTRY_m13)
		printf_m13("no entry\n");
	else if (slice->end_time == BEGINNING_OF_TIME_m13)
		printf_m13("beginning of time\n");
	else if (slice->end_time == END_OF_TIME_m13)
		printf_m13("end of time\n");
	else
		printf_m13("%ld\n", slice->end_time);
	
	printf_m13("Start Sample/Frame Number: ");
	if (slice->start_samp_num == SAMPLE_NUMBER_NO_ENTRY_m13)
		printf_m13("no entry\n");
	else if (slice->start_samp_num == END_OF_SAMPLE_NUMBERS_m13)
		printf_m13("end of samples/frames\n");
	else
		printf_m13("%ld\n", slice->start_samp_num);
	
	printf_m13("End Sample/Frame Number: ");
	if (slice->end_samp_num == SAMPLE_NUMBER_NO_ENTRY_m13)
		printf_m13("no entry\n");
	else if (slice->end_samp_num == END_OF_SAMPLE_NUMBERS_m13)
		printf_m13("end of samples/frames\n");
	else
		printf_m13("%ld\n", slice->end_samp_num);
	
	printf_m13("Start Segment Number: ");
	if (slice->start_seg_num == SEGMENT_NUMBER_NO_ENTRY_m13)
		printf_m13("no entry\n");
	else
		printf_m13("%d\n", slice->start_seg_num);
	
	printf_m13("End Segment Number: ");
	if (slice->end_seg_num == SEGMENT_NUMBER_NO_ENTRY_m13)
		printf_m13("no entry\n");
	else
		printf_m13("%d\n", slice->end_seg_num);
		
	printf_m13("\n");
	
	return_m13(TRUE_m13);
}


tern  G_show_timezone_info_m13(TIMEZONE_INFO_m13 *timezone_entry, tern show_DST_detail)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	printf_m13("Country: %s\n", timezone_entry->country);
	printf_m13("Country Acronym (2 letter): %s\n", timezone_entry->country_acronym_2_letter);
	printf_m13("Country Acronym (3 letter): %s\n", timezone_entry->country_acronym_3_letter);
	if (*timezone_entry->territory)
		printf_m13("Territory: %s\n", timezone_entry->territory);
	if (*timezone_entry->territory_acronym)
		printf_m13("Territory Acronym: %s\n", timezone_entry->territory_acronym);
	printf_m13("Standard Timezone: %s\n", timezone_entry->standard_timezone);
	printf_m13("Standard Timezone Acronym: %s\n", timezone_entry->standard_timezone_acronym);
	printf_m13("Standard UTC Offset (secs): %d\n", timezone_entry->standard_UTC_offset);
	
	if (timezone_entry->daylight_time_start_code) {
		printf_m13("Daylight Timezone: %s\n", timezone_entry->daylight_timezone);
		printf_m13("Daylight Timezone Acronym: %s\n", timezone_entry->daylight_timezone_acronym);
		if (timezone_entry->daylight_time_start_code == DTCC_VALUE_NO_ENTRY_m13) {
			printf_m13("Daylight Time data is not available\n");
		} else if (show_DST_detail == TRUE_m13) {
			printf_m13("Daylight Time Start Code: 0x%lX\n", timezone_entry->daylight_time_start_code);
			G_show_daylight_change_code_m13((DAYLIGHT_TIME_CHANGE_CODE_m13 *) &timezone_entry->daylight_time_start_code, "\t");
			printf_m13("Daylight Time End Code: 0x%lX\n", timezone_entry->daylight_time_end_code);
			G_show_daylight_change_code_m13((DAYLIGHT_TIME_CHANGE_CODE_m13 *) &timezone_entry->daylight_time_end_code, "\t");
		}
	} else {
		printf_m13("Daylight Time is not observed\n");
	}
	
	return_m13(TRUE_m13);
}


tern	G_show_universal_header_m13(FPS_m13 *fps, UH_m13 *uh)
{
	tern	ephemeral_flag;
	si1	hex_str[HEX_STR_BYTES_m13(PASSWORD_VALIDATION_FIELD_BYTES_m13, 1)], time_str[TIME_STRING_BYTES_m13];
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// suppress warnings
	G_add_behavior_m13(SUPPRESS_WARNING_OUTPUT_m13);
	
	// assign
	ephemeral_flag = UNKNOWN_m13;
	if (fps) {
		uh = fps->uh;
		if (fps->params.fp) {
			if (fps->params.fp->fd == FPS_FD_EPHEMERAL_m13)
				ephemeral_flag = TRUE_m13;
			else
				ephemeral_flag = FALSE_m13;
		}
	} else {
		if (uh == NULL) {
			G_set_error_m13(E_UNKN_m13, "invalid input");
			return_m13(FALSE_m13);
		}
	}
	
	printf_m13("---------------- Universal Header - START ----------------\n");
	if (uh->header_CRC == CRC_NO_ENTRY_m13) {
		printf_m13("Header CRC: no entry\n");
	} else {
		STR_hex_m13(hex_str, (ui1 *)  &uh->header_CRC, CRC_BYTES_m13, NULL, TRUE_m13);
		printf_m13("Header CRC: 0x%s\n", hex_str);
	}
	if (uh->body_CRC == CRC_NO_ENTRY_m13) {
		printf_m13("Body CRC: no entry\n");
	} else {
		STR_hex_m13(hex_str, (ui1 *) &uh->body_CRC, CRC_BYTES_m13, NULL, TRUE_m13);
		printf_m13("Body CRC: 0x%s\n", hex_str);
	}
	if (uh->n_entries == UH_NUMBER_OF_ENTRIES_NO_ENTRY_m13) {
		printf_m13("Number of Entries: no entry\n");
	} else {
		printf_m13("Number of Entries: %ld  ", uh->n_entries);
		switch (uh->type_code) {
			case REC_DATA_TYPE_CODE_m13:
				printf_m13("(number of records in the file)\n");
				break;
			case REC_INDS_TYPE_CODE_m13:
				printf_m13("(number of record indices in the file)\n");
				break;
			case TS_METADATA_TYPE_CODE_m13:
			case VID_METADATA_TYPE_CODE_m13:
				if (ephemeral_flag == TRUE_m13)
					printf_m13("(maximum number of records in records files at this level and below)\n");
				else if (ephemeral_flag == FALSE_m13)
					printf_m13("(one metadata entry per metadata file)\n");
				else // UNKNOWN
					printf_m13("(one metadata entry, or maximum number of records in a records file at this level and below)\n");
				break;
			case VID_INDS_TYPE_CODE_m13:
				printf_m13("(number of video indices in the file)\n");
				break;
			case TS_DATA_TYPE_CODE_m13:
				printf_m13("(number of CMP blocks in the file)\n");
				break;
			case TS_INDS_TYPE_CODE_m13:
				printf_m13("(number of time series indices in the file)\n");
				break;
			default:
				printf_m13("\n");
				break;
		}
	}
	if (uh->maximum_entry_size == UH_MAXIMUM_ENTRY_SIZE_NO_ENTRY_m13) {
		printf_m13("Maximum Entry Size: no entry\n");
	} else {
		printf_m13("Maximum Entry Size: %u  ", uh->maximum_entry_size);
		switch (uh->type_code) {
			case REC_DATA_TYPE_CODE_m13:
				printf_m13("(number of bytes in the largest record in the file)\n");
				break;
			case REC_INDS_TYPE_CODE_m13:
				printf_m13("(number of bytes in a record index)\n");
				break;
			case TS_METADATA_TYPE_CODE_m13:
			case VID_METADATA_TYPE_CODE_m13:
				if (ephemeral_flag == TRUE_m13)
					printf_m13("(maximum number of bytes in a record at this level and below)\n");
				else if (ephemeral_flag == FALSE_m13)
					printf_m13("(number of bytes in a metadata structure)\n");
				else // UNKNOWN
					printf_m13("(metadata bytes, or maximum number of bytes in a record at this level and below)\n");
				break;
			case VID_INDS_TYPE_CODE_m13:
				printf_m13("(number of bytes in a video index)\n");
				break;
			case TS_DATA_TYPE_CODE_m13:
				printf_m13("(number of bytes in the largest CMP block in the file)\n");
				break;
			case TS_INDS_TYPE_CODE_m13:
				printf_m13("(number of bytes in a time series index)\n");
				break;
			default:
				printf_m13("\n");
				break;
				
		}
	}
	if (*uh->type_string) {
		STR_hex_m13(hex_str, (ui1 *) uh->type_string, sizeof(ui4), NULL, TRUE_m13);
		printf_m13("Type String: \"%s\"  (code: 0x%s)\n", uh->type_string, hex_str);
	} else {
		printf_m13("Type String: no entry\n");
	}
	if (uh->MED_version_major == UH_MED_VERSION_MAJOR_NO_ENTRY_m13 || uh->MED_version_minor == UH_MED_VERSION_MINOR_NO_ENTRY_m13) {
		if (uh->MED_version_major == UH_MED_VERSION_MAJOR_NO_ENTRY_m13)
			printf_m13("MED Version Major: no entry\n");
		else
			printf_m13("MED Version Major: %hhu\n", uh->MED_version_major);
		if (uh->MED_version_minor == UH_MED_VERSION_MINOR_NO_ENTRY_m13)
			printf_m13("MED Version Minor: no entry\n");
		else
			printf_m13("MED Version Minor: %hhu\n", uh->MED_version_minor);
	} else {
		printf_m13("MED Version: %u.%03hhu\n", uh->MED_version_major, uh->MED_version_minor);
	}
	if (uh->byte_order_code == UH_BYTE_ORDER_CODE_NO_ENTRY_m13) {
		printf_m13("Byte Order Code: no entry ");
	} else {
		printf_m13("Byte Order Code: %hhu ", uh->byte_order_code);
		if (uh->byte_order_code == LITTLE_ENDIAN_m13)
			printf_m13("(little endian)\n");
		else if (uh->byte_order_code == BIG_ENDIAN_m13)
			printf_m13("(big endian)\n");
		else
			printf_m13("(unrecognized code)\n");
	}
	if (uh->session_start_time == UUTC_NO_ENTRY_m13) {
		printf_m13("Session Start Time: no entry\n");
	} else {
		STR_time_m13((LH_m13 *) fps, uh->session_start_time, time_str, TRUE_m13, FALSE_m13, FALSE_m13);
		printf_m13("Session Start Time: %ld (oUTC), %s\n", uh->session_start_time, time_str);
	}
	if (uh->segment_start_time == UUTC_NO_ENTRY_m13) {
		printf_m13("Segment or File Start Time: no entry\n");
	} else {
		STR_time_m13((LH_m13 *) fps, uh->segment_start_time, time_str, TRUE_m13, FALSE_m13, FALSE_m13);
		printf_m13("Segment or File Start Time: %ld (oUTC), %s\n", uh->segment_start_time, time_str);
	}
	if (uh->segment_end_time == UUTC_NO_ENTRY_m13) {
		printf_m13("Segment or File End Time: no entry\n");
	} else {
		STR_time_m13((LH_m13 *) fps, uh->segment_end_time, time_str, TRUE_m13, FALSE_m13, FALSE_m13);
		printf_m13("Segment or File End Time: %ld (oUTC), %s\n", uh->segment_end_time, time_str);
	}
	if (*uh->session_name)
		printf_m13("Session Name: %s\n", uh->session_name);
	else
		printf_m13("Session Name: no entry\n");
	if (*uh->channel_name)
		printf_m13("Channel Name: %s\n", uh->channel_name);
	else
		printf_m13("Channel Name: no entry\n");
	if (uh->segment_number == UH_SEGMENT_NUMBER_NO_ENTRY_m13)
		printf_m13("Segment Number: no entry\n");
	else if (uh->segment_number == UH_CHANNEL_LEVEL_CODE_m13)
		printf_m13("Segment Number: channel level\n");
	else if (uh->segment_number == UH_SESSION_LEVEL_CODE_m13)
		printf_m13("Segment Number: session level\n");
	else
		printf_m13("Segment Number: %d\n", uh->segment_number);
	if (uh->session_UID == UID_NO_ENTRY_m13) {
		printf_m13("Session UID: no entry\n");
	} else {
		STR_hex_m13(hex_str, (void *) &uh->session_UID, UID_BYTES_m13, NULL, TRUE_m13);
		printf_m13("Session UID: 0x%s\n", hex_str);
	}
	if (uh->channel_UID == UID_NO_ENTRY_m13) {
		printf_m13("Channel UID: no entry\n");
	} else {
		STR_hex_m13(hex_str, (void *) &uh->channel_UID, UID_BYTES_m13, NULL, TRUE_m13);
		printf_m13("Channel UID: 0x%s\n", hex_str);
	}
	if (uh->segment_UID == UID_NO_ENTRY_m13) {
		printf_m13("Segment UID: no entry\n");
	} else {
		STR_hex_m13(hex_str, (void *) &uh->segment_UID, UID_BYTES_m13, NULL, TRUE_m13);
		printf_m13("Segment UID: 0x%s\n", hex_str);
	}
	if (uh->file_UID == UID_NO_ENTRY_m13) {
		printf_m13("File UID: no entry\n");
	} else {
		STR_hex_m13(hex_str, (void *) &uh->file_UID, UID_BYTES_m13, NULL, TRUE_m13);
		printf_m13("File UID: 0x%s\n", hex_str);
	}
	if (uh->provenance_UID == UID_NO_ENTRY_m13) {
		printf_m13("Provenance UID: no entry\n");
	} else {
		STR_hex_m13(hex_str, (void *) &uh->provenance_UID, UID_BYTES_m13, NULL, TRUE_m13);
		printf_m13("Provenance UID: 0x%s  ", hex_str);
		if (uh->provenance_UID == uh->file_UID)
			printf_m13("(original)\n");
		else
			printf_m13("(derivative)\n");
	}
	if (G_all_zeros_m13(uh->level_1_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m13) == TRUE_m13) {
		printf_m13("Level 1 Password Validation Field: no entry\n");
	} else {
		STR_hex_m13(hex_str, (void *) uh->level_1_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m13, "-", FALSE_m13);
		printf_m13("Level 1 Password Validation Field: 0x %s\n", hex_str);
	}
	if (G_all_zeros_m13(uh->level_2_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m13) == TRUE_m13) {
		printf_m13("Level 2 Password Validation Field: no entry\n");
	} else {
		STR_hex_m13(hex_str, (void *) uh->level_2_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m13, "-", FALSE_m13);
		printf_m13("Level 2 Password Validation Field: 0x %s\n", hex_str);
	}
	if (G_all_zeros_m13(uh->level_3_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m13) == TRUE_m13) {
		printf_m13("Level 3 Password Validation Field: no entry\n");
	} else {
		STR_hex_m13(hex_str, (void *) uh->level_3_password_validation_field, PASSWORD_VALIDATION_FIELD_BYTES_m13, "-", FALSE_m13);
		printf_m13("Level 3 Password Validation Field: 0x %s\n", hex_str);
	}
	if (MED_VER_1_0_m13(uh) == FALSE_m13) {
		printf_m13("Ordered: %s\n", STR_tern_m13(uh->ordered));
		printf_m13("Expanded Passwords: %s\n", STR_tern_m13(uh->expanded_passwords));
		printf_m13("Encryption Rounds: %hhu\n", uh->encryption_rounds);
		printf_m13("Encryption 1: %hhd ", uh->encryption_1);
		if (uh->encryption_1 == NO_ENCRYPTION_m13)
			printf_m13("(none)\n");
		else if (uh->encryption_1 == LEVEL_1_ENCRYPTION_m13)
			printf_m13("(level 1, currently encrypted)\n");
		else if (uh->encryption_1 == LEVEL_2_ENCRYPTION_m13)
			printf_m13("(level 2, currently encrypted)\n");
		else if (uh->encryption_1 == -LEVEL_1_ENCRYPTION_m13)
			printf_m13("(level 1, currently decrypted)\n");
		else if (uh->encryption_1 == -LEVEL_2_ENCRYPTION_m13)
			printf_m13("(level 2, currently decrypted)\n");
		else if (uh->encryption_1 == ENCRYPTION_VARIABLE_m13)
			printf_m13("(variable encryption)\n");
		else
			printf_m13("(unrecognized code)\n");
		
		printf_m13("Encryption 2: %hhd ", uh->encryption_2);
		if (uh->encryption_2 == NO_ENCRYPTION_m13)
			printf_m13("(none)\n");
		else if (uh->encryption_2 == LEVEL_1_ENCRYPTION_m13)
			printf_m13("(level 1, currently encrypted)\n");
		else if (uh->encryption_2 == LEVEL_2_ENCRYPTION_m13)
			printf_m13("(level 2, currently encrypted)\n");
		else if (uh->encryption_2 == -LEVEL_1_ENCRYPTION_m13)
			printf_m13("(level 1, currently decrypted)\n");
		else if (uh->encryption_2 == -LEVEL_2_ENCRYPTION_m13)
			printf_m13("(level 2, currently decrypted)\n");
		else if (uh->encryption_2 == ENCRYPTION_VARIABLE_m13)
			printf_m13("(variable encryption)\n");
		else
			printf_m13("(unrecognized code)\n");
		
		printf_m13("Encryption 3: %hhd ", uh->encryption_3);
		if (uh->encryption_3 == NO_ENCRYPTION_m13)
			printf_m13("(none)\n");
		else if (uh->encryption_3 == LEVEL_1_ENCRYPTION_m13)
			printf_m13("(level 1, currently encrypted)\n");
		else if (uh->encryption_3 == LEVEL_2_ENCRYPTION_m13)
			printf_m13("(level 2, currently encrypted)\n");
		else if (uh->encryption_3 == -LEVEL_1_ENCRYPTION_m13)
			printf_m13("(level 1, currently decrypted)\n");
		else if (uh->encryption_3 == -LEVEL_2_ENCRYPTION_m13)
			printf_m13("(level 2, currently decrypted)\n");
		else if (uh->encryption_3 == ENCRYPTION_VARIABLE_m13)
			printf_m13("(variable encryption)\n");
		else
			printf_m13("(unrecognized code)\n");
	}

	printf_m13("---------------- Universal Header - END ----------------\n");
	
	G_pop_behavior_m13();

	return_m13(TRUE_m13);
}


tern	G_sort_channels_by_acq_num_m13(SESS_m13 *sess)
{
	tern			read_metadata;
	si1				seg_dir[PATH_BYTES_m13], md_file[PATH_BYTES_m13], num_str[FILE_NUMBERING_DIGITS_m13 + 1];
	si4				i, n_chans, seg_idx;
	CHAN_m13			*chan;
	SEG_m13			*seg;
	FPS_m13	*md_fps;
	ACQ_NUM_SORT_m13		*acq_idxs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Currently function only sort time series channels
	// Returns TRUE if sorted, FALSE if duplicate numbers exist, or other error condition
	
	n_chans = sess->n_ts_chans;
	if (n_chans == 0) {
		G_set_error_m13(E_UNKN_m13, "no time series channels allocated");
		return_m13(FALSE_m13);
	}
	
	// build ACQ_NUM_SORT_m13 array
	acq_idxs = (ACQ_NUM_SORT_m13 *) malloc(n_chans * sizeof(ACQ_NUM_SORT_m13));
	seg_idx = G_segment_index_m13(FIRST_OPEN_SEG_m13, (LH_m13 *) sess);
	*num_str = 0;
	for (i = 0; i < n_chans; ++i) {
		chan = sess->ts_chans[i];
		read_metadata = FALSE_m13;
		if (chan->segs == NULL) {
			read_metadata = TRUE_m13;
		} else {
			seg = chan->segs[seg_idx];
			if (seg == NULL)
				read_metadata = TRUE_m13;
			else if (seg->metadata_fps == NULL)
				read_metadata = TRUE_m13;
		}
		if (read_metadata == TRUE_m13) {
			if (*num_str == 0)
				STR_fixed_width_int_m13(num_str, FILE_NUMBERING_DIGITS_m13, seg_idx + 1);
			sprintf_m13(seg_dir, "%s/%s_s%s.%s", chan->path, chan->name, num_str, TS_SEG_TYPE_STR_m13);
			sprintf_m13(md_file, "%s/%s_s%s.%s", seg_dir, chan->name, num_str, TS_METADATA_TYPE_STR_m13);
			if (G_exists_m13(md_file) == FILE_EXISTS_m13) {
				md_fps = FPS_read_m13(NULL, 0, FPS_FULL_FILE_m13, 1, NULL, md_file, "r", NULL, NULL);
				if (md_fps == NULL) {
					free((void *) acq_idxs);
					return_m13(FALSE_m13);
				}
			} else {
				free((void *) acq_idxs);
				G_set_error_m13(E_UNKN_m13, "metadata file \"%s\" is missing\n", md_file);
				return_m13(FALSE_m13);
			}
			acq_idxs[i].acq_num = md_fps->metadata->time_series_section_2.acquisition_channel_number;
			FPS_free_m13(&md_fps);
		} else {
			seg = chan->segs[seg_idx];
			acq_idxs[i].acq_num = seg->metadata_fps->metadata->time_series_section_2.acquisition_channel_number;
		}
		acq_idxs[i].chan = chan;
	}
		
	// sort
	qsort((void *) acq_idxs, (size_t) n_chans, sizeof(ACQ_NUM_SORT_m13), G_compare_acq_nums_m13);
	
	// check for duplicates
	for (i = 1; i < n_chans; ++i)
		if (acq_idxs[i].acq_num == acq_idxs[i - 1].acq_num)
			break;
	if (i < n_chans) {
		G_warning_message_m13("%s(): duplicate acquisition channel numbers => not sorting\n", __FUNCTION__);
		free((void *) acq_idxs);
		return_m13(FALSE_m13);
	}

	// move channel pointers
	for (i = 0; i < n_chans; ++i)
		sess->ts_chans[i] = acq_idxs[i].chan;
	free((void *) acq_idxs);

	return_m13(TRUE_m13);
}


tern	G_sort_records_m13(FPS_m13 *rec_inds_fps, FPS_m13 *rec_data_fps)
{
	static tern		message_given = FALSE_m13;
	tern			ri_open, rd_open;
	ui1			*tmp_rec_data;
	si1			path[PATH_BYTES_m13], name[SEG_NAME_BYTES_m13];
	si8			i, n_recs, file_start_time;
	FPS_m13			*ri_fps, *rd_fps;
	REC_IDX_m13		*ri;
	REC_HDR_m13		*rh;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// call with either rec_inds_fps or rec_data_fps, other can be NULL, but both will be processed
	// this process is not terribly efficient, but should only need to be done once
	
	
	if (globals_m13->write_sorted_records == FALSE_m13)
		return_m13(FALSE_m13);

	ri_fps = rec_inds_fps;
	rd_fps = rec_data_fps;
	ri_open = FPS_is_open_m13(ri_fps);
	rd_open = FPS_is_open_m13(ri_fps);
	if (ri_fps) {
		FPS_read_m13(ri_fps, 0, FPS_FULL_FILE_m13, 0, NULL, NULL);
		if (rd_fps == NULL) {
			G_path_parts_m13(ri_fps->path, path, name, NULL);
			sprintf_m13(path, "%s/%s.%s", path, name, REC_DATA_TYPE_STR_m13);
			rd_fps = FPS_read_m13(NULL, 0, FPS_FULL_FILE_m13, 0, NULL, path, "r", NULL, NULL);
		} else {
			rd_fps = FPS_read_m13(rd_fps, 0, FPS_FULL_FILE_m13, 0, NULL);
		}
	} else if (rd_fps) {
		FPS_read_m13(rd_fps, 0, FPS_FULL_FILE_m13, 0, NULL, NULL);
		if (ri_fps == NULL) {
			ri_open = FALSE_m13;
			G_path_parts_m13(rd_fps->path, path, name, NULL);
			sprintf_m13(path, "%s/%s.%s", path, name, REC_INDS_TYPE_STR_m13);
			ri_fps = FPS_read_m13(NULL, 0, FPS_FULL_FILE_m13, 0, NULL, path, "r", NULL, NULL);
		} else {
			ri_fps = FPS_read_m13(ri_fps, 0, FPS_FULL_FILE_m13, 0, NULL);
		}
	} else {
		G_set_error_m13(E_UNKN_m13, "both FPSs are NULL");
		return_m13(FALSE_m13);
	}
	if (ri_fps == NULL || ri_fps == NULL)
		return_m13(FALSE_m13);

	// check if already sorted
	if (ri_fps->uh->ordered == TRUE_m13 && rd_fps->uh->ordered == TRUE_m13)
		return_m13(TRUE_m13);

	if (message_given == FALSE_m13) {
		G_message_m13("Sorting records ...\n");
		message_given = TRUE_m13;
	}
		
	// fix any no-entry start times
	n_recs = rd_fps->n_items;
	ri = ri_fps->rec_inds;
	file_start_time = ri_fps->uh->file_start_time;
	for (i = n_recs; i--; ++ri) {
		if (ri->start_time == UUTC_NO_ENTRY_m13) {
			rh = (REC_HDR_m13 *) (rd_fps->params.raw_data + ri->file_offset);
			ri->start_time = rh->start_time = file_start_time;
		}
	}
	
	// sort indices (leave file offsets intact)
	qsort((void *) ri_fps->rec_inds, (size_t) n_recs, sizeof(REC_IDX_m13), G_compare_record_index_times);  // leave terminal index where it is
	
	// copy record data before writing
	tmp_rec_data = (ui1 *) malloc((size_t) rd_fps->params.raw_data_bytes);
	memcpy((void *) tmp_rec_data, (void *) rd_fps->params.raw_data, (size_t) rd_fps->params.raw_data_bytes);
			
	// reopen files for reading & writing
	freopen_m13(NULL, "r+", ri_fps->params.fp);
	freopen_m13(NULL, "r+", rd_fps->params.fp);

	// set file pointers to start of entries
	FPS_seek_m13(ri_fps, UH_BYTES_m13);
	ri_fps->params.fp->len = UH_BYTES_m13;
	FPS_seek_m13(rd_fps, UH_BYTES_m13);
	rd_fps->params.fp->len = UH_BYTES_m13;

	// write out sorted records
	ri = ri_fps->rec_inds;
	for (i = n_recs; i--; ++ri) {
		rh = (REC_HDR_m13 *) (tmp_rec_data + ri->file_offset);
		ri->file_offset = rd_fps->params.fp->len;
		FPS_write_m13(ri_fps, FPS_APPEND_m13, INDEX_BYTES_m13, 1, (void *) ri);
		FPS_write_m13(rd_fps, FPS_APPEND_m13, rh->total_record_bytes, 1, (void *) rh);
	}
	
	// update record data universal header
	rd_fps->uh->ordered = TRUE_m13;
	rd_fps->direcs.flags |= FPS_DF_UPDATE_UH_m13;
	if (rd_open == FALSE_m13)
		rd_fps->direcs.flags |= FPS_DF_CLOSE_AFTER_OP_m13;
	FPS_write_m13(rd_fps, 0, FPS_UH_ONLY_m13, 0, NULL);

	// write terminal index
	ri->file_offset = rd_fps->params.fp->len;
	ri->start_time = ri_fps->uh->segment_end_time + 1;
	ri->type_code = REC_Term_TYPE_CODE_m13;
	ri->version_major = 0xFF;
	ri->version_minor = 0xFF;
	ri->encryption_level = NO_ENCRYPTION_m13;
	
	// write out terminal index & update universal header
	ri_fps->uh->ordered = TRUE_m13;
	ri_fps->direcs.flags |= FPS_DF_UPDATE_UH_m13;
	if (ri_open == FALSE_m13)
		ri_fps->direcs.flags |= FPS_DF_CLOSE_AFTER_OP_m13;
	FPS_write_m13(ri_fps, FPS_APPEND_m13, INDEX_BYTES_m13, 1, (void *) ri);

	// clean up
	free((void *) tmp_rec_data);
		
	return_m13(TRUE_m13);
}


tern	G_terminal_entry_m13(si1 *prompt, si1 type, void *buffer, void *default_input, tern required, tern validate)
{
	si8	items;
	si1	local_buffer[128], local_prompt[128];
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (default_input) {
		if (type == RC_STRING_TYPE_m13)
			if (*((si1 *) default_input) == 0)
				default_input = NULL;
	}

GET_TERMINAL_ENTRY_RETRY_m13:
	
	if (required == TRUE_m13)
		sprintf_m13(local_prompt, "* %s", prompt);
	else
		strcpy(local_prompt, prompt);

	// clear
	if (buffer != default_input) {
		switch (type) {
			case RC_STRING_TYPE_m13:
				*((si1 *) buffer) = 0;
				break;
			case RC_FLOAT_TYPE_m13:
				*((sf8 *) buffer) = (sf8) 0;
				break;
			case RC_INTEGER_TYPE_m13:
				*((si8 *) buffer) = (si8) 0;
				break;
			case RC_TERNARY_TYPE_m13:
				*((si1 *) buffer) = (si1) 0;
				break;
			default:
				G_set_error_m13(E_UNKN_m13, "unrecognized data type");
				return_m13(FALSE_m13);
		}
	}

	if (default_input) {
		switch (type) {
			case RC_STRING_TYPE_m13:
				sprintf_m13(local_prompt, "%s [%s]", local_prompt, (si1 *) default_input);
				break;
			case RC_FLOAT_TYPE_m13:
				sprintf_m13(local_prompt, "%s [%lf]", local_prompt, *((sf8 *) default_input));
				break;
			case RC_INTEGER_TYPE_m13:
				sprintf_m13(local_prompt, "%s [%ld]", local_prompt, *((si8 *) default_input));
				break;
			case RC_TERNARY_TYPE_m13:
				sprintf_m13(local_prompt, "%s [%hhd]", local_prompt, *((si1 *) default_input));
				break;
		}
	}
		
	printf_m13("%s: ", local_prompt);
	fflush(stdout);
	items = scanf("%[^\n]", (si1 *) local_buffer);
	if (items) {
		switch (type) {
			case RC_STRING_TYPE_m13:
				strcpy((si1 *) buffer, local_buffer);
				break;
			case RC_FLOAT_TYPE_m13:
				*((sf8 *) buffer) = strtod(local_buffer, NULL);
				break;
			case RC_INTEGER_TYPE_m13:
				*((si8 *) buffer) = (si8) strtol(local_buffer, NULL, 10);
				break;
			case RC_TERNARY_TYPE_m13:
				*((si1 *) buffer) = (si1) strtol(local_buffer, NULL, 10);
				break;
		}
	}
	getchar();  // clear '\n' from stdin
	
	if (items == 0 && default_input && buffer != default_input) {
		switch (type) {
			case RC_STRING_TYPE_m13:
				strcpy((si1 *) buffer, (si1 *) default_input);
				break;
			case RC_FLOAT_TYPE_m13:
				*((sf8 *) buffer) = *((sf8 *) default_input);
				break;
			case RC_INTEGER_TYPE_m13:
				*((si8 *) buffer) = *((si8 *) default_input);
				break;
			case RC_TERNARY_TYPE_m13:
				*((si1 *) buffer) = *((si1 *) default_input);
				break;
		}
	}

	if (validate == TRUE_m13) {
		if (items == 1 || default_input) {
			switch (type) {
				case RC_STRING_TYPE_m13:
					printf_m13("\tIs %s\"%s\"%s correct (y/n): ", TC_RED_m13, (si1 *) buffer, TC_RESET_m13);
					break;
				case RC_FLOAT_TYPE_m13:
					printf_m13("\tIs %s%lf%s correct (y/n): ", TC_RED_m13, *((sf8 *) buffer), TC_RESET_m13);
					break;
				case RC_INTEGER_TYPE_m13:
					printf_m13("\tIs %s%ld%s correct (y/n): ", TC_RED_m13, *((si8 *) buffer), TC_RESET_m13);
					break;
				case RC_TERNARY_TYPE_m13:
					printf_m13("\tIs %s%hhd%s correct (y/n): ", TC_RED_m13, *((si1 *) buffer), TC_RESET_m13);
					break;
			}
		} else {
			printf_m13("\tIs %s<no entry>%s correct (y/n): ", TC_RED_m13, TC_RESET_m13);
		}
		fflush(stdout);
		*local_buffer = 0;
		scanf("%[^\n]", local_buffer);
		getchar();  // clear '\n' from stdin
		if (*local_buffer == 'y' || *local_buffer == 'Y') {
			required = FALSE_m13;
		} else {
			default_input = NULL;  // in case user wanted no entry instead of default
			goto GET_TERMINAL_ENTRY_RETRY_m13;
		}
	}

	if (items == 0 && required == TRUE_m13) {
		*local_buffer = 0;
		G_warning_message_m13("No entry in required field\n");
		goto GET_TERMINAL_ENTRY_RETRY_m13;
	}
	
	putchar('\n');

	return_m13(TRUE_m13);
}


tern	G_terminal_password_bytes_m13(si1 *password, si1 *password_bytes)
{
	si1	*s;
	si4	i, cb;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// get terminal (most unique) bytes of UTF-8 password characters

	s = password;
	for (i = 0; *s; ++i) {
		cb = UTF8_char_bytes_m13(s);
		if (cb) {
			password_bytes[i] = *(s + (cb - 1));
			s += cb;
		} else {
			G_set_error_m13(E_UNKN_m13, "invalid character");
			return_m13(FALSE_m13);
		}
	}

	// zero rest of bytes
	for (; i < PASSWORD_BYTES_m13; ++i)
		password_bytes[i] = 0;
	
	return_m13(TRUE_m13);
}
		
		
#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	G_ternary_entry_m13(si1 *entry)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (STR_empty_m13(entry) == TRUE_m13) {
		G_warning_message_m13("%s(): empty string => returning UNKNOWN\n", __FUNCTION__);
		return_m13(UNKNOWN_m13);
	}
		  
	switch (*entry) {
		case 't':  // "true" case
		case 'T':  // "True / TRUE" case
		case 'y':  // "yes" case
		case 'Y':  // "Yes / YES" case
		case '1':  // ternary case
			return_m13(TRUE_m13);
			break;
		case 'f':  // "false" case
		case 'F':  // "False / FALSE" case
		case 'n':  // "no" case
		case 'N':  // "No / NO" case
			return_m13(FALSE_m13);
			break;
		case '-':  // possibly ternary case
			if (*(entry + 1) == '1')
				return_m13(FALSE_m13);
			break;
		case 'u':  // "unknown" case
		case 'U':  // "Unknown / UNKNOWN" case
		case '0':  // ternary case
			return_m13(UNKNOWN_m13);
			break;
	}
		  
	G_warning_message_m13("%s(): unrecognized pattern => returning UNKNOWN\n", __FUNCTION__);
	  
	return_m13(UNKNOWN_m13);
}


tern  G_textbelt_text_m13(si1 *phone_number, si1 *content, si1 *textbelt_key)
{
	si1 command[1024];
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (STR_empty_m13(phone_number) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "phone number is empty");
		return_m13(FALSE_m13);
	}
	if (STR_empty_m13(content) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "content is empty");
		return_m13(FALSE_m13);
	}
	if (STR_empty_m13(textbelt_key) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "key is empty");
		return_m13(FALSE_m13);
	}

#if defined MACOS_m13 || defined LINUX_m13
	sprintf(command, "/usr/bin/curl --connect-timeout 5.0 -X POST https://textbelt.com/text --data-urlencode phone='%s' --data-urlencode message='%s' -d key=%s > %s 2>&1", phone_number, content, textbelt_key, NULL_DEVICE_m13);
	system(command);
#endif
#ifdef WINDOWS_m13
	sprintf(command, "curl.exe --connect-timeout 5.0 -X POST https://textbelt.com/text --data-urlencode phone=\"%s\" --data-urlencode message=\"%s\" -d key=%s > %s 2>&1", phone_number, content, textbelt_key, NULL_DEVICE_m13);
	WN_system_m13(command);
#endif

	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_thread_exit_m13(void)
{
	BEHAVIOR_STACK_m13	*b_stack;

	
	// called by return_thread_m13()
	
	b_stack = G_behavior_stack_m13();
	if (b_stack) {
		b_stack->_id = 0;
		b_stack->top_idx = -1;
	}
	
	#ifdef FT_DEBUG_m13
	FUNCTION_STACK_m13	*f_stack;
	
	f_stack = G_function_stack_m13(0);
	if (f_stack) {
		// release function stack unless this thread set causal error set
		if (globals_m13->error.code) {
			if (globals_m13->error.thread_id != gettid_m13()) {
				f_stack->top_idx = -1;
				f_stack->_id = f_stack->_pid = 0;
			}
		}
	}
	#endif
	
	return;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
FILE_m13	*G_unique_temp_file_m13(void)
{
	si1		temp_name[PATH_BYTES_m13];
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	G_unique_temp_file_name_m13(temp_name);
	
	return_m13(fopen_m13(temp_name, "w+"));
}


si1	*G_unique_temp_file_name_m13(si1 *temp_name)
{
	ui8	rand_val;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// use instead of globals_m13->temp_file for anything that could be threaded
	
	// if NULL is passed, caller is responsible for freeing
	if (temp_name == NULL)
		temp_name = (si1 *) malloc_m13((size_t) PATH_BYTES_m13);
	
	do {
		#if defined MACOS_m13 || defined LINUX_m13
		rand_val = (ui8) random();
		rand_val <<= 32;
		rand_val |= (ui8) random();
		#endif
		
		#ifdef WINDOWS_m13
		rand_val = (ui8) rand();
		rand_val <<= 16;
		rand_val |= (ui8) rand();
		rand_val <<= 16;
		rand_val |= (ui8) rand();
		rand_val <<= 16;
		rand_val |= (ui8) rand();
		#endif
		
		sprintf_m13(temp_name, "%s/MED_junk_%016lx", globals_m13->temp_dir, rand_val);
		
	} while (G_exists_m13(temp_name) == TRUE_m13);
	
	return_m13(temp_name);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	G_update_access_time_m13(LH_m13 *lh)
{
	si8	acc;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	acc = G_current_uutc_m13();
	do {
		lh->access_time = acc;
		lh = lh->parent;
	} while (lh);

	return_void_m13;
}


tern	G_update_channel_name_m13(CHAN_m13 *chan)
{
	static tern	message_given = FALSE_m13;
	si1		**file_list, **seg_list, **vid_list, path[PATH_BYTES_m13], tmp_path[PATH_BYTES_m13];
	si1		fs_name[NAME_BYTES_m13], name[MAX_NAME_BYTES_m13], sufx[8];
	si4		i, j, n_files, n_segs, n_vids;
	si8		len;
	
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (chan == NULL) {
		G_set_error_m13(E_UNKN_m13, "channel is NULL");
		return_m13(FALSE_m13);
	}
	
	if (message_given == FALSE_m13) {  // don't want message given for every channel - could be a lot
		G_message_m13("Updating channel names ...\n");
		message_given = TRUE_m13;
	}
	
	G_path_parts_m13(chan->path, NULL, fs_name, NULL);
	strcpy(chan->name, fs_name);
	
	// channel record indices
	file_list = G_file_list_m13(NULL, &n_files, chan->path, NULL, REC_INDS_TYPE_STR_m13, GFL_NAME_m13);
	if (n_files) {
		sprintf_m13(path, "%s/%s.%s", chan->path, fs_name, REC_INDS_TYPE_STR_m13);
		G_path_parts_m13(file_list[0], NULL, name, NULL);
		if (strcmp_m13(fs_name, name))
			mv_m13(file_list[0], path);
		free_m13((void *) file_list);
		G_update_channel_name_header_m13(path, fs_name);
	}
	
	// channel record data
	file_list = G_file_list_m13(NULL, &n_files, chan->path, NULL, REC_DATA_TYPE_STR_m13, GFL_NAME_m13);
	if (n_files) {
		sprintf_m13(path, "%s/%s.%s", chan->path, fs_name, REC_DATA_TYPE_STR_m13);
		G_path_parts_m13(file_list[0], NULL, name, NULL);
		if (strcmp_m13(fs_name, name))
			mv_m13(file_list[0], path);
		free_m13((void *) file_list);
		G_update_channel_name_header_m13(path, fs_name);
	}
	
	// time series segments
	seg_list = G_file_list_m13(NULL, &n_segs, chan->path, NULL, TS_SEG_TYPE_STR_m13, GFL_FULL_PATH_m13);
	if (n_segs) {
		for (i = 0; i < n_segs; ++i) {
			
			// rename directory
			G_path_parts_m13(seg_list[i], NULL, name, NULL);
			len = strlen(name);
			name[len - 5] = 0;
			if (strcmp_m13(fs_name, name)) {
				STR_replace_pattern_m13(name, fs_name, seg_list[i], path);
				mv_m13(seg_list[i], path);
				strcpy(seg_list[i], path);
			}
			name[len - 5] = '_';
			
			// time series metadata
			sprintf_m13(path, "%s/%s.%s", seg_list[i], name, TS_METADATA_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13) {
				STR_replace_pattern_m13(name, fs_name, path, tmp_path);
				mv_m13(path, tmp_path);
				G_update_channel_name_header_m13(tmp_path, fs_name);
			}
			
			// time series indices
			sprintf_m13(path, "%s/%s.%s", seg_list[i], name, TS_INDS_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13) {
				STR_replace_pattern_m13(name, fs_name, path, tmp_path);
				mv_m13(path, tmp_path);
				G_update_channel_name_header_m13(tmp_path, fs_name);
			}
			
			// time series data
			sprintf_m13(path, "%s/%s.%s", seg_list[i], name, TS_DATA_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13) {
				STR_replace_pattern_m13(name, fs_name, path, tmp_path);
				mv_m13(path, tmp_path);
				G_update_channel_name_header_m13(tmp_path, fs_name);
			}
			
			// segment record indices
			sprintf_m13(path, "%s/%s.%s", seg_list[i], name, REC_INDS_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13) {
				STR_replace_pattern_m13(name, fs_name, path, tmp_path);
				mv_m13(path, tmp_path);
				G_update_channel_name_header_m13(tmp_path, fs_name);
			}
			
			// segment record data
			sprintf_m13(path, "%s/%s.%s", seg_list[i], name, REC_DATA_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13) {
				STR_replace_pattern_m13(name, fs_name, path, tmp_path);
				mv_m13(path, tmp_path);
				G_update_channel_name_header_m13(tmp_path, fs_name);
			}
		}
		free_m13((void *) seg_list);
	}
	
	// video segments
	seg_list = G_file_list_m13(NULL, &n_segs, chan->path, NULL, VID_SEG_TYPE_STR_m13, GFL_FULL_PATH_m13);
	if (n_segs) {
		for (i = 0; i < n_segs; ++i) {
			
			// rename directory
			G_path_parts_m13(seg_list[i], NULL, name, NULL);
			len = strlen(name);
			strcpy(sufx, name + (len - 5));
			name[len - 5] = 0;
			if (strcmp_m13(fs_name, name)) {
				STR_replace_pattern_m13(name, fs_name, seg_list[i], path);
				mv_m13(seg_list[i], path);
				strcpy(seg_list[i], path);
			}
			
			// video metadata
			sprintf_m13(tmp_path, "%s/%s%s.%s", seg_list[i], name, sufx, VID_METADATA_TYPE_STR_m13);
			if (G_exists_m13(tmp_path) == TRUE_m13) {
				sprintf_m13(path, "%s/%s%s.%s", seg_list[i], fs_name, sufx, VID_METADATA_TYPE_STR_m13);
				mv_m13(tmp_path, path);
				G_update_channel_name_header_m13(path, fs_name);
			}
			
			// video indices
			sprintf_m13(tmp_path, "%s/%s%s.%s", seg_list[i], name, sufx, VID_INDS_TYPE_STR_m13);
			if (G_exists_m13(tmp_path) == TRUE_m13) {
				sprintf_m13(path, "%s/%s%s.%s", seg_list[i], fs_name, sufx, VID_INDS_TYPE_STR_m13);
				mv_m13(tmp_path, path);
				G_update_channel_name_header_m13(path, fs_name);
			}
			
			// video data
			vid_list = G_file_list_m13(NULL, &n_vids, seg_list[i], "*_n????", NULL, GFL_FULL_PATH_m13);
			if (n_vids) {
				for (j = 0; j < n_vids; ++j) {
					STR_replace_pattern_m13(name, fs_name, vid_list[i], path);
					mv_m13(vid_list[i], path);
					G_update_channel_name_header_m13(path, fs_name);
				}
				free_m13((void *) vid_list);
			}
			
			// segment record indices
			sprintf_m13(tmp_path, "%s/%s%s.%s", seg_list[i], name, sufx, REC_INDS_TYPE_STR_m13);
			if (G_exists_m13(tmp_path) == TRUE_m13) {
				sprintf_m13(path, "%s/%s%s.%s", seg_list[i], fs_name, sufx, REC_INDS_TYPE_STR_m13);
				mv_m13(tmp_path, path);
				G_update_channel_name_header_m13(path, fs_name);
			}
			
			// segment record data
			sprintf_m13(tmp_path, "%s/%s%s.%s", seg_list[i], name, sufx, REC_DATA_TYPE_STR_m13);
			if (G_exists_m13(tmp_path) == TRUE_m13) {
				sprintf_m13(path, "%s/%s%s.%s", seg_list[i], fs_name, sufx, REC_DATA_TYPE_STR_m13);
				mv_m13(tmp_path, path);
				G_update_channel_name_header_m13(path, fs_name);
			}
		}
		free_m13((void *) seg_list);
	}
	
	return_m13(TRUE_m13);
}


tern	G_update_channel_name_header_m13(si1 *path, si1 *fs_name)  // used by G_update_chan_name_m13
{
	size_t		nr, nw;
	FILE		*fp;
	UH_m13		uh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// not using medlib versions of standard functions here for speed
	
#if defined MACOS_m13 || defined LINUX_m13
	fp = fopen(path, "r+");
#endif
#ifdef WINDOWS_m13
	fp = fopen(path, "rb+");
#endif
	if (fp == NULL) {
		G_set_error_m13(E_OPEN_m13, NULL);
		return_m13(FALSE_m13);
	}
	nr = fread((void *) &uh, sizeof(ui1), (size_t) UH_BYTES_m13, fp);
	if (nr != UH_BYTES_m13) {
		fclose(fp);
		G_set_error_m13(E_READ_m13, NULL);
		return_m13(FALSE_m13);
	}
	if (strcmp_m13(uh.channel_name, fs_name)) {
		strncpy(uh.channel_name, fs_name, NAME_BYTES_m13);
		uh.header_CRC = CRC_calculate_m13((ui1 *) &uh + UH_HEADER_CRC_START_OFFSET_m13, UH_BYTES_m13 - UH_HEADER_CRC_START_OFFSET_m13);
#if defined MACOS_m13 || defined LINUX_m13
		fseek(fp, 0, SEEK_SET);
#endif
#ifdef WINDOWS_m13
		_fseeki64(fp, 0, SEEK_SET);
#endif
		nw = fwrite((void *) &uh, sizeof(ui1), (size_t) UH_BYTES_m13, fp);
		if (nw != UH_BYTES_m13) {
			fclose(fp);
			G_set_error_m13(E_WRITE_m13, NULL);
			return_m13(FALSE_m13);
		}
	}
	fclose(fp);

	return_m13(TRUE_m13);
}


tern	G_update_maximum_entry_size_m13(FPS_m13 *fps, si8 n_bytes, si8 n_items, si8 offset)
{
	ui4				entry_size;
	si8				i;
	REC_HDR_m13		*rh;
	CMP_FIXED_BH_m13	*bh;
	UH_m13		*uh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	uh = fps->uh;
	switch (uh->type_code) {
		case TS_INDS_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
		case REC_INDS_TYPE_CODE_m13:
			uh->maximum_entry_size = INDEX_BYTES_m13;
			return_m13(TRUE_m13);
		case TS_METADATA_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
			uh->maximum_entry_size = METADATA_BYTES_m13;
			return_m13(TRUE_m13);
	}
	
	if (n_items == 1) {
		if (uh->maximum_entry_size < n_bytes)
			uh->maximum_entry_size = n_bytes;
		return_m13(TRUE_m13);
	}
	
	FPS_set_pointers_m13(fps, offset);
	switch (uh->type_code) {
		case TS_DATA_TYPE_CODE_m13:
			bh = fps->params.cps->block_header;
			for (i = 0; i < n_items; ++i) {
				entry_size = (si8) bh->total_block_bytes;
				if (uh->maximum_entry_size < entry_size)
					uh->maximum_entry_size = entry_size;
				bh = (CMP_FIXED_BH_m13 *) ((ui1 *) bh + entry_size);
			}
			break;
		case REC_DATA_TYPE_CODE_m13:
			rh = (REC_HDR_m13 *) fps->rec_data;
			for (i = 0; i < n_items; ++i) {
				entry_size = (si8) rh->total_record_bytes;
				if (uh->maximum_entry_size < entry_size)
					uh->maximum_entry_size = entry_size;
				rh = (REC_HDR_m13 *) ((ui1 *) rh + entry_size);
			}
			break;
	}
		
	return_m13(TRUE_m13);
}


tern	G_update_MED_type_m13(si1 *path)
{
	ui1				*rd, *encryption_key, *block, *recd;
	si1				tmp_path[PATH_BYTES_m13], *c1, *c2;
	ui4				type_code, bh_clear_mask, temp_CRC, full_CRC;
	si8				i, fpos, bytes_to_read, bytes_to_write, n_blocks;
	si8				body_bytes, description_bytes;
	size_t				nr, nw;
	PROC_GLOBS_m13			*proc_globs;
	FILE_m13			*fp, *tmp_fp;
	UH_m13				*uh;
	METADATA_SECTION_1_m13		*md1;
	CMP_FIXED_BH_m13		*bh;
	REC_IDX_m13			*ri;
	REC_HDR_m13			*rh;
	REC_Sgmt_v10_m13		Sgmt_v10;
	REC_Sgmt_v11_m13		*Sgmt_v11;
	PASSWORD_DATA_m13		*pwd;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (G_exists_m13(path) == FALSE_m13)
		return_m13(FALSE_m13);

	fp = fopen_m13(path, "r+");
	if (fp == NULL)
		return_m13(FALSE_m13);

	// metadata
	type_code = G_MED_type_code_from_string_m13(path);
	if (METADATA_CODE_m13(type_code) == TRUE_m13) {

		// read in raw data
		bytes_to_read = METADATA_FILE_BYTES_m13;
		rd = (ui1 *) malloc_m13((size_t) bytes_to_read);
		if (rd == NULL) {
			fclose_m13(fp);
			return_m13(FALSE_m13);
		}
		fseek_m13(fp, 0, SEEK_SET);
		nr = fread_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_read, fp);
		if (nr != bytes_to_read) {
			FILE_show_m13(fp);
			fclose_m13(fp);
			free_m13((void *) rd);
			return_m13(FALSE_m13);
		}
				
		// set up
		uh = (UH_m13 *) rd;
		md1 = (METADATA_SECTION_1_m13 *) (rd + METADATA_SECTION_1_OFFSET_m13);  // unencrypted section

		// update version
		uh->MED_version_major = MED_FORMAT_VERSION_MAJOR_m13;
		uh->MED_version_minor = MED_FORMAT_VERSION_MINOR_m13;
		
		// update fields: no overlaps, no encryption
		
		// ordered
		uh->ordered = UNKNOWN_m13;
		
		// encryption
		uh->expanded_passwords = FALSE_m13;  // not available in MED 1.0
		uh->encryption_1 = NO_ENCRYPTION_m13;
		uh->encryption_2 = *((si1 *) (rd + MED_10_METADATA_SECTION_2_ENCRYPTION_LEVEL_OFFSET_m13));
		uh->encryption_3 = *((si1 *) (rd + MED_10_METADATA_SECTION_3_ENCRYPTION_LEVEL_OFFSET_m13));
		if (uh->encryption_2 > NO_ENCRYPTION_m13 || uh->encryption_3 > NO_ENCRYPTION_m13)
			uh->encryption_rounds = 1;  // only one round available in MED 1.0
		else
			uh->encryption_rounds = 0;  // no encryption
		
		// zero old section 1 encryption fields
		*((si1 *) (rd + MED_10_METADATA_SECTION_2_ENCRYPTION_LEVEL_OFFSET_m13)) = 0;
		*((si1 *) (rd + MED_10_METADATA_SECTION_3_ENCRYPTION_LEVEL_OFFSET_m13)) = 0;
		*((si1 *) (rd + MED_10_METADATA_TS_DATA_ENCRYPTION_LEVEL_OFFSET_m13)) = 0;

		// anonymized subject id
		strncpy_m13(md1->anonymized_subject_ID, (si1 *) (rd + MED_10_UH_ANONYMIZED_SUBJECT_ID_OFFSET_m13), METADATA_ANONYMIZED_SUBJECT_ID_BYTES_m13);
		memset((void *) (rd + UH_SUPPLEMENTARY_PROTECTED_REGION_OFFSET_m13), 0, UH_SUPPLEMENTARY_PROTECTED_REGION_BYTES_m13);  // zero previous location
		
		// update CRCs
		uh->header_CRC = CRC_calculate_m13((ui1 *) uh + UH_HEADER_CRC_START_OFFSET_m13, UH_BYTES_m13 - UH_HEADER_CRC_START_OFFSET_m13);
		uh->body_CRC = CRC_calculate_m13((ui1 *) uh + UH_BYTES_m13, METADATA_BYTES_m13);

		// write out
		fseek_m13(fp, 0, SEEK_SET);
		bytes_to_write = bytes_to_read;
		if (globals_m13->update_parity == TRUE_m13)
			PRTY_update_m13(fp, 0, rd, bytes_to_write);
		nw = fwrite_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_write, fp);
		if (nw != bytes_to_write) {
			fclose_m13(fp);
			free_m13((void *) rd);
			return_m13(FALSE_m13);
		}
	}
	
	// time & video indices
	else if (type_code == TS_INDS_TYPE_CODE_m13 || type_code == VID_INDS_TYPE_CODE_m13) {

		// read in raw data
		bytes_to_read = UH_BYTES_m13;
		rd = (ui1 *) malloc_m13((size_t) bytes_to_read);
		if (rd == NULL) {
			fclose_m13(fp);
			return_m13(FALSE_m13);
		}
		fseek_m13(fp, 0, SEEK_SET);
		nr = fread_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_read, fp);
		if (nr != bytes_to_read) {
			fclose_m13(fp);
			free_m13((void *) rd);
			return_m13(FALSE_m13);
		}

		// set up
		uh = (UH_m13 *) rd;

		// update version
		uh->MED_version_major = MED_FORMAT_VERSION_MAJOR_m13;
		uh->MED_version_minor = MED_FORMAT_VERSION_MINOR_m13;

		// update fields: no overlaps, no encryption
		
		// ordered
		uh->expanded_passwords = FALSE_m13;  // not available in MED 1.0
		if (type_code == REC_INDS_TYPE_CODE_m13)
			uh->ordered = FALSE_m13;  // may not be true in MED 1.0
		else  // TS_INDS_TYPE_CODE_m13 & VID_INDS_TYPE_CODE_m13
			uh->ordered = TRUE_m13;  // must be true in MED 1.0
		
		// encryption
		uh->encryption_rounds = 0;  // indices not encrypted
		uh->encryption_1 = uh->encryption_2 = uh->encryption_3 = NO_ENCRYPTION_m13;
		
		// anonymized subject
		memset((void *) (rd + UH_SUPPLEMENTARY_PROTECTED_REGION_OFFSET_m13), 0, UH_SUPPLEMENTARY_PROTECTED_REGION_BYTES_m13);  // zero anonymized subject
		
		// update CRCs
		uh->header_CRC = CRC_calculate_m13((ui1 *) uh + UH_HEADER_CRC_START_OFFSET_m13, UH_BYTES_m13 - UH_HEADER_CRC_START_OFFSET_m13);

		// write out
		fseek_m13(fp, 0, SEEK_SET);
		bytes_to_write = bytes_to_read;
		if (globals_m13->update_parity == TRUE_m13)
			PRTY_update_m13(fp, 0, rd, bytes_to_write);
		nw = fwrite_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_write, fp);
		if (nw != bytes_to_write) {
			fclose_m13(fp);
			free_m13((void *) rd);
			return_m13(FALSE_m13);
		}
	}
	
	// time series data
	else if (type_code == TS_DATA_TYPE_CODE_m13) {

		// read in universal header & first block header (for encryption flags)
		bytes_to_read = UH_BYTES_m13 + CMP_BLOCK_FIXED_HDR_BYTES_m13;
		rd = (ui1 *) malloc_m13((size_t) bytes_to_read);
		if (rd == NULL) {
			fclose_m13(fp);
			return_m13(FALSE_m13);
		}
		fseek_m13(fp, 0, SEEK_SET);
		nr = fread_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_read, fp);
		if (nr != bytes_to_read) {
			fclose_m13(fp);
			free_m13((void *) rd);
			return_m13(FALSE_m13);
		}

		// set up
		uh = (UH_m13 *) rd;
		bh = (CMP_FIXED_BH_m13 *) (rd + UH_BYTES_m13);

		// update version
		uh->MED_version_major = MED_FORMAT_VERSION_MAJOR_m13;
		uh->MED_version_minor = MED_FORMAT_VERSION_MINOR_m13;

		// update fields: no overlaps
		
		// ordered
		uh->ordered = TRUE_m13;  // must be true in MED 1.0
		
		// encryption
		uh->expanded_passwords = FALSE_m13;  // not available in MED 1.0
		if (bh->block_flags & MED_10_CMP_BF_LEVEL_1_ENCRYPTION_BIT_m13) {
			uh->encryption_1 = LEVEL_1_ENCRYPTION_m13;
			uh->encryption_rounds = 1;  // only one round available in MED 1.0
		} else if (bh->block_flags & MED_10_CMP_BF_LEVEL_2_ENCRYPTION_BIT_m13) {
			uh->encryption_1 = LEVEL_2_ENCRYPTION_m13;
			uh->encryption_rounds = 1;  // only one round available in MED 1.0
		} else {
			uh->encryption_1 = NO_ENCRYPTION_m13;
			uh->encryption_rounds = 0;  // not encrypted
		}
		uh->encryption_2 = uh->encryption_3 = NO_ENCRYPTION_m13;
		
		// anonymized subject
		memset((void *) (rd + UH_SUPPLEMENTARY_PROTECTED_REGION_OFFSET_m13), 0, UH_SUPPLEMENTARY_PROTECTED_REGION_BYTES_m13);  // zero anonymized subject
		
		// loop over blocks
		if (uh->encryption_1 != NO_ENCRYPTION_m13) {
			fseek_m13(fp, UH_BYTES_m13, SEEK_SET);
			n_blocks = uh->n_entries;
			fpos = UH_BYTES_m13;  // just wrote out universal header
			block = (ui1 *) malloc_m13((size_t) uh->maximum_entry_size);
			if (block == NULL) {
				fclose_m13(fp);
				free_m13((void *) rd);
				return_m13(FALSE_m13);
			}
			bh_clear_mask = ~((ui4) MED_10_CMP_BF_LEVEL_1_ENCRYPTION_BIT_m13 | (ui4) MED_10_CMP_BF_LEVEL_2_ENCRYPTION_BIT_m13);
			uh->body_CRC = CRC_START_VALUE_m13;
			for (i = 0; i < n_blocks; ++i) {
				bytes_to_read = CMP_BLOCK_FIXED_HDR_BYTES_m13;
				nr = fread_m13((void *) block, sizeof(ui1), (size_t) bytes_to_read, fp);
				if (nr != bytes_to_read) {
					fclose_m13(fp);
					return_m13(FALSE_m13);
				}
				bh = (CMP_FIXED_BH_m13 *) block;
				bytes_to_read = bh->total_block_bytes - CMP_BLOCK_FIXED_HDR_BYTES_m13;
				nr = fread_m13((void *) (block + CMP_BLOCK_FIXED_HDR_BYTES_m13), sizeof(ui1), (size_t) bytes_to_read, fp);
				if (nr != bytes_to_read) {
					fclose_m13(fp);
					free_m13((void *) rd);
					free_m13((void *) block);
					return_m13(FALSE_m13);
				}

				// clear encryption bits (encryption level made gloabl & moved to universal header)
				bh->block_flags &= bh_clear_mask;
				
				// calculate block crc
				bh->block_CRC = CRC_calculate_m13((ui1 *) bh + CMP_BLOCK_CRC_START_OFFSET_m13, bh->total_block_bytes - CMP_BLOCK_CRC_START_OFFSET_m13);
				
				// update header body crc
				temp_CRC = CRC_calculate_m13((ui1 *) bh, CMP_BLOCK_CRC_START_OFFSET_m13);
				full_CRC = CRC_combine_m13(temp_CRC, bh->block_CRC, bh->total_block_bytes - CMP_BLOCK_CRC_START_OFFSET_m13);
				uh->body_CRC = CRC_combine_m13(uh->body_CRC, full_CRC, bh->total_block_bytes);
				
				// write out
				fseek_m13(fp, fpos, SEEK_SET);
				bytes_to_write = bh->total_block_bytes;
				if (globals_m13->update_parity == TRUE_m13)
					PRTY_update_m13(fp, fpos, rd, bytes_to_write);
				nw = fwrite_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_write, fp);
				if (nw != bytes_to_write) {
					fclose_m13(fp);
					free_m13((void *) rd);
					free_m13((void *) block);
					return_m13(FALSE_m13);
				}

				// move to next block
				fpos += bh->total_block_bytes;
			}
			free_m13((void *) block);
		}

		// update header CRC
		uh->header_CRC = CRC_calculate_m13((ui1 *) uh + UH_HEADER_CRC_START_OFFSET_m13, UH_BYTES_m13 - UH_HEADER_CRC_START_OFFSET_m13);

		// write out header
		fseek_m13(fp, 0, SEEK_SET);
		bytes_to_write = UH_BYTES_m13;
		if (globals_m13->update_parity == TRUE_m13)
			PRTY_update_m13(fp, 0, rd, bytes_to_write);
		nw = fwrite_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_write, fp);
		if (nw != bytes_to_write) {
			fclose_m13(fp);
			free_m13((void *) rd);
			return_m13(FALSE_m13);
		}
	}
	
	// video data
	else if (type_code == VID_DATA_TYPE_CODE_m13) {
		// read in raw data
		bytes_to_read = UH_BYTES_m13;
		rd = (ui1 *) malloc_m13((size_t) bytes_to_read);
		if (rd == NULL) {
			fclose_m13(fp);
			return_m13(FALSE_m13);
		}
		fseek_m13(fp, -UH_BYTES_m13, SEEK_END);
		nr = fread_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_read, fp);
		if (nr != bytes_to_read) {
			fclose_m13(fp);
			free_m13((void *) rd);
			return_m13(FALSE_m13);
		}

		// set up
		uh = (UH_m13 *) rd;

		// update version
		uh->MED_version_major = MED_FORMAT_VERSION_MAJOR_m13;
		uh->MED_version_minor = MED_FORMAT_VERSION_MINOR_m13;

		// update fields: no overlaps, no encryption
		
		// ordered
		uh->ordered = TRUE_m13;
		
		// encryption
		uh->expanded_passwords = FALSE_m13;  // not available in MED 1.0
		uh->encryption_rounds = 0;  // no encryption in MED 1.0 video
		uh->encryption_1 = uh->encryption_2 = uh->encryption_3 = NO_ENCRYPTION_m13;  // no encryption in MED 1.0 video
		
		// anonymized subject
		memset((void *) (rd + UH_SUPPLEMENTARY_PROTECTED_REGION_OFFSET_m13), 0, UH_SUPPLEMENTARY_PROTECTED_REGION_BYTES_m13);  // zero anonymized subject
		
		// update header CRC
		uh->header_CRC = CRC_calculate_m13((ui1 *) uh + UH_HEADER_CRC_START_OFFSET_m13, UH_BYTES_m13 - UH_HEADER_CRC_START_OFFSET_m13);

		// write out
		fseek_m13(fp, -UH_BYTES_m13, SEEK_END);
		bytes_to_write = bytes_to_read;
		if (globals_m13->update_parity == TRUE_m13)
			PRTY_update_m13(fp, flen_m13(fp) - UH_BYTES_m13, rd, bytes_to_write);
		nw = fwrite_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_write, fp);
		if (nw != bytes_to_write) {
			fclose_m13(fp);
			free_m13((void *) rd);
			return_m13(FALSE_m13);
		}
	}
		
	// record indices
	else if (type_code == REC_INDS_TYPE_CODE_m13) {

		// read in raw data
		bytes_to_read = flen_m13(fp);
		rd = (ui1 *) malloc_m13((size_t) bytes_to_read);
		if (rd == NULL) {
			fclose_m13(fp);
			return_m13(FALSE_m13);
		}
		fseek_m13(fp, 0, SEEK_SET);
		nr = fread_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_read, fp);
		if (nr != bytes_to_read) {
			fclose_m13(fp);
			free_m13((void *) rd);
			return_m13(FALSE_m13);
		}

		// set up
		uh = (UH_m13 *) rd;

		// update version
		uh->MED_version_major = MED_FORMAT_VERSION_MAJOR_m13;
		uh->MED_version_minor = MED_FORMAT_VERSION_MINOR_m13;

		// update fields: no overlaps, no encryption
		
		// ordered
		uh->ordered = FALSE_m13;  // may not be true in MED 1.0
		
		// encryption
		uh->expanded_passwords = FALSE_m13;  // not available in MED 1.0
		uh->encryption_rounds = 1;  // records encrypted individually; only one round available in MED 1.0
		uh->encryption_1 = ENCRYPTION_VARIABLE_m13;
		uh->encryption_2 = uh->encryption_3 = NO_ENCRYPTION_m13;
		
		// anonymized subject
		memset((void *) (rd + UH_SUPPLEMENTARY_PROTECTED_REGION_OFFSET_m13), 0, UH_SUPPLEMENTARY_PROTECTED_REGION_BYTES_m13);  // zero anonymized subject
		
		// loop over blocks
		n_blocks = uh->n_entries;
		ri = (REC_IDX_m13 *) (rd + UH_BYTES_m13);
		
		// write out new file universal header
		fseek_m13(fp, UH_BYTES_m13, SEEK_SET);

		// update Sgmt index versions (data will be done also as always used as a pair)
		uh->body_CRC = CRC_START_VALUE_m13;
		for (i = 0; i < n_blocks; ++i, ++ri) {
			// update Sgmt record idex versions
			if (ri->type_code == REC_Sgmt_TYPE_CODE_m13)
				if (ri->version_major == 1 && ri->version_minor == 0)
					ri->version_minor = 1;
				
			// update header body CRC
			uh->body_CRC = CRC_update_m13((ui1 *) ri, REC_IDX_BYTES_m13, uh->body_CRC);
		}

		// update header CRC
		uh->header_CRC = CRC_calculate_m13((ui1 *) uh + UH_HEADER_CRC_START_OFFSET_m13, UH_BYTES_m13 - UH_HEADER_CRC_START_OFFSET_m13);

		// write out
		fseek_m13(fp, 0, SEEK_SET);
		bytes_to_write = bytes_to_read;
		if (globals_m13->update_parity == TRUE_m13)
			PRTY_update_m13(fp, 0, rd, bytes_to_write);
		nw = fwrite_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_write, fp);
		if (nw != bytes_to_write) {
			fclose_m13(fp);
			free_m13((void *) rd);
			return_m13(FALSE_m13);
		}
	}
	
	// record data (new Sgmt record format is different size - requires new temp file)
	else if (type_code == REC_DATA_TYPE_CODE_m13) {

		// create new file
		sprintf_m13(tmp_path, "%s.tmp", path);
		tmp_fp = fopen_m13(tmp_path, "w");
		if (tmp_fp == NULL) {
			fclose_m13(fp);
			return_m13(FALSE_m13);
		}

		// read in raw data
		bytes_to_read = UH_BYTES_m13;
		rd = (ui1 *) malloc_m13((size_t) bytes_to_read);
		if (rd == NULL) {
			fclose_m13(fp);
			fclose_m13(tmp_fp);
			return_m13(FALSE_m13);
		}
		fseek_m13(fp, 0, SEEK_SET);
		nr = fread_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_read, fp);
		if (nr != bytes_to_read) {
			fclose_m13(fp);
			fclose_m13(tmp_fp);
			free_m13((void *) rd);
			return_m13(FALSE_m13);
		}

		// set up
		uh = (UH_m13 *) rd;

		// update version
		uh->MED_version_major = MED_FORMAT_VERSION_MAJOR_m13;
		uh->MED_version_minor = MED_FORMAT_VERSION_MINOR_m13;

		// update fields: no overlaps, no encryption
		
		// ordered
		uh->ordered = FALSE_m13;  // may not be true in MED 1.0
		
		// encryption
		uh->expanded_passwords = FALSE_m13;  // not available in MED 1.0
		uh->encryption_rounds = 1;  // records encrypted individually; only one round available in MED 1.0
		uh->encryption_1 = ENCRYPTION_VARIABLE_m13;
		uh->encryption_2 = uh->encryption_3 = NO_ENCRYPTION_m13;
		
		// anonymized subject
		memset((void *) (rd + UH_SUPPLEMENTARY_PROTECTED_REGION_OFFSET_m13), 0, UH_SUPPLEMENTARY_PROTECTED_REGION_BYTES_m13);  // zero anonymized subject
		
		// loop over blocks
		n_blocks = uh->n_entries;
		block = (ui1 *) realloc_m13((void *) rd, (size_t) (UH_BYTES_m13 + uh->maximum_entry_size));
		if (block == NULL) {
			fclose_m13(fp);
			fclose_m13(tmp_fp);
			free_m13((void *) rd);
			return_m13(FALSE_m13);
		}
		rd = block;
		recd = rd + UH_BYTES_m13;
		rh = (REC_HDR_m13 *) recd;

		proc_globs = G_proc_globs_m13(NULL);
		pwd = &proc_globs->password_data;
		
		uh->body_CRC = CRC_START_VALUE_m13;
		
		// write out new file universal header
		bytes_to_write = UH_BYTES_m13;
		if (globals_m13->update_parity == TRUE_m13)
			PRTY_update_m13(fp, 0, rd, bytes_to_write);
		nw = fwrite_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_write, tmp_fp);
		if (nw != bytes_to_write) {
			fclose_m13(fp);
			fclose_m13(tmp_fp);
			free_m13((void *) rd);
			G_set_error_m13(E_WRITE_m13, NULL);
			return_m13(FALSE_m13);
		}

		fpos = UH_BYTES_m13;
		for (i = 0; i < n_blocks; ++i) {
			bytes_to_read = REC_HDR_BYTES_m13;
			nr = fread_m13((void *) recd, sizeof(ui1), (size_t) bytes_to_read, fp);
			if (nr != bytes_to_read) {
				fclose_m13(fp);
				fclose_m13(tmp_fp);
				free_m13((void *) rd);
				return_m13(FALSE_m13);
			}

			bytes_to_read = rh->total_record_bytes - REC_HDR_BYTES_m13;
			nr = fread_m13((void *) (recd + REC_HDR_BYTES_m13), sizeof(ui1), (size_t) bytes_to_read, fp);
			if (nr != bytes_to_read) {
				fclose_m13(fp);
				fclose_m13(tmp_fp);
				free_m13((void *) rd);
				return_m13(FALSE_m13);
			}

			// update Sgmt record
			if (rh->type_code == REC_Sgmt_TYPE_CODE_m13) {
				if (rh->version_major == 1 && rh->version_minor == 0) {
					// decrypt
					if (rh->encryption_level > NO_ENCRYPTION_m13) {
						if (rh->encryption_level == LEVEL_1_ENCRYPTION_m13)
							encryption_key = pwd->level_1_encryption_key;
						else
							encryption_key = pwd->level_2_encryption_key;
						AES_decrypt_m13(rd + REC_HDR_BYTES_m13, rh->total_record_bytes - REC_HDR_BYTES_m13, NULL, encryption_key, 1);
					}
					
					Sgmt_v10 = *((REC_Sgmt_v10_m13 *) (recd + REC_HDR_BYTES_m13));  // copy
					Sgmt_v11 = (REC_Sgmt_v11_m13 *) (recd + REC_HDR_BYTES_m13);  // pointer
					Sgmt_v11->end_time = Sgmt_v10.end_time;
					Sgmt_v11->start_samp_num = Sgmt_v10.start_samp_num;
					Sgmt_v11->end_samp_num = Sgmt_v10.end_samp_num;
					Sgmt_v11->seg_num = Sgmt_v10.seg_num;
					Sgmt_v11->samp_freq = (sf4) Sgmt_v10.samp_freq;
					description_bytes = (si8) (rh->total_record_bytes - (REC_HDR_BYTES_m13 + REC_Sgmt_v10_BYTES_m13));
					if (description_bytes) {
						c1 = (si1 *) (Sgmt_v11 + 1);
						c2 = (si1 *) recd + REC_HDR_BYTES_m13 + REC_Sgmt_v10_DESCRIPTION_OFFSET_m13;
						description_bytes = strcpy_m13(c1, c2) + 1;  // account for terminal zero
					}
					body_bytes = REC_Sgmt_v11_BYTES_m13 + description_bytes;
					if (description_bytes)
						rh->total_record_bytes = G_pad_m13((ui1 *) Sgmt_v11, body_bytes, REC_BODY_ALIGNMENT_BYTES_m13) + REC_HDR_BYTES_m13;
					else
						rh->total_record_bytes = body_bytes + REC_HDR_BYTES_m13;

					// encrypt
					if (rh->encryption_level > NO_ENCRYPTION_m13)
						AES_encrypt_m13(recd + REC_HDR_BYTES_m13, rh->total_record_bytes - REC_HDR_BYTES_m13, NULL, encryption_key, 1);

					// update version
					rh->version_minor = 1;
					
					// calculate record crc
					rh->record_CRC = CRC_calculate_m13((ui1 *) rh + REC_HDR_CRC_START_OFFSET_m13, rh->total_record_bytes - REC_HDR_CRC_START_OFFSET_m13);
				}
			}
			
			// update header body CRC
			temp_CRC = CRC_calculate_m13((ui1 *) rh, REC_HDR_CRC_START_OFFSET_m13);
			full_CRC = CRC_combine_m13(temp_CRC, rh->record_CRC, rh->total_record_bytes - REC_HDR_CRC_START_OFFSET_m13);
			uh->body_CRC = CRC_combine_m13(uh->body_CRC, full_CRC, rh->total_record_bytes);

			// write out
			bytes_to_write = rh->total_record_bytes;
			if (globals_m13->update_parity == TRUE_m13) {
				PRTY_update_m13(fp, fpos, rd, bytes_to_write);
				fpos += rh->total_record_bytes;
			}
			nw = fwrite_m13((void *) recd, sizeof(ui1), (size_t) bytes_to_write, tmp_fp);
			if (nw != bytes_to_write) {
				fclose_m13(fp);
				fclose_m13(tmp_fp);
				free_m13((void *) rd);
				return_m13(FALSE_m13);
			}
		}

		// update header CRC
		uh->header_CRC = CRC_calculate_m13((ui1 *) uh + UH_HEADER_CRC_START_OFFSET_m13, UH_BYTES_m13 - UH_HEADER_CRC_START_OFFSET_m13);

		// write out universal header
		fseek_m13(tmp_fp, 0, SEEK_SET);
		bytes_to_write = UH_BYTES_m13;
		if (globals_m13->update_parity == TRUE_m13)
			PRTY_update_m13(fp, fpos, rd, bytes_to_write);  // note: parity file may be left with some extra bytes because of shrinking - that's OK
		nw = fwrite_m13((void *) rd, sizeof(ui1), (size_t) bytes_to_write, tmp_fp);
		if (nw != bytes_to_write) {
			fclose_m13(fp);
			fclose_m13(tmp_fp);
			G_set_error_m13(E_WRITE_m13, NULL);
			return_m13(FALSE_m13);
		}
		
		// move new file into place
		fclose_m13(tmp_fp);
		fclose_m13(&fp);  // close before moving (passing address nulls local fp)
		mv_m13(tmp_path, path);
	}

	// unknown file type
	else {
		fclose_m13(fp);
		G_set_error_m13(E_MED_m13, NULL);
		return_m13(FALSE_m13);
	}

	// clean up
	free_m13((void *) rd);
	fclose_m13(fp);
	
	return_m13(TRUE_m13);
}


tern	G_update_MED_version_m13(FPS_m13 *fps)
{
	volatile static tern	updated = FALSE_m13;
	si1			**file_list, **chan_list, **seg_list, **vid_list;
	si1			*sess_path, path[SEG_NAME_BYTES_m13], *fs_name;
	si1			chan_name[NAME_BYTES_m13], seg_name[SEG_NAME_BYTES_m13];
	si4			i, j, k, n_files, n_chans, n_segs, n_vids;
	PROC_GLOBS_m13		*proc_globs;
	size_t			fps_bytes_to_read;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (globals_m13->update_MED_version == FALSE_m13)
		return_m13(FALSE_m13);
	
	if (fps == NULL) {
		G_set_error_m13(E_UNKN_m13, "FPS is NULL");
		return_m13(FALSE_m13);
	}
	
	pthread_mutex_lock_m13(&globals_m13->update_mutex);
	if (updated == TRUE_m13) {
		pthread_mutex_unlock_m13(&globals_m13->update_mutex);
		return_m13(TRUE_m13);
	}
	updated = TRUE_m13;
	G_message_m13("Updating to MED version %d.%d ...\n", MED_FORMAT_VERSION_MAJOR_m13, MED_FORMAT_VERSION_MINOR_m13);
	
	// set up
	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	sess_path = proc_globs->current_session.directory;
	if (STR_empty_m13(sess_path) == TRUE_m13) {
		G_session_directory_m13(fps);
		if (STR_empty_m13(sess_path) == TRUE_m13) {
			pthread_mutex_unlock_m13(&globals_m13->update_mutex);
			G_set_error_m13(E_UNKN_m13, "session path is empty");
			return_m13(FALSE_m13);
		}
	}
	fs_name = proc_globs->current_session.fs_name;

	if (FPS_is_open_m13(fps) == TRUE_m13) {
		fps_bytes_to_read = ftell_m13(fps->params.fp);
		FPS_close_m13(fps);
	} else {
		fps_bytes_to_read = 0;
	}
	
	// session record indices
	sprintf_m13(path, "%s/%s.%s", sess_path, fs_name, REC_INDS_TYPE_STR_m13);
	G_update_MED_type_m13(path);

	// session record data
	sprintf_m13(path, "%s/%s.%s", sess_path, fs_name, REC_DATA_TYPE_STR_m13);
	G_update_MED_type_m13(path);

	// segmented session records
	sprintf_m13(path, "%s/%s.%s", sess_path, fs_name, SSR_TYPE_STR_m13);
	if (G_exists_m13(path) == DIR_EXISTS_m13) {
		// seg sess record indices
		file_list = G_file_list_m13(NULL, &n_files, path, NULL, REC_INDS_TYPE_STR_m13, GFL_FULL_PATH_m13);
		for (i = 0; i < n_files; ++i)
			G_update_MED_type_m13(file_list[i]);
		if (file_list)
			free_m13((void *) file_list);

		// seg sess record data
		file_list = G_file_list_m13(NULL, &n_files, path, NULL, REC_DATA_TYPE_STR_m13, GFL_FULL_PATH_m13);
		for (i = 0; i < n_files; ++i)
			G_update_MED_type_m13(file_list[i]);
		if (file_list)
			free_m13((void *) file_list);
	}
		
	// time series channels
	chan_list = G_file_list_m13(NULL, &n_chans, sess_path, NULL, TS_CHAN_TYPE_STR_m13, GFL_FULL_PATH_m13);
	for (i = 0; i < n_chans; ++i) {
		G_path_parts_m13(chan_list[i], NULL, chan_name, NULL);
		
		// channel record indices
		sprintf_m13(path, "%s/%s.%s", chan_list[i], chan_name, REC_INDS_TYPE_STR_m13);
		if (G_exists_m13(path) == TRUE_m13)
			G_update_MED_type_m13(path);
		
		// channel record data
		sprintf_m13(path, "%s/%s.%s", chan_list[i], chan_name, REC_DATA_TYPE_STR_m13);
		if (G_exists_m13(path) == TRUE_m13)
			G_update_MED_type_m13(path);

		// time series segments
		seg_list = G_file_list_m13(NULL, &n_segs, chan_list[i], NULL, TS_SEG_TYPE_STR_m13, GFL_FULL_PATH_m13);
		for (j = 0; j < n_segs; ++j) {
			G_path_parts_m13(seg_list[j], NULL, seg_name, NULL);
			
			// time series metadata
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, TS_METADATA_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_MED_type_m13(path);

			// time series indices
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, TS_INDS_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_MED_type_m13(path);

			// time series data
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, TS_DATA_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_MED_type_m13(path);

			// segment record indices
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, REC_INDS_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_MED_type_m13(path);

			// segment record data
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, REC_DATA_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_MED_type_m13(path);
		}
		if (seg_list)
			free_m13((void *) seg_list);
	}
	if (chan_list)
		free_m13((void *) chan_list);

	// video channels
	chan_list = G_file_list_m13(NULL, &n_chans, sess_path, NULL, VID_CHAN_TYPE_STR_m13, GFL_FULL_PATH_m13);
	for (i = 0; i < n_chans; ++i) {
		G_path_parts_m13(chan_list[i], NULL, chan_name, NULL);
		
		// channel record indices
		sprintf_m13(path, "%s/%s.%s", chan_list[i], chan_name, REC_INDS_TYPE_STR_m13);
		if (G_exists_m13(path) == DIR_EXISTS_m13)
			G_update_MED_type_m13(path);

		// channel record data
		sprintf_m13(path, "%s/%s.%s", chan_list[i], chan_name, REC_DATA_TYPE_STR_m13);
		if (G_exists_m13(path) == DIR_EXISTS_m13)
			G_update_MED_type_m13(path);

		// video segments
		seg_list = G_file_list_m13(NULL, &n_segs, chan_list[i], NULL, VID_SEG_TYPE_STR_m13, GFL_FULL_PATH_m13);
		for (j = 0; j < n_segs; ++j) {
			G_path_parts_m13(seg_list[j], NULL, seg_name, NULL);
			
			// video metadata
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, VID_METADATA_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_MED_type_m13(path);

			// video indices
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, VID_INDS_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_MED_type_m13(path);

			// video data
			vid_list = G_file_list_m13(NULL, &n_vids, seg_list[j], "*_n????", NULL, GFL_FULL_PATH_m13);
			if (n_vids) {
				for (k = 0; k < n_vids; ++k)
					G_update_MED_type_m13(vid_list[k]);
				free_m13((void *) vid_list);
			}
			
			// segment record indices
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, REC_INDS_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_MED_type_m13(path);

			// segment record data
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, REC_DATA_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_MED_type_m13(path);
		}
		if (seg_list)
			free_m13((void *) seg_list);
	}
	if (chan_list)
		free_m13((void *) chan_list);
	
	pthread_mutex_unlock_m13(&globals_m13->update_mutex);

	// reopen fps
	if (fps_bytes_to_read) {
		FPS_reopen_m13(fps, fps->params.mode_str);
		fread_m13((void *) fps->params.raw_data, sizeof(ui1), fps_bytes_to_read, fps->params.fp);
	}
	
	return_m13(TRUE_m13);
}


tern	G_update_session_name_m13(FPS_m13 *fps)
{
	volatile static tern	updated = FALSE_m13;
	tern			path_exists;
	si1			**file_list, **chan_list, **seg_list, **vid_list;
	si1			*sess_path, path[SEG_NAME_BYTES_m13], tmp_path[SEG_NAME_BYTES_m13], *fs_name, *uh_name;
	si1			chan_name[NAME_BYTES_m13], seg_name[SEG_NAME_BYTES_m13];
	si4			i, j, k, n_files, n_chans, n_segs, n_vids;
	PROC_GLOBS_m13		*proc_globs;
	size_t			fps_bytes_to_read;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// update all MED universal header session names to file system session name
	// if mismatched channel names are encountered in the process, they will be update also

	if (globals_m13->update_header_names == FALSE_m13)
		return_m13(FALSE_m13);
	
	if (fps == NULL) {
		G_set_error_m13(E_UNKN_m13, "FPS is NULL");
		return_m13(FALSE_m13);
	}

	pthread_mutex_lock_m13(&globals_m13->update_mutex);
	if (updated == TRUE_m13) {
		pthread_mutex_unlock_m13(&globals_m13->update_mutex);
		return_m13(TRUE_m13);
	}
	updated = TRUE_m13;
	G_message_m13("Updating session name ...\n");

	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	sess_path = proc_globs->current_session.directory;
	if (STR_empty_m13(sess_path) == TRUE_m13) {
		G_session_directory_m13(fps);
		if (STR_empty_m13(sess_path) == TRUE_m13) {
			pthread_mutex_unlock_m13(&globals_m13->update_mutex);
			G_set_error_m13(E_UNKN_m13, "session path is empty");
			return_m13(FALSE_m13);
		}
	}
	fs_name = proc_globs->current_session.fs_name;
	uh_name = proc_globs->current_session.uh_name;

	// close passed fps (just to be safe)
	if (FPS_is_open_m13(fps) == TRUE_m13) {
		fps_bytes_to_read = ftell_m13(fps->params.fp);
		FPS_close_m13(fps);
	} else {
		fps_bytes_to_read = 0;
	}

	// session record indices
	sprintf_m13(path, "%s/%s.%s", sess_path, fs_name, REC_INDS_TYPE_STR_m13);
	G_update_session_name_header_m13(path, fs_name, uh_name);

	// session record data
	sprintf_m13(path, "%s/%s.%s", sess_path, fs_name, REC_DATA_TYPE_STR_m13);
	G_update_session_name_header_m13(path, fs_name, uh_name);

	// segmented session records
	sprintf_m13(path, "%s/%s.%s", sess_path, fs_name, SSR_TYPE_STR_m13);
	path_exists = FALSE_m13;
	if (G_exists_m13(path) == FALSE_m13) {
		sprintf_m13(tmp_path, "%s/%s.%s", sess_path, uh_name, SSR_TYPE_STR_m13);
		if (G_exists_m13(tmp_path) == DIR_EXISTS_m13) {
			mv_m13(tmp_path, path);
			path_exists = TRUE_m13;
		}
	} else {
		path_exists = TRUE_m13;
	}
	if (path_exists == TRUE_m13) {
		// seg sess record indices
		file_list = G_file_list_m13(NULL, &n_files, path, NULL, REC_INDS_TYPE_STR_m13, GFL_FULL_PATH_m13);
		for (i = 0; i < n_files; ++i)
			G_update_session_name_header_m13(file_list[i], fs_name, uh_name);
		if (file_list)
			free_m13((void *) file_list);

		// seg sess record data
		file_list = G_file_list_m13(NULL, &n_files, path, NULL, REC_DATA_TYPE_STR_m13, GFL_FULL_PATH_m13);
		for (i = 0; i < n_files; ++i)
			G_update_session_name_header_m13(file_list[i], fs_name, uh_name);
		if (file_list)
			free_m13((void *) file_list);
	}
		
	// time series channels
	chan_list = G_file_list_m13(NULL, &n_chans, sess_path, NULL, TS_CHAN_TYPE_STR_m13, GFL_FULL_PATH_m13);
	for (i = 0; i < n_chans; ++i) {
		G_path_parts_m13(chan_list[i], NULL, chan_name, NULL);
		
		// channel record indices
		sprintf_m13(path, "%s/%s.%s", chan_list[i], chan_name, REC_INDS_TYPE_STR_m13);
		if (G_exists_m13(path) == TRUE_m13)
			G_update_session_name_header_m13(path, fs_name, uh_name);
		
		// channel record data
		sprintf_m13(path, "%s/%s.%s", chan_list[i], chan_name, REC_DATA_TYPE_STR_m13);
		if (G_exists_m13(path) == TRUE_m13)
			G_update_session_name_header_m13(path, fs_name, uh_name);
		
		// time series segments
		seg_list = G_file_list_m13(NULL, &n_segs, chan_list[i], NULL, TS_SEG_TYPE_STR_m13, GFL_FULL_PATH_m13);
		for (j = 0; j < n_segs; ++j) {
			G_path_parts_m13(seg_list[j], NULL, seg_name, NULL);
			
			// time series metadata
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, TS_METADATA_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_session_name_header_m13(path, fs_name, uh_name);

			// time series indices
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, TS_INDS_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_session_name_header_m13(path, fs_name, uh_name);

			// time series data
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, TS_DATA_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_session_name_header_m13(path, fs_name, uh_name);
			
			// segment record indices
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, REC_INDS_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_session_name_header_m13(path, fs_name, uh_name);

			// segment record data
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, REC_DATA_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_session_name_header_m13(path, fs_name, uh_name);
		}
		if (seg_list)
			free_m13((void *) seg_list);
	}
	if (chan_list)
		free_m13((void *) chan_list);

	// video channels
	chan_list = G_file_list_m13(NULL, &n_chans, sess_path, NULL, VID_CHAN_TYPE_STR_m13, GFL_FULL_PATH_m13);
	for (i = 0; i < n_chans; ++i) {
		G_path_parts_m13(chan_list[i], NULL, chan_name, NULL);
		
		// channel record indices
		sprintf_m13(path, "%s/%s.%s", chan_list[i], chan_name, REC_INDS_TYPE_STR_m13);
		if (G_exists_m13(path) == DIR_EXISTS_m13)
			G_update_session_name_header_m13(path, fs_name, uh_name);
		
		// channel record data
		sprintf_m13(path, "%s/%s.%s", chan_list[i], chan_name, REC_DATA_TYPE_STR_m13);
		if (G_exists_m13(path) == DIR_EXISTS_m13)
			G_update_session_name_header_m13(path, fs_name, uh_name);
		
		// video segments
		seg_list = G_file_list_m13(NULL, &n_segs, chan_list[i], NULL, VID_SEG_TYPE_STR_m13, GFL_FULL_PATH_m13);
		for (j = 0; j < n_segs; ++j) {
			G_path_parts_m13(seg_list[j], NULL, seg_name, NULL);
			
			// video metadata
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, VID_METADATA_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_session_name_header_m13(path, fs_name, uh_name);

			// video indices
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, VID_INDS_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_session_name_header_m13(path, fs_name, uh_name);

			// video data
			vid_list = G_file_list_m13(NULL, &n_vids, seg_list[j], "*_n????", NULL, GFL_FULL_PATH_m13);
			if (n_vids) {
				for (k = 0; k < n_vids; ++k)
					G_update_session_name_header_m13(vid_list[k], fs_name, uh_name);
				free_m13((void *) vid_list);
			}
			
			// segment record indices
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, REC_INDS_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_session_name_header_m13(path, fs_name, uh_name);

			// segment record data
			sprintf_m13(path, "%s/%s.%s", seg_list[j], seg_name, REC_DATA_TYPE_STR_m13);
			if (G_exists_m13(path) == TRUE_m13)
				G_update_session_name_header_m13(path, fs_name, uh_name);
		}
		if (seg_list)
			free_m13((void *) seg_list);
	}
	if (chan_list)
		free_m13((void *) chan_list);
	
	// update process globals
	strcpy(proc_globs->current_session.uh_name, proc_globs->current_session.fs_name);
	proc_globs->current_session.names_differ = FALSE_m13;

	pthread_mutex_unlock_m13(&globals_m13->update_mutex);
	
	// reopen fps
	if (fps_bytes_to_read) {
		FPS_reopen_m13(fps, fps->params.mode_str);
		fread_m13((void *) fps->params.raw_data, sizeof(ui1), fps_bytes_to_read, fps->params.fp);
	}
	
	return_m13(TRUE_m13);
}


tern	G_update_session_name_header_m13(si1 *path, si1 *fs_name, si1 *uh_name)  // used by G_update_sess_name_m13()
{
	si1		tmp_path[PATH_BYTES_m13], tmp_name[MAX_NAME_BYTES_m13], ext[TYPE_BYTES_m13];
	FILE_m13	*fp;
	UH_m13		uh;
	size_t		nrw;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// putative path passed with fs_name in construction

	if (G_exists_m13(path) == FALSE_m13) {
		G_path_parts_m13(path, tmp_path, tmp_name, ext);
		STR_replace_pattern_m13(fs_name, uh_name, tmp_name, tmp_name);
		sprintf_m13(tmp_path, "%s/%s.%s", tmp_path, tmp_name, ext);
		if (G_exists_m13(tmp_path) == TRUE_m13)
			mv_m13(tmp_path, path);  // rename to form of fs_name
		else
			return_m13(FALSE_m13);
	}

	fp = fopen_m13(path, "r+");
	if (fp == NULL)
		return_m13(FALSE_m13);

	nrw = fread_m13((void *) &uh, sizeof(ui1), (size_t) UH_BYTES_m13, fp);
	if (nrw != UH_BYTES_m13) {
		fclose_m13(fp);
		return_m13(FALSE_m13);
	}
	
	if (strcmp_m13(uh.session_name, fs_name)) {
		strncpy_m13(uh.session_name, fs_name, NAME_BYTES_m13);
		
		// update header CRC
		uh.header_CRC = CRC_calculate_m13((ui1 *) &uh + UH_HEADER_CRC_START_OFFSET_m13, UH_BYTES_m13 - UH_HEADER_CRC_START_OFFSET_m13);

		fseek_m13(fp, 0, SEEK_SET);
		if (globals_m13->update_parity == TRUE_m13)
			PRTY_update_m13(fp, 0, (void *) &uh, UH_BYTES_m13);
		nrw = fwrite_m13((void *) &uh, sizeof(ui1), (size_t) UH_BYTES_m13, fp);
		if (nrw != UH_BYTES_m13) {
			fclose_m13(fp);
			return_m13(FALSE_m13);
		}
	}
	
	fclose_m13(fp);

	return_m13(TRUE_m13);
}


si8 G_uutc_for_frame_number_m13(LH_m13 *lh, si8 target_frame_number, ui4 mode, ...)  // varargs: si8 ref_frame_number, si8 ref_uutc, sf8 frame_rate
{
	tern			terminal_index;
	si1			tmp_str[PATH_BYTES_m13], num_str[FILE_NUMBERING_DIGITS_m13 + 1];
	si4			seg_num, seg_idx;
	si8 			uutc, absolute_numbering_offset, ref_frame_number;
	si8			ref_uutc, i, n_inds, tmp_si8;
	sf8 			tmp_sf8, frame_rate;
	ui4			mask;
	va_list			v_args;
	PROC_GLOBS_m13		*proc_globs;
	SEG_m13			*seg;
	CHAN_m13		*chan;
	SESS_m13		*sess;
	VID_IDX_m13		*vi;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// G_uutc_for_frame_number_m13(NULL, si8 target_frame_number, ui4 mode, si8 ref_frame_number, si8 ref_uutc, sf8 frame_rate)
	// returns uutc extrapolated from ref_uutc
	// NOTE: in this mode, target_frame_number must be session-relative (global indexing)
	
	// G_uutc_for_frame_number_m13(seg, target_uutc, mode)
	// returns uutc extrapolated from closest video index in frame specified by mode (this is typically more accurate, & takes discontinuities into account)
	
	// frame time is defined as the period from frame onset until the next frame
	// mode FIND_START_m13 (default): first uutc >= start of target frame period
	// mode FIND_END_m13: last uutc < start of next frame period
	// mode FIND_CENTER_m13: uutc closest to the center of the frame period
	
	if (lh == NULL) {  // reference points passed
		va_start(v_args, mode);
		ref_frame_number = va_arg(v_args, si8);
		ref_uutc = va_arg(v_args, si8);
		frame_rate = va_arg(v_args, sf8);
		frame_rate /= (sf8) 1e6;  // samples per microsecond
		va_end(v_args);
		vi = NULL;
	} else {  // level header passed
		switch (lh->type_code) {
			case VID_SEG_TYPE_CODE_m13:
				seg = (SEG_m13 *) lh;
				break;
			case VID_CHAN_TYPE_CODE_m13:
			case SESS_TYPE_CODE_m13:
				seg_num = G_segment_for_frame_number_m13(lh, target_frame_number);
				seg_idx = G_segment_index_m13(seg_num, lh);
				if (seg_idx == FALSE_m13)
					return_m13(UUTC_NO_ENTRY_m13);
				if (lh->type_code == VID_CHAN_TYPE_CODE_m13) {
					chan = (CHAN_m13 *) lh;
				} else {
					proc_globs = G_proc_globs_m13(lh);
					chan = proc_globs->current_session.index_channel;
					if (chan->type_code != VID_CHAN_TYPE_CODE_m13) {
						sess = (SESS_m13 *) lh;
						chan = sess->vid_chans[0];
					}
				}
				seg = chan->segs[seg_idx];
				break;
			case TS_CHAN_TYPE_CODE_m13:
			case TS_SEG_TYPE_CODE_m13:
				return_m13(G_uutc_for_sample_number_m13(lh, target_frame_number, mode));
			default:
				G_set_error_m13(E_UNKN_m13, "invalid level type (%u)", lh->type_code);
				return_m13(UUTC_NO_ENTRY_m13);
		}
		// open segment
		if (seg == NULL) {
			STR_fixed_width_int_m13(num_str, FILE_NUMBERING_DIGITS_m13, seg_num);
			sprintf_m13(tmp_str, "%s/%s_s%s.%s", chan->path, chan->name, num_str, VID_SEG_TYPE_STR_m13);
			seg = chan->segs[seg_idx] = G_open_segment_m13(NULL, NULL, tmp_str, (LH_m13 *) chan, chan->flags, NULL);
			if (seg == NULL)
				return_m13(UUTC_NO_ENTRY_m13);
		}

		vi = seg->vid_inds_fps->vid_inds;
		if (vi == NULL) {
			G_set_error_m13(E_UNKN_m13, "video indices are NULL");
			return_m13(UUTC_NO_ENTRY_m13);
		}
		n_inds = seg->vid_inds_fps->uh->n_entries;  // account for terminal index here - cleaner code below
		if (seg->vid_inds_fps->uh->segment_end_time > 0) {
			--n_inds;  // account for terminal index here - cleaner code below
			terminal_index = TRUE_m13;
		} else {
			terminal_index = FALSE_m13;
		}

		i = G_find_index_m13(seg, target_frame_number, SAMPLE_SEARCH_m13);
		if (i == -1) {  // target frame earlier than segment start => return segment start time
			i = vi->start_time;
			return_m13(i);
		}
		vi += i;
		if (i == n_inds) {  // target frame later than segment end => return segment end uutc
			if (terminal_index == TRUE_m13)
				return_m13(vi->start_time - 1);
			--vi;
		}

		// make target_frame_number relative
		absolute_numbering_offset = seg->metadata_fps->metadata->video_section_2.session_start_frame_number;
		if (target_frame_number > absolute_numbering_offset)
			target_frame_number -= absolute_numbering_offset;

		ref_uutc = vi->start_time;
		ref_frame_number = vi->start_frame_num;
		if (terminal_index == FALSE_m13 && i == n_inds) {
			frame_rate = seg->metadata_fps->metadata->video_section_2.frame_rate / (sf8) 1e6;
		} else {
			++vi;
			frame_rate = (sf8) (vi->start_frame_num - ref_frame_number) / (sf8) (vi->start_time - ref_uutc);  // frames per microsecond
		}
	}
	
	tmp_sf8 = (sf8) (target_frame_number - ref_frame_number);
	mask = (ui4) (FIND_END_m13 | FIND_CENTER_m13 | FIND_START_m13);
	switch (mode & mask) {
		case FIND_END_m13:
			tmp_sf8 = (tmp_sf8 + (sf8) 1.0) / frame_rate;
			tmp_si8 = (si8) tmp_sf8;
			if (tmp_sf8 == (sf8) tmp_si8)  // floor() without calling function
				--tmp_si8;
			break;
		case FIND_CENTER_m13:
			tmp_si8 = (si8) (((tmp_sf8 + (sf8) 0.5) / frame_rate) + (sf8) 0.5);
			break;
		case FIND_START_m13:
		default:
			tmp_sf8 = tmp_sf8 / frame_rate;
			tmp_si8 = (si8) tmp_sf8;
			if (tmp_sf8 != (sf8) tmp_si8)  // ceil() without calling function
				++tmp_si8;
			break;
	}
	
	uutc = ref_uutc + tmp_si8;
	if (vi)
		if (uutc >= vi->start_time)
			uutc = vi->start_time - 1;

	return_m13(uutc);
}


si8	G_uutc_for_sample_number_m13(LH_m13 *lh, si8 target_sample_number, ui4 mode, ...)  // varargs: si8 ref_sample_number, si8 ref_uutc, sf8 sampling_frequency
{
	tern			terminal_index;
	si1			tmp_str[PATH_BYTES_m13], num_str[FILE_NUMBERING_DIGITS_m13 + 1];
	si4			seg_num, seg_idx;
	si8			absolute_numbering_offset, ref_sample_number;
	si8			ref_uutc, n_inds, i, tmp_si8;
	sf8			tmp_sf8, sampling_frequency;
	ui4			mask;
	va_list			v_args;
	PROC_GLOBS_m13		*proc_globs;
	SEG_m13			*seg;
	CHAN_m13		*chan;
	SESS_m13		*sess;
	TS_IDX_m13		*tsi;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// G_uutc_for_sample_number_m13(NULL, si8 target_sample_number, ui4 mode, si8 ref_sample_number, si8 ref_uutc, sf8 sampling_frequency)
	// returns uutc extrapolated from ref_uutc
	// NOTE: in this mode, target_sample_number must be session-relative (global indexing)

	// G_uutc_for_sample_number_m13(seg, target_uutc, mode)
	// returns uutc extrapolated from closest time series index in frame specified by mode (this is typically more accurate, & takes discontinuities into account)
	
	// sample time is defined as the period from sample onset until the next sample
	// mode FIND_START_m13 (default): first uutc >= start of target sample period
	// mode FIND_END_m13: last uutc < start of next sample period
	// mode FIND_CENTER_m13: uutc closest to the center of the sample period
	
	if (lh == NULL) {  // reference points passed
		va_start(v_args, mode);
		ref_sample_number = va_arg(v_args, si8);
		ref_uutc = va_arg(v_args, si8);
		sampling_frequency = va_arg(v_args, sf8);
		sampling_frequency /= (sf8) 1e6;  // samples per microsecond
		va_end(v_args);
		tsi = NULL;
	} else {  // level header passed
		switch (lh->type_code) {
			case TS_SEG_TYPE_CODE_m13:
				seg = (SEG_m13 *) lh;
				break;
			case TS_CHAN_TYPE_CODE_m13:
			case SESS_TYPE_CODE_m13:
				seg_num = G_segment_for_sample_number_m13(lh, target_sample_number);
				seg_idx = G_segment_index_m13(seg_num, lh);
				if (seg_idx == FALSE_m13)
					return_m13(UUTC_NO_ENTRY_m13);
				if (lh->type_code == TS_CHAN_TYPE_CODE_m13) {
					chan = (CHAN_m13 *) lh;
				} else {
					proc_globs = G_proc_globs_m13(lh);
					chan = proc_globs->current_session.index_channel;
					if (chan->type_code != TS_CHAN_TYPE_CODE_m13) {
						sess = (SESS_m13 *) lh;
						chan = sess->ts_chans[0];
					}
				}
				seg = chan->segs[seg_idx];
				break;
			case VID_CHAN_TYPE_CODE_m13:
			case VID_SEG_TYPE_CODE_m13:
				return_m13(G_uutc_for_frame_number_m13(lh, target_sample_number, mode));
			default:
				G_set_error_m13(E_UNKN_m13, "invalid level type");
				return_m13(UUTC_NO_ENTRY_m13);
		}
		// open segment
		if (seg == NULL) {
			STR_fixed_width_int_m13(num_str, FILE_NUMBERING_DIGITS_m13, seg_num);
			sprintf_m13(tmp_str, "%s/%s_s%s.%s", chan->path, chan->name, num_str, TS_SEG_TYPE_STR_m13);
			seg = chan->segs[seg_idx] = G_open_segment_m13(NULL, NULL, tmp_str, (LH_m13 *) chan, chan->flags, NULL);
			if (seg == NULL)
				return_m13(UUTC_NO_ENTRY_m13);
		}

		tsi = seg->ts_inds_fps->ts_inds;
		if (tsi == NULL) {
			G_set_error_m13(E_UNKN_m13, "time series indices are NULL");
			return_m13(UUTC_NO_ENTRY_m13);
		}
		n_inds = seg->ts_inds_fps->uh->n_entries;
		if (seg->ts_inds_fps->uh->segment_end_time > 0) {
			--n_inds;  // account for terminal index here - cleaner code below
			terminal_index = TRUE_m13;
		} else {
			terminal_index = FALSE_m13;
		}

		i = G_find_index_m13(seg, target_sample_number, SAMPLE_SEARCH_m13);
		if (i == -1)  // target sample earlier than segment start => return segment start time
			return_m13(tsi->start_time);
		tsi += i;
		if (i == n_inds) {  // target sample later than segment end => return segment end uutc
			if (terminal_index == TRUE_m13)
				return_m13(tsi->start_time - 1);
			--tsi;
		}
		
		// make target_sample_number relative, if needed
		absolute_numbering_offset = seg->metadata_fps->metadata->time_series_section_2.session_start_sample_number;
		if (target_sample_number > absolute_numbering_offset)
			target_sample_number -= absolute_numbering_offset;

		ref_uutc = tsi->start_time;
		ref_sample_number = tsi->start_samp_num;
		if (terminal_index == FALSE_m13 && i == n_inds) {
			sampling_frequency = seg->metadata_fps->metadata->time_series_section_2.sampling_frequency / (sf8) 1e6;
		} else {
			++tsi;
			sampling_frequency = (sf8) (tsi->start_samp_num - ref_sample_number) / (sf8) (tsi->start_time - ref_uutc);  // samples per microsecond
		}
	}
	
	tmp_sf8 = (sf8) (target_sample_number - ref_sample_number);
	mask = (ui4) (FIND_END_m13 | FIND_CENTER_m13 | FIND_START_m13);
	switch (mode & mask) {
		case FIND_END_m13:
			tmp_sf8 = (tmp_sf8 + (sf8) 1.0) / sampling_frequency;
			tmp_si8 = (si8) tmp_sf8;
			if (tmp_sf8 == (sf8) tmp_si8)  // floor() without calling function
				--tmp_si8;
			break;
		case FIND_CENTER_m13:
			tmp_si8 = (si8) (((tmp_sf8 + (sf8) 0.5) / sampling_frequency) + (sf8) 0.5);
			break;
		case FIND_START_m13:
		default:
			tmp_sf8 = tmp_sf8 / sampling_frequency;
			tmp_si8 = (si8) tmp_sf8;
			if (tmp_sf8 != (sf8) tmp_si8)  // ceil() without calling function
				++tmp_si8;
			break;
	}
		
	return_m13(ref_uutc + tmp_si8);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	G_valid_file_code_m13(ui4 file_type_code)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	switch (file_type_code) {
		case TS_METADATA_TYPE_CODE_m13:
		case TS_INDS_TYPE_CODE_m13:
		case TS_DATA_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
		case VID_DATA_TYPE_CODE_m13:
		case REC_INDS_TYPE_CODE_m13:
		case REC_DATA_TYPE_CODE_m13:
			return_m13(TRUE_m13);
	}
	
	return_m13(FALSE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	G_valid_level_code_m13(ui4 level_code)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	switch (level_code) {
		case SESS_TYPE_CODE_m13:
		case SSR_TYPE_CODE_m13:
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
		case PROC_GLOBS_TYPE_CODE_m13:
		case TS_METADATA_TYPE_CODE_m13:
		case TS_INDS_TYPE_CODE_m13:
		case TS_DATA_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
		case VID_DATA_TYPE_CODE_m13:
		case REC_INDS_TYPE_CODE_m13:
		case REC_DATA_TYPE_CODE_m13:
			return_m13(TRUE_m13);
	}
	
	return_m13(FALSE_m13);
}


tern  G_validate_record_data_CRCs_m13(FPS_m13 *fps)
{
	tern  	valid;
	si8 	i;
	REC_HDR_m13	*rh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	valid = TRUE_m13;
	rh = (REC_HDR_m13	*) fps->rec_data;
	for (i = fps->n_items; i--;) {
		
		valid = CRC_validate_m13((ui1 *) rh + REC_HDR_CRC_START_OFFSET_m13, rh->total_record_bytes - REC_HDR_CRC_START_OFFSET_m13, rh->record_CRC);
		if (valid == FALSE_m13)
			return_m13(valid);
		
		rh = (REC_HDR_m13 *) ((ui1 *) rh + rh->total_record_bytes);
	}
	
	return_m13(valid);
}


tern  G_validate_time_series_data_CRCs_m13(FPS_m13 *fps)
{
	tern  		valid;
	si8 		i;
	CMP_FIXED_BH_m13	*bh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	valid = TRUE_m13;
	bh = fps->params.cps->block_header;
	for (i = fps->n_items; i--;) {
		
		valid = CRC_validate_m13((ui1 *) bh + CMP_BLOCK_CRC_START_OFFSET_m13, bh->total_block_bytes - CMP_BLOCK_CRC_START_OFFSET_m13, bh->block_CRC);
		if (valid == FALSE_m13)
			return_m13(valid);
		
		bh = (CMP_FIXED_BH_m13 *) ((ui1 *) bh + bh->total_block_bytes);
	}
	
	return_m13(valid);
}


tern  G_validate_video_data_CRCs_m13(FPS_m13 *fps)
{
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	return_m13(TRUE_m13);
}


tern	G_video_data_m13(const si1 *string)
{
	tern		ext_only;
	si1		*c, name[VID_NAME_BYTES_m13], ext[TYPE_BYTES_m13];
	const si1	*video_exts[19] = { "mp4", "m4p", "m4v", "mov", "avi", "wmv", "mkv", "flv", "webm", "mpg", "mpeg", "m2v", "m2ts", "3gp", "3g2", "avchd", "ogv", "ogg", "f4v" };
	const si4	n_video_exts = 19;
	si4		i, len;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	G_path_parts_m13(string, NULL, name, ext);
	if (*ext) {
		ext_only = FALSE_m13;
	} else if (*name) {  // if no period in string, extension is considered name in G_path_parts_m13()
		strncpy(ext, name, TYPE_BYTES_m13 - 1);
		ext_only = TRUE_m13;
	} else {  // no extension or name
		return_m13(FALSE_m13);
	}

	// check list of standard video extensions
	for (i = n_video_exts; i--;)
		if (strcmp_m13(string, video_exts[i]) == 0)
			break;
	if (i < 0)
		return_m13(FALSE_m13);
	
	if (ext_only == TRUE_m13)
		return_m13(TRUE_m13);
	
	// check that string conforms to MED video data naming convention
	len = (si4) strlen(name);
	if (len <= 12)
		return_m13(FALSE_m13);
	c = name + (len - 12);
	if (*c++ != '-')
		return_m13(FALSE_m13);
	if (*c++ != 's')
		return_m13(FALSE_m13);
	for (i = FILE_NUMBERING_DIGITS_m13; i--; ++c)
		if (*c < '0' || *c > '9')
			return_m13(FALSE_m13);
	if (*c++ != '-')
		return_m13(FALSE_m13);
	if (*c++ != 'n')
		return_m13(FALSE_m13);
	for (i = FILE_NUMBERING_DIGITS_m13; i--; ++c)
		if (*c < '0' || *c > '9')
			return_m13(FALSE_m13);
	
	return_m13(TRUE_m13);
}


void  G_warning_message_m13(const si1 *fmt, ...)
{
	va_list		v_args;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// GREEN suppressible text to stderr
	if (!(G_current_behavior_m13() & SUPPRESS_WARNING_OUTPUT_m13)) {
#ifndef MATLAB_m13
		fprintf(stderr, TC_GREEN_m13);
#endif
		va_start(v_args, fmt);
		vfprintf_m13(stderr_m13, fmt, v_args);
		va_end(v_args);
#ifndef MATLAB_m13
		fprintf(stderr, TC_RESET_m13);
		fflush(stderr);
#endif
	}
	
	return_void_m13;
}



//**********************************//
// MARK: ENCRYPTION FUNCTIONS  (AES)
//**********************************//

// ATTRIBUTION
//
// Advanced Encryption Standard implementation in C.
// By Niyaz PK
// E-mail: niyazlife@gmail.com
// Downloaded from Website: www.hoozi.com
//
// "This is the source code for encryption using the AES algorithm,
// also called Rijndael algorithm. The AES algorithm is recommended
// for non-classified use by the National Institute of Standards
// and Technology (NIST), USA."
//
// For the complete description of the algorithm, see:
// http://www.csrc.nist.gov/publications/fips/fips197/fips-197.pdf
//
// The code include here is for 128-bit AES encryption & decryption only.
//
// Modifications have been made for compatibility with the MED Library.


// this function adds the round key to the state
void	AES_add_round_key_m13(si4 round, ui1 state[][4], ui1 *round_key)
{
	si4	i, j;
	

	for (i = 0; i < 4; i++)
		for (j = 0; j < 4; j++)
			state[j][i] ^= round_key[(round * AES_NB_m13 * 4) + (i * AES_NB_m13) + j];
	
	return;
}


// cipher is the main encryption function
void	AES_cipher_m13(ui1 *in, ui1 *out, ui1 state[][4], ui1 *round_key)
{
	si4	i, j, round;
	

	// copy the input to state array
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			state[j][i] = in[i * 4 + j];
		}
	}

	// Add the First round key to the state before starting the rounds.
	AES_add_round_key_m13(0, state, round_key);
	
	// there will be AES_NR rounds.
	// the first AES_NR - 1 rounds are identical
	// these AES_NR - 1 rounds are executed in the loop below
	for (round = 1; round < AES_NR_m13; round++) {
		AES_sub_bytes_m13(state);
		AES_shift_rows_m13(state);
		AES_mix_columns_m13(state);
		AES_add_round_key_m13(round, state, round_key);
	}
	
	// the last round is given below
	// the mix_columns function is not here in the last round
	AES_sub_bytes_m13(state);
	AES_shift_rows_m13(state);
	AES_add_round_key_m13(AES_NR_m13, state, round_key);
	
	// the encryption process is over
	// copy the state array to output array
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			out[i * 4 + j] = state[j][i];
		}
	}

	return;
}


// "data" is buffer to be decrypted
// "len" is bytes to be decrypted
// if decrypting multiple times with the same encryption key, pass in expanded key
// decryption is done in place
void	AES_decrypt_m13(ui1 *data, si8 len, si1 *password, ui1 *expanded_key, ui1 rounds)
{
	ui1	state[4][4];
	ui1	*round_key, local_round_key[AES_EXPANDED_KEY_BYTES_m13];
	ui1	*ui1_p, tmp_round_key[AES_EXPANDED_KEY_BYTES_m13], *orig_round_key;
	si4	i;
	ui8	*ui8_p;
	si8	j, encryption_blocks, n_leftovers;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (rounds < 1) {
		if (rounds < 0)
			G_set_error_m13(E_ENC_m13, "negative number of rounds");
		return_void_m13;
	}

	if (globals_m13->tables->AES_rsbox_table == NULL)
		AES_init_tables_m13();
	
	if (expanded_key == NULL) {
		round_key = local_round_key;
		if (AES_key_expansion_m13(round_key, password) == NULL) {  // key expansion must be done before encryption
			G_set_error_m13(E_ENC_m13, "no password or expanded key passed");
			return_void_m13;
		}
	} else {
		round_key = expanded_key;
	}
	
	if (rounds > 1) {  // copy key if rounds > 1 to keep thread-safe
		orig_round_key = round_key;
		memcpy((void *) tmp_round_key, (void *) round_key, (size_t) ENCRYPTION_KEY_BYTES_m13);
		round_key = tmp_round_key;
	}

	// decrypt
	encryption_blocks = len >> 4;
	n_leftovers = len & (si8) 0xF;
	ui8_p = (ui8 *) state;
	for (i = (si4) rounds; i--;) {
		
		// AES decryption
		ui8_p[0] = ui8_p[1] = (ui8) 0;  // zero state array
		ui1_p = data;
		for (j = encryption_blocks; j--;) {
			AES_inv_cipher_m13(ui1_p, ui1_p, state, round_key);
			ui1_p += ENCRYPTION_BLOCK_BYTES_m13;
		}
		
		// leftover decryption
		if (n_leftovers)
			AES_partial_decrypt_m13(n_leftovers, ui1_p, round_key);
		
		// encrypt round key (reverse of encrypt)
		if (i) {
			ui8_p[0] = ui8_p[1] = (ui8) 0;  // zero state array
			ui1_p = round_key;
			for (j = ENCRYPTION_KEY_BLOCKS_m13; j--;) {
				AES_cipher_m13(ui1_p, ui1_p, state, orig_round_key);  // use orig_round key b/c round key changes on each iteration of this loop
				ui1_p += ENCRYPTION_BLOCK_BYTES_m13;
			}
		}
	}
		
	return_void_m13;
}


// "data" is buffer to be encrypted
// "len" is bytes to be encrypted
// if encrypting multiple times with the same encryption key, pass in expanded key
// encryption is done in place
void	AES_encrypt_m13(ui1 *data, si8 len, si1 *password, ui1 *expanded_key, ui1 rounds)
{
	ui1	state[AES_NK_m13][AES_NB_m13];
	ui1	*round_key, local_round_key[AES_EXPANDED_KEY_BYTES_m13];
	ui1	*ui1_p, tmp_round_key[AES_EXPANDED_KEY_BYTES_m13], *orig_round_key;
	si4	i;
	ui8	*ui8_p;
	si8	j, encryption_blocks, n_leftovers;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (rounds < 1) {
		if (rounds < 0)
			G_set_error_m13(E_ENC_m13, "negative number of rounds");
		return_void_m13;
	}
	
	if (globals_m13->tables->AES_sbox_table == NULL)  // all tables initialized together
		AES_init_tables_m13();
	
	if (expanded_key == NULL) {
		round_key = local_round_key;
		if (AES_key_expansion_m13(round_key, password) == NULL) {  // key expansion must be done before encryption
			G_set_error_m13(E_ENC_m13, "no password or expanded key passed");
			return_void_m13;
		}
	} else {
		round_key = expanded_key;
	}

	ui8_p = (ui8 *) state;
	if (rounds > 1) {
		orig_round_key = round_key;
		memcpy((void *) tmp_round_key, (void *) round_key, (size_t) ENCRYPTION_KEY_BYTES_m13);  // copy key if rounds > 1 to keep thread-safe
		round_key = tmp_round_key;
		
		// self-encrypt for each round so not using same key in next round
		// done in encryption so decryption (more common) is more efficient
		for (i = (si4) rounds; --i;) {
			ui8_p[0] = ui8_p[1] = (ui8) 0;  // zero state array
			ui1_p = round_key;
			for (j = ENCRYPTION_KEY_BLOCKS_m13; j--;) {
				AES_cipher_m13(ui1_p, ui1_p, state, orig_round_key);  // use orig_round key b/c round key changes on each iteration of this loop
				ui1_p += ENCRYPTION_BLOCK_BYTES_m13;
			}
		}
	}
	
	// encryption
	encryption_blocks = len >> 4;
	n_leftovers = len & (si8) 0xF;
	for (i = (si4) rounds; i--;) {
		
		// AES encryption
		ui8_p[0] = ui8_p[1] = (ui8) 0;  // zero state array
		ui1_p = data;
		for (j = encryption_blocks; j--;) {
			AES_cipher_m13(ui1_p, ui1_p, state, round_key);
			ui1_p += ENCRYPTION_BLOCK_BYTES_m13;
		}

		// leftover encryption
		if (n_leftovers)
			AES_partial_encrypt_m13(n_leftovers, ui1_p, round_key);

		// decrypt round key back to original (encrypted above)
		if (i) {
			ui8_p[0] = ui8_p[1] = (ui8) 0;  // zero state array
			ui1_p = round_key;
			for (j = ENCRYPTION_KEY_BLOCKS_m13; j--;) {
				AES_inv_cipher_m13(ui1_p, ui1_p, state, orig_round_key);  // use orig_round key b/c round key changes on each iteration of this loop
				ui1_p += ENCRYPTION_BLOCK_BYTES_m13;
			}
		}
	}
	
	return_void_m13;
}


tern	AES_init_tables_m13(void)
{
	GLOBAL_TABLES_m13	*tables;

	
	tables = globals_m13->tables;
	if (tables->AES_rcon_table)
		return(TRUE_m13);

	pthread_mutex_lock_m13(&tables->mutex);
	if (tables->AES_rcon_table) {  // may have been done by another thread while waiting
		pthread_mutex_unlock_m13(&tables->mutex);
		return(TRUE_m13);
	}

	// rcon table
	tables->AES_rcon_table = (ui1 *) malloc((size_t) AES_RCON_ENTRIES_m13);
	if (tables->AES_rcon_table == NULL) {
		pthread_mutex_unlock_m13(&tables->mutex);
		return(FALSE_m13);
	}
	{
		ui1 temp[AES_RCON_ENTRIES_m13] = AES_RCON_m13;
		
		memcpy((void *) tables->AES_rcon_table, (void *) temp, (size_t) AES_RCON_ENTRIES_m13);
	}
	
	// rsbox table
	tables->AES_rsbox_table = (ui1 *) malloc((size_t) AES_RSBOX_ENTRIES_m13);
	if (tables->AES_rsbox_table == NULL) {
		pthread_mutex_unlock_m13(&tables->mutex);
		return(FALSE_m13);
	}
	{
		ui1 temp[AES_RSBOX_ENTRIES_m13] = AES_RSBOX_m13;
		
		memcpy((void *) tables->AES_rsbox_table, (void *) temp, (size_t) AES_RSBOX_ENTRIES_m13);
	}

	// sbox table
	tables->AES_sbox_table = (ui1 *) malloc((size_t) AES_SBOX_ENTRIES_m13);
	if (tables->AES_sbox_table == NULL) {
		pthread_mutex_unlock_m13(&tables->mutex);
		return(FALSE_m13);
	}
	{
		ui1 temp[AES_SBOX_ENTRIES_m13] = AES_SBOX_m13;
		
		memcpy((void *) tables->AES_sbox_table, (void *) temp, (size_t) AES_SBOX_ENTRIES_m13);
	}

	pthread_mutex_unlock_m13(&tables->mutex);

	return(TRUE_m13);
}


// inv_cipher is the main decryption function
void	AES_inv_cipher_m13(ui1 *in, ui1 *out, ui1 state[][4], ui1 *round_key)
{
	si4	i, j, round = 0;
	

	// copy the encrypted data to the state array
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			state[j][i] = in[i * 4 + j];
		}
	}

	// add the first round key to the state before starting the rounds
	AES_add_round_key_m13(AES_NR_m13, state, round_key);
	
	// there will be AES_NR rounds
	// the first AES_NR - 1 rounds are identical
	// these AES_NR - 1 rounds are executed in the loop below
	for (round = AES_NR_m13 - 1; round > 0; round--) {
		AES_inv_shift_rows_m13(state);
		AES_inv_sub_bytes_m13(state);
		AES_add_round_key_m13(round, state, round_key);
		AES_inv_mix_columns_m13(state);
	}
	
	// the last round is given below
	// the mix_columns function is not here in the last round
	AES_inv_shift_rows_m13(state);
	AES_inv_sub_bytes_m13(state);
	AES_add_round_key_m13(0, state, round_key);
	
	// the decryption process is over
	// copy the state array to output array
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			out[i * 4 + j] = state[j][i];
		}
	}

	return;
}


void	AES_inv_mix_columns_m13(ui1 state[][4])
{
	si4	i;
	ui1	a, b, c, d;
	

	for (i = 0; i < AES_NB_m13; i++) {
		a = state[0][i];
		b = state[1][i];
		c = state[2][i];
		d = state[3][i];
		state[0][i] = AES_MULTIPLY_m13(a, 0x0e) ^ AES_MULTIPLY_m13(b, 0x0b) ^ AES_MULTIPLY_m13(c, 0x0d) ^ AES_MULTIPLY_m13(d, 0x09);
		state[1][i] = AES_MULTIPLY_m13(a, 0x09) ^ AES_MULTIPLY_m13(b, 0x0e) ^ AES_MULTIPLY_m13(c, 0x0b) ^ AES_MULTIPLY_m13(d, 0x0d);
		state[2][i] = AES_MULTIPLY_m13(a, 0x0d) ^ AES_MULTIPLY_m13(b, 0x09) ^ AES_MULTIPLY_m13(c, 0x0e) ^ AES_MULTIPLY_m13(d, 0x0b);
		state[3][i] = AES_MULTIPLY_m13(a, 0x0b) ^ AES_MULTIPLY_m13(b, 0x0d) ^ AES_MULTIPLY_m13(c, 0x09) ^ AES_MULTIPLY_m13(d, 0x0e);
	}
	
	return;
}


void	AES_inv_shift_rows_m13(ui1 state[][4])
{
	ui1	temp;
	

	// rotate first row 1 columns to right
	temp = state[1][3];
	state[1][3] = state[1][2];
	state[1][2] = state[1][1];
	state[1][1] = state[1][0];
	state[1][0] = temp;
	
	// rotate second row 2 columns to right
	temp = state[2][0];
	state[2][0] = state[2][2];
	state[2][2] = temp;
	
	temp = state[2][1];
	state[2][1] = state[2][3];
	state[2][3] = temp;
	
	// rotate third row 3 columns to right
	temp = state[3][0];
	state[3][0] = state[3][1];
	state[3][1] = state[3][2];
	state[3][2] = state[3][3];
	state[3][3] = temp;
	
	return;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	AES_inv_sub_bytes_m13(ui1 state[][4])
{
	ui1	*ui1_p, *rsbox_table;
	si4	i;
	
	
	rsbox_table = globals_m13->tables->AES_rsbox_table;
	ui1_p = (ui1 *) state;
	for (i = AES_NS_m13; i--; ++ui1_p)
		*ui1_p = rsbox_table[*ui1_p];
	
	return;
}


// the key expansion function produces AES_NB * (AES_NR + 1) round keys
// the round keys are used in each round to encrypt the states
// NOTE: ensure any terminal unused bytes in key array (password) are zeroed
ui1	*AES_key_expansion_m13(ui1 *expanded_key, si1 *key)
{
	ui1	*rcon_table, *sbox_table, temp[4], k;
	si1	*si1_p1, *si1_p2, conditioned_key[AES_KEY_BYTES_m13];
	si4	i, j;
	

	// the round constant word array, rcon[i], contains the values given by
	// x to the power (i - 1) being powers of x (x is denoted as {02}) in the field GF(28)
	// note that i starts at 1, not 0)
	
	// load tables
	if (globals_m13->tables->AES_sbox_table == NULL)
		AES_init_tables_m13();
	rcon_table = globals_m13->tables->AES_rcon_table;
	sbox_table = globals_m13->tables->AES_sbox_table;

	if (expanded_key == NULL)  // caller takes ownership
		expanded_key = (ui1 *) malloc_m13((size_t) AES_KEY_BYTES_m13);
		
	if (STR_empty_m13(key) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "key is empty");
		return(NULL);
	}

	// condition key; zero-pad past null termination, if exists (truncate if longer)
	si1_p1 = key;
	si1_p2 = conditioned_key;
	for (i = AES_KEY_BYTES_m13; i--;) {
		if ((*si1_p2++ = *si1_p1++))
			continue;
		while (i--)
			*si1_p2++ = (ui1) 0;
		break;
	}
	
	// the first round key is the key itself
	for (i = j = 0; i < AES_NK_m13; i++, j += AES_NB_m13) {
		expanded_key[j] = conditioned_key[j];
		expanded_key[j + 1] = conditioned_key[j + 1];
		expanded_key[j + 2] = conditioned_key[j + 2];
		expanded_key[j + 3] = conditioned_key[j + 3];
	}
	
	// All other round keys are found from the previous round keys.
	while (i < (AES_NB_m13 * (AES_NR_m13 + 1))) {
		
		for (j = 0; j < AES_NB_m13; j++)
			temp[j] = expanded_key[(i - 1) * 4 + j];
		
		if (i % AES_NK_m13 == 0) {
			// this rotates the 4 bytes in a word to the left once
			// [a0, a1, a2, a3] becomes [a1, a2, a3, a0]
			k = temp[0];
			temp[0] = temp[1];
			temp[1] = temp[2];
			temp[2] = temp[3];
			temp[3] = k;
			
			// this takes a four-byte input word and applies the s-box
			// to each of the four bytes to produce an output word
			temp[0] = sbox_table[temp[0]];
			temp[1] = sbox_table[temp[1]];
			temp[2] = sbox_table[temp[2]];
			temp[3] = sbox_table[temp[3]];
			
			temp[0] = temp[0] ^ (ui1) rcon_table[i / AES_NK_m13];
		} else if (AES_NK_m13 > 6 && i % AES_NK_m13 == 4) {
			// this takes a four-byte input word and applies the s-box
			// to each of the four bytes to produce an output word
			temp[0] = sbox_table[temp[0]];
			temp[1] = sbox_table[temp[1]];
			temp[2] = sbox_table[temp[2]];
			temp[3] = sbox_table[temp[3]];
		}
		
		expanded_key[i * AES_NB_m13] = expanded_key[(i - AES_NK_m13) * AES_NB_m13] ^ temp[0];
		expanded_key[(i * AES_NB_m13) + 1] = expanded_key[((i - AES_NK_m13) * AES_NB_m13) + 1] ^ temp[1];
		expanded_key[(i * AES_NB_m13) + 2] = expanded_key[((i - AES_NK_m13) * AES_NB_m13) + 2] ^ temp[2];
		expanded_key[(i * AES_NB_m13) + 3] = expanded_key[((i - AES_NK_m13) * AES_NB_m13) + 3] ^ temp[3];

		i++;
	}
	
	return(expanded_key);
}


// the mix_columns function mixes the columns of the state matrix
void	AES_mix_columns_m13(ui1 state[][4])
{
	si4	i;
	ui1	tmp, tm, t;
	

	for (i = 0; i < AES_NB_m13; i++) {
		t = state[0][i];
		tmp = state[0][i] ^ state[1][i] ^ state[2][i] ^ state[3][i];
		tm = state[0][i] ^ state[1][i];
		tm = AES_XTIME_m13(tm);
		state[0][i] ^= tm ^ tmp;
		tm = state[1][i] ^ state[2][i];
		tm = AES_XTIME_m13(tm);
		state[1][i] ^= tm ^ tmp;
		tm = state[2][i] ^ state[3][i];
		tm = AES_XTIME_m13(tm);
		state[2][i] ^= tm ^ tmp;
		tm = state[3][i] ^ t;
		tm = AES_XTIME_m13(tm);
		state[3][i] ^= tm ^ tmp;
	}
	
	return;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	AES_partial_decrypt_m13(si4 n_bytes, ui1 *data, ui1 *round_key)
{
	ui1	*ui1_p1, *ui1_p2;
	si4	i;
	
	
	// decryption for data encrypted with AES_partial_encrypt_m13()
	// for keyless decryption pass NULL for round_key
	
	if (n_bytes > 0) {
		
		// undo xor or with first n_bytes of round key
		if (round_key) {
			ui1_p2 = data;
			ui1_p1 = round_key;
			for (i = n_bytes; i--;)
				*ui1_p2++ ^= *ui1_p1++;
		}
		
		// undo successive byte xor
		ui1_p2 = data + --n_bytes;
		ui1_p1 = ui1_p2 - 1;
		for (i = n_bytes; i--;)
			*ui1_p2-- ^= *ui1_p1--;
		
		// un-not first byte
		*ui1_p2 = ~*ui1_p2;
	} else if (n_bytes < 0){
		G_set_error_m13(E_ENC_m13, "negative number of bytes");
	}

	return;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	AES_partial_encrypt_m13(si4 n_bytes, ui1 *data, ui1 *round_key)
{
	ui1	*ui1_p1, *ui1_p2;
	si4	i;
	

	// encryption for blocks smaller than 128 bits (16 bytes)
	// for keyless encryption pass NULL for round_key
	
	if (n_bytes > 0) {
		
		// not first byte
		ui1_p1 = data;
		*ui1_p1 = ~*ui1_p1;
		
		// successive byte xor
		ui1_p2 = ui1_p1 + 1;
		for (i = n_bytes; i--;)
			*ui1_p2++ ^= *ui1_p1++;

		// xor with first n_bytes of round key
		if (round_key) {
			ui1_p2 = data;
			ui1_p1 = round_key;
			for (i = n_bytes; i--;)
				*ui1_p2++ ^= *ui1_p1++;
		}
	} else if (n_bytes < 0){
		G_set_error_m13(E_ENC_m13, "negative number of bytes");
	}

	return;
}


// the shift_rows function shifts the rows in the state to the left
// each row is shifted with a different offset
// offset == row number, so the first row is not shifted
void	AES_shift_rows_m13(ui1 state[][4])
{
	ui1	temp;
	

	// Rotate first row 1 columns to left
	temp = state[1][0];
	state[1][0] = state[1][1];
	state[1][1] = state[1][2];
	state[1][2] = state[1][3];
	state[1][3] = temp;
	
	// Rotate second row 2 columns to left
	temp = state[2][0];
	state[2][0] = state[2][2];
	state[2][2] = temp;
	
	temp = state[2][1];
	state[2][1] = state[2][3];
	state[2][3] = temp;
	
	// Rotate third row 3 columns to left
	temp = state[3][0];
	state[3][0] = state[3][3];
	state[3][3] = state[3][2];
	state[3][2] = state[3][1];
	state[3][1] = temp;
	
	return;
}


// the sub_bytes function substitutes the values in the
// state matrix with values in an s-box.
#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	AES_sub_bytes_m13(ui1 state[][4])
{
	ui1	*ui1_p, *sbox_table;
	si4	i;
	
	
	sbox_table = globals_m13->tables->AES_sbox_table;
	ui1_p = (ui1 *) state;
	for (i = AES_NS_m13; i--; ++ui1_p)
		*ui1_p = sbox_table[*ui1_p];
	
	return;
}



//*******************************************//
// MARK: ALIGNMENT CHECKING FUNCTIONS  (ALCK)
//*******************************************//


tern  ALCK_all_m13(void)
{
	tern  return_value;
	ui1		*bytes;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	return_value = TRUE_m13;
	bytes = (ui1 *) malloc(METADATA_FILE_BYTES_m13);  // METADATA is largest file structure
	
	// check all structures
	if ((ALCK_universal_header_m13(bytes)) == FALSE_m13)
		return_value = FALSE_m13;
	if ((ALCK_metadata_m13(bytes)) == FALSE_m13)
		return_value = FALSE_m13;
	if ((ALCK_time_series_indices_m13(bytes)) == FALSE_m13)
		return_value = FALSE_m13;
	if ((ALCK_video_indices_m13(bytes)) == FALSE_m13)
		return_value = FALSE_m13;
	if ((ALCK_record_indices_m13(bytes)) == FALSE_m13)
		return_value = FALSE_m13;
	if ((ALCK_record_header_m13(bytes)) == FALSE_m13)
		return_value = FALSE_m13;
	if ((REC_check_structure_alignments_m13(bytes)) == FALSE_m13)
		return_value = FALSE_m13;
	if ((CMP_check_block_header_alignment_m13(bytes)) == FALSE_m13)
		return_value = FALSE_m13;

	free((void *) bytes);
		
	return_m13(return_value);
}


tern  ALCK_metadata_m13(ui1 *bytes)
{
	tern	return_value, free_flag = FALSE_m13;
	METADATA_m13	*md;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	return_value = TRUE_m13;
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(METADATA_FILE_BYTES_m13);
		free_flag = TRUE_m13;
	}
	
	// check overall size
	if (sizeof(METADATA_m13) != METADATA_BYTES_m13)
		return_value = FALSE_m13;

	// check substructure offsets
	md = (METADATA_m13 *) bytes;
	if (&md->section_1 != (METADATA_SECTION_1_m13 *) bytes)
		return_value = FALSE_m13;
	if (&md->time_series_section_2 != (TS_METADATA_SECTION_2_m13 *) (bytes + METADATA_SECTION_1_BYTES_m13))
		return_value = FALSE_m13;
	if (&md->video_section_2 != (VID_METADATA_SECTION_2_m13 *) (bytes + METADATA_SECTION_1_BYTES_m13))
		return_value = FALSE_m13;
	if (&md->section_3 != (METADATA_SECTION_3_m13 *) (bytes + METADATA_SECTION_1_BYTES_m13 + METADATA_SECTION_2_BYTES_m13))
		return_value = FALSE_m13;

	// check substructure contents
	if (ALCK_metadata_section_1_m13(bytes) == FALSE_m13)
		return_value = FALSE_m13;
	if (ALCK_time_series_metadata_section_2_m13(bytes) == FALSE_m13)
		return_value = FALSE_m13;
	if (ALCK_video_metadata_section_2_m13(bytes) == FALSE_m13)
		return_value = FALSE_m13;
	if (ALCK_metadata_section_3_m13(bytes) == FALSE_m13)
			return_value = FALSE_m13;
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(return_value);
}


tern	ALCK_metadata_section_1_m13(ui1 *bytes)
{
	METADATA_SECTION_1_m13	*md1;
	tern		free_flag = FALSE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// check overall size
	if (sizeof(METADATA_SECTION_1_m13) != METADATA_SECTION_1_BYTES_m13)
		goto METADATA_SECTION_1_NOT_ALIGNED_m13;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(METADATA_FILE_BYTES_m13);
		free_flag = TRUE_m13;
	}
	md1 = (METADATA_SECTION_1_m13 *) (bytes + UH_BYTES_m13);
	if (md1->level_1_password_hint != (si1 *) (bytes + METADATA_LEVEL_1_PASSWORD_HINT_OFFSET_m13))
		goto METADATA_SECTION_1_NOT_ALIGNED_m13;
	if (md1->level_2_password_hint != (si1 *) (bytes + METADATA_LEVEL_2_PASSWORD_HINT_OFFSET_m13))
		goto METADATA_SECTION_1_NOT_ALIGNED_m13;
	if (md1->anonymized_subject_ID != (si1 *) (bytes + METADATA_ANONYMIZED_SUBJECT_ID_OFFSET_m13))
		goto METADATA_SECTION_1_NOT_ALIGNED_m13;
	if (md1->protected_region != (ui1 *) (bytes + METADATA_SECTION_1_PROTECTED_REGION_OFFSET_m13))
		goto METADATA_SECTION_1_NOT_ALIGNED_m13;
	if (md1->discretionary_region != (ui1 *) (bytes + METADATA_SECTION_1_DISCRETIONARY_REGION_OFFSET_m13))
		goto METADATA_SECTION_1_NOT_ALIGNED_m13;
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(TRUE_m13);
	
	// not aligned
METADATA_SECTION_1_NOT_ALIGNED_m13:
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(FALSE_m13);
}


tern	ALCK_metadata_section_3_m13(ui1 *bytes)
{
	METADATA_SECTION_3_m13	*md3;
	tern		free_flag = FALSE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// check overall size
	if (sizeof(METADATA_SECTION_3_m13) != METADATA_SECTION_3_BYTES_m13)
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(METADATA_FILE_BYTES_m13);
		free_flag = TRUE_m13;
	}
	md3 = (METADATA_SECTION_3_m13 *) (bytes + METADATA_SECTION_3_OFFSET_m13);
	if (&md3->recording_time_offset != (si8 *) (bytes + METADATA_RECORDING_TIME_OFFSET_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (&md3->daylight_time_start_code != (DAYLIGHT_TIME_CHANGE_CODE_m13 *) (bytes + METADATA_DAYLIGHT_TIME_START_CODE_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (&md3->daylight_time_end_code != (DAYLIGHT_TIME_CHANGE_CODE_m13 *) (bytes + METADATA_DAYLIGHT_TIME_END_CODE_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->standard_timezone_acronym != (si1 *) (bytes + METADATA_STANDARD_TIMEZONE_ACRONYM_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->standard_timezone_string != (si1 *) (bytes + METADATA_STANDARD_TIMEZONE_STRING_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->daylight_timezone_acronym != (si1 *) (bytes + METADATA_DAYLIGHT_TIMEZONE_ACRONYM_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->daylight_timezone_string != (si1 *) (bytes + METADATA_DAYLIGHT_TIMEZONE_STRING_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->subject_name_1 != (si1 *) (bytes + METADATA_SUBJECT_NAME_1_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->subject_name_2 != (si1 *) (bytes + METADATA_SUBJECT_NAME_2_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->subject_name_3 != (si1 *) (bytes + METADATA_SUBJECT_NAME_3_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->subject_ID != (si1 *) (bytes + METADATA_SUBJECT_ID_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->recording_country != (si1 *) (bytes + METADATA_RECORDING_COUNTRY_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->recording_territory != (si1 *) (bytes + METADATA_RECORDING_TERRITORY_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->recording_locality != (si1 *) (bytes + METADATA_RECORDING_LOCALITY_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->recording_institution != (si1 *) (bytes + METADATA_RECORDING_INSTITUTION_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->geotag_format != (si1 *) (bytes + METADATA_GEOTAG_FORMAT_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->geotag_data != (si1 *) (bytes + METADATA_GEOTAG_DATA_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (&md3->standard_UTC_offset != (si4 *) (bytes + METADATA_STANDARD_UTC_OFFSET_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->protected_region != (ui1 *) (bytes + METADATA_SECTION_3_PROTECTED_REGION_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	if (md3->discretionary_region != (ui1 *) (bytes + METADATA_SECTION_3_DISCRETIONARY_REGION_OFFSET_m13))
		goto METADATA_SECTION_3_NOT_ALIGNED_m13;
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(TRUE_m13);
	
	// not aligned
METADATA_SECTION_3_NOT_ALIGNED_m13:
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(FALSE_m13);
}


tern	ALCK_record_header_m13(ui1 *bytes)
{
	REC_HDR_m13	*rh;
	tern  		free_flag = FALSE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// check overall size
	if (sizeof(REC_HDR_m13) != REC_HDR_BYTES_m13)
		goto REC_HDR_NOT_ALIGNED_m13;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(REC_HDR_BYTES_m13);
		free_flag = TRUE_m13;
	}
	rh = (REC_HDR_m13 *) bytes;
	if (&rh->record_CRC != (ui4 *) (bytes + REC_HDR_CRC_OFFSET_m13))
		goto REC_HDR_NOT_ALIGNED_m13;
	if (&rh->total_record_bytes != (ui4 *) (bytes + REC_HDR_TOTAL_RECORD_BYTES_OFFSET_m13))
		goto REC_HDR_NOT_ALIGNED_m13;
	if (&rh->start_time != (si8 *) (bytes + REC_HDR_START_TIME_OFFSET_m13))
		goto REC_HDR_NOT_ALIGNED_m13;
	if (rh->type_string != (si1 *) (bytes + REC_HDR_TYPE_STR_OFFSET_m13))
		goto REC_HDR_NOT_ALIGNED_m13;
	if (&rh->type_code != (ui4 *) (bytes + REC_HDR_TYPE_CODE_OFFSET_m13))
		goto REC_HDR_NOT_ALIGNED_m13;
	if (&rh->type_string_terminal_zero != (si1 *) (bytes + REC_HDR_TYPE_STR_TERMINAL_ZERO_OFFSET_m13))
		goto REC_HDR_NOT_ALIGNED_m13;
	if (&rh->version_major != (ui1 *) (bytes + REC_HDR_VERSION_MAJOR_OFFSET_m13))
		goto REC_HDR_NOT_ALIGNED_m13;
	if (&rh->version_minor != (ui1 *) (bytes + REC_HDR_VERSION_MINOR_OFFSET_m13))
		goto REC_HDR_NOT_ALIGNED_m13;
	if (&rh->encryption_level != (si1 *) (bytes + REC_HDR_ENCRYPTION_LEVEL_OFFSET_m13))
		goto REC_HDR_NOT_ALIGNED_m13;
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(TRUE_m13);
	
	// not aligned
REC_HDR_NOT_ALIGNED_m13:
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(FALSE_m13);
}


tern	ALCK_record_indices_m13(ui1 *bytes)
{
	REC_IDX_m13	*ri;
	tern		free_flag = FALSE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// check overall size
	if (sizeof(REC_IDX_m13) != REC_IDX_BYTES_m13)
		goto REC_INDS_NOT_ALIGNED_m13;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(REC_IDX_BYTES_m13);
		free_flag = TRUE_m13;
	}
	ri = (REC_IDX_m13 *) bytes;
	if (&ri->file_offset != (si8 *) (bytes + REC_IDX_FILE_OFFSET_OFFSET_m13))
		goto REC_INDS_NOT_ALIGNED_m13;
	if (&ri->start_time != (si8 *) (bytes + REC_IDX_START_TIME_OFFSET_m13))
		goto REC_INDS_NOT_ALIGNED_m13;
	if (ri->type_string != (si1 *) (bytes + REC_IDX_TYPE_STR_OFFSET_m13))
		goto REC_INDS_NOT_ALIGNED_m13;
	if (&ri->type_code != (ui4 *) (bytes + REC_IDX_TYPE_CODE_OFFSET_m13))
		goto REC_INDS_NOT_ALIGNED_m13;
	if (&ri->type_string_terminal_zero != (si1 *) (bytes + REC_IDX_TYPE_STR_TERMINAL_ZERO_OFFSET_m13))
		goto REC_INDS_NOT_ALIGNED_m13;
	if (&ri->version_major != (ui1 *) (bytes + REC_IDX_VERSION_MAJOR_OFFSET_m13))
		goto REC_INDS_NOT_ALIGNED_m13;
	if (&ri->version_minor != (ui1 *) (bytes + REC_IDX_VERSION_MINOR_OFFSET_m13))
		goto REC_INDS_NOT_ALIGNED_m13;
	if (&ri->encryption_level != (si1 *) (bytes + REC_IDX_ENCRYPTION_LEVEL_OFFSET_m13))
		goto REC_INDS_NOT_ALIGNED_m13;
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(TRUE_m13);
	
	// not aligned
REC_INDS_NOT_ALIGNED_m13:
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(FALSE_m13);
}


tern	ALCK_time_series_indices_m13(ui1 *bytes)
{
	TS_IDX_m13	*tsi;
	tern		free_flag = FALSE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// check overall size
	if (sizeof(TS_IDX_m13) != TS_IDX_BYTES_m13)
		goto TS_INDS_NOT_ALIGNED_m13;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(TS_IDX_BYTES_m13);
		free_flag = TRUE_m13;
	}
	tsi = (TS_IDX_m13 *) bytes;
	if (&tsi->file_offset != (si8 *) (bytes + TS_IDX_FILE_OFFSET_OFFSET_m13))
		goto TS_INDS_NOT_ALIGNED_m13;
	if (&tsi->start_time != (si8 *) (bytes + TS_IDX_START_TIME_OFFSET_m13))
		goto TS_INDS_NOT_ALIGNED_m13;
	if (&tsi->start_samp_num != (si8 *) (bytes + TS_IDX_START_SAMPLE_NUMBER_OFFSET_m13))
		goto TS_INDS_NOT_ALIGNED_m13;
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(TRUE_m13);
	
	// not aligned
TS_INDS_NOT_ALIGNED_m13:
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(FALSE_m13);
}


tern	ALCK_time_series_metadata_section_2_m13(ui1 *bytes)
{
	TS_METADATA_SECTION_2_m13	*md2;
	tern				free_flag = FALSE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// check overall size
	if (sizeof(TS_METADATA_SECTION_2_m13) != METADATA_SECTION_2_BYTES_m13)
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(METADATA_FILE_BYTES_m13);
		free_flag = TRUE_m13;
	}
	md2 = (TS_METADATA_SECTION_2_m13 *) (bytes + METADATA_SECTION_2_OFFSET_m13);
	// channel type independent fields
	if (md2->session_description != (si1 *) (bytes + METADATA_SESSION_DESCRIPTION_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (md2->channel_description != (si1 *) (bytes + METADATA_CHANNEL_DESCRIPTION_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (md2->segment_description != (si1 *) (bytes + METADATA_SEGMENT_DESCRIPTION_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (md2->equipment_description != (si1 *) (bytes + METADATA_EQUIPMENT_DESCRIPTION_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->acquisition_channel_number != (si4 *) (bytes + METADATA_ACQUISITION_CHANNEL_NUMBER_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	// channel type specific fields
	if (md2->reference_description != (si1 *) (bytes + TS_METADATA_REFERENCE_DESCRIPTION_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->sampling_frequency != (sf8 *) (bytes + TS_METADATA_SAMPLING_FREQUENCY_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->low_frequency_filter_setting != (sf8 *) (bytes + TS_METADATA_LOW_FREQUENCY_FILTER_SETTING_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->high_frequency_filter_setting != (sf8 *) (bytes + TS_METADATA_HIGH_FREQUENCY_FILTER_SETTING_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->notch_filter_frequency_setting != (sf8 *) (bytes + TS_METADATA_NOTCH_FILTER_FREQUENCY_SETTING_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->AC_line_frequency != (sf8 *) (bytes + TS_METADATA_AC_LINE_FREQUENCY_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->amplitude_units_conversion_factor != (sf8 *) (bytes + TS_METADATA_AMPLITUDE_UNITS_CONVERSION_FACTOR_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (md2->amplitude_units_description != (si1 *) (bytes + TS_METADATA_AMPLITUDE_UNITS_DESCRIPTION_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->time_base_units_conversion_factor != (sf8 *) (bytes + TS_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (md2->time_base_units_description != (si1 *) (bytes + TS_METADATA_TIME_BASE_UNITS_DESCRIPTION_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->session_start_sample_number != (si8 *) (bytes + TS_METADATA_SESSION_START_SAMPLE_NUMBER_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->number_of_samples != (si8 *) (bytes + TS_METADATA_NUMBER_OF_SAMPLES_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->number_of_blocks != (si8 *) (bytes + TS_METADATA_NUMBER_OF_BLOCKS_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->maximum_block_bytes != (si8 *) (bytes + TS_METADATA_MAXIMUM_BLOCK_BYTES_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->maximum_block_samples != (ui4 *) (bytes + TS_METADATA_MAXIMUM_BLOCK_SAMPLES_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->maximum_block_keysample_bytes != (ui4 *) (bytes + TS_METADATA_MAXIMUM_BLOCK_KEYSAMPLE_BYTES_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->maximum_block_duration != (sf8 *) (bytes + TS_METADATA_MAXIMUM_BLOCK_DURATION_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->number_of_discontinuities != (si8 *) (bytes + TS_METADATA_NUMBER_OF_DISCONTINUITIES_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->maximum_contiguous_blocks != (si8 *) (bytes + TS_METADATA_MAXIMUM_CONTIGUOUS_BLOCKS_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->maximum_contiguous_block_bytes != (si8 *) (bytes + TS_METADATA_MAXIMUM_CONTIGUOUS_BLOCK_BYTES_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&md2->maximum_contiguous_samples != (si8 *) (bytes + TS_METADATA_MAXIMUM_CONTIGUOUS_SAMPLES_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (md2->protected_region != (ui1 *) (bytes + TS_METADATA_SECTION_2_PROTECTED_REGION_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (md2->discretionary_region != (ui1 *) (bytes + TS_METADATA_SECTION_2_DISCRETIONARY_REGION_OFFSET_m13))
		goto TS_METADATA_SECTION_2_NOT_ALIGNED_m13;
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(TRUE_m13);
	
	// not aligned
TS_METADATA_SECTION_2_NOT_ALIGNED_m13:
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(FALSE_m13);
}


tern	ALCK_universal_header_m13(ui1 *bytes)
{
	UH_m13	*uh;
	tern		free_flag = FALSE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// check overall size
	if (sizeof(UH_m13) != UH_BYTES_m13)
		goto UH_NOT_ALIGNED_m13;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(UH_BYTES_m13);
		free_flag = TRUE_m13;
	}
	uh = (UH_m13 *) bytes;
	if (&uh->header_CRC != (ui4 *) (bytes + UH_HEADER_CRC_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->body_CRC != (ui4 *) (bytes + UH_BODY_CRC_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->segment_end_time != (si8 *) (bytes + UH_FILE_END_TIME_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->n_entries != (si8 *) (bytes + UH_NUMBER_OF_ENTRIES_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->maximum_entry_size != (ui4 *) (bytes + UH_MAXIMUM_ENTRY_SIZE_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->segment_number != (si4 *) (bytes + UH_SEGMENT_NUMBER_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (uh->type_string != (si1 *) (bytes + UH_TYPE_STR_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->type_code != (ui4 *) (bytes + UH_TYPE_CODE_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->type_string_terminal_zero != (si1 *) (bytes + UH_TYPE_STR_TERMINAL_ZERO_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->MED_version_major != (ui1 *) (bytes + UH_MED_VERSION_MAJOR_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->MED_version_minor != (ui1 *) (bytes + UH_MED_VERSION_MINOR_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->byte_order_code != (ui1 *) (bytes + UH_BYTE_ORDER_CODE_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->session_start_time != (si8 *) (bytes + UH_SESSION_START_TIME_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->segment_start_time != (si8 *) (bytes + UH_FILE_START_TIME_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (uh->session_name != (si1 *) (bytes + UH_SESSION_NAME_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (uh->channel_name != (si1 *)  (bytes + UH_CHANNEL_NAME_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->channel_UID != (ui8 *) (bytes + UH_CHANNEL_UID_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (uh->supplementary_protected_region != (ui1 *) (bytes + UH_SUPPLEMENTARY_PROTECTED_REGION_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->segment_UID != (ui8 *) (bytes + UH_SEGMENT_UID_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->file_UID != (ui8 *) (bytes + UH_FILE_UID_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->provenance_UID != (ui8 *) (bytes + UH_PROVENANCE_UID_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (uh->level_1_password_validation_field != (ui1 *) (bytes + UH_LEVEL_1_PASSWORD_VALIDATION_FIELD_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (uh->level_2_password_validation_field != (ui1 *) (bytes + UH_LEVEL_2_PASSWORD_VALIDATION_FIELD_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (uh->level_3_password_validation_field != (ui1 *) (bytes + UH_LEVEL_3_PASSWORD_VALIDATION_FIELD_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->video_data_file_number != (ui4 *) (bytes + UH_VIDEO_DATA_FILE_NUMBER_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->ordered != (tern *) (bytes + UH_ORDERED_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->expanded_passwords != (tern *) (bytes + UH_EXPANDED_PASSWORDS_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->encryption_rounds != (ui1 *) (bytes + UH_ENCRYPTION_ROUNDS_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->encryption_1 != (si1 *) (bytes + UH_ENCRYPTION_1_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->encryption_2 != (si1 *) (bytes + UH_ENCRYPTION_2_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (&uh->encryption_3 != (si1 *) (bytes + UH_ENCRYPTION_3_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (uh->protected_region != (ui1 *) (bytes + UH_PROTECTED_REGION_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	if (uh->discretionary_region != (ui1 *) (bytes + UH_DISCRETIONARY_REGION_OFFSET_m13))
		goto UH_NOT_ALIGNED_m13;
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(TRUE_m13);
	
	// not aligned
UH_NOT_ALIGNED_m13:
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(FALSE_m13);
}


tern	ALCK_video_indices_m13(ui1 *bytes)
{
	VID_IDX_m13	*vi;
	tern		free_flag = FALSE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// check overall size
	if (sizeof(VID_IDX_m13) != VID_IDX_BYTES_m13)
		goto VID_INDS_NOT_ALIGNED_m13;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(VID_IDX_BYTES_m13);
		free_flag = TRUE_m13;
	}
	vi = (VID_IDX_m13 *) bytes;
	if (&vi->file_offset != (si8 *) (bytes + VID_IDX_FILE_OFFSET_OFFSET_m13))
		goto VID_INDS_NOT_ALIGNED_m13;
	if (&vi->start_time != (si8 *) (bytes + VID_IDX_START_TIME_OFFSET_m13))
		goto VID_INDS_NOT_ALIGNED_m13;
	if (&vi->start_frame_num != (ui4 *) (bytes + VID_IDX_START_FRAME_OFFSET_m13))
		goto VID_INDS_NOT_ALIGNED_m13;
	if (&vi->vid_file_num != (ui4 *) (bytes + VID_IDX_VIDEO_FILE_NUMBER_OFFSET_m13))
		goto VID_INDS_NOT_ALIGNED_m13;
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(TRUE_m13);
	
	// not aligned
VID_INDS_NOT_ALIGNED_m13:
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(FALSE_m13);
}


tern	ALCK_video_metadata_section_2_m13(ui1 *bytes)
{
	VID_METADATA_SECTION_2_m13	*vmd2;
	tern			free_flag = FALSE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// check overall size
	if (sizeof(VID_METADATA_SECTION_2_m13) != METADATA_SECTION_2_BYTES_m13)
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(METADATA_FILE_BYTES_m13);
		free_flag = TRUE_m13;
	}
	vmd2 = (VID_METADATA_SECTION_2_m13 *) (bytes + METADATA_SECTION_2_OFFSET_m13);
	// channel type independent fields
	if (vmd2->session_description != (si1 *) (bytes + METADATA_SESSION_DESCRIPTION_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (vmd2->channel_description != (si1 *) (bytes + METADATA_CHANNEL_DESCRIPTION_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (vmd2->equipment_description != (si1 *) (bytes + METADATA_EQUIPMENT_DESCRIPTION_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->acquisition_channel_number != (si4 *) (bytes + METADATA_ACQUISITION_CHANNEL_NUMBER_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	// channel type specific fields
	if (&vmd2->time_base_units_conversion_factor != (sf8 *) (bytes + VID_METADATA_TIME_BASE_UNITS_CONVERSION_FACTOR_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (vmd2->time_base_units_description != (si1 *) (bytes + VID_METADATA_TIME_BASE_UNITS_DESCRIPTION_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->session_start_frame_number != (si8 *) (bytes + VID_METADATA_SESSION_START_FRAME_NUMBER_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->number_of_frames != (si8 *) (bytes + VID_METADATA_NUMBER_OF_FRAMES_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->frame_rate != (sf8 *) (bytes + VID_METADATA_FRAME_RATE_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->number_of_clips != (si8 *) (bytes + VID_METADATA_NUMBER_OF_CLIPS_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->maximum_clip_bytes != (si8 *) (bytes + VID_METADATA_MAXIMUM_CLIP_BYTES_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->maximum_clip_frames != (ui4 *) (bytes + VID_METADATA_MAXIMUM_CLIP_FRAMES_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->number_of_video_files != (si4 *) (bytes + VID_METADATA_NUMBER_OF_VIDEO_FILES_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->maximum_clip_duration != (sf8 *) (bytes + VID_METADATA_MAXIMUM_CLIP_DURATION_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->number_of_discontinuities != (si8 *) (bytes + VID_METADATA_NUMBER_OF_DISCONTINUITIES_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->maximum_contiguous_clips != (si8 *) (bytes + VID_METADATA_MAXIMUM_CONTIGUOUS_CLIPS_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->maximum_contiguous_clip_bytes != (si8 *) (bytes + VID_METADATA_MAXIMUM_CONTIGUOUS_CLIP_BYTES_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->maximum_contiguous_frames != (si8 *) (bytes + VID_METADATA_MAXIMUM_CONTIGUOUS_FRAMES_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->horizontal_pixels != (ui4 *) (bytes + VID_METADATA_HORIZONTAL_PIXELS_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (&vmd2->vertical_pixels != (ui4 *) (bytes + VID_METADATA_VERTICAL_PIXELS_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (vmd2->video_format != (si1 *) (bytes + VID_METADATA_VIDEO_FORMAT_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (vmd2->protected_region != (ui1 *) (bytes + VID_METADATA_SECTION_2_PROTECTED_REGION_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	if (vmd2->discretionary_region != (ui1 *) (bytes + VID_METADATA_SECTION_2_DISCRETIONARY_REGION_OFFSET_m13))
		goto VID_METADATA_SECTION_2_NOT_ALIGNED_m13;
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(TRUE_m13);
	
	// not aligned
VID_METADATA_SECTION_2_NOT_ALIGNED_m13:
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(FALSE_m13);
}



//******************************************//
// MARK: ALLOCATION TRACKING FUNCTIONS  (AT)
//******************************************//


#ifdef AT_DEBUG_m13
ui8	AT_actual_size_m13(void *address)
{
	si8		i;
	ui8		actual_bytes;
	AT_ENTRY_m13	*ate;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (address == NULL)  // usually from realloc() with ptr == NULL
		return_m13(0);
	
	pthread_mutex_lock_m13(&globals_m13->AT_list->mutex);

	ate = globals_m13->AT_list->entries;
	for (i = globals_m13->AT_list->top_idx + 1; i--; ++ate) {
		if (ate->address == address) {
			actual_bytes = ate->actual_bytes;
			pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);
			return_m13(actual_bytes);
		}
	}
	
	G_warning_message_m13("%s(): %sno entry for address%s\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13);
	
	pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);

	return_m13(0);
}


void	AT_add_entry_m13(const si1 *function, si4 line, void *address, size_t requested_bytes)
{
	si1		thread_name[PROC_THREAD_NAME_LEN_DEFAULT_m13];
	ui8		actual_bytes;
	si4		i, n_entries;
	pid_t_m13	tid;
	AT_LIST_m13	*list;
	AT_ENTRY_m13	*ate;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	pthread_getname_m13(0, thread_name, (size_t) PROC_THREAD_NAME_LEN_DEFAULT_m13);
	tid = gettid_m13();

	if (address == NULL) {
		if (*thread_name == '<')
			G_warning_message_m13("%s(): %sattempting to add NULL object%s  [called from %s(); at line %d; in thread %lu]\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13, function, line, tid);
		else
			G_warning_message_m13("%s(): %sattempting to add NULL object%s  [called from %s(); at line %d; in thread \"%s\" (id %lu)]\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13, function, line, thread_name, tid);
		return_void_m13;
	}
	
	// get mutex
	pthread_mutex_lock_m13(&globals_m13->AT_list->mutex);

	// find first freed address
	list = globals_m13->AT_list;
	n_entries = list->top_idx + 1;
	ate = list->entries;
	for (i = n_entries; i--; ++ate)
		if (ate->free_function)
			break;

	if (i == -1) {  // new address
		if (n_entries == list->size) {  // expand list
			list->size += GLOBALS_AT_LIST_SIZE_INCREMENT_m13;
			list->entries = (AT_ENTRY_m13 *) realloc((void *) list->entries, list->size * sizeof(AT_ENTRY_m13));
			if (list->entries == NULL) {
				pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);
				exit_m13(-1);
			}
			// zero new memory
			memset((void *) (list->entries + n_entries), (si4) 0, (size_t) GLOBALS_AT_LIST_SIZE_INCREMENT_m13 * sizeof(AT_ENTRY_m13));
		}
		++list->top_idx;
		ate = list->entries + list->top_idx;
	}  // else reuse previously freed address
	
	// get true allocated bytes
#ifdef MACOS_m13
	actual_bytes = (ui8) malloc_size(address);
#endif
#ifdef LINUX_m13
	actual_bytes = (ui8) malloc_usable_size(address);
#endif
#ifdef WINDOWS_m13
	actual_bytes = (ui8) _msize(address);
#endif
			
	// fill in
	ate->requested_bytes = requested_bytes;
	ate->address = address;
	ate->actual_bytes = actual_bytes;
	ate->alloc_function = function;
	ate->alloc_line = line;
	strcpy(ate->alloc_thread_name, thread_name);
	ate->alloc_thread_id = gettid_m13();
	ate->free_function = NULL;
	ate->free_line = 0;
	*ate->free_thread_name = 0;
	ate->free_thread_id = 0;

	// return mutex
	pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);
	
	return_void_m13;
}


void	AT_free_all_m13(const si1 *function, si4 line)
{
	const si1	*plural_str;
	si1		thread_name[PROC_THREAD_NAME_LEN_DEFAULT_m13];
	si8		i, alloced_entries;
	pid_t_m13	tid;
	AT_LIST_m13	*list;
	AT_ENTRY_m13	*ate;
	
	
	pthread_getname_m13(0, thread_name, (size_t) PROC_THREAD_NAME_LEN_DEFAULT_m13);
	tid = gettid_m13();

	pthread_mutex_lock_m13(&globals_m13->AT_list->mutex);

	alloced_entries = 0;
	list = globals_m13->AT_list;
	ate = list->entries;
	for (i = list->top_idx + 1; i--; ++ate)
		if (ate->free_function == NULL)
			++alloced_entries;

	if (alloced_entries) {
		if (alloced_entries > 1)
			plural_str = "ies";
		else
			plural_str = "y";
		#ifdef MATLAB_m13
			mexPrintf("\n%s(): freeing %ld entr%s:\n", __FUNCTION__, alloced_entries, plural_str);
		#else
			printf_m13("\n%s(): freeing %ld entr%s:\n", __FUNCTION__, alloced_entries, plural_str);
		#endif

		ate = list->entries;
		for (i = list->top_idx + 1; i--; ++ate) {
			if (ate->free_function == NULL) {
				pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);  // release mutex for AT_show_entry_m13()
				AT_show_entry_m13(ate->address);
				pthread_mutex_lock_m13(&globals_m13->AT_list->mutex);  // reclaim mutex
				#ifdef MATLAB_PERSISTENT_m13
				mxFree(ate->address);
				#else
				free(ate->address);
				#endif
				ate->free_function = function;
				ate->free_line = line;
				strcpy(ate->free_thread_name, thread_name);
				ate->free_thread_id = tid;
			}
		}
	}

	pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);

	return;
}


tern	AT_freeable_m13(void *address)
{
	si8		i;
	AT_ENTRY_m13	*ate;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// silent function - just to tell whether an address is in the AT list
	
	if (address == NULL)
		return_m13(FALSE_m13);
	
	// get mutex
	pthread_mutex_lock_m13(&globals_m13->AT_list->mutex);
	
	// look for match entry
	ate = globals_m13->AT_list->entries;
	for (i = globals_m13->AT_list->top_idx + 1; i--; ++ate)
		if (ate->address == address)
			break;

	// no entry
	if (i == -1) {
		pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);
		return_m13(FALSE_m13);
	}

	// already freed
	if (ate->free_function) {
		pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);
		return_m13(FALSE_m13);
	}

	// return mutex
	pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);
	
	return_m13(TRUE_m13);
}


tern	AT_remove_entry_m13(void *address, const si1 *function, si4 line)
{
	si1		thread_name[PROC_THREAD_NAME_LEN_DEFAULT_m13];
	pid_t_m13	tid;
	si8		i;
	AT_LIST_m13	*list;
	AT_ENTRY_m13	*ate;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Note this function does not free the accociated memory, just marks it as freed in the AT list

	pthread_getname_m13(0, thread_name, (size_t) PROC_THREAD_NAME_LEN_DEFAULT_m13);
	tid = gettid_m13();
	
	if (address == NULL) {
		if (*thread_name == '<')
			G_warning_message_m13("%s(): %sattempting to free NULL object%s  [called from %s(); at line %d; in thread %lu]\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13, function, line, tid);
		else
			G_warning_message_m13("%s(): %sattempting to free NULL object%s  [called from %s(); at line %d; in thread \"%s\" (id %lu)]\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13, function, line, thread_name, tid);
		
		return_m13(FALSE_m13);
	}

	// get mutex
	pthread_mutex_lock_m13(&globals_m13->AT_list->mutex);
	
	// look for match entry
	list = globals_m13->AT_list;
	ate = list->entries;
	for (i = list->top_idx + 1; i--; ++ate)
		if (ate->address == address)
			break;

	// no entry
	if (i < 0) {
		if (*thread_name == '<')
			G_warning_message_m13("%s(): %saddress was not allocated%s  [called from %s(); at line; %d in thread %lu]\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13, function, line, tid);
		else
			G_warning_message_m13("%s(): %saddress was not allocated%s  [called from %s() at line %d; in thread \"%s\" (id %lu)]\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13, function, line, thread_name, tid);
		
		pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);

		return_m13(FALSE_m13);
	}
	
	// already freed
	else if (ate->free_function) {
		G_warning_message_m13("%s(): %sDouble Free%s\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13);
		if (*ate->free_thread_name == '<') {
		}
		if (*thread_name == '<') {
			G_warning_message_m13("\tPrior free: called from %s(); at line %d; in thread %lu.\n", ate->free_function, ate->free_line, ate->free_thread_id);
			G_warning_message_m13("\tThis free: called from %s(); at line %d; in thread \"%s\" (id %lu).\n", function, line, thread_name, tid);
		} else {
			G_warning_message_m13("\tPrior free: called from %s(); at line %d; in thread \"%s\" (id %lu).\n", ate->free_function, ate->free_line, ate->free_thread_name, ate->free_thread_id);
			G_warning_message_m13("\tThis free: called from %s(); at line %d; in thread \"%s\" (id %lu).\n", function, line, thread_name, tid);
		}

		pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);
		
		return_m13(FALSE_m13);
	}
	
	// mark as freed
	ate->free_function = function;
	ate->free_line = line;
	strcpy(ate->free_thread_name, thread_name);

	if (ate == list->entries + list->top_idx)
		--list->top_idx;
	
	// return mutex
	pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);
	
	return_m13(TRUE_m13);
}


ui8	AT_requested_size_m13(void *address)
{
	si8		i;
	ui8		requested_bytes;
	AT_ENTRY_m13	*ate;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (address == NULL) {
		G_warning_message_m13("%s(): %sNULL address%s\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13);
		return_m13(0);
	}
	
	pthread_mutex_lock_m13(&globals_m13->AT_list->mutex);

	ate = globals_m13->AT_list->entries;
	for (i = globals_m13->AT_list->top_idx + 1; i--; ++ate) {
		if (ate->address == address) {
			requested_bytes = ate->requested_bytes;
			pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);
			return_m13(requested_bytes);
		}
	}
	
	G_warning_message_m13("%s(): %sno entry for address%s\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13);
	
	pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);

	return_m13(0);
}


void	AT_show_entries_m13(void)
{
	si8		i;
	AT_ENTRY_m13	*ate;
	si8		alloced_entries = 0;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	pthread_mutex_lock_m13(&globals_m13->AT_list->mutex);
	
	ate = globals_m13->AT_list->entries;
	for (i = globals_m13->AT_list->top_idx + 1; i--; ++ate) {
		if (ate->free_function == NULL) {
			printf_m13("\naddress: %lu\n", (ui8) ate->address);
			printf_m13("requested bytes: %lu\n", ate->requested_bytes);
			printf_m13("actual bytes: %lu\n", ate->actual_bytes);
			printf_m13("allocating function: %s()\n", ate->alloc_function);
			printf_m13("allocating line: %d\n", ate->alloc_line);
			printf_m13("allocating thread name: \"%s\"\n", ate->alloc_thread_name);
			printf_m13("allocating thread id: %lu\n", ate->alloc_thread_id);
			++alloced_entries;
		}
	}

	printf_m13("\ncurrently allocated AT entries: %lu\n", alloced_entries);

	pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);

	return_void_m13;
}


void	AT_show_entry_m13(void *address)
{
	si8		i;
	AT_ENTRY_m13	*ate;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (address == NULL) {
		G_warning_message_m13("%s(): %sattempting to show a NULL object%s\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13);
		return_void_m13;
	}
	
	pthread_mutex_lock_m13(&globals_m13->AT_list->mutex);

	ate = globals_m13->AT_list->entries;
	for (i = globals_m13->AT_list->top_idx + 1; i--; ++ate) {
		if (ate->address == address) {
			printf_m13("\naddress: %lu\n", (ui8) ate->address);
			printf_m13("requested bytes: %lu\n", ate->requested_bytes);
			printf_m13("actual bytes: %lu\n", ate->actual_bytes);
			printf_m13("allocating function: %s()\n", ate->alloc_function);
			printf_m13("allocating line: %d\n", ate->alloc_line);
			printf_m13("allocating thread name: \"%s\"\n", ate->alloc_thread_name);
			printf_m13("allocating thread id: %lu\n", ate->alloc_thread_id);
			if (ate->free_function) {
				printf_m13("freeing function: %s()\n", ate->free_function);
				printf_m13("freeing line: %d\n", ate->free_line);
				printf_m13("freeing thread name: \"%s\"\n", ate->free_thread_name);
				printf_m13("freeing thread id: %lu\n", ate->free_thread_id);
			}
			pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);
			return_void_m13;
		}
	}
	
	G_warning_message_m13("%s(): %sno entry for address%s\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13);
	
	pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);

	return_void_m13;
}


tern	AT_update_entry_m13(const si1 *function, si4 line, void *orig_address, void *new_address, size_t requested_bytes)
{
	si1		thread_name[PROC_THREAD_NAME_LEN_DEFAULT_m13];
	pid_t_m13	tid;
	si8		i;
	AT_ENTRY_m13	*ate;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (orig_address == NULL) {
		if (new_address) {
			AT_add_entry_m13(function, line, new_address, requested_bytes);
			return_m13(TRUE_m13);
		}
	}
	
	pthread_getname_m13(0, thread_name, (size_t) PROC_THREAD_NAME_LEN_DEFAULT_m13);
	tid = gettid_m13();

	if (new_address == NULL) {
		G_warning_message_m13("%s(): %sattempting to reassign to NULL object%s  [called from %s() at line %d in \"%s\" (id %lu)]\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13, function, line, thread_name, (ui8) tid);
		return_m13(FALSE_m13);
	}
	
	// get mutex
	pthread_mutex_lock_m13(&globals_m13->AT_list->mutex);

	// look for match entry
	ate = globals_m13->AT_list->entries;
	for (i = globals_m13->AT_list->top_idx + 1; i--; ++ate)
		if (ate->address == orig_address)
			break;
	
	// no entry
	if (i == -1) {
		pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);
		G_warning_message_m13("%s(): %saddress is not allocated%s  [called from %s() at line %d in \"%s\" (id %lu)]\n", __FUNCTION__, TC_RED_m13, TC_RESET_m13, function, line, thread_name, (ui8) tid);
		return_m13(FALSE_m13);
	}
	
	if (ate->free_function) {
		G_warning_message_m13("%s(): %saddress %lu was already freed%s  [called from %s() at line %d in \"%s\" (id %lu)]\n", __FUNCTION__, TC_RED_m13, (ui8) orig_address, TC_RESET_m13, function, line, thread_name, (ui8) tid);
		AT_show_entry_m13(orig_address);
		G_warning_message_m13("=> replacing with new data\n");
		ate->free_function = NULL;
		ate->free_line = 0;
		*ate->free_thread_name = 0;
		ate->free_thread_id = 0;
	}

	// update
	ate->address = new_address;
#ifdef MACOS_m13
	ate->actual_bytes = (ui8) malloc_size(new_address);
#endif
#ifdef LINUX_m13
	ate->actual_bytes = (ui8) malloc_usable_size(new_address);
#endif
#ifdef WINDOWS_m13
	ate->actual_bytes = (ui8) _msize(new_address);
#endif
	ate->requested_bytes = requested_bytes;
	ate->alloc_function = function;
	ate->alloc_line = line;
	strcpy(ate->alloc_thread_name, thread_name);
	ate->alloc_thread_id = tid;

	// return mutex
	pthread_mutex_unlock_m13(&globals_m13->AT_list->mutex);

	return_m13(TRUE_m13);
}
#endif // AT_DEBUG_m13



//*************************************************//
// MARK: COMPRESSION & COMPUTATION FUNCTIONS  (CMP)
//*************************************************//

#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
CMP_BUFFERS_m13  *CMP_allocate_buffers_m13(CMP_BUFFERS_m13 *buffers, si8 n_buffers, si8 n_elements, si8 element_size, tern zero_data, tern lock_memory)
{
	tern	free_structure;
	ui1	*array_base;
	ui8	pointer_bytes, array_bytes, total_requested_bytes, mod;
	si8	i;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// all buffers are 8-byte aligned
	// also use this function to re-allocate (data not preserved)
	// cast buffer pointers to desired type (as long as element_size <= allocated type size)
	// e.g.  sf8_array = (sf8 *) buffer[0]; si4_array = (si4 *) buffer[1];
	
	free_structure = FALSE_m13;
	if (buffers == NULL) {
		buffers = (CMP_BUFFERS_m13 *) calloc_m13((size_t) 1, sizeof(CMP_BUFFERS_m13));
		if (buffers == NULL)
			return_m13(NULL);
		free_structure = TRUE_m13;
	} else if (buffers->n_buffers >= n_buffers && buffers->n_elements >= n_elements && buffers->element_size >= element_size) {
		return_m13(buffers);
	}
	
	// buffer pointers
	pointer_bytes = (ui8) (n_buffers * sizeof(void *));
	if ((mod = (pointer_bytes & (ui8) 7)))
		pointer_bytes += ((ui8) 8 - mod);
	
	// array bytes (pass sizeof(x) for element size so any pad bytes of structures are included)
	array_bytes = (ui8) (n_elements * element_size);
	if ((mod = (array_bytes & (ui8) 7)))
		array_bytes += ((ui8) 8 - mod);
	
	// allocate
	total_requested_bytes = pointer_bytes + (n_buffers * array_bytes);
	if (total_requested_bytes > buffers->total_allocated_bytes) {
		if (buffers->buffer) {
			if (buffers->locked == TRUE_m13)
				buffers->locked = munlock_m13((void *) buffers->buffer, (size_t) buffers->total_allocated_bytes);
			free_m13((void *) buffers->buffer);  // usually faster to free & alloc than realloc because of potential memory move
		}
		if (zero_data == TRUE_m13)
			buffers->buffer = (void **) calloc_m13((size_t) total_requested_bytes, sizeof(ui1));
		else
			buffers->buffer = (void **) malloc_m13((size_t) total_requested_bytes);
		if (buffers->buffer == NULL) {
			if (free_structure == TRUE_m13)
				free_m13((void *) buffers);
			return_m13(NULL);
		}
		buffers->total_allocated_bytes = total_requested_bytes;
	} else if (zero_data == TRUE_m13) {
		memset((void *) buffers->buffer, 0, (size_t) total_requested_bytes);
	}
	buffers->n_buffers = n_buffers;
	buffers->n_elements = n_elements;
	buffers->element_size = element_size;
	
	// assign pointers
	array_base = (ui1 *) buffers->buffer + pointer_bytes;
	for (i = 0; i < n_buffers; ++i) {
		buffers->buffer[i] = (void *) array_base;
		array_base += array_bytes;
	}
	
	// lock
	buffers->locked = FALSE_m13;
	if (lock_memory == TRUE_m13)
		buffers->locked = mlock_m13((void *) buffers->buffer, (size_t) buffers->total_allocated_bytes);
	
	return_m13(buffers);
}


CPS_m13	*CMP_allocate_CPS_m13(FPS_m13 *fps, ui4 mode, si8 data_samples, si8 compressed_data_bytes, si8 keysample_bytes, ui4 block_samples, CPS_DIRECS_m13 *directives, CPS_PARAMS_m13 *parameters)
{
	tern	need_compressed_data = FALSE_m13;
	tern	need_decompressed_data = FALSE_m13;
	tern	need_original_data = FALSE_m13;
	tern	need_keysample_buffer = FALSE_m13;
	tern	need_detrended_buffer = FALSE_m13;
	tern	need_derivative_buffer = FALSE_m13;
	tern	need_scrap_buffer = FALSE_m13;
	tern	need_scaled_amplitude_buffer = FALSE_m13;
	tern	need_scaled_frequency_buffer = FALSE_m13;
	tern	need_VDS_buffers = FALSE_m13;
	si8	pad_samples;
	CPS_m13	*cps;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// pass CMP_SELF_MANAGED_MEMORY_m13 for data_samples to prevent automatic re-allocation

	if (fps) {
		if (fps->uh->type_code != TS_DATA_TYPE_CODE_m13) {
			G_set_error_m13(E_UNKN_m13, "fps must be time series data");
			return_m13(NULL);
		}
		
		if (fps->params.cps == NULL)
			fps->params.cps = (CPS_m13 *) calloc_m13((size_t) 1, sizeof(CPS_m13));
		cps = fps->params.cps;
	} else {
		cps = (CPS_m13 *) calloc_m13((size_t) 1, sizeof(CPS_m13));
	}
	
	// set up directives
	if (directives)
		cps->direcs = *directives;
	else // set defaults
		CMP_init_direcs_m13(&cps->direcs, (ui1) mode);
	if (fps) {
		if (fps->parent) {  // set level header directives
			if (((LH_m13 *) fps->parent)->flags & LH_NO_CPS_PTR_RESET_m13)
				cps->direcs.flags &= ~CPS_DF_CPS_POINTER_RESET_m13;  // default is TRUE_m13
			if (((LH_m13 *) fps->parent)->flags & LH_NO_CPS_CACHING_m13)
				cps->direcs.flags &= ~CPS_DF_CPS_CACHING_m13;  // default is TRUE_m13
		}
	}
	
	// set up parameters
	if (parameters)
		cps->params = *parameters;
	else  // set defaults
		CMP_init_params_m13(&cps->params);
		
	if (mode == CMP_COMPRESSION_MODE_NO_ENTRY_m13) {
		G_set_error_m13(E_UNKN_m13, "no compression mode specified");
		return_m13(cps);
	}
	if (mode == CMP_COMPRESSION_MODE_m13)
		cps->direcs.flags |= CPS_DF_COMPRESSION_MODE_m13;
	else
		cps->direcs.flags &= ~CPS_DF_COMPRESSION_MODE_m13;
	
	// allocate RED/PRED buffers
	if (cps->direcs.flags & (CPS_DF_RED1_ALGORITHM_m13 | CPS_DF_RED2_ALGORITHM_m13)) {
		if (mode == CMP_COMPRESSION_MODE_m13) {
			cps->params.count = calloc_m13(CMP_RED_MAX_STATS_BINS_m13, sizeof(ui4));
			cps->params.sorted_count = calloc_m13(CMP_RED_MAX_STATS_BINS_m13, sizeof(CMP_STATISTICS_BIN_m13));
			cps->params.symbol_map = calloc_m13(CMP_RED_MAX_STATS_BINS_m13, sizeof(ui1));
			need_derivative_buffer = TRUE_m13;
		} else {
			cps->params.count = NULL;
			cps->params.sorted_count = NULL;
			cps->params.symbol_map = NULL;
		}
		cps->params.cumulative_count = calloc_m13(CMP_RED_MAX_STATS_BINS_m13 + 1, sizeof(ui8));
		cps->params.minimum_range = calloc_m13(CMP_RED_MAX_STATS_BINS_m13, sizeof(ui8));
	} else if (cps->direcs.flags & (CPS_DF_PRED1_ALGORITHM_m13 | CPS_DF_PRED2_ALGORITHM_m13 | CPS_DF_VDS_ALGORITHM_m13)) {  // VDS uses RED & PRED, but buffers allocated for PRED
		if (mode == CMP_COMPRESSION_MODE_m13) {
			cps->params.count = calloc_2D_m13((size_t) CMP_PRED_CATS_m13, CMP_RED_MAX_STATS_BINS_m13, sizeof(ui4));
			cps->params.sorted_count = calloc_2D_m13((size_t) CMP_PRED_CATS_m13, CMP_RED_MAX_STATS_BINS_m13, sizeof(CMP_STATISTICS_BIN_m13));
			cps->params.symbol_map = calloc_2D_m13((size_t) CMP_PRED_CATS_m13, CMP_RED_MAX_STATS_BINS_m13, sizeof(ui1));
			need_derivative_buffer = TRUE_m13;
		} else {
			cps->params.count = NULL;
			cps->params.sorted_count = NULL;
			cps->params.symbol_map = NULL;
		}
		cps->params.cumulative_count = calloc_2D_m13((size_t) CMP_PRED_CATS_m13, CMP_RED_MAX_STATS_BINS_m13 + 1, sizeof(ui8));
		cps->params.minimum_range = calloc_2D_m13((size_t) CMP_PRED_CATS_m13, CMP_RED_MAX_STATS_BINS_m13, sizeof(ui8));
	} else {
		if (mode == CMP_COMPRESSION_MODE_m13)  // MBE needs derivative buffer for compression
			need_derivative_buffer = TRUE_m13;
		cps->params.count = NULL;
		cps->params.sorted_count = NULL;
		cps->params.symbol_map = NULL;
		cps->params.cumulative_count = NULL;
		cps->params.minimum_range = NULL;
	}

	// VDS
	if (cps->direcs.flags & CPS_DF_VDS_ALGORITHM_m13)
		need_VDS_buffers = TRUE_m13;
	
	// decompression
	if (mode == CMP_DECOMPRESSION_MODE_m13) {
		need_compressed_data = TRUE_m13;
		need_decompressed_data = TRUE_m13;
		need_keysample_buffer = TRUE_m13;
	} else {  // compression
		need_compressed_data = TRUE_m13;
		need_original_data = TRUE_m13;
		need_keysample_buffer = TRUE_m13;
		
		if (cps->direcs.flags & CPS_DF_DETREND_DATA_m13)
			need_detrended_buffer = TRUE_m13;
		if (cps->direcs.flags & CPS_DF_FIND_DERIVATIVE_LEVEL_m13)
			need_scrap_buffer = TRUE_m13;
		if (cps->direcs.flags & (CPS_DF_SET_AMPLITUDE_SCALE_m13 | CPS_DF_FIND_AMPLITUDE_SCALE_m13))
			need_scaled_amplitude_buffer = TRUE_m13;
		if (cps->direcs.flags & (CPS_DF_SET_FREQUENCY_SCALE_m13 | CPS_DF_FIND_FREQUENCY_SCALE_m13))
			need_scaled_frequency_buffer = TRUE_m13;
		if (cps->direcs.flags & (CPS_DF_FIND_AMPLITUDE_SCALE_m13 | CPS_DF_FIND_FREQUENCY_SCALE_m13))
			need_decompressed_data = TRUE_m13;
	}
	
	// original_data - caller specified array size
	if (need_original_data == TRUE_m13 && data_samples > 0)
		cps->input_buffer = cps->original_ptr = cps->original_data = (si4 *) calloc_m13((size_t) data_samples, sizeof(si4));
	else
		cps->input_buffer = cps->original_ptr = cps->original_data = NULL;
	
	// allocated_block_samples applies to any array whose size depends only on number of block samples
	cps->params.allocated_block_samples = block_samples;
	
	// compressed_data - caller specified array size
	if (need_compressed_data == TRUE_m13) {
		if (fps) {
			if (fps->params.raw_data_bytes < (compressed_data_bytes + UH_BYTES_m13)) {  // FPS_realloc_m13 assumes universal header bytes
				FPS_realloc_m13(fps, compressed_data_bytes);
			} else {
				cps->params.allocated_compressed_bytes = fps->params.raw_data_bytes - UH_BYTES_m13;
				cps->block_header = (CMP_FIXED_BH_m13 *) fps->data_ptrs;
			}
		} else {
			cps->block_header = (CMP_FIXED_BH_m13 *) realloc_m13((void *) cps->block_header, compressed_data_bytes);
			cps->params.allocated_compressed_bytes = compressed_data_bytes;
		}
		cps->compressed_data = (ui1 *) cps->block_header;
	} else {
		cps->params.allocated_compressed_bytes = 0;
	}
	
	// keysample_buffer - caller specified or maximum bytes required for specified block size
	if (keysample_bytes == 0)
		keysample_bytes = CMP_MAX_KEYSAMPLE_BYTES_m13(block_samples);
	if (need_keysample_buffer == TRUE_m13) {
		cps->params.keysample_buffer = (si1 *) calloc_m13((size_t) keysample_bytes, sizeof(ui1));
		cps->params.allocated_keysample_bytes = keysample_bytes;
	} else {
		cps->params.keysample_buffer = NULL;
		cps->params.allocated_keysample_bytes = 0;
	}

	// decompressed_data - caller specified array size
	if (need_decompressed_data == TRUE_m13) {
		if (mode == CMP_DECOMPRESSION_MODE_m13) {
			if (data_samples > 0) {
				cps->params.cache = cps->decompressed_data = cps->decompressed_ptr = (si4 *) calloc_m13((size_t) data_samples, sizeof(si4));
			} else {
				cps->params.cache = cps->decompressed_data = cps->decompressed_ptr = NULL;
			}
			cps->params.allocated_decompressed_samples = data_samples;
		} else { // cps->direcs.compression_mode == CMP_COMPRESSION_MODE_m13  (decompressed_ptr used to calculate mean residual ratio for each block)
			cps->params.cache = cps->decompressed_data = cps->decompressed_ptr = (si4 *) calloc_m13((size_t) block_samples, sizeof(si4));
			cps->params.allocated_decompressed_samples = block_samples;
		}
	} else {
		cps->params.cache = cps->decompressed_data = cps->decompressed_ptr = NULL;
		cps->params.allocated_decompressed_samples = 0;
	}
	
	// detrended_buffer - maximum bytes required for caller specified block size
	if (need_detrended_buffer == TRUE_m13)
		cps->params.detrended_buffer = (si4 *) calloc_m13((size_t) block_samples, sizeof(si4));
	else
		cps->params.detrended_buffer = NULL;
	
	// derivative_buffer - maximum bytes required for caller specified block size
	if (need_derivative_buffer == TRUE_m13) {
		cps->params.derivative_buffer = (si4 *) malloc_m13((size_t) (block_samples << 2));
	} else {
		cps->params.derivative_buffer = NULL;
	}
	
	// scrap_buffers: here maximum bytes required for caller specified block size (other routines may expand)
	if (need_scrap_buffer == TRUE_m13) {
		cps->params.scrap_buffers = CMP_allocate_buffers_m13(NULL, 1, block_samples, sizeof(si4), FALSE_m13, FALSE_m13);
	} else {
		cps->params.scrap_buffers = NULL;
	}

	// scaled_amplitude_buffer - maximum bytes required for caller specified block size
	if (need_scaled_amplitude_buffer == TRUE_m13)
		cps->params.scaled_amplitude_buffer = (si4 *) calloc_m13((size_t) block_samples, sizeof(si4));
	else
		cps->params.scaled_amplitude_buffer = NULL;
	
	// scaled_frequency_buffer - maximum bytes required for caller specified block size
	if (need_scaled_frequency_buffer == TRUE_m13)
		cps->params.scaled_frequency_buffer = (si4 *) calloc_m13((size_t) block_samples, sizeof(si4));
	else
		cps->params.scaled_frequency_buffer = NULL;
	
	// VDS buffers - maximum bytes required for caller specified block size
	if (need_VDS_buffers == TRUE_m13) {
		if (mode == CMP_COMPRESSION_MODE_m13)
			pad_samples = CMP_VDS_LOWPASS_ORDER_m13 * 6;
		else
			pad_samples = CMP_MAK_PAD_SAMPLES_m13;
		cps->params.VDS_input_buffers = CMP_allocate_buffers_m13(NULL, CMP_VDS_INPUT_BUFFERS_m13, (si8) block_samples + pad_samples, sizeof(sf8), FALSE_m13, FALSE_m13);
		cps->params.VDS_output_buffers = CMP_allocate_buffers_m13(NULL, CMP_VDS_OUTPUT_BUFFERS_m13, (si8) block_samples, sizeof(sf8), FALSE_m13, FALSE_m13);
	} else {
		cps->params.VDS_input_buffers = cps->params.VDS_output_buffers = NULL;
	}

	return_m13(cps);
}


tern	CMP_binterpolate_sf8_m13(sf8 *in_data, si8 in_len, sf8 *out_data, si8 out_len, ui4 center_mode, tern extrema, sf8 *minima, sf8 *maxima)
{
	si8		i, j, max_bin_width;
	si8		i_bin_width, i_bin_start, i_bin_end;
	sf8		*in_val, *bin_start_p, f_bin_width, f_bin_end, bin_min, bin_max, bin_sum, *quantile_buf, us_ratio;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (in_len <= 1) {
		if (in_len == 0)
			return_m13(TRUE_m13);
		for (i = 0; i < out_len; ++i)
			out_data[i] = in_data[0];
		if (extrema == TRUE_m13)
			minima[i] = maxima[i] = in_data[0];
		return_m13(TRUE_m13);
	}
	if (in_len == out_len) {
		memcpy(out_data, in_data, in_len << 3);
		if (extrema == TRUE_m13) {
			memcpy(minima, in_data, in_len << 3);
			memcpy(maxima, in_data, in_len << 3);
		}
		return_m13(TRUE_m13);
	}
	
	switch (center_mode) {
		case	CMP_CENT_MODE_NONE_m13:
			if (extrema == FALSE_m13)  // no binterpolation requested: interpolate
				return_m13(TRUE_m13);
		case	CMP_CENT_MODE_MIDPOINT_m13:
		case	CMP_CENT_MODE_MEAN_m13:
		case	CMP_CENT_MODE_MEDIAN_m13:
			break;
		case	CMP_CENT_MODE_FASTEST_m13:
			if (extrema == TRUE_m13)
				center_mode = CMP_CENT_MODE_MIDPOINT_m13;
			else
				center_mode = CMP_CENT_MODE_MEAN_m13;
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "invalid center mode");
			return_m13(FALSE_m13);
	}
	
	// upsample
	if (in_len <= out_len) {
		if (center_mode == CMP_CENT_MODE_NONE_m13)
			out_data = (sf8 *) malloc((size_t) (out_len << 3));
		if (in_len == out_len) {
			memcpy((void *) out_data, (void *) in_data, (size_t) (out_len << 3));
		} else {
			us_ratio = (sf8) out_len / (sf8) in_len;
			if (us_ratio >= CMP_SPLINE_UPSAMPLE_SF_RATIO_m13)  // not an option at this point
				CMP_spline_interp_sf8_m13(in_data, in_len, out_data, out_len, NULL);
			else
				CMP_lin_interp_sf8_m13(in_data, in_len, out_data, out_len);
		}
		if (extrema == TRUE_m13) {
			memcpy((void *) minima, (void *) out_data, (size_t) (out_len << 3));
			memcpy((void *) maxima, (void *) out_data, (size_t) (out_len << 3));
		}
		if (center_mode == CMP_CENT_MODE_NONE_m13)
			free((void *) out_data);
		
		return_m13(TRUE_m13);
	}

	// downsample
	--out_len;
	f_bin_width = (sf8) in_len / (sf8) out_len;
	f_bin_end = f_bin_width / (sf8) 2.0;
	i_bin_end = (si8) (f_bin_end + 0.5);
	in_val = in_data;
	if (center_mode == CMP_CENT_MODE_MEDIAN_m13) {
		max_bin_width = (si8) ceil(f_bin_width);
		quantile_buf = (sf8 *) malloc((size_t) (max_bin_width << 3));
	}
	
	// initial half-bin (no central tendency measure - could skew)
	if (center_mode != CMP_CENT_MODE_NONE_m13)
		out_data[0] = in_data[0];
	if (extrema == TRUE_m13) {
		bin_min = bin_max = *in_val++;
		for (j = i_bin_end; --j; ++in_val) {
			if (*in_val < bin_min)
				bin_min = *in_val;
			else if (*in_val > bin_max)
				bin_max = *in_val;
		}
		minima[0] = bin_min;
		maxima[0] = bin_max;
	} else {
		in_val += i_bin_end;
	}
	
	// central bins
	// Note: every combination is done to avoid unnessary computation where possible
	if (extrema == TRUE_m13) {
		switch (center_mode) {
			case CMP_CENT_MODE_NONE_m13:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					bin_min = bin_max = *in_val++;
					for (j = i_bin_width; --j; ++in_val) {
						if (*in_val < bin_min)
							bin_min = *in_val;
						else if (*in_val > bin_max)
							bin_max = *in_val;
					}
					minima[i] = bin_min;
					maxima[i] = bin_max;
				}
				break;
			case CMP_CENT_MODE_MIDPOINT_m13:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					bin_min = bin_max = *in_val++;
					for (j = i_bin_width; --j; ++in_val) {
						if (*in_val < bin_min)
							bin_min = *in_val;
						else if (*in_val > bin_max)
							bin_max = *in_val;
					}
					minima[i] = bin_min;
					maxima[i] = bin_max;
					out_data[i] = (bin_min + bin_max) / (sf8) 2.0;
				}
				break;
			case	CMP_CENT_MODE_MEAN_m13:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					bin_sum = bin_min = bin_max = *in_val++;
					for (j = i_bin_width; --j; ++in_val) {
						bin_sum += *in_val;
						if (*in_val < bin_min)
							bin_min = *in_val;
						else if (*in_val > bin_max)
							bin_max = *in_val;
					}
					minima[i] = bin_min;
					maxima[i] = bin_max;
					out_data[i] = bin_sum / (sf8) i_bin_width;
				}
				break;
			case	CMP_CENT_MODE_MEDIAN_m13:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					bin_start_p = in_val;
					bin_sum = bin_min = bin_max = *in_val++;
					for (j = i_bin_width; --j; ++in_val) {
						bin_sum += *in_val;
						if (*in_val < bin_min)
							bin_min = *in_val;
						else if (*in_val > bin_max)
							bin_max = *in_val;
					}
					minima[i] = bin_min;
					maxima[i] = bin_max;
					out_data[i] = CMP_quantval_m13(bin_start_p, i_bin_width, (sf8) 0.5, TRUE_m13, quantile_buf);
				}
				break;
		}
	} else {  // extrema == FALSE_m13
		switch (center_mode) {
			case CMP_CENT_MODE_MIDPOINT_m13:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					bin_min = bin_max = *in_val++;
					for (j = i_bin_width; --j; ++in_val) {
						if (*in_val < bin_min)
							bin_min = *in_val;
						else if (*in_val > bin_max)
							bin_max = *in_val;
					}
					out_data[i] = (bin_min + bin_max) / (sf8) 2.0;
				}
				break;
			case	CMP_CENT_MODE_MEAN_m13:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					bin_sum = *in_val++;
					for (j = i_bin_width; --j; ++in_val)
						bin_sum += *in_val;
					out_data[i] = bin_sum / (sf8) i_bin_width;
				}
				break;
			case	CMP_CENT_MODE_MEDIAN_m13:
				for (i = 1; i < out_len; ++i) {
					i_bin_start = i_bin_end;
					f_bin_end += f_bin_width;
					i_bin_end = (si8) (f_bin_end + 0.5);
					i_bin_width = i_bin_end - i_bin_start;
					out_data[i] = CMP_quantval_m13(in_val, i_bin_width, (sf8) 0.5, TRUE_m13, quantile_buf);
					in_val += i_bin_width;
				}
				break;
		}
	}
		
	// terminal half-bin (no central tendency measure - could skew)
	if (center_mode != CMP_CENT_MODE_NONE_m13)
		out_data[out_len] = in_data[in_len - 1];
	if (extrema == TRUE_m13) {
		i_bin_start = i_bin_end;
		i_bin_end = in_len;
		i_bin_width = i_bin_end - i_bin_start;
		bin_min = bin_max = *in_val++;
		for (j = i_bin_width; --j; ++in_val) {
			if (*in_val < bin_min)
				bin_min = *in_val;
			else if (*in_val > bin_max)
				bin_max = *in_val;
		}
		minima[out_len] = bin_min;
		maxima[out_len] = bin_max;
	}
	
	if (center_mode == CMP_CENT_MODE_MEDIAN_m13)
		free((void *) quantile_buf);


	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	CMP_byte_to_hex_m13(ui1 byte, si1 *hex)
{
	ui1	hi_val, lo_val;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	hi_val = byte >> 4;
	if (hi_val > 9)
		hi_val += ((ui1) 'a' - 10);
	else
		hi_val += (ui1) '0';
	*hex++ = (si1) hi_val;
	
	lo_val = byte & 0x0F;
	if (lo_val > 9)
		lo_val += ((ui1) 'a' - 10);
	else
		lo_val += (ui1) '0';
	*hex = (si1) lo_val;

	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
sf8  CMP_calculate_mean_residual_ratio_m13(si4 *original_data, si4 *lossy_data, ui4 n_samps)
{
	sf8  sum, mrr, diff, r;
	si8  i;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	sum = (sf8) 0.0;
	for (i = n_samps; i--;) {
		if (*original_data) {
			diff = (sf8) (*original_data - *lossy_data++);
			r = diff / (sf8) *original_data++;
			sum += ABS_m13(r);
		} else {
			--n_samps;
			++original_data;
			++lossy_data;
		}
	}
	
	if (sum == (sf8) 0.0)
		mrr = (sf8) 0.0;
	else
		mrr = sum / (sf8) n_samps;
	
	return_m13(mrr);
}


tern  CMP_calculate_statistics_m13(REC_Stat_v10_m13 *stats, si4 *input_buffer, si8 len, CMP_NODE_m13 *nodes)
{
	CMP_NODE_m13		*np, head, tail;
	tern		free_nodes;
	si4			*x;
	sf8  		sum_x, n, dm, t, sdm2, sdm3, sdm4, m1, m2, m3, m4;
	sf8 	true_median;
	si8 	i, n_nodes, mid_idx, max_cnt, running_cnt;
	ui1 	median_found;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// allocate
	if (nodes == NULL) {
		nodes = (CMP_NODE_m13 *) calloc_m13((size_t)len, sizeof(CMP_NODE_m13));
		free_nodes = TRUE_m13;
	} else {
		free_nodes = FALSE_m13;
	}
	
	// sort
	x = input_buffer;
	n_nodes = CMP_ts_sort_m13(x, len, nodes, &head, &tail, FALSE_m13);
	
	// min, max, mean, median, & mode
	sum_x = (sf8) 0.0;
	running_cnt = max_cnt = 0;
	mid_idx = len >> 1;
	median_found = 0;
	for (i = n_nodes, np = head.next; i--; np = np->next) {
		sum_x += (sf8) np->val * (sf8) np->count;
		if (np->count > max_cnt) {
			max_cnt = np->count;
			stats->mode = np->val;
		}
		if (median_found == 0) {
			running_cnt += np->count;
			if (running_cnt >= mid_idx) {
				if (running_cnt == mid_idx) {
					true_median = (sf8) np->val + (sf8) np->next->val;
					stats->median = CMP_round_si4_m13(true_median);
				} else {
					stats->median = np->val;
				}
				median_found = 1;
			}
		}
	}
	n = (sf8) len;
	stats->minimum = head.next->val;
	stats->maximum = tail.prev->val;
	m1 = sum_x / n;
	stats->mean = CMP_round_si4_m13((sf8) m1);
	
	// variance
	sdm2 = sdm3 = sdm4 = (sf8) 0.0;
	for (i = n_nodes, np = head.next; i--; np = np->next) {
		dm = (sf8) np->val - m1;
		sdm2 += (t = dm * dm * (sf8) np->count);
		sdm3 += (t *= dm);
		sdm4 += (t *= dm);
	}
	stats->variance = (sf4) (m2 = sdm2 / n);
	m3 = sdm3 / n;
	m4 = sdm4 / n;
	
	// skewness
	t = m3 / sqrt(m2 * m2 * m2);
	if (isnan(t))
		t = (sf8) 0.0;  // possible NaN here: set to zero
	else if (len > 2) // correct bias
		t *= sqrt((n - (sf8) 1.0) / n) * (n / (n - (sf8) 2.0));
	stats->skewness = (sf4) t;
	
	// kurtosis
	t = m4 / (m2 * m2);
	if (len > 3) { // correct bias
		t = ((n + (sf8) 1.0) * t) - ((sf8) 3.0 * (n - (sf8) 1.0));
		t *= (n - (sf8) 1.0) / ((n - (sf8) 2.0) * (n - (sf8) 3.0));
		t += 3;
	}
	stats->kurtosis = (sf4) t;
	
	// clean up
	if (free_nodes == TRUE_m13)
		free_m13((void *) nodes);
	
	return_m13(TRUE_m13);
}


tern  CMP_check_block_header_alignment_m13(ui1 *bytes)
{
	CMP_FIXED_BH_m13	*cbh;
	tern			free_flag = FALSE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// check overall size
	if (sizeof(CMP_FIXED_BH_m13) != CMP_BLOCK_FIXED_HDR_BYTES_m13)
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(CMP_BLOCK_FIXED_HDR_BYTES_m13);
		free_flag = TRUE_m13;
	}
	cbh = (CMP_FIXED_BH_m13 *)bytes;
	if (&cbh->block_start_UID != (ui8 *) (bytes + CMP_BLOCK_START_UID_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->block_CRC != (ui4 *) (bytes + CMP_BLOCK_CRC_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->block_flags != (ui4 *) (bytes + CMP_BLOCK_BLOCK_FLAGS_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->start_time != (si8 *) (bytes + CMP_BLOCK_START_TIME_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->acquisition_channel_number != (si4 *) (bytes + CMP_BLOCK_ACQUISITION_CHANNEL_NUMBER_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->total_block_bytes != (ui4 *) (bytes + CMP_BLOCK_TOTAL_BLOCK_BYTES_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->number_of_samples != (ui4 *) (bytes + CMP_BLOCK_NUMBER_OF_SAMPLES_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->number_of_records != (ui2 *) (bytes + CMP_BLOCK_NUMBER_OF_RECORDS_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->record_region_bytes != (ui2 *) (bytes + CMP_BLOCK_RECORD_REGION_BYTES_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->parameter_flags != (ui4 *) (bytes + CMP_BLOCK_PARAMETER_FLAGS_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->parameter_region_bytes != (ui2 *) (bytes + CMP_BLOCK_PARAMETER_REGION_BYTES_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->protected_region_bytes != (ui2 *) (bytes + CMP_BLOCK_PROTECTED_REGION_BYTES_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->discretionary_region_bytes != (ui2 *) (bytes + CMP_BLOCK_DISCRETIONARY_REGION_BYTES_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->model_region_bytes != (ui2 *) (bytes + CMP_BLOCK_MODEL_REGION_BYTES_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	if (&cbh->total_header_bytes != (ui4 *) (bytes + CMP_BLOCK_TOTAL_HEADER_BYTES_OFFSET_m13))
		goto CMP_BLOCK_HDR_NOT_ALIGNED_m13;
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(TRUE_m13);
	
	// not aligned
CMP_BLOCK_HDR_NOT_ALIGNED_m13:
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(FALSE_m13);
}


tern CMP_check_CPS_allocation_m13(FPS_m13 *fps)
{
	tern	ret_val = TRUE_m13;
	si1		need_compressed_data = FALSE_m13;
	si1		need_decompressed_data = FALSE_m13;
	si1		need_original_data = FALSE_m13;
	si1		need_detrended_buffer = FALSE_m13;
	si1		need_derivative_buffer = FALSE_m13;
	si1		need_scaled_amplitude_buffer = FALSE_m13;
	si1		need_scaled_frequency_buffer = FALSE_m13;
	si1		need_keysample_buffer = FALSE_m13;
	si1		need_VDS_buffers = FALSE_m13;
	CPS_m13	*cps;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (fps->uh->type_code != TS_DATA_TYPE_CODE_m13) {
		G_set_error_m13(E_UNKN_m13, "fps must be time series data");
		return_m13(FALSE_m13);
	}
	
	cps = fps->params.cps;
	if (cps == NULL) {
		G_set_error_m13(E_UNKN_m13, "cps is not allocated");
		return_m13(FALSE_m13);
	}
	
	if (cps->direcs.flags & CPS_DF_VDS_ALGORITHM_m13)
		need_VDS_buffers = TRUE_m13;

	need_compressed_data = TRUE_m13;
	need_keysample_buffer = TRUE_m13;
	
	// compression
	if (cps->direcs.flags & CPS_DF_COMPRESSION_MODE_m13) {
		need_original_data = TRUE_m13;
		if (cps->direcs.flags & CPS_DF_DETREND_DATA_m13)
			need_detrended_buffer = TRUE_m13;
		if (cps->direcs.flags & (CPS_DF_SET_DERIVATIVE_LEVEL_m13 | CPS_DF_FIND_DERIVATIVE_LEVEL_m13))
			need_derivative_buffer = TRUE_m13;
		if (cps->direcs.flags & (CPS_DF_SET_AMPLITUDE_SCALE_m13 | CPS_DF_FIND_AMPLITUDE_SCALE_m13))
			need_scaled_amplitude_buffer = TRUE_m13;
		if (cps->direcs.flags & (CPS_DF_SET_FREQUENCY_SCALE_m13 | CPS_DF_FIND_FREQUENCY_SCALE_m13))
			need_scaled_frequency_buffer = TRUE_m13;
		if (cps->direcs.flags & (CPS_DF_FIND_AMPLITUDE_SCALE_m13 | CPS_DF_FIND_FREQUENCY_SCALE_m13))
			need_decompressed_data = TRUE_m13;
	} else { // decompression
		need_decompressed_data = TRUE_m13;
	}

	
	// check compressed_data
	if (need_compressed_data == TRUE_m13 && fps->ts_data == NULL) {
		G_warning_message_m13("%s(): \"compressed_data\" is not allocated in the FILE_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m13;
	}
	
	// check keysample_buffer
	if (need_keysample_buffer == TRUE_m13 && cps->params.keysample_buffer == NULL) {
		G_warning_message_m13("%s(): \"keysample_buffer\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m13;
	}
	
	// check original_data
	if (need_original_data == TRUE_m13 && cps->original_data == NULL) {
		G_warning_message_m13("%s(): \"original_data\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m13;
	}
	if (need_original_data == FALSE_m13 && cps->original_data) {
		G_warning_message_m13("%s(): \"original_data\" is needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		free_m13((void *) cps->original_data);
		cps->original_ptr = cps->original_data = NULL;
		ret_val = FALSE_m13;
	}
	
	// check decompressed_data
	if (need_decompressed_data == TRUE_m13 && cps->decompressed_data == NULL) {
		G_warning_message_m13("%s(): \"decompressed_data\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m13;
	}
	if (need_decompressed_data == FALSE_m13 && cps->decompressed_data) {
		G_warning_message_m13("%s(): \"decompressed_data\" is needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		free_m13((void *) cps->decompressed_data);
		cps->decompressed_ptr = cps->decompressed_data = NULL;
		ret_val = FALSE_m13;
	}
	
	// check detrended_buffer
	if (need_detrended_buffer == TRUE_m13 && cps->params.detrended_buffer == NULL) {
		G_warning_message_m13("%s(): \"detrended_buffer\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m13;
	}
	if (need_detrended_buffer == FALSE_m13 && cps->params.detrended_buffer) {
		G_warning_message_m13("%s(): \"detrended_buffer\" is needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		free_m13((void *) cps->params.detrended_buffer);
		cps->params.detrended_buffer = NULL;
		ret_val = FALSE_m13;
	}
	
	// check derivative_buffer
	if (need_derivative_buffer == TRUE_m13 && cps->params.derivative_buffer == NULL) {
		G_warning_message_m13("%s(): \"derivative_buffer\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m13;
	}
	if (need_derivative_buffer == FALSE_m13 && cps->params.derivative_buffer) {
		G_warning_message_m13("%s(): \"derivative_buffer\" is needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		free_m13((void *) cps->params.derivative_buffer);
		cps->params.derivative_buffer = NULL;
		ret_val = FALSE_m13;
	}
	
	// check scaled_amplitude_buffer
	if (need_scaled_amplitude_buffer == TRUE_m13 && cps->params.scaled_amplitude_buffer == NULL) {
		G_warning_message_m13("%s(): \"scaled_amplitude_buffer\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m13;
	}
	if (need_scaled_amplitude_buffer == FALSE_m13 && cps->params.scaled_amplitude_buffer) {
		G_warning_message_m13("%s(): \"scaled_amplitude_buffer\" is needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		free_m13((void *) cps->params.scaled_amplitude_buffer);
		cps->params.scaled_amplitude_buffer = NULL;
		ret_val = FALSE_m13;
	}
	
	// check scaled_frequency_buffer
	if (need_scaled_frequency_buffer == TRUE_m13 && cps->params.scaled_frequency_buffer == NULL) {
		G_warning_message_m13("%s(): \"scaled_frequency_buffer\" is not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m13;
	}
	if (need_scaled_frequency_buffer == FALSE_m13 && cps->params.scaled_frequency_buffer) {
		G_warning_message_m13("%s(): \"scaled_frequency_buffer\" is needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		free_m13((void *) cps->params.scaled_frequency_buffer);
		cps->params.scaled_frequency_buffer = NULL;
		ret_val = FALSE_m13;
	}
	
	// check VDS buffers
	if (need_VDS_buffers == TRUE_m13 && (cps->params.VDS_input_buffers == NULL || cps->params.VDS_output_buffers == NULL)) {
		G_warning_message_m13("%s(): \"VDS_buffers\" are not allocated in the CMP_PROCESSING_STRUCT\n", __FUNCTION__);
		ret_val = FALSE_m13;
	}
	if (need_VDS_buffers == FALSE_m13 && (cps->params.VDS_input_buffers || cps->params.VDS_output_buffers)) {
		G_warning_message_m13("%s(): \"VDS_buffers\" are needlessly allocated in the CMP_PROCESSING_STRUCT => freeing\n", __FUNCTION__);
		CMP_free_buffers_m13(&cps->params.VDS_input_buffers);
		CMP_free_buffers_m13(&cps->params.VDS_output_buffers);
		ret_val = FALSE_m13;
	}
	
	return_m13(ret_val);
}


tern  CMP_check_record_header_alignment_m13(ui1 *bytes)
{
	CMP_REC_HDR_m13	*crh;
	tern		free_flag = FALSE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// check overall size
	if (sizeof(CMP_REC_HDR_m13) != CMP_REC_HDR_BYTES_m13)
		goto CMP_REC_HEADER_NOT_ALIGNED_m13;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc(CMP_REC_HDR_BYTES_m13);
		free_flag = TRUE_m13;
	}
	crh = (CMP_REC_HDR_m13 *)bytes;
	if (&crh->type_code != (ui4 *) (bytes + CMP_REC_HDR_TYPE_CODE_OFFSET_m13))
		goto CMP_REC_HEADER_NOT_ALIGNED_m13;
	if (&crh->version_major != (ui1 *) (bytes + CMP_REC_HDR_VERSION_MAJOR_OFFSET_m13))
		goto CMP_REC_HEADER_NOT_ALIGNED_m13;
	if (&crh->version_minor != (ui1 *) (bytes + CMP_REC_HDR_VERSION_MINOR_OFFSET_m13))
		goto CMP_REC_HEADER_NOT_ALIGNED_m13;
	if (&crh->total_bytes != (ui2 *) (bytes + CMP_REC_HDR_TOTAL_BYTES_OFFSET_m13))
		goto CMP_REC_HEADER_NOT_ALIGNED_m13;
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(TRUE_m13);
	
	// not aligned
CMP_REC_HEADER_NOT_ALIGNED_m13:
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(FALSE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4 CMP_compare_sf8_m13(const void *a, const void * b)
{
	if (*((sf8 *) a) > *((sf8 *) b))
		return(1);
	else if (*((sf8 *) a) < *((sf8 *) b))
		return(-1);
	return(0);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4 CMP_compare_si4_m13(const void *a, const void * b)
{
	if (*((si4 *) a) > *((si4 *) b))
		return(1);
	else if (*((si4 *) a) < *((si4 *) b))
		return(-1);
	return(0);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4 CMP_compare_si8_m13(const void *a, const void * b)
{
	if (*((si8 *) a) > *((si8 *) b))
		return(1);
	else if (*((si8 *) a) < *((si8 *) b))
		return(-1);
	return(0);
}


si4	CMP_count_bins_m13(CPS_m13 *cps, si4 *deriv_p, ui1 n_derivs)
{
	ui1	*ui1_p, overflow_bytes, ks_flag;
	ui4	n_samps, n_deriv_samps, *count;
	si4	low_d, high_d, n_bins, diff;
	si8	i, j;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// generate count & build keysample array
	if (cps->params.minimum_difference_value > 0) {  // positive derivatives
		low_d = 1; high_d = 255;
		ks_flag = CMP_POS_DERIV_KEYSAMPLE_FLAG_m13;  // == 0 (non-overflow range: 1 to 255)
	} else {
		low_d = -127; high_d = 127;
		ks_flag = CMP_UI1_KEYSAMPLE_FLAG_m13;  // == -128 (non-overflow range: -127 to +127)
	}
	
	count = (ui4 *) cps->params.count;
	memset((void *) count, 0, CMP_RED_MAX_STATS_BINS_m13 * sizeof(ui4));
	overflow_bytes = CMP_get_overflow_bytes_m13(cps, CMP_COMPRESSION_MODE_m13, CMP_RED_COMPRESSION_m13);
	deriv_p += + n_derivs;
	n_samps = cps->block_header->number_of_samples;
	n_deriv_samps = n_samps - n_derivs;
	
	for (i = n_deriv_samps; i--;) {
		diff = *deriv_p++;
		if (diff < low_d || diff > high_d) {
			ui1_p = (ui1 *) &diff;
			++count[ks_flag];
			j = overflow_bytes; do {
				++count[*ui1_p++];
			} while (--j);
		} else {
			++count[(ui1) diff];
		}
	}

	n_bins = 0;
	for (i = 0; i < 256; ++i)
		if (count[i])
			++n_bins;
	
	return_m13(n_bins);
}


tern  CMP_decode_m13(FPS_m13 *fps)
{
	ui4			offset;
	si4			*si4_p;
	sf4			*sf4_p;
	sf8			intercept, gradient, amplitude_scale, frequency_scale;
	tern			(*decompression_f)(CPS_m13 *cps);
	CMP_FIXED_BH_m13	*bh;
	CPS_m13			*cps;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (fps->uh->type_code != TS_DATA_TYPE_CODE_m13) {
		G_set_error_m13(E_UNKN_m13, "fps must be time series data");
		return_m13(FALSE_m13);
	}
	
	cps = fps->params.cps;
	bh = cps->block_header;
	if (cps->params.allocated_block_samples < bh->number_of_samples) {
		if (CMP_realloc_cps_m13(fps, CMP_DECOMPRESSION_MODE_m13, (si8) bh->number_of_samples, bh->number_of_samples) == NULL)
			return_m13(FALSE_m13);
		bh = cps->block_header;
	}
	
	// discontinuity
	if (bh->block_flags & CMP_BF_DISCONTINUITY_m13)
		cps->params.discontinuity = TRUE_m13;
	else
		cps->params.discontinuity = FALSE_m13;
	
	// get variable region
	CMP_get_variable_region_m13(cps);
	
	// decompress
	cps->direcs.flags &= ~CPS_DF_ALGORITHM_MASK_m13;  // clear directives algorithm flags
	switch (bh->block_flags & CMP_BF_ALGORITHMS_MASK_m13) {
		case CMP_BF_RED1_ENCODING_m13:
			cps->direcs.flags |= CPS_DF_RED1_ALGORITHM_m13;
			decompression_f = CMP_RED1_decode_m13;
			break;
		case CMP_BF_PRED1_ENCODING_m13:
			cps->direcs.flags |= CPS_DF_PRED1_ALGORITHM_m13;
			decompression_f = CMP_PRED1_decode_m13;
			break;
		case CMP_BF_RED2_ENCODING_m13:
			cps->direcs.flags |= CPS_DF_RED2_ALGORITHM_m13;
			decompression_f = CMP_RED2_decode_m13;
			break;
		case CMP_BF_PRED2_ENCODING_m13:
			cps->direcs.flags |= CPS_DF_PRED2_ALGORITHM_m13;
			decompression_f = CMP_PRED2_decode_m13;
			break;
		case CMP_BF_MBE_ENCODING_m13:
			cps->direcs.flags |= CPS_DF_MBE_ALGORITHM_m13;
			decompression_f = CMP_MBE_decode_m13;
			break;
		case CMP_BF_VDS_ENCODING_m13:
			cps->direcs.flags |= CPS_DF_VDS_ALGORITHM_m13;
			decompression_f = CMP_VDS_decode_m13;
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "unrecognized compression algorithm (%u)\n", bh->block_flags & CMP_BF_ALGORITHMS_MASK_m13);
			return_m13(FALSE_m13);
	}
	(*decompression_f)(cps);  // block-specific decompression algorithm

	if (!(cps->direcs.flags & CPS_DF_VDS_ALGORITHM_m13)) {
		// unscale frequency-scaled decompressed_data if scaled (in place)
		// no blockwise frequency scaling in VDS encoded data
		if (bh->parameter_flags & CMP_PF_FREQUENCY_SCALE_m13) {
			sf4_p = (sf4 *) cps->block_parameters;
			offset = cps->params.block_parameter_map[CMP_PF_FREQUENCY_SCALE_IDX_m13];
			frequency_scale = (sf8) *(sf4_p + offset);
			CMP_unscale_frequency_si4_m13(cps->decompressed_ptr, cps->decompressed_ptr, (si8) bh->number_of_samples, frequency_scale);
		}
		
		// unscale amplitude-scaled decompressed_data if scaled (in place)
		// VDS_decode_m13() does amplitude scaling itself
		if (bh->parameter_flags & CMP_PF_AMPLITUDE_SCALE_m13) {
			sf4_p = (sf4 *) cps->block_parameters;
			offset = cps->params.block_parameter_map[CMP_PF_AMPLITUDE_SCALE_IDX_m13];
			amplitude_scale = (sf8) *(sf4_p + offset);
			CMP_unscale_amplitude_si4_m13(cps->decompressed_ptr, cps->decompressed_ptr, (si8) bh->number_of_samples, amplitude_scale);
		}
		
		// add trend to decompressed_data if detrended (in place)
		// VDS_decode_m13() does retrending itself
		if (CMP_IS_DETRENDED_m13(bh)) {
			sf4_p = (sf4 *) cps->block_parameters;
			offset = cps->params.block_parameter_map[CMP_PF_GRADIENT_IDX_m13];
			gradient = (sf8) *(sf4_p + offset);
			si4_p = (si4 *) cps->block_parameters;
			offset = cps->params.block_parameter_map[CMP_PF_INTERCEPT_IDX_m13];
			intercept = (sf8) *(si4_p + offset);
			CMP_retrend_si4_m13(cps->decompressed_ptr, cps->decompressed_ptr, bh->number_of_samples, gradient, intercept);
		}
	}
	
	// restrict returned samples
	cps->params.block_end_index = 0xFFFFFFFF;  // reset
	if (cps->params.block_start_index) {
		if (!(cps->direcs.flags & CPS_DF_VDS_ALGORITHM_m13) || (cps->direcs.flags & CPS_DF_CPS_CACHING_m13))
			cps->decompressed_data = cps->params.cache + cps->params.block_start_index;
		cps->params.block_start_index = 0;  // reset
	}

	return_m13(TRUE_m13);
}


tern	CMP_decrypt_m13(FPS_m13 *fps)
{
	ui1			*key;
	si1			enc_level;
	si8			encryption_bytes, encryptable_bytes;
	PROC_GLOBS_m13		*proc_globs;
	UH_m13			*uh;
	CMP_FIXED_BH_m13	*bh;
	PASSWORD_DATA_m13	*pwd;
	CPS_m13			*cps;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (fps->uh->type_code != TS_DATA_TYPE_CODE_m13) {
		G_set_error_m13(E_UNKN_m13, "fps must be time series data");
		return_m13(FALSE_m13);
	}
	cps = fps->params.cps;
	bh = cps->block_header;
	
	// block not encrypted
	if (!(bh->block_flags & CMP_BF_ENCRYPTED_m13))
		return_m13(TRUE_m13);

	// get decryption key
	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	pwd = &proc_globs->password_data;
	uh = fps->uh;
	enc_level = uh->encryption_1;
	if (pwd->access_level >= enc_level) {
		if (enc_level == LEVEL_1_ENCRYPTION_m13)
			key = pwd->level_1_encryption_key;
		else
			key = pwd->level_1_encryption_key;
	} else {
		G_set_error_m13(E_ENC_m13, "cannot decrypt data: insufficient access");
		return_m13(FALSE_m13);
	}
	
	// calculate encryption bytes
	encryptable_bytes = bh->total_block_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m13;
	if (bh->block_flags | CMP_BF_MBE_ENCODING_m13) {
		encryption_bytes = encryptable_bytes;
	} else {
		encryption_bytes = (bh->total_header_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m13) + ENCRYPTION_BLOCK_BYTES_m13;
		if (encryption_bytes > encryptable_bytes)
			encryption_bytes = encryptable_bytes;
	}
	
	// decrypt
	AES_decrypt_m13((ui1 *) bh + CMP_BLOCK_ENCRYPTION_START_OFFSET_m13, encryption_bytes, NULL, key, uh->encryption_rounds);
	
	// mark block as decrypted
	bh->block_flags &= ~CMP_BF_ENCRYPTED_m13;
	
	return_m13(TRUE_m13);
}


tern	CMP_detrend_m13(si4 *input_buffer, si4 *output_buffer, si8 len, CPS_m13 *cps)
{
	si4	*si4_p1, *si4_p2;
	sf4	sf4_m;
	si4	si4_b;
	sf8	m, b, mx_plus_b;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// detrend from input_buffer to output_buffer
	// slope and intercept values entered into bh
	// if input_buffer == output_buffer detrending will be done in place
	// if cps store coefficients in block parameters
	
	CMP_lad_reg_si4_m13(input_buffer, len, &m, &b);
	
	// store m & b in block parameter region
	// NOTE: block parameter region must be setup first
	if (cps) {
		// demote precision
		sf4_m = (sf4) m;
		si4_b = CMP_round_si4_m13(b);  // this is an integer because sf4 can only precisely encode offsets up to 24 bits, but MED guarantees 32-bit lossless detrending
		// store the values
		*((sf4 *) cps->block_parameters + cps->params.block_parameter_map[CMP_PF_GRADIENT_IDX_m13]) = sf4_m;
		*((si4 *) cps->block_parameters + cps->params.block_parameter_map[CMP_PF_INTERCEPT_IDX_m13]) = si4_b;
		// promote back to sf8, maintaining demoted precision
		m = (sf8) sf4_m;
		b = (sf8) si4_b;
	}

	// subtract trend from input_buffer to output_buffer
	mx_plus_b = b;
	si4_p1 = input_buffer;
	si4_p2 = output_buffer;
	while (len--)
		*si4_p2++ = CMP_round_si4_m13((sf8) *si4_p1++ - (mx_plus_b += m));

	return_m13(TRUE_m13);
}

					 
tern	CMP_detrend_sf8_m13(sf8 *input_buffer, sf8 *output_buffer, si8 len)
{
	sf8	*sf8_p1, *sf8_p2, m, b, mx_plus_b;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// detrend from input_buffer to output_buffer
	// slope and intercept values entered into bh
	// if input_buffer == output_buffer detrending will be done in place
	// if cps store coefficients in block parameters
	
	CMP_lad_reg_sf8_m13(input_buffer, len, &m, &b);
	
	// subtract trend from input_buffer to output_buffer
	mx_plus_b = b;
	sf8_p1 = input_buffer;
	sf8_p2 = output_buffer;
	while (len--)
		*sf8_p2++ = *sf8_p1++ - (mx_plus_b += m);

	return_m13(TRUE_m13);
}


ui1	CMP_differentiate_m13(CPS_m13 *cps)
{
	ui1			deriv_level, set_deriv_level;
	ui4			n_samps, n_diffs;
	si4			*input_buffer, *deriv_buffer, samp_min, samp_max, diff_min, diff_max;
	si4			diff, *si4_p1, *si4_p2, *si4_p3, n_bins, last_bins;
	si8			i, si8_diff, pos_inf_si4, neg_inf_si4;
	CMP_FIXED_BH_m13	*bh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Returns 0-255
	
	// from input buffer to derivative buffer
	bh = cps->block_header;
	n_samps = bh->number_of_samples;
	if (n_samps <= 1) {
		if (n_samps == 1)
			cps->params.minimum_sample_value = cps->params.maximum_sample_value = cps->input_buffer[0];
		else
			cps->params.minimum_sample_value = cps->params.maximum_sample_value = 0;
		cps->params.derivative_level = cps->params.minimum_difference_value = cps->params.maximum_difference_value = 0;
		return_m13(0);
	}

	set_deriv_level = 1;  // default
	if (cps->direcs.flags & CPS_DF_FIND_DERIVATIVE_LEVEL_m13)
		set_deriv_level = 0xFF;
	else if (cps->direcs.flags & CPS_DF_SET_DERIVATIVE_LEVEL_m13)
		set_deriv_level = cps->params.goal_derivative_level;
	if (set_deriv_level != 1) {
		if (set_deriv_level == 0) {
			G_warning_message_m13("%s(): requested derivative level is zero\n", __FUNCTION__);
			CMP_find_extrema_m13(NULL, 0, NULL, NULL, cps);
			memcpy((void *) cps->params.derivative_buffer, (void *) cps->input_buffer, (size_t) (n_samps << 2));
			cps->params.derivative_level = cps->params.minimum_difference_value = cps->params.maximum_difference_value = 0;
			return_m13(0);
		}
		cps->params.scrap_buffers = CMP_allocate_buffers_m13(cps->params.scrap_buffers, 1, n_samps, sizeof(si4), FALSE_m13, FALSE_m13);
	}
	
	// first derivative level (gets min & max sample values)
	input_buffer = cps->input_buffer;
	deriv_buffer = cps->params.derivative_buffer;
	si4_p1 = input_buffer + (n_samps - 1);
	si4_p2 = si4_p1 - 1;
	si4_p3 = deriv_buffer + (n_samps - 1);
	samp_min = samp_max = input_buffer[0];
	diff_min = diff_max = input_buffer[1] - input_buffer[0];
	deriv_level = (ui1) 1;
	n_diffs = n_samps - deriv_level;
	pos_inf_si4 = (si8) POS_INF_SI4_m13;
	neg_inf_si4 = (si8) NEG_INF_SI4_m13;
	for (i = n_diffs; i--;) {
		if (*si4_p1 < samp_min)
			samp_min = *si4_p1;
		else if (*si4_p1 > samp_max)
			samp_max = *si4_p1;
		si8_diff = (si8) *si4_p1-- - (si8) *si4_p2--;
		if (si8_diff > pos_inf_si4 || si8_diff < neg_inf_si4) {
			G_warning_message_m13("\n%s(): difference exceeds 4-byte integer range => returning derivative level zero\n", __FUNCTION__);
			CMP_find_extrema_m13(NULL, 0, NULL, NULL, cps);
			memcpy((void *) cps->params.derivative_buffer, (void *) cps->input_buffer, (size_t) (n_samps << 2));
			cps->params.derivative_level = cps->params.minimum_difference_value = cps->params.maximum_difference_value = 0;
			return_m13(0);
		}
		diff = (si4) si8_diff;
		if (diff < diff_min)
			diff_min = diff;
		else if (diff > diff_max)
			diff_max = diff;
		*si4_p3-- = diff;
	}
	*si4_p3 = *si4_p1;  // first derivative initial value
	cps->params.minimum_sample_value = samp_min;
	cps->params.maximum_sample_value = samp_max;
	cps->params.minimum_difference_value = diff_min;
	cps->params.maximum_difference_value = diff_max;
	cps->params.derivative_level = 1;

	if (set_deriv_level == 1)
		return_m13(1);
	
	// higher derivatives
	if (set_deriv_level == 0xFF)  // find_derivative_level option
		last_bins = CMP_count_bins_m13(cps, cps->params.derivative_buffer, deriv_level);
	
	while (--n_diffs) {
		input_buffer = cps->params.derivative_buffer;
		deriv_buffer = (si4 *) cps->params.scrap_buffers->buffer[0];  // need a scrap buffer for "find" option
		si4_p1 = input_buffer + (n_samps - 1);
		si4_p2 = si4_p1 - 1;
		si4_p3 = deriv_buffer + (n_samps - 1);
		diff_min = diff_max = input_buffer[deriv_level + 1] - input_buffer[deriv_level];
		for (i = n_diffs; i--;) {
			si8_diff = (si8) *si4_p1-- - (si8) *si4_p2--;
			if (si8_diff > pos_inf_si4 || si8_diff < neg_inf_si4) {
				cps->params.derivative_level = deriv_level;
				return_m13(deriv_level);  // return previous derivative level level
			}
			diff = (si4) si8_diff;
			if (diff < diff_min)
				diff_min = diff;
			else if (diff > diff_max)
				diff_max = diff;
			*si4_p3-- = diff;
		}
		*si4_p3 = *si4_p1;  // derivative initial value
		++deriv_level;
		if (set_deriv_level == 0xFF) {  // find_derivative_level option
			n_bins = CMP_count_bins_m13(cps, deriv_buffer, deriv_level);
			if (n_bins < last_bins) {
				cps->params.minimum_difference_value = diff_min;
				cps->params.maximum_difference_value = diff_max;
				cps->params.derivative_level = deriv_level;
				last_bins = n_bins;
				memcpy((void *) input_buffer, (void *) deriv_buffer, (size_t) (n_samps << 2));  // copy into CPS derivative buffer (called "input_buffer" here)
			} else {
				--deriv_level;
				break;
			}
		} else {
			cps->params.minimum_difference_value = diff_min;
			cps->params.maximum_difference_value = diff_max;
			cps->params.derivative_level = deriv_level;
			memcpy((void *) input_buffer, (void *) deriv_buffer, (size_t) (n_samps << 2));  // copy into CPS derivative buffer (called "input_buffer" here)
			if (deriv_level == set_deriv_level)
				break;
		}
	}
	
	return_m13(deriv_level);
}


tern  CMP_encode_m13(FPS_m13 *fps, si8 start_time, si4 acquisition_channel_number, ui4 n_samples)
{
	tern 	 		data_is_compressed, allow_lossy_compression;
	ui1			normality;
	tern			(*compression_f)(CPS_m13 *cps);
	CPS_m13			*cps;
	CMP_FIXED_BH_m13	*bh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (fps->uh->type_code != TS_DATA_TYPE_CODE_m13) {
		G_set_error_m13(E_UNKN_m13, "fps must be time series data");
		return_m13(FALSE_m13);
	}

	cps = fps->params.cps;
	bh = cps->block_header;
	if (cps->params.allocated_block_samples < n_samples) {
		if (CMP_realloc_cps_m13(fps, CMP_COMPRESSION_MODE_m13, (si8) n_samples, n_samples) == NULL)
			return_m13(FALSE_m13);
		bh = cps->block_header;
	}

	// calling function must set cps->input_buffer to use anything other than cps->original_ptr
	if (cps->input_buffer == NULL) {
		if (cps->original_ptr == NULL) {
			G_set_error_m13(E_UNKN_m13, "input buffer is NULL");
			return_m13(FALSE_m13);
		} else {
			cps->input_buffer = cps->original_ptr;
		}
	}
	
	// fill in passed header fields
	bh->block_start_UID = CMP_BLOCK_START_UID_m13;
	bh->start_time = start_time;
	bh->acquisition_channel_number = acquisition_channel_number;
	bh->number_of_samples = n_samples;
	
	// reset block flags
	bh->block_flags = 0;
	
	// set up variable region
	CMP_set_variable_region_m13(cps);
	
	// discontinuity
	if (cps->params.discontinuity == TRUE_m13) {
		bh->block_flags |= CMP_BF_DISCONTINUITY_m13;
		if (cps->direcs.flags & CPS_DF_RESET_DISCONTINUITY_m13)
			cps->params.discontinuity = FALSE_m13;
	}
		
	// select compression
	// (compression algorithms are responsible for filling in: algorithm block flag, total_header_bytes, total_block_bytes, model_region_bytes, & model details)
	switch (cps->direcs.flags & CPS_DF_ALGORITHM_MASK_m13) {
		case CPS_DF_RED1_ALGORITHM_m13:
			compression_f = CMP_RED1_encode_m13;
			break;
		case CPS_DF_PRED1_ALGORITHM_m13:
			compression_f = CMP_PRED1_encode_m13;
			break;
		case CPS_DF_RED2_ALGORITHM_m13:
			compression_f = CMP_RED2_encode_m13;
			break;
		case CPS_DF_PRED2_ALGORITHM_m13:
			compression_f = CMP_PRED2_encode_m13;
			break;
		case CPS_DF_MBE_ALGORITHM_m13:
			compression_f = CMP_MBE_encode_m13;
			break;
		case CPS_DF_VDS_ALGORITHM_m13:
			compression_f = CMP_VDS_encode_m13;
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "unrecognized compression algorithm\n");
			return_m13(FALSE_m13);
	}
	
	// detrend
	if (cps->direcs.flags & CPS_DF_DETREND_DATA_m13) {
		CMP_detrend_m13(cps->input_buffer, cps->params.detrended_buffer, bh->number_of_samples, cps);
		cps->input_buffer = cps->params.detrended_buffer;
	}
	
	// lossy compression
	data_is_compressed = FALSE_m13;
	if (compression_f != CMP_VDS_encode_m13) {
		allow_lossy_compression = TRUE_m13;
		if (cps->direcs.flags & CPS_DF_REQUIRE_NORMALITY_m13) {
			normality = CMP_normality_score_m13(cps->input_buffer, bh->number_of_samples);
			if (normality < cps->params.minimum_normality) {
				allow_lossy_compression = FALSE_m13;
				bh->parameter_flags &= ~(CMP_PF_AMPLITUDE_SCALE_m13 | CMP_PF_FREQUENCY_SCALE_m13);
			}
		}
		if (allow_lossy_compression == TRUE_m13) {
			if (cps->direcs.flags & (CPS_DF_SET_AMPLITUDE_SCALE_m13 | CPS_DF_FIND_AMPLITUDE_SCALE_m13)) {
				if (cps->direcs.flags & CPS_DF_FIND_AMPLITUDE_SCALE_m13)
					data_is_compressed = CMP_find_amplitude_scale_m13(cps, compression_f);
				else if (cps->direcs.flags & CPS_DF_SET_AMPLITUDE_SCALE_m13)
					CMP_scale_amplitude_si4_m13(cps->input_buffer, cps->params.scaled_amplitude_buffer, bh->number_of_samples, (sf8) cps->params.amplitude_scale, cps);
				cps->input_buffer = cps->params.scaled_amplitude_buffer;
			}
			  if (cps->direcs.flags & (CPS_DF_SET_FREQUENCY_SCALE_m13 | CPS_DF_FIND_FREQUENCY_SCALE_m13)) {
				if (cps->direcs.flags & CPS_DF_FIND_FREQUENCY_SCALE_m13)
					data_is_compressed = CMP_find_frequency_scale_m13(cps, compression_f);
				else if (cps->direcs.flags & CPS_DF_SET_FREQUENCY_SCALE_m13)
					CMP_scale_frequency_si4_m13(cps->input_buffer, cps->params.scaled_frequency_buffer, bh->number_of_samples, (sf8)cps->params.frequency_scale, cps);
				cps->input_buffer = cps->params.scaled_frequency_buffer;
			}
		}
	}
	
	// noise scores
	if (cps->direcs.flags & CPS_DF_INCLUDE_NOISE_SCORES_m13) {
		// code not written yet
	}
	
	// compress
	if (data_is_compressed == FALSE_m13)
		(*compression_f)(cps);

	// encryption done in write_file_m13()
	// if done here, leave_decrypted FPS directive won't work
	// call would be: CMP_encrypt_m13(cps);

	// reset input_buffer (because this can be changed by internal library functions)
	cps->input_buffer = NULL;
	
	return_m13(TRUE_m13);
}


tern CMP_encrypt_m13(FPS_m13 *fps)
{
	ui1				*key;
	si1				enc_level;
	ui4				encryption_bytes, encryptable_bytes;
	PROC_GLOBS_m13		*proc_globs;
	UH_m13		*uh;
	PASSWORD_DATA_m13		*pwd;
	CMP_FIXED_BH_m13	*bh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (fps->uh->type_code != TS_DATA_TYPE_CODE_m13) {
		G_set_error_m13(E_UNKN_m13, "fps must be time series data");
		return_m13(FALSE_m13);
	}

	uh = fps->uh;
	enc_level = uh->encryption_1;
	if (enc_level == NO_ENCRYPTION_m13)
		return_m13(TRUE_m13);

	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	pwd = &proc_globs->password_data;
	bh = fps->params.cps->block_header;
	
	// block already encrypted
	if (bh->block_flags & CMP_BF_ENCRYPTED_m13)
		return_m13(TRUE_m13);
	
	// check access
	if (pwd->access_level >= enc_level) {
		if (enc_level == LEVEL_1_ENCRYPTION_m13) {
			key = pwd->level_1_encryption_key;
		} else {
			key = pwd->level_2_encryption_key;
		}
	} else {
		G_set_error_m13(E_ENC_m13, "cannot encrypt data => insufficient access\n");
		return_m13(FALSE_m13);
	}
	
	// calculate encryption bytes
	encryptable_bytes = bh->total_block_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m13;
	if (bh->block_flags | CMP_BF_MBE_ENCODING_m13) {
		encryption_bytes = encryptable_bytes;
	} else {
		encryption_bytes = (bh->total_header_bytes - CMP_BLOCK_ENCRYPTION_START_OFFSET_m13) + ENCRYPTION_BLOCK_BYTES_m13;
		if (encryption_bytes > encryptable_bytes)
			encryption_bytes = encryptable_bytes;
	}
	
	// encrypt
	AES_encrypt_m13((ui1 *) bh + CMP_BLOCK_ENCRYPTION_START_OFFSET_m13, encryption_bytes, NULL, key, uh->encryption_rounds);
	
	// mark block as encrypted
	bh->block_flags |= CMP_BF_ENCRYPTED_m13;

	return_m13(TRUE_m13);
}


tern  CMP_find_amplitude_scale_m13(CPS_m13 *cps, tern (*compression_f)(CPS_m13 *cps))
{
	tern 			data_is_compressed;
	si8 			i;
	si4			*input_buffer;
	sf8 			original_size, goal_compression_ratio;
	sf8 			low_sf, high_sf, mrr, mrr2, mrr5, sf_per_mrr;
	sf8 			goal_low_bound, goal_high_bound, goal_mrr, goal_tol;
	sf4 			new_scale_factor;
	CMP_FIXED_BH_m13	*bh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	input_buffer = cps->input_buffer;
	bh = cps->block_header;
	data_is_compressed = FALSE_m13;

	if (cps->direcs.flags & CPS_DF_USE_COMPRESSION_RATIO_m13) {
		goal_compression_ratio = cps->params.goal_ratio;
		goal_low_bound = goal_compression_ratio - cps->params.goal_tolerance;
		goal_high_bound = goal_compression_ratio + cps->params.goal_tolerance;
		cps->params.amplitude_scale = (sf4) 1.0;
		(*compression_f)(cps);
		data_is_compressed = TRUE_m13;
		original_size = (sf8) bh->number_of_samples * (sf8) sizeof(si4);
		cps->params.actual_ratio = (sf8) bh->total_block_bytes / original_size;
		if (cps->params.actual_ratio > goal_high_bound) {
			// loop until acceptable scale factor found
			for (i = cps->params.maximum_goal_attempts; i--;) {
				new_scale_factor = cps->params.amplitude_scale * (sf4) (cps->params.actual_ratio / goal_compression_ratio);
				if ((ABS_m13(new_scale_factor - cps->params.amplitude_scale) <= (sf4) 0.000001) || (new_scale_factor <= (sf4) 1.0))
					break;
				cps->params.amplitude_scale = new_scale_factor;
				(*compression_f)(cps);  // compress
				cps->params.actual_ratio = (sf8) bh->total_block_bytes / original_size;
				if ((cps->params.actual_ratio <= goal_high_bound) && (cps->params.actual_ratio >= goal_low_bound))
					break;
			}
		}
	}
	if (cps->direcs.flags & CPS_DF_USE_MEAN_RESIDUAL_RATIO_m13) {
		// get residual ratio at sf 2 & 5 (roughly linear relationship: reasonable sample points)
		cps->params.amplitude_scale = (sf4) 2.0;
		CMP_generate_lossy_data_m13(cps, input_buffer, cps->decompressed_ptr, CMP_AMPLITUDE_SCALE_MODE_m13);
		mrr2 = CMP_calculate_mean_residual_ratio_m13(input_buffer, cps->decompressed_ptr, bh->number_of_samples);
		if (mrr2 == (sf8) 0.0) {  // all zeros in block
			cps->params.amplitude_scale = (sf4) 1.0;
			cps->params.actual_ratio = (sf8) 0.0;
			(*compression_f)(cps);
			goto CMP_MRR_DONE_m13;
		}
		cps->params.amplitude_scale = (sf4) 5.0;
		CMP_generate_lossy_data_m13(cps, input_buffer, cps->decompressed_ptr, CMP_AMPLITUDE_SCALE_MODE_m13);
		mrr5 = CMP_calculate_mean_residual_ratio_m13(input_buffer, cps->decompressed_ptr, bh->number_of_samples);
		sf_per_mrr = (sf8) 3.0 / (mrr5 - mrr2);
		// estimate starting points
		goal_mrr = cps->params.goal_ratio;
		goal_tol = cps->params.goal_tolerance;
		goal_low_bound = goal_mrr - goal_tol;
		goal_high_bound = goal_mrr + goal_tol;
		cps->params.amplitude_scale = (sf4)(((goal_mrr - mrr2) * sf_per_mrr) + (sf8)2.0);
		high_sf = ((goal_high_bound - mrr2) * sf_per_mrr) + (sf8) 2.0;
		high_sf *= (sf8) 2.0;  // empirically reasonable
		low_sf = (sf8) 1.0;
		for (i = cps->params.maximum_goal_attempts; i--;) {
			CMP_generate_lossy_data_m13(cps, input_buffer, cps->decompressed_ptr, CMP_AMPLITUDE_SCALE_MODE_m13);
			mrr = CMP_calculate_mean_residual_ratio_m13(input_buffer, cps->decompressed_ptr, bh->number_of_samples);
			if (mrr < goal_low_bound)
				low_sf = (sf8) cps->params.amplitude_scale;
			else if (mrr > goal_high_bound)
				high_sf = (sf8) cps->params.amplitude_scale;
			else
				break;
			new_scale_factor = (sf4) ((low_sf + high_sf) / (sf8) 2.0);
			if (new_scale_factor <= (sf4) 1.0)
				break;
			cps->params.amplitude_scale = new_scale_factor;
			if ((high_sf - low_sf) < (sf8) 0.005)
				break;
		}
		cps->params.actual_ratio = mrr;
	} else {
		G_set_error_m13(E_UNKN_m13, "either use_compression_ratio or use_mean_residual_ratio directive must be set");
		return_m13(data_is_compressed);
	} CMP_MRR_DONE_m13:
	
	return_m13(data_is_compressed);
}


si8  *CMP_find_crits_m13(sf8 *data, si8 data_len, si8 *n_crits, si8 *crit_xs)
{
	const si1	PEAK = 1, TROUGH = -1;
	si1 	mode;
	si8 	nc, i, j, n, crit;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// find peaks & troughs (also see CMP_find_crits_2_m13)
	// if crit_xs == NULL, array is allocated & returned;
	
	if (data == NULL) {
		G_set_error_m13(E_UNKN_m13, "NULL pointer passed");
		return_m13(NULL);
	}

	if (crit_xs == NULL)
		crit_xs = (si8 *) malloc((size_t) (data_len << 3));
	
	// skip leading nans
	for (n = 0; isnan(data[n]) && n < data_len; ++n);
	 
	for (j = n; j < data_len; ++j)
		if (data[j] != data[n])
			break;
	
	crit_xs[0] = 0;
	if (j == data_len) {
		*n_crits = 2;
		crit_xs[1] = data_len - 1;
		return_m13(crit_xs);
	}
	nc = 1;
	
	if (data[0] < data[j])
		mode = PEAK;
	else
		mode = TROUGH;
	
	i = j - 1;
	while (j < data_len) {
		if (mode == PEAK) {
			while (j < data_len) {
				if (data[j] > data[i])
					i = j++;
				else if (data[j] == data[i])
					++j;
				else if (data[j] < data[i])
					break;
				else  // nan
					++j;
			}
			mode = TROUGH;
		} else {  // mode == TROUGH
			while (j < data_len) {
				if (data[j] < data[i])
					i = j++;
				else if (data[j] == data[i])
					++j;
				else if (data[j] > data[i])
					break;
				else  // nan
					++j;
			}
			mode = PEAK;
		}
		if (i == (j - 1)) {
			crit = i;
		} else {
			crit = (i + j + 1) / 2;
			i = j - 1;
		}
		crit_xs[nc++] = crit;
	}
	
	if (crit_xs[nc - 1] != (data_len - 1))
		crit_xs[nc++] = (data_len - 1);
	
	*n_crits = nc;
	
	return_m13(crit_xs);
}


tern	CMP_find_crits_2_m13(sf8 *data, si8 data_len, si8 *n_peaks, si8 *peak_xs, si8 *n_troughs, si8 *trough_xs)
{
	const si1	PEAK = 1, TROUGH = 2;
	si1 	mode;
	si8 	np, nt, i, j, n, crit;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// CMP_find_crits_2(): find peaks & troughs separately (see CMP_find_crits_m13)
	
	if (data == NULL || peak_xs == NULL || trough_xs == NULL) {
		G_set_error_m13(E_UNKN_m13, "NULL pointer passed");
		return_m13(FALSE_m13);
	}
	
	for (n = 0; isnan(data[n]) && n < data_len; ++n);
	 
	for (j = n + 1; j < data_len; ++j)
		if (data[j] != data[n])
			break;
	
	peak_xs[0] = trough_xs[0] = 0;
	if (j == data_len) {
		peak_xs[1] = trough_xs[1] = data_len - 1;
		*n_peaks = *n_troughs = 2;
		return_m13(TRUE_m13);
	}
	np = nt = 1;
	
	if (data[0] < data[j])
		mode = PEAK;
	else
		mode = TROUGH;
	
	i = j - 1;
	while (j < data_len) {
		if (mode == PEAK) {
			while (j < data_len) {
				if (data[j] > data[i])
					i = j++;
				else if (data[j] == data[i])
					++j;
				else if (data[j] < data[i])
					break;
				else  // nan
					++j;
			}
			mode = TROUGH;
		} else {  // mode == TROUGH
			while (j < data_len) {
				if (data[j] < data[i])
					i = j++;
				else if (data[j] == data[i])
					++j;
				else if (data[j] > data[i])
					break;
				else  // nan
					++j;
			}
			mode = PEAK;
		}
		if (i == (j - 1)) {
			crit = i;
		} else {
			crit = (i + j + 1) / 2;
			i = j - 1;
		}
		if (mode == TROUGH)
			peak_xs[np++] = crit;
		else
			trough_xs[nt++] = crit;
	}
	
	if (peak_xs[np - 1] != (data_len - 1))
		peak_xs[np++] = (data_len - 1);
	if (trough_xs[nt - 1] != (data_len - 1))
		trough_xs[nt++] = (data_len - 1);
	
	*n_peaks = np;
	*n_troughs = nt;
	
	return_m13(TRUE_m13);
}


tern  CMP_find_extrema_m13(si4 *input_buffer, si8 len, si4 *minimum, si4 *maximum, CPS_m13 *cps)
{
	si4 min, max;
	si8 i;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (cps) {
		len = cps->block_header->number_of_samples;
		input_buffer = cps->input_buffer;
	}
	
	min = max = *input_buffer;
	for (i = len; --i;) {
		if (*++input_buffer > max)
			max = *input_buffer;
		else if (*input_buffer < min)
			min = *input_buffer;
	}
	
	if (cps) {
		cps->params.minimum_sample_value = min;
		cps->params.maximum_sample_value = max;
	}
	if (minimum)
		*minimum = min;
	if (maximum)
		*maximum = max;
	
	// get extreme difference values
	if (cps && cps->params.derivative_buffer && cps->params.derivative_level > 0) {
		input_buffer = cps->params.derivative_buffer + (si8) cps->params.derivative_level;
		min = max = *input_buffer;
		len -= (si8) cps->params.derivative_level;
		for (i = len; --i;) {
			if (*++input_buffer > max)
				max = *input_buffer;
			else if (*input_buffer < min)
				min = *input_buffer;
		}
		cps->params.minimum_difference_value = min;
		cps->params.maximum_difference_value = max;
	}

	return_m13(TRUE_m13);
}


tern	CMP_find_frequency_scale_m13(CPS_m13 *cps, tern (*compression_f)(CPS_m13 *cps))
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// code not written yet
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern  CMP_free_buffers_m13(CMP_BUFFERS_m13 **buffers_ptr)
{
	CMP_BUFFERS_m13 *buffers;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns FALSE_m13 if buffer not freed
	if (buffers_ptr == NULL)
		return_m13(FALSE_m13);
	buffers = *buffers_ptr;
	if (buffers == NULL)
		return_m13(FALSE_m13);
	
	if (buffers->locked == TRUE_m13) {
#if defined MACOS_m13 || defined LINUX_m13
		munlock((void *) buffers->buffer, (size_t) buffers->total_allocated_bytes);
#endif
#ifdef WINDOWS_m13
		VirtualUnlock((void *) buffers->buffer, (size_t) buffers->total_allocated_bytes);
#endif
	}
	free_m13((void *) buffers->buffer);
	
	if (freeable_m13((void *) buffers) == TRUE_m13)
		free_m13((void *) buffers);
	
	*buffers_ptr = NULL;
	
	return_m13(TRUE_m13);
}


tern  CMP_free_cps_cache_m13(CPS_m13 *cps)
{
	tern	freed = FALSE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (cps == NULL)
		return_m13(freed);

	if (cps->params.cache) {
		free_m13((void * ) cps->params.cache);
		cps->params.allocated_decompressed_samples = 0;
		cps->decompressed_data = cps->decompressed_ptr = cps->params.cache = NULL;
		freed = TRUE_m13;
	}

	if (cps->params.cached_blocks) {
		free_m13((void *) cps->params.cached_blocks);
		cps->params.cached_blocks = NULL;
		cps->params.cached_block_list_len = cps->params.cached_block_cnt = 0;
		freed = TRUE_m13;
	}

	return_m13(freed);
}


tern  CMP_free_cps_m13(CPS_m13 **cps_ptr)
{
	CPS_m13			*cps;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (cps_ptr == NULL) {
		G_set_error_m13(E_UNKN_m13, "cps_ptr is NULL");
		return_m13(FALSE_m13);
	}
	cps = *cps_ptr;
	if (cps == NULL) {
		G_set_error_m13(E_UNKN_m13, "cps is NULL");
		return_m13(FALSE_m13);
	}

	if (cps->original_data)
		free_m13((void *) cps->original_data);
	
	if (cps->params.cache)  // decompressed_data is pointer into this
		free_m13((void *) cps->params.cache);
	
	if (cps->params.keysample_buffer)
		free_m13((void *) cps->params.keysample_buffer);
	
	if (cps->params.detrended_buffer)
		free_m13((void *) cps->params.detrended_buffer);
	
	if (cps->params.scaled_amplitude_buffer)
		free_m13((void *) cps->params.scaled_amplitude_buffer);
	
	if (cps->params.scaled_frequency_buffer)
		free_m13((void *) cps->params.scaled_frequency_buffer);
	
	if (cps->params.scrap_buffers)
		CMP_free_buffers_m13(&cps->params.scrap_buffers);
	
	if (cps->params.count)
		free_m13((void *) cps->params.count);
	
	if (cps->params.cumulative_count)
		free_m13((void *) cps->params.cumulative_count);
	
	if (cps->params.sorted_count)
		free_m13((void *) cps->params.sorted_count);
	
	if (cps->params.minimum_range)
		free_m13((void *) cps->params.minimum_range);
	
	if (cps->params.symbol_map)
		free_m13((void *) cps->params.symbol_map);
	
	if (cps->params.VDS_input_buffers)
		CMP_free_buffers_m13(&cps->params.VDS_input_buffers);
	if (cps->params.VDS_output_buffers)
		CMP_free_buffers_m13(&cps->params.VDS_output_buffers);
	
	if (freeable_m13((void *) cps) == TRUE_m13)
		free_m13((void *) cps);
	
	*cps_ptr = NULL;
	
	return_m13(TRUE_m13);
}


sf8	CMP_gamma_cdf_m13(sf8 x, sf8 k, sf8 theta, sf8 offset)
{
	sf8  p;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	x -= offset;
	
	if (x < (sf8) 0.0)
		x = (sf8) 0.0;
	if (k <= (sf8) 0.0)
		k = nan(NULL);
	if (theta <= (sf8) 0.0)
		theta = nan(NULL);

	x /= theta;
	p = CMP_gamma_p_m13(k, x);
	
	return_m13(p);
}


sf8	CMP_gamma_cf_m13(sf8 a, sf8 x, sf8 *g_ln)
{
	si4		i;
	static si4	ITMAX = 100;
	sf8		gam_cf, an, b, c, d, del, h;
	static sf8	EPS = 3.0e-7;
	static sf8	FPMIN = 1.0e-30;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	*g_ln = CMP_gamma_ln_m13(a);
	b = x + (sf8) 1.0 - a;
	c = (sf8) 1.0 / FPMIN;
	d = (sf8) 1.0 / b;
	h = d;
	for (i = 1;i <= ITMAX; i++) {
		an = (sf8) -i * ((sf8) i - a);
		b += (sf8) 2.0;
		d = (an * d) + b;
		if (fabs(d) < FPMIN)
			d = FPMIN;
		c = b + (an / c);
		if (fabs(c) < FPMIN)
			c = FPMIN;
		d = (sf8) 1.0 / d;
		del = d * c;
		h *= del;
		if (fabs(del - (sf8) 1.0) < EPS)
			break;
	}
	if (i > ITMAX) {
		G_set_error_m13(E_UNKN_m13, "a too large or ITMAX too small");
		return_m13((sf8) 0.0);
	}
	gam_cf = exp(-x + (a * log(x)) - (*g_ln)) * h;
	
	return_m13(gam_cf);
}


sf8	CMP_gamma_inv_cdf_m13(sf8 p, sf8 k, sf8 theta, sf8 offset)
{
	sf8  x;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (p < (sf8) 0.0)
		p = (sf8) 0.0;
	if (p > (sf8) 1.0)
		p = (sf8) 1.0;
	if (k <= (sf8) 0.0)
		k = nan(NULL);
	if (theta <= (sf8) 0.0)
		theta = nan(NULL);
	
	x = CMP_gamma_inv_p_m13(p, k);
	x = (x * theta) + offset;
	
	return_m13(x);
}


sf8	CMP_gamma_inv_p_m13(sf8 p, sf8 a)
{
	si4		j;
	sf8		x, err, u, pp, lna1, afac, a1, t, t2, g_ln;
	const sf8	EPS = 1.e-8;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// inverse incomplete gamma
	a1 = a - (sf8) 1.0;
	g_ln = CMP_gamma_ln_m13(a);
	
	if (a <= (sf8) 0.0) {
		G_error_message_m13("a must be pos\n", __FUNCTION__);
		exit(1);
	}
	
	if (p >= (sf8) 1.0) {
		t = a + ((sf8) 100.0 * sqrt(a));
		if (t > (sf8) 100.0)
			return_m13(t);
		else
			return_m13((sf8) 100.0);
	}
	
	if (p <= (sf8) 0.0)
		return_m13((sf8) 0.0);
	
	if (a > (sf8) 1.0) {
		lna1 = log(a1);
		afac = exp((a1 * (lna1 - (sf8) 1.0)) - g_ln);
		pp = (p < (sf8) 0.5) ? p : ((sf8) 1.0 - p);
		t = sqrt((sf8) -2.0 * log(pp));
		x = (((sf8) 2.30753 + (t * (sf8) 0.27061)) / ((sf8) 1.0 + (t * ((sf8) 0.99229 + (t * (sf8) 0.04481))))) - t;
		if (p < (sf8) 0.5)
			x = -x;
		t = a * pow(((sf8) 1.0 - ((sf8) 1.0 / ((sf8) 9.0 * a)) - (x / ((sf8) 3.0 * sqrt(a)))), (sf8) 3.0);
		if (t > (sf8) 1.0e-3)
			x = t;
		else
			x = (sf8) 1.0e-3;
	} else {
		t = (sf8) 1.0 - (a * ((sf8) 0.253 + (a * (sf8) 0.12)));
		if (p < t)
			x = pow((p / t), ((sf8) 1.0 / a));
		else
			x = (sf8) 1.0 - log((sf8) 1.0 - ((p - t) / ((sf8) 1.0 - t)));
	}
	
	for (j = 0; j < 12; j++) {
		if (x <= (sf8) 0.0)
			return_m13((sf8) 0.0);
		err = CMP_gamma_p_m13(a, x) - p;
		if (a > (sf8) 1.0)
			t = afac * exp(-(x - a1) + a1 * (log(x) - lna1));
		else
			t = exp(-x + a1 * log(x) - g_ln);
		u = err / t;
		t2 = u * (((a - (sf8) 1.0) / x) - (sf8) 1.0);
		if (t2 > (sf8) 1.0)
			t2 = (sf8) 1.0;
		x -= (t = u / ((sf8) 1.0 - ((sf8) 0.5 * t2)));
		if (x <= (sf8) 0.0)
		  x = (sf8) 0.5 * (x + t);
		if (fabs(t) < (EPS * x))
			break;
	}
		  
	return_m13(x);
}


sf8	CMP_gamma_ln_m13(sf8 xx)
{
	si4 i;
	sf8 x, y, tmp, ser;
	static sf8  cof[6] = {76.18009172947146, -86.50532032941677, 24.01409824083091, -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5};

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	y = x = xx;
	tmp = x + (sf8) 5.5;
	tmp -= (x + (sf8) 0.5) * log(tmp);
	ser = (sf8) 1.000000000190015;
	for (i = 0; i <= 5; i++)
		ser += cof[i] / ++y;
	
	return_m13(-tmp + log((sf8) 2.5066282746310005 * ser / x));
}


sf8	CMP_gamma_p_m13(sf8 a, sf8 x)
{
	sf8 gam_ser, gam_cf, g_ln;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (x < (sf8) 0.0 || a <= (sf8) 0.0) {
		G_set_error_m13(E_UNKN_m13, "invalid arguments");
		return_m13((sf8) 0.0);
	}
	if (x < (a + (sf8) 1.0)) {
		gam_ser = CMP_gamma_ser_m13(a, x, &g_ln);
		return_m13(gam_ser);
	}
	
	gam_cf = CMP_gamma_cf_m13(a, x, &g_ln);
	
	return_m13((sf8) 1.0 - gam_cf);
}


sf8	CMP_gamma_ser_m13(sf8 a, sf8 x, sf8 *g_ln)
{
	si4		i;
	static si4	ITMAX = 100;
	sf8		sum, del, ap, gam_ser;
	static sf8	EPS = 3.0e-7;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	*g_ln = CMP_gamma_ln_m13(a);
	
	if (x <= (sf8) 0.0) {
		if (x < (sf8) 0.0)
			G_set_error_m13(E_UNKN_m13, "x less than 0");
		return_m13((sf8) 0.0);
	}
	
	ap = a;
	del = sum = (sf8) 1.0 / a;
	for (i = 0; i < ITMAX; i++) {
		++ap;
		del *= (x / ap);
		sum += del;
		if (fabs(del) < (fabs(sum) * EPS)) {
			gam_ser = sum * exp(-x + (a*log(x)) - (*g_ln));
			return_m13(gam_ser);
		}
	}
	
	G_set_error_m13(E_UNKN_m13, "a too large or ITMAX too small");
	
	return_m13((sf8) 0.0);
}


tern  CMP_generate_lossy_data_m13(CPS_m13 *cps, si4 *input_buffer, si4 *output_buffer, ui1 mode)
{
	CMP_FIXED_BH_m13	*bh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// generates lossy data from input_buffer to output_buffer
	// if input_buffer == output_buffer lossy data will be made in place
	bh = cps->block_header;
	
	if (mode == CMP_AMPLITUDE_SCALE_MODE_m13) {
		// amplitude scale from input_buffer to scaled_amplitude_buffer (lossy)
		CMP_scale_amplitude_si4_m13(input_buffer, cps->params.scaled_amplitude_buffer, bh->number_of_samples, (sf8) cps->params.amplitude_scale, cps);
		// unscale from scaled_amplitude_buffer to output_buffer
		CMP_unscale_amplitude_si4_m13(cps->params.scaled_amplitude_buffer, output_buffer, bh->number_of_samples, (sf8) cps->params.amplitude_scale);
	} else if (mode == CMP_FREQUENCY_SCALE_MODE_m13) {
		// frequency scale from input_buffer to scaled_frequency_buffer (lossy)
		CMP_scale_frequency_si4_m13(input_buffer, cps->params.scaled_frequency_buffer, bh->number_of_samples, (sf8) cps->params.frequency_scale, cps);
		// unscale from scaled_frequency_buffer to output_buffer
		CMP_unscale_frequency_si4_m13(cps->params.scaled_frequency_buffer, output_buffer, bh->number_of_samples, (sf8) cps->params.frequency_scale);
	} else {
		G_set_error_m13(E_UNKN_m13, "unrecognized lossy compression mode => no data generated");
		return_m13(FALSE_m13);
	}
	
	return_m13(TRUE_m13);
}


tern	CMP_generate_parameter_map_m13(CPS_m13 *cps)
{
	ui4			bit, flags, n_params, i, *p_map;
	CMP_FIXED_BH_m13	*bh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// add up parameter bytes (4 bytes for each bit set)
	bh = cps->block_header;
	flags = bh->parameter_flags;
	p_map = cps->params.block_parameter_map;
	for (bit = 1, n_params = i = 0; i < CMP_PF_PARAMETER_FLAG_BITS_m13; ++i, bit <<= 1)
		if (flags & bit)
			p_map[i] = n_params++;
	
	cps->params.n_block_parameters = (si4) n_params;
	bh->parameter_region_bytes = (ui2) (n_params * 4);
	
	return_m13(TRUE_m13);
}


ui1  CMP_get_overflow_bytes_m13(CPS_m13 *cps, ui4 mode, ui4 algorithm)
{
	ui1					bits_per_samp;
	ui2					flags;
	si8					i, val, abs_min, abs_max;
	CMP_RED_MODEL_FIXED_HDR_m13		*RED_header;
	CMP_PRED_MODEL_FIXED_HDR_m13		*PRED_header;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (mode == CMP_COMPRESSION_MODE_m13) {  // assumes extrema are known & derivative level is set
		if (cps->direcs.flags & CPS_DF_FIND_OVERFLOW_BYTES_m13) {
			if (cps->params.derivative_level) {
				abs_min = ABS_m13((si8) cps->params.minimum_difference_value); // cannot make 0x80000000 positive as si4, must use si8 here
				abs_max = ABS_m13((si8) cps->params.maximum_difference_value);
			} else {  // level zero => use raw data
				abs_min = ABS_m13((si8) cps->params.minimum_sample_value);
				abs_max = ABS_m13((si8) cps->params.maximum_sample_value);
			}
			val = (abs_min > abs_max) ? abs_min : abs_max;
			for (bits_per_samp = 1, i = val; i; i >>= 1)
				++bits_per_samp;
			if (algorithm == CMP_RED1_COMPRESSION_m13 || algorithm == CMP_RED2_COMPRESSION_m13) {
				RED_header = (CMP_RED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
				if (RED_header->flags & CMP_RED_FLAGS_POSITIVE_DERIVATIVES_m13)
					--bits_per_samp;  // don't need a sign bit
			}
			cps->params.overflow_bytes = (bits_per_samp + 7) >> 3;
		} else if (cps->direcs.flags & CPS_DF_SET_OVERFLOW_BYTES_m13) {
			if (cps->params.goal_overflow_bytes != 2 && cps->params.goal_overflow_bytes != 3) {
				G_warning_message_m13("%s(): overflow bytes must be 2-4 => setting to 4\n", __FUNCTION__);
				cps->params.goal_overflow_bytes = CPS_PARAMS_OVERFLOW_BYTES_DEFAULT_m13;  // 4
				cps->params.overflow_bytes = CPS_PARAMS_OVERFLOW_BYTES_DEFAULT_m13;  // 4
			}
		} else {
			cps->params.goal_overflow_bytes = CPS_PARAMS_OVERFLOW_BYTES_DEFAULT_m13;  // 4
			cps->params.overflow_bytes = CPS_PARAMS_OVERFLOW_BYTES_DEFAULT_m13;  // 4
		}
		// set block flag
		if (algorithm == CMP_RED1_COMPRESSION_m13 || algorithm == CMP_RED2_COMPRESSION_m13) {
			RED_header->flags &= ~CMP_RED_OVERFLOW_BYTES_MASK_m13;
			if (cps->params.overflow_bytes == 2)
				RED_header->flags |= CMP_RED_2_BYTE_OVERFLOWS_m13;
			else if	(cps->params.overflow_bytes == 3)
				RED_header->flags |= CMP_RED_3_BYTE_OVERFLOWS_m13;
		} else if (algorithm == CMP_PRED1_COMPRESSION_m13 || algorithm == CMP_PRED2_COMPRESSION_m13 ) {
			PRED_header = (CMP_PRED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
			PRED_header->flags &= ~CMP_PRED_OVERFLOW_BYTES_MASK_m13;
			if (cps->params.overflow_bytes == 2)
				PRED_header->flags |= CMP_PRED_2_BYTE_OVERFLOWS_m13;
			else if	(cps->params.overflow_bytes == 3)
				PRED_header->flags |= CMP_PRED_3_BYTE_OVERFLOWS_m13;
		}
	} else {  // CMP_DECOMPRESSION_MODE_m13
		if (algorithm == CMP_RED1_COMPRESSION_m13 || algorithm == CMP_RED2_COMPRESSION_m13) {
			RED_header = (CMP_RED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
			flags = RED_header->flags & CMP_RED_OVERFLOW_BYTES_MASK_m13;
			if (flags == CMP_RED_2_BYTE_OVERFLOWS_m13)
				cps->params.overflow_bytes =  2;
			else if (flags == CMP_RED_3_BYTE_OVERFLOWS_m13)
				cps->params.overflow_bytes =  3;
			else
				cps->params.overflow_bytes = CPS_PARAMS_OVERFLOW_BYTES_DEFAULT_m13;  // 4
		} else if (algorithm == CMP_PRED_COMPRESSION_m13) {
			PRED_header = (CMP_PRED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
			flags = PRED_header->flags & CMP_PRED_OVERFLOW_BYTES_MASK_m13;
			if (flags == CMP_PRED_2_BYTE_OVERFLOWS_m13)
				cps->params.overflow_bytes =  2;
			else if (flags == CMP_PRED_3_BYTE_OVERFLOWS_m13)
				cps->params.overflow_bytes =  3;
			else
				cps->params.overflow_bytes = CPS_PARAMS_OVERFLOW_BYTES_DEFAULT_m13;  // 4
		}
	}
	
	return_m13(cps->params.overflow_bytes);
}


tern  CMP_get_variable_region_m13(CPS_m13 *cps)
{
	ui1			*var_reg_ptr;
	CMP_FIXED_BH_m13	*bh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	bh = cps->block_header;
	var_reg_ptr = (ui1 *) bh + CMP_BLOCK_FIXED_HDR_BYTES_m13;  // pointer to beginning of variable region
	
	// records region (user sets bh->record_region_bytes)
	cps->block_records = var_reg_ptr;
	var_reg_ptr += bh->record_region_bytes;
	
	// parameter region
	cps->block_parameters = (ui4 *) var_reg_ptr;
	CMP_generate_parameter_map_m13(cps);
	var_reg_ptr += bh->parameter_region_bytes;
	
	// protected region
	// cps->protected_region = var_reg_ptr;  // no pointer to this in CPS
	var_reg_ptr += bh->protected_region_bytes;
	
	// discretionary region (user sets bh->discretionary_region_bytes)
	cps->discretionary_region = var_reg_ptr;
	var_reg_ptr += bh->discretionary_region_bytes;
	
	// variable region bytes
	cps->params.variable_region_bytes = CMP_VARIABLE_REGION_BYTES_v1_m13(bh);
	
	// model region (not part of variable region, but convenient to do this here)
	cps->params.model_region = var_reg_ptr;
	
	return_m13(TRUE_m13);
}


tern	CMP_hex_to_int_m13(si1 *hex_str, void *hex_val, si4 val_bytes)
{
	ui1	hi_val, lo_val, *byte;
	si4	i, hex_bytes;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// if "hex_str" is null-terminated string, can pass zero for len
	// can be done in place i.e. "hex_str" can == "hex_val"
	
	if (*hex_str == (ui1) '0' && ((*(hex_str + 1) == (ui1) 'x') || (*(hex_str + 1) == (ui1) 'X')))
		hex_str += 2;
	
	hex_bytes = strlen(hex_str);
	if (hex_bytes & 1) {
		sprintf_m13(hex_str, "0%s", hex_str);
		++hex_bytes;
	}
	hex_bytes >>= 1;
	if (val_bytes == 0) {  // user passed zero for output bytes - use hex bytes in string
		val_bytes = hex_bytes;
	} else if (val_bytes < hex_bytes) {
		G_set_error_m13(E_UNKN_m13, "fewer output bytes than hex bytes in string");
		return_m13(FALSE_m13);
	}
	
	byte = (ui1 *) hex_val + (hex_bytes - 1);
	for (i = 0; i < hex_bytes; ++i) {
		if (*hex_str >= (ui1) 'a') {
			if (*hex_str > (ui1) 'f')
				return_m13(FALSE_m13);
			hi_val = (*hex_str - (ui1) 'a') + 10;
		} else if (*hex_str >= (ui1) 'A') {
			if (*hex_str > (ui1) 'F')
				return_m13(FALSE_m13);
			hi_val = (*hex_str - (ui1) 'A') + 10;
		} else if (*hex_str >= (ui1) '0') {
			if (*hex_str > (ui1) '9')
				return_m13(FALSE_m13);
			hi_val = *hex_str - (ui1) '0';
		} else {
			return_m13(FALSE_m13);
		}
		++hex_str;
		if (*hex_str >= (ui1) 'a') {
			if (*hex_str > (ui1) 'f')
				return_m13(FALSE_m13);
			lo_val = (*hex_str - (ui1) 'a') + 10;
		} else if (*hex_str >= (ui1) 'A') {
			if (*hex_str > (ui1) 'F')
				return_m13(FALSE_m13);
			lo_val = (*hex_str - (ui1) 'A') + 10;
		} else if (*hex_str >= (ui1) '0') {
			if (*hex_str > (ui1) '9')
				return_m13(FALSE_m13);
			lo_val = *hex_str - (ui1) '0';
		} else {
			return_m13(FALSE_m13);
		}
		++hex_str;
		*byte-- = (hi_val << 4) | lo_val;
	}
	
	// zero unspecified high bytes, if any
	if (val_bytes > hex_bytes) {
		byte = (ui1 *) hex_val + hex_bytes;
		for (i = hex_bytes; i < val_bytes; ++i)
			*byte++ = 0;
	}
	
	return_m13(TRUE_m13);
}


CPS_DIRECS_m13	*CMP_init_direcs_m13(CPS_DIRECS_m13 *direcs, ui1 compression_mode)
{
	ui8	flags;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (direcs == NULL)
		direcs = (CPS_DIRECS_m13 *) calloc_m13((size_t) 1, sizeof(CPS_DIRECS_m13));
	
	flags = (ui8) 0;
	
	if (compression_mode == CMP_COMPRESSION_MODE_NO_ENTRY_m13)
		if (CPS_DIRECTIVES_COMPRESSION_MODE_DEFAULT_m13 == TRUE_m13)
			compression_mode = CMP_COMPRESSION_MODE_m13;
	if (compression_mode == CMP_COMPRESSION_MODE_m13)
		flags |= CPS_DF_COMPRESSION_MODE_m13;
	
	if (CPS_DIRECTIVES_PRED_ALGORITHM_DEFAULT_m13 == TRUE_m13)  // default lossless (PRED2)
		flags |= CPS_DF_PRED2_ALGORITHM_m13;
	else if (CPS_DIRECTIVES_VDS_ALGORITHM_DEFAULT_m13 == TRUE_m13)  // default lossless
		flags |= CPS_DF_VDS_ALGORITHM_m13;
	else if (CPS_DIRECTIVES_MBE_ALGORITHM_DEFAULT_m13 == TRUE_m13)  // fastest
		flags |= CPS_DF_MBE_ALGORITHM_m13;
	else if (CPS_DIRECTIVES_RED_ALGORITHM_DEFAULT_m13 == TRUE_m13)  // generally only used in hardware (RED2)
		flags |= CPS_DF_RED2_ALGORITHM_m13;
		
	if (CPS_DIRECTIVES_CPS_POINTER_RESET_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_CPS_POINTER_RESET_m13;

	if (CPS_DIRECTIVES_CPS_CACHING_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_CPS_CACHING_m13;

	if (CPS_DIRECTIVES_FALL_THROUGH_TO_BEST_ENCODING_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_FALL_THROUGH_TO_BEST_ENCODING_m13;

	if (CPS_DIRECTIVES_RESET_DISCONTINUITY_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_RESET_DISCONTINUITY_m13;

	if (CPS_DIRECTIVES_INCLUDE_NOISE_SCORES_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_INCLUDE_NOISE_SCORES_m13;

	if (CPS_DIRECTIVES_NO_ZERO_COUNTS_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_NO_ZERO_COUNTS_m13;

	if (CPS_DIRECTIVES_SET_OVERFLOW_BYTES_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_SET_OVERFLOW_BYTES_m13;

	if (CPS_DIRECTIVES_FIND_OVERFLOW_BYTES_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_FIND_OVERFLOW_BYTES_m13;

	if (CPS_DIRECTIVES_POSITIVE_DERIVATIVES_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_POSITIVE_DERIVATIVES_m13;

	if (CPS_DIRECTIVES_SET_DERIVATIVE_LEVEL_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_SET_DERIVATIVE_LEVEL_m13;

	if (CPS_DIRECTIVES_FIND_DERIVATIVE_LEVEL_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_FIND_DERIVATIVE_LEVEL_m13;

	if (CPS_DIRECTIVES_CONVERT_TO_NATIVE_UNITS_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_CONVERT_TO_NATIVE_UNITS_m13;

	if (CPS_DIRECTIVES_DETREND_DATA_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_DETREND_DATA_m13;

	if (CPS_DIRECTIVES_REQUIRE_NORMALITY_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_REQUIRE_NORMALITY_m13;

	if (CPS_DIRECTIVES_USE_COMPRESSION_RATIO_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_USE_COMPRESSION_RATIO_m13;

	if (CPS_DIRECTIVES_USE_MEAN_RESIDUAL_RATIO_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_USE_MEAN_RESIDUAL_RATIO_m13;

	if (CPS_DIRECTIVES_USE_RELATIVE_RATIO_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_USE_RELATIVE_RATIO_m13;

	if (CPS_DIRECTIVES_SET_AMPLITUDE_SCALE_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_SET_AMPLITUDE_SCALE_m13;

	if (CPS_DIRECTIVES_FIND_AMPLITUDE_SCALE_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_FIND_AMPLITUDE_SCALE_m13;

	if (CPS_DIRECTIVES_SET_FREQUENCY_SCALE_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_SET_FREQUENCY_SCALE_m13;

	if (CPS_DIRECTIVES_FIND_FREQUENCY_SCALE_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_FIND_FREQUENCY_SCALE_m13;

	if (CPS_DIRECTIVES_SET_OVERFLOW_BYTES_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_SET_OVERFLOW_BYTES_m13;

	if (CPS_DIRECTIVES_FIND_OVERFLOW_BYTES_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_FIND_OVERFLOW_BYTES_m13;
	
	if (CPS_DIRECTIVES_VDS_SCALE_BY_BASELINE_DEFAULT_m13 == TRUE_m13)
		flags |= CPS_DF_VDS_SCALE_BY_BASELINE_m13;
		
	direcs->flags = flags;
	
	return_m13(direcs);
}


CPS_PARAMS_m13	*CMP_init_params_m13(CPS_PARAMS_m13 *params)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (params == NULL)
		params = (CPS_PARAMS_m13 *) calloc_m13((size_t) 1, sizeof(CPS_PARAMS_m13));
	
	params->cache = NULL;
	params->cached_blocks = NULL;
	params->cached_block_cnt = 0;
	params->cached_block_list_len = 0;
	params->block_start_index = 0;
	params->block_end_index = 0xFFFFFFFF;
	params->allocated_block_samples = 0;
	params->allocated_keysample_bytes = 0;
	params->allocated_compressed_bytes = 0;
	params->allocated_decompressed_samples = 0;
	params->discontinuity = CPS_PARAMS_DISCONTINUITY_DEFAULT_m13;
	params->goal_derivative_level = CPS_PARAMS_DERIVATIVE_LEVEL_DEFAULT_m13;
	params->derivative_level = 0;
	params->goal_overflow_bytes = CPS_PARAMS_OVERFLOW_BYTES_DEFAULT_m13;
	params->overflow_bytes = 0;
	params->n_block_parameters = 0;
	params->minimum_sample_value = CPS_PARAMS_MINIMUM_SAMPLE_VALUE_DEFAULT_m13;
	params->maximum_sample_value = CPS_PARAMS_MAXIMUM_SAMPLE_VALUE_DEFAULT_m13;
	params->user_number_of_records = CMP_USER_NUMBER_OF_RECORDS_DEFAULT_m13;
	params->user_record_region_bytes = CMP_USER_RECORD_REGION_BYTES_DEFAULT_m13;
	params->user_parameter_flags = CMP_USER_PARAMETER_FLAGS_DEFAULT_m13;
	params->protected_region_bytes = CMP_PROTECTED_REGION_BYTES_DEFAULT_m13;
	params->user_discretionary_region_bytes = CMP_USER_DISCRETIONARY_REGION_BYTES_DEFAULT_m13;
	params->variable_region_bytes = 0;
	params->goal_ratio = CPS_PARAMS_GOAL_RATIO_DEFAULT_m13;
	params->goal_tolerance = CPS_PARAMS_GOAL_TOLERANCE_DEFAULT_m13;
	params->maximum_goal_attempts = CPS_PARAMS_MAXIMUM_GOAL_ATTEMPTS_DEFAULT_m13;
	params->minimum_normality = CPS_PARAMS_MINIMUM_NORMALITY_DEFAULT_m13;
	params->amplitude_scale = CPS_PARAMS_AMPLITUDE_SCALE_DEFAULT_m13;
	params->frequency_scale = CPS_PARAMS_FREQUENCY_SCALE_DEFAULT_m13;
	params->VDS_sampling_frequency = RATE_NO_ENTRY_m13;
	params->VDS_LFP_high_fc = RATE_NO_ENTRY_m13;
	params->VDS_threshold = CPS_PARAMS_VDS_THRESHOLD_DEFAULT_m13;

	params->count = NULL;
	params->sorted_count = NULL;
	params->cumulative_count = NULL;
	params->minimum_range = NULL;
	params->symbol_map = NULL;
	params->VDS_input_buffers = NULL;
	params->VDS_output_buffers = NULL;
	params->filtps = NULL;
	params->n_filtps = 0;

	return_m13(params);
}


tern	CMP_init_tables_m13(void)
{
	size_t			len;
	GLOBAL_TABLES_m13	*tables;
	

	tables = globals_m13->tables;
	if (tables->CMP_normal_CDF_table)
		return(TRUE_m13);
	
	pthread_mutex_lock_m13(&tables->mutex);
	if (tables->CMP_normal_CDF_table) {
		pthread_mutex_unlock_m13(&tables->mutex);
		return(TRUE_m13);
	}

	tables->CMP_normal_CDF_table = (sf8 *) calloc((size_t) CMP_NORMAL_CDF_TABLE_ENTRIES_m13, sizeof(sf8));
	if (tables->CMP_normal_CDF_table == NULL) {
		pthread_mutex_unlock_m13(&tables->mutex);
		return(FALSE_m13);
	}
	{
		sf8 temp[CMP_NORMAL_CDF_TABLE_ENTRIES_m13] = CMP_NORMAL_CDF_TABLE_m13;
		
		len = (size_t) CMP_NORMAL_CDF_TABLE_ENTRIES_m13 * sizeof(sf8);
		memcpy(tables->CMP_normal_CDF_table, temp, len);
	}
	
	tables->CMP_VDS_threshold_map = (CMP_VDS_THRESHOLD_MAP_ENTRY_m13 *) calloc((size_t) CMP_VDS_THRESHOLD_MAP_TABLE_ENTRIES_m13, sizeof(CMP_VDS_THRESHOLD_MAP_ENTRY_m13));
	if (tables->CMP_VDS_threshold_map == NULL) {
		pthread_mutex_unlock_m13(&tables->mutex);
		return(FALSE_m13);
	}
	{
		CMP_VDS_THRESHOLD_MAP_ENTRY_m13	temp[CMP_VDS_THRESHOLD_MAP_TABLE_ENTRIES_m13] = CMP_VDS_THRESHOLD_MAP_TABLE_m13;

		len = (size_t) CMP_VDS_THRESHOLD_MAP_TABLE_ENTRIES_m13 * sizeof(CMP_VDS_THRESHOLD_MAP_ENTRY_m13);
		memcpy(tables->CMP_VDS_threshold_map, temp, len);
	}
		
	pthread_mutex_unlock_m13(&tables->mutex);

	return(TRUE_m13);
}


tern	CMP_integrate_m13(CPS_m13 *cps)
{
	ui1			deriv_level;
	ui4			n_samps;
	si4			*deriv_buffer, *si4_p1, *si4_p2;
	si8			i;
	CMP_FIXED_BH_m13	*bh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// integrates in place from/to decompressed_ptr
	deriv_level = cps->params.derivative_level;
	if (deriv_level == 0)
		return_m13(TRUE_m13);

	bh = cps->block_header;
	n_samps = bh->number_of_samples;
	deriv_buffer = cps->decompressed_ptr;
	do {
		si4_p2 = deriv_buffer + deriv_level;
		si4_p1 = si4_p2 - 1;
		for (i = n_samps - deriv_level; i--;)
			*si4_p2++ += *si4_p1++;
	} while (--deriv_level);

	return_m13(TRUE_m13);
}


tern  CMP_lad_reg_2_sf8_m13(sf8 *x_input_buffer, sf8 *y_input_buffer, si8 len, sf8 *m, sf8 *b)
{
	sf8		t, *xp, *yp, *buff, *bp, min_x, max_x, min_y, max_y, min_m, max_m;
	sf8 d, ma, ba, m_eps, b_eps, lad_eps, test_m, lad, upper_m, lower_m;
	si8 i;
	const sf8	safe_eps = DBL_EPSILON * (sf8) 1000.0;
	const sf8	thresh = safe_eps * (sf8) 10.0;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// linear least absolute deviation_regression (2 array input)

	// allocate
	buff = (sf8 *) malloc((size_t) len * sizeof(sf8));

	// setup
	xp = x_input_buffer;
	min_x = max_x = *xp;
	yp = y_input_buffer;
	min_y = max_y = *yp;
	for (i = len; --i;) {
		if (*++xp > max_x)
			max_x = *xp;
		else if (*xp < min_x)
			min_x = *xp;
		if (*++yp > max_y)
			max_y = *yp;
		else if (*yp < min_y)
			min_y = *yp;
	}
	upper_m = max_m = (max_y - min_y) / (max_x - min_x);
	lower_m = min_m = -max_m;
	d = max_m - min_m;

	// search
	while (d > thresh) {
		ma = (upper_m + lower_m) / (sf8) 2.0;
		bp = buff; xp = x_input_buffer; yp = y_input_buffer;
		for (i = len; i--;)
			*bp++ = *yp++ - (*xp++ * ma);
		ba = CMP_quantval_m13(buff, len, 0.5, 0, NULL);  // median
		bp = buff; lad = (sf8)0.0;
		for (i = len; i--;) {
			t = *bp++ - ba;
			lad += ABS_m13(t);
		}
		m_eps = ma + safe_eps;
		bp = buff; xp = x_input_buffer; yp = y_input_buffer;
		for (i = len; i--;)
			*bp++ = *yp++ - (*xp++ * m_eps);
		b_eps = CMP_quantval_m13(buff, len, 0.5, 0, NULL);  // median
		bp = buff; lad_eps = (sf8)0.0;
		for (i = len; i--;) {
			t = *bp++ - b_eps;
			lad_eps += ABS_m13(t);
		}
		test_m = lad_eps - lad;
		if (test_m > (sf8)0.0)
			upper_m = ma;
		else if (test_m < (sf8)0.0)
			lower_m = ma;
		else
			break;
		d = upper_m - lower_m;
	}

	*b = ba;
	*m = ma;

	// clean up
	free((void *) buff);

	return_m13(TRUE_m13);
}


tern  CMP_lad_reg_2_si4_m13(si4 *x_input_buffer, si4 *y_input_buffer, si8 len, sf8 *m, sf8 *b)
{
	sf8		*x, *y, t, *xp, *yp, *buff, *bp, min_x, max_x, min_y, max_y, min_m, max_m;
	sf8 d, ma, ba, m_eps, b_eps, lad_eps, test_m, lad, upper_m, lower_m;
	si8 i;
	const sf8	safe_eps = DBL_EPSILON * (sf8) 1000.0;
	const sf8	thresh = safe_eps * (sf8) 10.0;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// linear least absolute deviation_regression (2 array input)

	// allocate
	buff = (sf8 *) malloc((size_t) len * sizeof(sf8));
	x = (sf8 *) malloc((size_t) len * sizeof(sf8));
	y = (sf8 *) malloc((size_t) len * sizeof(sf8));

	// copy & cast
	for (xp = x, yp = y, i = len; i--;) {
		*xp++ = (sf8) *x_input_buffer++;
		*yp++ = (sf8) *y_input_buffer++;
	}

	// setup
	xp = x;
	min_x = max_x = *xp;
	yp = y;
	min_y = max_y = *yp;
	for (i = len; --i;) {
		if (*++xp > max_x)
			max_x = *xp;
		else if (*xp < min_x)
			min_x = *xp;
		if (*++yp > max_y)
			max_y = *yp;
		else if (*yp < min_y)
			min_y = *yp;
	}
	upper_m = max_m = (max_y - min_y) / (max_x - min_x);
	lower_m = min_m = -max_m;
	d = max_m - min_m;

	// search
	while (d > thresh) {
		ma = (upper_m + lower_m) / (sf8) 2.0;
		bp = buff; xp = x; yp = y;
		for (i = len; i--;)
			*bp++ = *yp++ - (*xp++ * ma);
		ba = CMP_quantval_m13(buff, len, 0.5, 0, NULL);  // median
		bp = buff; lad = (sf8)0.0;
		for (i = len; i--;) {
			t = *bp++ - ba;
			lad += ABS_m13(t);
		}
		m_eps = ma + safe_eps;
		bp = buff; xp = x; yp = y;
		for (i = len; i--;)
			*bp++ = *yp++ - (*xp++ * m_eps);
		b_eps = CMP_quantval_m13(buff, len, 0.5, 0, NULL);  // median
		bp = buff; lad_eps = (sf8)0.0;
		for (i = len; i--;) {
			t = *bp++ - b_eps;
			lad_eps += ABS_m13(t);
		}
		test_m = lad_eps - lad;
		if (test_m > (sf8)0.0)
			upper_m = ma;
		else if (test_m < (sf8)0.0)
			lower_m = ma;
		else
			break;
		d = upper_m - lower_m;
	}

	*b = ba;
	*m = ma;

	// clean up
	free((void *) buff);
	free((void *) x);
	free((void *) y);

	return_m13(TRUE_m13);
}


tern  CMP_lad_reg_sf8_m13(sf8 *y, si8 len, sf8 *m, sf8 *b)
{
	sf8 	lb, lm, t, *yp, *buff, *bp, min_y, max_y, min_m, max_m, m_sum;
	sf8 	d, m_eps, b_eps, lad_eps, test_m, lad, upper_m, lower_m;
	si8 	i;
	const sf8	safe_eps = DBL_EPSILON * (sf8) 1000.0;
	const sf8	thresh = safe_eps * (sf8) 10.0;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// least absolute differences linear regression
	// assumes x to be 1:length(x)
	// fit: y = mx + b
	
	// allocate
	buff = (sf8 *) malloc((size_t) len * sizeof(sf8));
	if (buff == NULL)
		G_set_error_m13(E_ALLOC_m13, "could not allocate enough memory");
	
	// setup
	yp = y;
	min_y = max_y = *yp;
	for (i = len; --i;) {
		if (*++yp > max_y)
			max_y = *yp;
		else if (*yp < min_y)
			min_y = *yp;
	}
	lower_m = min_m = (min_y - max_y) / (sf8) (len - 1);
	upper_m = max_m  = -min_m;
	d = max_m - min_m;
	
	// search
	while (d > thresh) {
		lm = (upper_m + lower_m) / (sf8) 2.0;
		bp = buff; yp = y;
		m_sum = (sf8) 0.0;
		for (i = len; i--;)
			*bp++ = *yp++ - (m_sum += lm);
		lb = CMP_quantval_m13(buff, len, 0.5, FALSE_m13, NULL);  // median
		bp = buff; lad = (sf8) 0.0;
		for (i = len; i--;) {
			t = *bp++ - lb;
			lad += ABS_m13(t);
		}
		m_eps = lm + safe_eps;
		bp = buff; yp = y;
		m_sum = (sf8) 0.0;
		for (i = len; i--;)
			*bp++ = *yp++ - (m_sum += m_eps);
		b_eps = CMP_quantval_m13(buff, len, 0.5, FALSE_m13, NULL);  // median
		bp = buff; lad_eps = (sf8) 0.0;
		for (i = len; i--;) {
			t = *bp++ - b_eps;
			lad_eps += ABS_m13(t);
		}
		test_m = lad_eps - lad;
		if (test_m > (sf8) 0.0)
			upper_m = lm;
		else if (test_m < (sf8) 0.0)
			lower_m = lm;
		else
			break;
		d = upper_m - lower_m;
	}
	*b = lb;
	*m = lm;
	
	// clean up
	free(buff);
	
	return_m13(TRUE_m13);
}


tern  CMP_lad_reg_si4_m13(si4 *input_buffer, si8 len, sf8 *m, sf8 *b)
{
	sf8		*y, t, *yp, *buff, *bp, min_y, max_y, min_m, max_m, m_sum;
	sf8 d, ma, ba, m_eps, b_eps, lad_eps, test_m, lad, upper_m, lower_m;
	si8 i;
	const sf8	safe_eps = DBL_EPSILON * (sf8) 1000.0;
	const sf8	thresh = safe_eps * (sf8) 10.0;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// linear least absolute deviation_regression (1 array input)
	
	// allocate
	buff = (sf8 *) calloc((size_t) len, sizeof(sf8));
	y = (sf8 *) calloc((size_t) len, sizeof(sf8));
	
	// copy & cast
	for (yp = y, i = len; i--;)
		*yp++ = (sf8) *input_buffer++;
	
	// setup
	yp = y;
	min_y = max_y = *yp;
	for (i = len; --i;) {
		if (*++yp > max_y)
			max_y = *yp;
		else if (*yp < min_y)
			min_y = *yp;
	}
	upper_m = max_m = (max_y - min_y) / (sf8)(len - 1);
	lower_m = min_m = -max_m;
	d = max_m - min_m;
	
	// search
	while (d > thresh) {
		ma = (upper_m + lower_m) / (sf8) 2.0;
		bp = buff; yp = y;
		m_sum = (sf8) 0.0;
		for (i = len; i--;)
			*bp++ = *yp++ - (m_sum += ma);
		ba = CMP_quantval_m13(buff, len, 0.5, 0, NULL);  // median
		bp = buff; lad = (sf8) 0.0;
		for (i = len; i--;) {
			t = *bp++ - ba;
			lad += ABS_m13(t);
		}
		m_eps = ma + safe_eps;
		bp = buff; yp = y;
		m_sum = (sf8) 0.0;
		for (i = len; i--;)
			*bp++ = *yp++ - (m_sum += m_eps);
		b_eps = CMP_quantval_m13(buff, len, 0.5, 0, NULL);  // median
		bp = buff; lad_eps = (sf8) 0.0;
		for (i = len; i--;) {
			t = *bp++ - b_eps;
			lad_eps += ABS_m13(t);
		}
		test_m = lad_eps - lad;
		if (test_m > (sf8) 0.0)
			upper_m = ma;
		else if (test_m < (sf8) 0.0)
			lower_m = ma;
		else
			break;
		d = upper_m - lower_m;
	}
	
	*b = ba;
	*m = ma;
	
	// clean up
	free((void *) buff);
	free((void *) y);
	
	return_m13(TRUE_m13);
}


sf8	*CMP_lin_interp_2_sf8_m13(si8 *in_x, sf8 *in_y, si8 in_len, sf8 *out_y, si8 *out_len)
{
	tern	free_out_y = FALSE_m13;
	si8	i, local_out_len, *xp, dx, last_x;
	sf8	*yp, *oy, dy, last_y, step;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// linear interpolation between points in (x,y) pairs at unitary spacing
		
	if (out_len == NULL)
		out_len = &local_out_len;
	*out_len = (in_x[in_len - 1] - in_x[0]) + 1;
	
	*out_len = (in_x[in_len - 1] - in_x[0]) + 1;
	if (out_y == NULL) {
		free_out_y = TRUE_m13;
		out_y = (sf8 *) malloc_m13((size_t) (*out_len << 3));
	}

	xp = in_x + 1;
	last_x = *xp;
	yp = in_y + 1;
	last_y = *yp;
	oy = out_y;
	*oy++ = *in_y;
	for (i = in_len - 1; i--;) {
		dx = *xp - last_x;
		if (dx <= 0) {
			if (dx)
				G_set_error_m13(E_CMP_m13, "x is not sorted");
			else
				G_set_error_m13(E_CMP_m13, "x is not unique");
			if (free_out_y == TRUE_m13)
				free_m13((void *) out_y);
			return_m13(NULL);
		}
		dy = *yp - last_y;
		step = dy / dx;
		while (dx--)
			*oy++ = (last_y += step);
		last_x = *xp++;
		last_y = *yp++;
	}
	
	return_m13(out_y);
}


sf8	*CMP_lin_interp_sf8_m13(sf8 *in_data, si8 in_len, sf8 *out_data, si8 out_len)
{
	sf8 x, inc, f_bot_x, bot_y, range;
	si8 i, bot_x, top_x, last_bot_x;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (out_data == NULL)
		out_data = (sf8 *) malloc_m13((size_t) (out_len << 3));
	
	if (in_len <= 1) {
		if (in_len == 0)
			return_m13(NULL);
		for (i = 0; i < out_len; ++i)
			out_data[i] = in_data[0];
		return_m13(out_data);
	}
	if (in_len == out_len) {
		memcpy((void *) out_data, (void *) in_data, (size_t) (in_len << 3));
		return_m13(out_data);
	}
	
	// interpolate
	--in_len; --out_len;
	inc = (sf8) in_len / (sf8) out_len;
	
	out_data[0] = in_data[0];
	if (out_len <= (in_len << 1)) {  // downsample, or upsample ratio <= 2:1 (upsampling this way is faster than below)
		for (x = inc, i = 1; i < out_len; ++i, x += inc) {
			top_x = (bot_x = (si8) x) + 1;
			out_data[i] = (x - (sf8) bot_x) * (in_data[top_x] - in_data[bot_x]) + in_data[bot_x];
		}
	} else {  // upsample ratio > 2:1
		for (last_bot_x = -1, x = inc, i = 1; i < out_len; ++i, x += inc) {
			bot_x = (si8) x;
			if (bot_x != last_bot_x) {
				range = in_data[bot_x + 1] - in_data[bot_x];
				bot_y = in_data[bot_x];
				f_bot_x = (sf8) bot_x;
				last_bot_x = bot_x;
			}
			out_data[i] = ((x - f_bot_x) * range) + bot_y;
		}
	}
	out_data[out_len] = in_data[in_len];
	
	return_m13(out_data);
}


si4	*CMP_lin_interp_si4_m13(si4 *in_data, si8 in_len, si4 *out_data, si8 out_len)
{
	sf8 x, inc, f_bot_x, bot_y, range;
	si8 i, bot_x, top_x, last_bot_x;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (out_data == NULL)
		out_data = (si4 *) malloc_m13((size_t) (out_len << 2));
	
	if (in_len <= 1) {
		if (in_len == 0)
			return_m13(NULL);
		for (i = 0; i < out_len; ++i)
			out_data[i] = in_data[0];
		return_m13(out_data);
	}
	if (in_len == out_len) {
		memcpy((void *) out_data, (void *) in_data, (size_t) (in_len << 2));
		return_m13(out_data);
	}
	
	// interpolate
	--in_len; --out_len;
	inc = (sf8) in_len / (sf8) out_len;
	
	out_data[0] = in_data[0];
	if (out_len <= (in_len << 1)) {  // downsample, or upsample ratio <= 2:1
		for (x = inc, i = 1; i < out_len; ++i, x += inc) {
			top_x = (bot_x = (si8) x) + 1;
			out_data[i] = CMP_round_si4_m13((x - (sf8) bot_x) * ((sf8) in_data[top_x] - (sf8) in_data[bot_x]) + (sf8) in_data[bot_x]);
		}
	} else {  // upsample ratio > 2:1
		for (last_bot_x = -1, x = inc, i = 1; i < out_len; ++i, x += inc) {
			bot_x = (si8) x;
			if (bot_x != last_bot_x) {
				range = (sf8) in_data[bot_x + 1] - (sf8) in_data[bot_x];
				bot_y = (sf8) in_data[bot_x];
				f_bot_x = (sf8) bot_x;
				last_bot_x = bot_x;
			}
			out_data[i] = CMP_round_si4_m13(((x - f_bot_x) * range) + bot_y);
		}
	}
	out_data[out_len] = in_data[in_len];
	
	return_m13(out_data);
}


tern  CMP_lin_reg_2_si4_m13(si4 *x_input_buffer, si4 *y_input_buffer, si8 len, sf8 *m, sf8 *b)
{
	sf8 sx, sy, sxx, sxy, n, mx, my, x_val, y_val;
	si8 i;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// linear least_squares regression (2 array input)
	n = (sf8) len;
	sx = sy = sxx = sxy = (sf8) 0.0;
	for (i = len; i--;) {
		x_val = (sf8) *x_input_buffer++;
		y_val = (sf8) *y_input_buffer++;
		sx += x_val;
		sxx += x_val * x_val;
		sy += y_val;
		sxy += x_val * y_val;
	}
	
	mx = sx / n;
	my = sy / n;
	*m = (((sx * my) - sxy) / ((sx * mx) - sxx));
	*b = (my - (*m * mx));
		
	return_m13(TRUE_m13);
}


tern  CMP_lin_reg_si4_m13(si4 *input_buffer, si8 len, sf8 *m, sf8 *b)
{
	sf8	sx, sy, sxx, sxy, n, mx, my, c, val;
	si8	i;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// linear least_squares regression (1 array input)
	
	n = (sf8) len;
	sx = (n * (n + (sf8) 1.0)) / (sf8) 2.0;
	sxx = (n * (n + (sf8) 1.0) * ((n * (sf8) 2.0) + (sf8) 1.0)) / (sf8) 6.0;
	
	c = sy = sxy = (sf8) 0.0;
	for (i = len; i--;) {
		val = (sf8)*input_buffer++;
		sy += val;
		sxy += val * (c += (sf8) 1.0);
	}
	
	mx = sx / n;
	my = sy / n;
	*m = (((sx * my) - sxy) / ((sx * mx) - sxx));
	*b = (my - (*m * mx));
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	CMP_lock_buffers_m13(CMP_BUFFERS_m13 *buffers)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// lock
	if (buffers->locked != TRUE_m13) {
		buffers->locked = mlock_m13((void *) buffers->buffer, buffers->total_allocated_bytes);
		buffers->locked = TRUE_m13;
	}

	return_m13(TRUE_m13);
}


tern  CMP_MBE_decode_m13(CPS_m13 *cps)
{
	ui4				n_samps, total_header_bytes;
	si4				*si4_p, *init_val_p, bits_per_samp, n_derivs;
	si8				i, lmin;
	ui8				out_val, *in_word, mask, temp_mask, high_bits, in_word_val;
	ui1				in_bit;
	CMP_FIXED_BH_m13		*bh;
	CMP_MBE_MODEL_FIXED_HDR_m13	*MBE_header;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// read header
	bh = cps->block_header;
	n_samps = bh->number_of_samples;
	MBE_header = (CMP_MBE_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
	lmin = (si8) MBE_header->minimum_value;
	bits_per_samp = (si4) MBE_header->bits_per_sample;
	n_derivs = (si4) MBE_header->derivative_level;
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->params.model_region + CMP_MBE_MODEL_FIXED_HDR_BYTES_m13);
	for (i = 0; i < n_derivs; ++i)
		cps->decompressed_ptr[i] = *init_val_p++;
	
	// set parameters for return
	cps->params.derivative_level = n_derivs;

	// MBE decode
	// Note: can't use bh->total_header_bytes in case input is VDS fall through
	total_header_bytes = (ui4) ((cps->params.model_region - (ui1 *) bh) + CMP_MBE_MODEL_FIXED_HDR_BYTES_m13 + (n_derivs * 4));
	in_word = (ui8 *) ((ui1 *) bh + (total_header_bytes & ~((ui4) 7)));
	in_bit = (total_header_bytes & (ui4) 7) << 3;
	mask = ((ui8) 1 << bits_per_samp) - 1;
	si4_p = cps->decompressed_ptr + n_derivs;
	in_word_val = *in_word >> in_bit;
	for (i = n_samps - n_derivs; i--;) {
		out_val = in_word_val & mask;
		in_word_val >>= bits_per_samp;
		if ((in_bit += bits_per_samp) > 63) {
			in_word_val = *++in_word;
			if (in_bit &= 63) {
				temp_mask = ((ui8) 1 << in_bit) - 1;
				high_bits = in_word_val & temp_mask;
				out_val |= (high_bits << (bits_per_samp - in_bit));
				in_word_val >>= in_bit;
			}
		}
		*si4_p++ = (si4) ((si8) out_val + lmin);
	}
	
	// integrate derivatives
	CMP_integrate_m13(cps);

	return_m13(TRUE_m13);
}


tern  CMP_MBE_encode_m13(CPS_m13 *cps)
{
	ui1				n_derivs;
	si4				*init_out_vals, *si4_p, bits_per_samp;
	ui4				n_samps, n_deriv_samps, cmp_data_bytes;
	si8				i, cmp_data_bits, lmin, lmax;
	ui8				out_val, *out_word;
	ui1				out_bit, *output;
	CMP_FIXED_BH_m13		*bh;
	CMP_MBE_MODEL_FIXED_HDR_m13	*MBE_header;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// compress from input buffer to block header
	// (compression algorithms are responsible for filling in: algorithm block flag, total_block_bytes, total_header_bytes, model_region_bytes, & model details)
	
	// set algorithm block flag
	bh = cps->block_header;
	bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
	bh->block_flags |= CMP_BF_MBE_ENCODING_m13;

	MBE_header = (CMP_MBE_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
	if (MBE_header->flags & CMP_MBE_FLAGS_PREPROCESSED_MASK_m13) {
		lmin = MBE_header->minimum_value;
		n_derivs = MBE_header->derivative_level;
		bits_per_samp = MBE_header->bits_per_sample;
		MBE_header->flags &= ~CMP_MBE_FLAGS_PREPROCESSED_MASK_m13;  // reset preprocessed flag
	} else {
		MBE_header->derivative_level = n_derivs = CMP_differentiate_m13(cps);  // CMP_differentiate_m13() sets parameter mins & maxs
		if (n_derivs == 0xFF)  // no entry
			return_m13(FALSE_m13);
		if (n_derivs == 0) {
			lmin = (si8) cps->params.minimum_sample_value;
			lmax = (si8) cps->params.maximum_sample_value;
		} else {
			cps->input_buffer = cps->params.derivative_buffer;
			lmin = (si8) cps->params.minimum_difference_value;
			lmax = (si8) cps->params.maximum_difference_value;
		}
		for (bits_per_samp = 0, i = lmax - lmin; i; i >>= 1)
			++bits_per_samp;
		MBE_header->minimum_value = (si4) lmin;
		MBE_header->bits_per_sample = bits_per_samp;
	}
	
	// copy initial derivative values
	n_samps = bh->number_of_samples;
	if (n_derivs) {
		init_out_vals = (si4 *) (cps->params.model_region + CMP_MBE_MODEL_FIXED_HDR_BYTES_m13);
		for (i = 0; i < n_derivs; ++i)
			init_out_vals[i] = cps->input_buffer[i];
	}
	n_deriv_samps = n_samps - n_derivs;
	
	// calculate header bytes
	bh->model_region_bytes = CMP_MBE_MODEL_FIXED_HDR_BYTES_m13 + (n_derivs * 4);
	bh->total_header_bytes = (cps->params.model_region - (ui1 *) bh) + bh->model_region_bytes;
	output = (ui1 *) bh + bh->total_header_bytes;
	
	// calculate total encoding bytes
	cmp_data_bits = (si8) n_deriv_samps * (si8) bits_per_samp;
	cmp_data_bytes = cmp_data_bits >> 3;
	if (cmp_data_bits & 7)
		++cmp_data_bytes;
	
	// MBE encode
	memset(output, 0, cmp_data_bytes);
	out_word = (ui8 *) bh + (bh->total_header_bytes >> 3);
	out_bit = (bh->total_header_bytes & 7) << 3;
	si4_p = cps->input_buffer + n_derivs;
	out_val = 0;
	for (i = n_deriv_samps; i--;) {
		out_val = (ui8) ((si8) *si4_p++ - lmin);
		*out_word |= (out_val << out_bit);
		if ((out_bit += bits_per_samp) > 63) {
			out_bit &= 63;
			*++out_word = (out_val >> (bits_per_samp - out_bit));
		}
	}
	
	// fill in block header
	bh->total_block_bytes = G_pad_m13((ui1 *) bh, (si8) (cmp_data_bytes + bh->total_header_bytes), 8);
	
	return_m13(TRUE_m13);
}


// Mofified Akima cubic interpolation
// Attribution: modifications based on Matlab's adjustments to weights of Akima function
// Note: input x's are integers, output x's are floats
sf8	*CMP_mak_interp_sf8_m13(CMP_BUFFERS_m13 *in_bufs, si8 in_len, CMP_BUFFERS_m13 *out_bufs, si8 out_len)
{
	si8		*index, *si8_p1, *si8_p2;
	si8 	i, j, filled_slopes, in_nm1, tmp_delta_len;
	si8		*in_x;
	sf8 	*delta, *tmp_delta, *weights, *slopes;
	sf8		delta_0, delta_m1, delta_n, delta_n1;
	sf8		*sf8_p1, *sf8_p2, *sf8_p3, *sf8_p4, *sf8_p5, *sf8_p6;
	sf8		sf8_v1, sf8_v2, sf8_v3, sf8_v4;
	sf8 		*in_y, *dx, *out_x, *tmp_out_x, *out_y, *coefs[4];

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Note: This function strays from the usual medlib template in that it does not allocate its processing buffers if not passed.
	// This is just because this function inherently complex anyway, and because otherwise there would be too many arguments for my taste.

	// input buffers
	// allocate with in_bufs =  CMP_allocate_buffers_m13(NULL, CMP_MAK_INTERP_INPUT_BUFFERS_m13, in_len + CMP_MAK_INTERP_PAD_SAMPLES_m13, sizeof(sf8), FALSE_m13, FALSE_m13);
	in_y = (sf8 *) in_bufs->buffer[CMP_MAK_IN_Y_BUF];  // == 0
	in_x = (si8 *) in_bufs->buffer[CMP_MAK_IN_X_BUF];  // == 1
	dx = (sf8 *) in_bufs->buffer[2];
	tmp_delta = (sf8 *) in_bufs->buffer[3];
	slopes = (sf8 *) in_bufs->buffer[4];
	weights = (sf8 *) in_bufs->buffer[5];
	coefs[0] = (sf8 *) in_bufs->buffer[6];
	coefs[1] = (sf8 *) in_bufs->buffer[7];
	
	// output buffers
	// allocate with out_bufs = CMP_allocate_buffers_m13(NULL, CMP_MAK_INTERP_OUTPUT_BUFFERS_m13, out_len, sizeof(sf8), FALSE_m13, FALSE_m13);
	out_y = (sf8 *) out_bufs->buffer[CMP_MAK_OUT_Y_BUF];  // == 0
	out_x = (sf8 *) out_bufs->buffer[CMP_MAK_OUT_X_BUF];  // == 1
	tmp_out_x = (sf8 *) out_bufs->buffer[2];
	index = (si8 *) out_bufs->buffer[3];

	// special cases
	if (in_len <= 1) {
		if (in_len == 0)
			return_m13(out_y);
		for (i = 0; i < out_len; ++i)
			out_y[i] = in_y[0];
		return_m13(out_y);
	}
	if (in_len == out_len) {
		sf8_p1 = out_x;
		si8_p1 = in_x;
		for (i = in_len; i--;)  // check for non-linearly spaced interpolation
			if (*sf8_p1++ != (sf8) *si8_p1++)
				break;
		if (i == -1) {
			memcpy((void *) out_y, (void *) in_y, (size_t) (in_len << 3));
			return_m13(out_y);
		}
	}

	in_nm1 = in_len - 1;
	tmp_delta_len = in_nm1 + 4;
	delta = tmp_delta + 2;
	si8_p1 = in_x;
	si8_p2 = in_x + 1;
	sf8_p1 = dx;
	sf8_p2 = delta;
	sf8_p3 = in_y;
	sf8_p4 = in_y + 1;
	for (i = in_nm1; i--;) {
		*sf8_p1 = (sf8) (*si8_p2++ - *si8_p1++); // dx
		*sf8_p2++ = (*sf8_p4++ - *sf8_p3++) / *sf8_p1++;  // delta = dy / dx
	}

	if (in_len > 2) {
		delta_0 = ((sf8) 2.0 * delta[0]) - delta[1];
		delta_m1 = ((sf8) 2.0 * delta_0) - delta[0];
		delta_n = ((sf8) 2.0 * delta[in_len - 2]) - delta[in_len - 3];
		delta_n1 = ((sf8) 2.0 * delta_n) - delta[in_len - 2];

		tmp_delta[0] = delta_m1;
		tmp_delta[1] = delta_0;
		tmp_delta[tmp_delta_len - 2] = delta_n;
		tmp_delta[tmp_delta_len - 1] = delta_n1;

		sf8_p1 = tmp_delta;
		sf8_p2 = tmp_delta + 1;
		sf8_p3 = weights;
		for (i = tmp_delta_len - 1; i--;) {
			sf8_v1 = *sf8_p1++;
			sf8_v2 = *sf8_p2++;
			sf8_v3 = (sf8_v1 + sf8_v2) / (sf8) 2.0;
			sf8_v3 = (sf8_v3 >= (sf8) 0.0) ? sf8_v3 : -sf8_v3;
			sf8_v4 = (sf8_v2 - sf8_v1);
			sf8_v4 = (sf8_v4 >= (sf8) 0.0) ? sf8_v4 : -sf8_v4;
			*sf8_p3++ = sf8_v3 + sf8_v4;
		}
		sf8_p1 = weights;
		sf8_p2 = weights + 2;
		sf8_p3 = tmp_delta + 1;
		sf8_p4 = tmp_delta + 2;
		sf8_p5 = slopes;
		for (i = in_len; i--;) {
			sf8_v1 = *sf8_p1 + *sf8_p2;
			if (sf8_v1 != 0.0)
				*sf8_p5++ = ((*sf8_p2++ * *sf8_p3++) + (*sf8_p1++ * *sf8_p4++)) / sf8_v1;
		}
		filled_slopes = (si8) (sf8_p5 - slopes);
	} else {
		slopes[0] = slopes[1] = delta[0];
		filled_slopes = (si8) 2;
	}
	// unfilled slopes need to be zeroed
	sf8_p1 = slopes + filled_slopes;
	for (i = in_len - filled_slopes; i--;)
		*sf8_p1++ = (sf8)  0.0;

	coefs[2] = slopes;
	coefs[3] = in_y;
	sf8_p1 = dx;
	sf8_p2 = slopes;
	sf8_p3 = slopes + 1;
	sf8_p4 = delta;
	sf8_p5 = coefs[0];
	sf8_p6 = coefs[1];
	for (i = in_nm1; i--;) {
		*sf8_p5++ = ((*sf8_p2 + *sf8_p3) - (*sf8_p4 * (sf8) 2.0)) / (*sf8_p1 * *sf8_p1);  // column 0
		*sf8_p6++ = ((*sf8_p4++ * (sf8) 3.0) - (*sf8_p2++ * (sf8) 2.0) - *sf8_p3++) / *sf8_p1++;  // column 1
	}

	for (i = 0, j = 0; i < out_len; ++i) {
		sf8_v1 = out_x[i];
		while (((sf8) in_x[j]) <= sf8_v1) {
			++j;
			if (j == in_nm1)
				break;
		}
		index[i] = j - 1;
		if (j == in_nm1) {
			for (++i, --j; i < out_len; ++i)
				index[i] = j;
			break;
		}
	}

	memcpy((void *) tmp_out_x, (void *) out_x, (size_t) (out_len << 3));  // don't destroy out_x (for repeat calls)
	sf8_p1 = tmp_out_x;
	si8_p1 = index;
	for (i = out_len; i--;)
		*sf8_p1++ -= in_x[*si8_p1++];
	sf8_p1 = out_y;
	sf8_p2 = coefs[0];
	si8_p1 = index;
	for (i = out_len; i--;)
		*sf8_p1++ = sf8_p2[*si8_p1++];

	for (i = 1; i < 4; ++i) {
		sf8_p1 = out_y;
		sf8_p2 = tmp_out_x;
		sf8_p3 = coefs[i];
		si8_p1 = index;
		for (j = out_len; j--; ++sf8_p1)
			*sf8_p1 = ((sf8) *sf8_p2++ * *sf8_p1) + sf8_p3[*si8_p1++];
	}

	return_m13(out_y);
}


ui1 CMP_normality_score_m13(si4 *data, ui4 n_samps)
{
	sf8 sx, sx2, sy, sy2, sxy, mx, mx2, sd, val, z, r, n, *norm_cdf;
	sf8 num, den1, den2, cdf[CMP_NORMAL_CDF_TABLE_ENTRIES_m13];
	si8 i, count[CMP_NORMAL_CDF_TABLE_ENTRIES_m13] = {0};
	si4	*si4_p, bin;
	ui1 ks;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Returns the correlation of the distribution in the data to that expected from a normal distribution.
	// Essentially a Kolmogorov-Smirnov test normalized to range [-1 to 0) = 0 & [0 to 1] = [0 to 254]. 255 is reserved for no entry.
	
	if (globals_m13->tables->CMP_normal_CDF_table == NULL)
		CMP_init_tables_m13();
	norm_cdf = globals_m13->tables->CMP_normal_CDF_table;

	// calculate mean & standard deviation
	n = (sf8) n_samps;
	si4_p = data;
	sx = sx2 = (sf8) 0.0;
	for (i = n_samps; i--;) {
		val = (sf8) *si4_p++;
		sx += val;
		sx2 += val * val;
	}
	mx = sx / n;
	mx2 = sx2 / n;
	sd = sqrt(mx2 - (mx * mx));
	
	// bin the samples
	si4_p = data;
	for (i = n_samps; i--;) {
		val = (sf8) *si4_p++;
		z = (val - mx) / sd;
		if (isnan(z))
			continue;
		bin = (si4) ((z + (sf8) 3.1) * (sf8) 10.0);
		if (bin < 0)
			bin = 0;
		else if (bin >= CMP_NORMAL_CDF_TABLE_ENTRIES_m13)
			bin = CMP_NORMAL_CDF_TABLE_ENTRIES_m13 - 1;
		++count[bin];
	}
	
	// generate data CDF
	cdf[0] = (sf8) count[0];
	for (i = 1; i < CMP_NORMAL_CDF_TABLE_ENTRIES_m13; ++i)
		cdf[i] = (sf8) count[i] + cdf[i - 1];
	
	// calculate correlation between data CDF and normal CDF
	sx = sx2 = sxy = (sf8) 0.0;
	sy = CMP_SUM_NORMAL_CDF_m13;
	sy2 = CMP_SUM_SQ_NORMAL_CDF_m13;
	for (i = 0; i < CMP_NORMAL_CDF_TABLE_ENTRIES_m13; ++i) {
		sx += cdf[i];
		sx2 += cdf[i] * cdf[i];
		sxy += cdf[i] * norm_cdf[i];
	}
	
	num = (n * sxy) - (sx * sy);
	den1 = (n * sx2) - (sx * sx);
	den2 = (n * sy2) - (sy * sy);
	
	//  handle rounding errors
	if ((den1 <= (sf8) 0.0) || (den2 <= (sf8) 0.0))
		r = (sf8) 0.0;
	else
		r = num / (sqrt(den1) * sqrt(den2));
	
	// calculate Kolmogorov Smirnov correlation
	r += CMP_KS_CORRECTION_m13;
	if (r < (sf8) 0.0)
		r = (sf8) 0.0;
	else if (r > (sf8) 1.0)
		r = (sf8) 1.0;
	
	// return KS score (negative values set to zero, positive scaled to 0-254, 255 reserved for no entry)
	ks = (ui1) CMP_round_si4_m13(r * (sf8) 254.0); // ks = (ui1) CMP_round_si4_m13(sqrt(1.0 - (r * r)) * 254);  => I had this before, but I don't know why
	
	return_m13(ks);
}


sf8	CMP_p2z_m13(sf8 p)
{
	const sf8	P_EPS = (sf8) 0.00000005;
	sf8 	z, low_z, high_z, temp_z, low_p, high_p, temp_p;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// forward search
	low_z = (sf8) 0.0;
	high_p = CMP_z2p_m13(low_z);
	high_z = (sf8) 2.0;
	low_p = CMP_z2p_m13(high_z);
	while (low_p > p) {
		low_z = high_z;
		high_p = low_p;
		high_z *= (sf8) 2.0;
		low_p = CMP_z2p_m13(high_z);
	}
	
	// binary search
	while ((high_p - low_p) > P_EPS) {
		temp_z = (low_z + high_z) / (sf8) 2.0;
		temp_p = CMP_z2p_m13(temp_z);
		if (temp_p >= p) {
			high_p = temp_p;
			low_z = temp_z;
		} else {
			low_p = temp_p;
			high_z = temp_z;
		}
	}
	z = (low_z + high_z) / (sf8) 2.0;
	
	return_m13(z);
}


tern  CMP_PRED1_decode_m13(CPS_m13 *cps)
{
	tern				no_zero_counts;
	ui1				*comp_p, *ui1_p, *low_bound_high_byte_p, *high_bound_high_byte_p;
	ui1				*goal_bound_high_byte_p, prev_cat, overflow_bytes;
	ui1				*symbol_map[CMP_PRED_CATS_m13], *symbols;
	si1				*si1_p1, *si1_p2, *key_p;
	ui2				*bin_counts, *stats_entries, *count[CMP_PRED_CATS_m13];
	ui4				n_samps, n_derivs, n_keysample_bytes, total_stats_entries, sign_bit, sign_bytes;
	si4				*si4_p, *init_val_p, overflow_val;
	ui8				**minimum_range, **cumulative_count;
	ui8				low_bound, high_bound, prev_high_bound, goal_bound, range;
	si8				i, j;
	CMP_FIXED_BH_m13		*bh;
	CMP_PRED_MODEL_FIXED_HDR_m13	*PRED_header;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// CMP decompress from block header to decompressed_ptr
	
	bh = cps->block_header;
	n_samps = bh->number_of_samples;
	
	// zero samples, or only one value
	if (n_samps <= 1) {
		if (bh->number_of_samples == 1)
			cps->decompressed_ptr[0] = *((si4 *) (cps->params.model_region + CMP_PRED_MODEL_FIXED_HDR_BYTES_m13));
		cps->params.derivative_level = 0;
		return_m13(TRUE_m13);
	}
	
	PRED_header = (CMP_PRED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
	n_derivs = PRED_header->derivative_level;
	n_keysample_bytes = PRED_header->n_keysample_bytes;
	stats_entries = PRED_header->numbers_of_statistics_bins;
	for (total_stats_entries = i = 0; i < CMP_PRED_CATS_m13; ++i)
		total_stats_entries += (ui4) stats_entries[i];
	
	// set parameters for return
	cps->params.derivative_level = n_derivs;
	
	// get block flags
	no_zero_counts = FALSE_m13;
	if (PRED_header->flags & CMP_PRED_FLAGS_NO_ZERO_COUNTS_m13)
		no_zero_counts = TRUE_m13;
	overflow_bytes = CMP_get_overflow_bytes_m13(cps, CMP_DECOMPRESSION_MODE_m13, CMP_PRED_COMPRESSION_m13);
	sign_bit = (ui4) 1 << ((overflow_bytes << 3) - 1);
	if (overflow_bytes == 4)
		sign_bytes = (ui4) 0;
	else  // Windows: shift of 32 bits is equated to shift of 0, so have to do this
		sign_bytes = (ui4) 0xFFFFFFFF << (overflow_bytes << 3);

	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->params.model_region + CMP_PRED_MODEL_FIXED_HDR_BYTES_m13);
	for (i = 0; i < n_derivs; ++i)
		cps->decompressed_ptr[i] = *init_val_p++;

	// build symbol map, count arrays, & minimum ranges
	bin_counts = (ui2 *) init_val_p;
	symbols = (ui1 *) (bin_counts + total_stats_entries);
	cumulative_count = (ui8 **) cps->params.cumulative_count;
	minimum_range = (ui8 **) cps->params.minimum_range;
	for (i = 0; i < CMP_PRED_CATS_m13; ++i) {
		count[i] = bin_counts; bin_counts += stats_entries[i];
		symbol_map[i] = symbols; symbols += stats_entries[i];
		if (no_zero_counts == TRUE_m13) {  // TO DO: decide mapping scheme for unmapped symbols in symbol map
			// TO DO: copy count & symbol map to arrays with 256 elements
			for (j = stats_entries[i]; i < 256; ++i)
				count[i][j] = 1;
		}
		for (cumulative_count[i][0] = j = 0; j < stats_entries[i]; ++j) {
			cumulative_count[i][j + 1] = cumulative_count[i][j] + (ui8) count[i][j];
			minimum_range[i][j] = CMP_RED_TOTAL_COUNTS_m13 / count[i][j];
			if (CMP_RED_TOTAL_COUNTS_m13 > (count[i][j] * minimum_range[i][j]))
				++minimum_range[i][j];
		}
	}
	
	// range decode
	key_p = cps->params.keysample_buffer;
	prev_high_bound = goal_bound = low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m13;
	comp_p = (ui1 *) bh + bh->total_header_bytes;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	goal_bound_high_byte_p = ((ui1 *) &goal_bound) + 5;
	ui1_p = goal_bound_high_byte_p;
	*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
	*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
	prev_cat = CMP_PRED_NIL_m13;
		
	for (i = n_keysample_bytes; i;) {
		for (j = 0; range >= minimum_range[prev_cat][j];) {
			high_bound = low_bound + ((range * cumulative_count[prev_cat][j + 1]) >> 16);
			if (high_bound > goal_bound) {
				*key_p = symbol_map[prev_cat][j];
				if (!--i)
					goto PRED1_RANGE_DECODE_DONE_m13;
				range = high_bound - (low_bound = prev_high_bound);
				prev_cat = CMP_PRED_CAT_m13(*key_p); ++key_p;
				j = 0;
			} else {
				prev_high_bound = high_bound;
				++j;
			}
		}
		high_bound = low_bound + range;
		if (*low_bound_high_byte_p != *high_bound_high_byte_p) {
			ui1_p = goal_bound_high_byte_p;
			*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
			*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
			low_bound = 0;
			range = CMP_RED_MAXIMUM_RANGE_m13;
		} else {
			do {
				low_bound <<= 8;
				high_bound <<= 8;
				goal_bound = (goal_bound << 8) | (ui8) *comp_p++;
				range <<= 8;
			} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
			low_bound &= CMP_RED_RANGE_MASK_m13;
			goal_bound &= CMP_RED_RANGE_MASK_m13;
		}
		prev_high_bound = low_bound;
	} PRED1_RANGE_DECODE_DONE_m13:

	// generate derivatives from keysample data
	si4_p = cps->decompressed_ptr + n_derivs;
	si1_p1 = (si1 *) cps->params.keysample_buffer;
	for (i = n_samps - n_derivs; i--;) {
		if (*si1_p1 == CMP_SI1_KEYSAMPLE_FLAG_m13) {
			overflow_val = 0;
			++si1_p1;
			si1_p2 = (si1 *) &overflow_val;
			j = overflow_bytes; do {
				*si1_p2++ = *si1_p1++;
			} while (--j);
			if (overflow_val & sign_bit)
				overflow_val |= sign_bytes;
			*si4_p++ = overflow_val;
		} else {
			*si4_p++ = (si4) *si1_p1++;
		}
	}

	// integrate derivatives
	CMP_integrate_m13(cps);

	return_m13(TRUE_m13);
}


tern  CMP_PRED2_decode_m13(CPS_m13 *cps)
{
	tern				no_zero_counts, multiply_method;
	ui1				*comp_p, *ui1_p, prev_cat, overflow_bytes;
	ui1				*low_bound_high_byte_p, *high_bound_high_byte_p, *goal_bound_high_byte_p;
	ui1				*symbol_map[CMP_PRED_CATS_m13], *symbols;
	si1				*si1_p1, *si1_p2, *key_p;
	ui2				*bin_counts, *stats_entries, *count[CMP_PRED_CATS_m13], *tc;
	ui4				n_samps, n_derivs, n_keysample_bytes, total_stats_entries, sign_bit, sign_bytes;
	si4				*si4_p, *init_val_p, overflow_val;
	ui8				**minimum_range, **cumulative_count, *cc;
	ui8				low_bound, high_bound, prev_high_bound, goal_bound, range, target_cc;
	si8				i, j;
	sf8				average_steps, multiply_time;
	CMP_FIXED_BH_m13		*bh;
	CMP_PRED_MODEL_FIXED_HDR_m13	*PRED_header;
	HW_PERFORMANCE_SPECS_m13	*perf_specs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// CMP decompress from block header to decompressed_ptr
	bh = cps->block_header;
	n_samps = bh->number_of_samples;
	
	// zero samples, or only one value
	if (n_samps <= 1) {
		if (bh->number_of_samples == 1)
			cps->decompressed_ptr[0] = *((si4 *) (cps->params.model_region + CMP_PRED_MODEL_FIXED_HDR_BYTES_m13));
		cps->params.derivative_level = 0;
		return_m13(TRUE_m13);
	}
	
	PRED_header = (CMP_PRED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
	n_derivs = PRED_header->derivative_level;
	n_keysample_bytes = PRED_header->n_keysample_bytes;
	stats_entries = PRED_header->numbers_of_statistics_bins;
	for (total_stats_entries = i = 0; i < CMP_PRED_CATS_m13; ++i)
		total_stats_entries += (ui4) stats_entries[i];
	
	// set parameters for return
	cps->params.derivative_level = n_derivs;
	
	// get block flags
	no_zero_counts = FALSE_m13;
	if (PRED_header->flags & CMP_PRED_FLAGS_NO_ZERO_COUNTS_m13)
		no_zero_counts = TRUE_m13;
	overflow_bytes = CMP_get_overflow_bytes_m13(cps, CMP_DECOMPRESSION_MODE_m13, CMP_PRED_COMPRESSION_m13);
	sign_bit = (ui4) 1 << ((overflow_bytes << 3) - 1);
	if (overflow_bytes == 4)
		sign_bytes = (ui4) 0;
	else  // Windows: shift of 32 bits is equated to shift of 0, so have to do this
		sign_bytes = (ui4) 0xFFFFFFFF << (overflow_bytes << 3);

	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->params.model_region + CMP_PRED_MODEL_FIXED_HDR_BYTES_m13);
	for (i = 0; i < n_derivs; ++i)
		cps->decompressed_ptr[i] = *init_val_p++;

	// build symbol map, count arrays, & minimum ranges
	bin_counts = (ui2 *) init_val_p;
	symbols = (ui1 *) (bin_counts + total_stats_entries);
	cumulative_count = (ui8 **) cps->params.cumulative_count;
	minimum_range = (ui8 **) cps->params.minimum_range;
	for (i = 0; i < CMP_PRED_CATS_m13; ++i) {
		count[i] = bin_counts; bin_counts += stats_entries[i];
		symbol_map[i] = symbols; symbols += stats_entries[i];
		if (no_zero_counts == TRUE_m13) {  // TO DO: decide mapping scheme for unmapped symbols in symbol map
			// TO DO: copy count & symbol map to arrays with 256 elements
			for (j = stats_entries[i]; i < 256; ++i)
				count[i][j] = 1;
		}
		for (cumulative_count[i][0] = j = 0; j < stats_entries[i]; ++j) {
			cumulative_count[i][j + 1] = cumulative_count[i][j] + (ui8) count[i][j];
			minimum_range[i][j] = CMP_RED_TOTAL_COUNTS_m13 / count[i][j];
			if (CMP_RED_TOTAL_COUNTS_m13 > (count[i][j] * minimum_range[i][j]))
				++minimum_range[i][j];
		}
	}
	
	// determine decompression method
	perf_specs = &globals_m13->tables->HW_params.performance_specs;
	if (perf_specs->integer_multiplications_per_sec == 0.0)
		HW_get_performance_specs_m13(FALSE_m13);
	for (average_steps = (sf8) 0.0, i = 0; i < CMP_PRED_CATS_m13; ++i) {
		tc = count[i];
		for (j = 0; j < stats_entries[i]; ++j)
			average_steps += (sf8) (j * (si8) tc[j]);
	}
	average_steps /= (sf8) (CMP_RED_TOTAL_COUNTS_m13 * CMP_PRED_CATS_m13);
	multiply_time = average_steps * perf_specs->nsecs_per_integer_multiplication;
	if (multiply_time < perf_specs->nsecs_per_integer_division)
		multiply_method = TRUE_m13;
	else
		multiply_method = FALSE_m13;

	// range decode
	key_p = cps->params.keysample_buffer;
	prev_high_bound = goal_bound = low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m13;
	comp_p = (ui1 *) bh + bh->total_header_bytes;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	goal_bound_high_byte_p = ((ui1 *) &goal_bound) + 5;
	ui1_p = goal_bound_high_byte_p;
	*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
	*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
	prev_cat = CMP_PRED_NIL_m13;
	
	if (multiply_method == TRUE_m13) {
		for (j = 0, i = n_keysample_bytes; i;) {
			while (range >= minimum_range[prev_cat][j]) {
				high_bound = low_bound + ((range * cumulative_count[prev_cat][j + 1]) >> 16);
				if (high_bound > goal_bound) {
					*key_p = symbol_map[prev_cat][j];
					if (!--i)
						goto PRED2_RANGE_DECODE_DONE_m13;
					range = high_bound - (low_bound = prev_high_bound);
					prev_cat = CMP_PRED_CAT_m13(*key_p); ++key_p;
					j = 0;
				} else {
					prev_high_bound = high_bound;
					++j;
				}
			}
			high_bound = low_bound + range;
			if (low_bound == high_bound || *low_bound_high_byte_p != *high_bound_high_byte_p) {
				ui1_p = goal_bound_high_byte_p;
				*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
				*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
				low_bound = 0;
				range = CMP_RED_MAXIMUM_RANGE_m13;
			} else {
				do {
					low_bound <<= 8;
					high_bound <<= 8;
					goal_bound = (goal_bound << 8) | (ui8) *comp_p++;
				} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
				low_bound &= CMP_RED_RANGE_MASK_m13;
				high_bound &= CMP_RED_RANGE_MASK_m13;
				goal_bound &= CMP_RED_RANGE_MASK_m13;
				range = high_bound - low_bound;
			}
			prev_high_bound = low_bound;
			if (j)
				prev_high_bound += (range * cumulative_count[prev_cat][j]) >> 16;
		}
	} else {  // division method
		for (j = 0, i = n_keysample_bytes; i;) {
			while (range >= minimum_range[prev_cat][j]) {
				high_bound = low_bound + ((range * cumulative_count[prev_cat][j + 1]) >> 16);
				if (high_bound > goal_bound) {
					*key_p = symbol_map[prev_cat][j];
					if (!--i)
						goto PRED2_RANGE_DECODE_DONE_m13;
					range = high_bound - (low_bound = prev_high_bound);
					prev_cat = CMP_PRED_CAT_m13(*key_p); ++key_p;
					target_cc =  ((goal_bound - low_bound) << 16) / range;
					cc = cumulative_count[prev_cat];
					for (j = 1; j < stats_entries[prev_cat]; ++j)
						if (target_cc <= cc[j])
							break;
					if (--j)
						prev_high_bound += (range * cumulative_count[prev_cat][j]) >> 16;
				} else {
					prev_high_bound = high_bound;
					++j;
				}
			}
			high_bound = low_bound + range;
			if (low_bound == high_bound || *low_bound_high_byte_p != *high_bound_high_byte_p) {
				ui1_p = goal_bound_high_byte_p;
				*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
				*ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++; *ui1_p-- = *comp_p++;
				low_bound = 0;
				range = CMP_RED_MAXIMUM_RANGE_m13;
			} else {
				do {
					low_bound <<= 8;
					high_bound <<= 8;
					goal_bound = (goal_bound << 8) | (ui8) *comp_p++;
				} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
				low_bound &= CMP_RED_RANGE_MASK_m13;
				high_bound &= CMP_RED_RANGE_MASK_m13;
				goal_bound &= CMP_RED_RANGE_MASK_m13;
				range = high_bound - low_bound;
			}
			prev_high_bound = low_bound;
			target_cc =  ((goal_bound - low_bound) << 16) / range;
			cc = cumulative_count[prev_cat];
			for (j = 1; j < stats_entries[prev_cat]; ++j)
				if (target_cc <= cc[j])
					break;
			if (--j)
				prev_high_bound += (range * cumulative_count[prev_cat][j]) >> 16;
		}
	}
	PRED2_RANGE_DECODE_DONE_m13:

	// generate derivatives from keysample data
	si4_p = cps->decompressed_ptr + n_derivs;
	si1_p1 = (si1 *) cps->params.keysample_buffer;
	for (i = n_samps - n_derivs; i--;) {
		if (*si1_p1 == CMP_SI1_KEYSAMPLE_FLAG_m13) {
			overflow_val = 0;
			++si1_p1;
			si1_p2 = (si1 *) &overflow_val;
			j = overflow_bytes; do {
				*si1_p2++ = *si1_p1++;
			} while (--j);
			if (overflow_val & sign_bit)
				overflow_val |= sign_bytes;
			*si4_p++ = overflow_val;
		} else {
			*si4_p++ = (si4) *si1_p1++;
		}
	}

	// integrate derivatives
	CMP_integrate_m13(cps);

	return_m13(TRUE_m13);
}


tern  CMP_PRED1_encode_m13(CPS_m13 *cps)
{
	tern				no_zero_counts, use_raw;
	ui1				*low_bound_high_byte_p, *high_bound_high_byte_p, *ui1_p, prev_cat, n_derivs;
	ui1				*key_p, *comp_p, *symbols, **symbol_map, overflow_bytes;
	ui2				*bin_counts, *stats_entries;
	ui4				n_samps, n_keysamp_bytes, **count, n_deriv_samps, PRED_total_bytes, total_stats_entries, header_bytes;
	ui4				cat_total_counts[CMP_PRED_CATS_m13], goal_total_counts[CMP_PRED_CATS_m13], bin, fall_through_bytes, rem;
	si4				*deriv_p, *init_val_p, diff, bits_per_samp, raw_bits_per_samp;
	ui8				**cumulative_count, **minimum_range;
	ui8				range, high_bound, low_bound;
	si8				i, j, k, m, extra_counts, scaled_total_counts, MBE_data_bits;
	CMP_STATISTICS_BIN_m13		**sorted_count, temp_sorted_count;
	CMP_FIXED_BH_m13		*bh;
	CMP_PRED_MODEL_FIXED_HDR_m13	*PRED_header;
	CMP_MBE_MODEL_FIXED_HDR_m13	*MBE_header;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// CMP compress from input buffer to block header
	// (compression algorithms are responsible for filling in: algorithm block flag, total_block_bytes, total_header_bytes, model_region_bytes, & model details)

	// set algorithm block flag
	bh = cps->block_header;
	bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
	bh->block_flags |= CMP_BF_PRED1_ENCODING_m13;
	
	PRED_header = (CMP_PRED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
	n_samps = bh->number_of_samples;
	PRED_header->flags = (ui1) 0;

	// zero or one or samples
	if (n_samps <= 1) {
		bh->model_region_bytes = (ui2) CMP_PRED_MODEL_FIXED_HDR_BYTES_m13;
		if (bh->number_of_samples == 1) {
			*((si4 *) (cps->params.model_region + bh->model_region_bytes)) = cps->input_buffer[0];  // note: no statistics
			bh->model_region_bytes += sizeof(si4);
		}
		PRED_header->n_keysample_bytes = 0;
		PRED_header->derivative_level = 0;
		PRED_header->n_nil_statistics_bins = PRED_header->n_pos_statistics_bins = PRED_header->n_neg_statistics_bins = 0;
		bh->total_header_bytes = (ui4) (cps->params.model_region - (ui1 *) bh) + bh->model_region_bytes;
		bh->total_block_bytes = G_pad_m13((ui1 *) bh, bh->total_header_bytes, 8);
		return_m13(TRUE_m13);
	}
	
	// calculate derivatives
	n_derivs = CMP_differentiate_m13(cps);

	// set up PRED arrays
	count = (ui4 **) cps->params.count;
	cumulative_count = (ui8 **) cps->params.cumulative_count;
	minimum_range = (ui8 **) cps->params.minimum_range;
	sorted_count = (CMP_STATISTICS_BIN_m13 **) cps->params.sorted_count;
	symbol_map = (ui1 **) cps->params.symbol_map;

	// set model parameters
	PRED_header->derivative_level = n_derivs;
	no_zero_counts = FALSE_m13;
	if (cps->direcs.flags & CMP_PRED_FLAGS_NO_ZERO_COUNTS_m13) {
		no_zero_counts = TRUE_m13;
		PRED_header->flags |= CMP_PRED_FLAGS_NO_ZERO_COUNTS_m13;
	}
	overflow_bytes = CMP_get_overflow_bytes_m13(cps, CMP_COMPRESSION_MODE_m13, CMP_PRED_COMPRESSION_m13);

	// generate count & build keysample array
	memset((void *) count[0], 0, CMP_RED_MAX_STATS_BINS_m13 * CMP_PRED_CATS_m13 * sizeof(ui4));
	key_p = (ui1 *) cps->params.keysample_buffer;
	deriv_p = cps->params.derivative_buffer + n_derivs;
	prev_cat = CMP_PRED_NIL_m13;
	n_deriv_samps = n_samps - (ui4) n_derivs;
	for (i = n_deriv_samps; i--;) {
		diff = *deriv_p++;
		if (diff < -127 || diff > 127) {
			ui1_p = (ui1 *) &diff;
			++count[prev_cat][*key_p++ = CMP_UI1_KEYSAMPLE_FLAG_m13];
			prev_cat = CMP_PRED_NEG_m13;
			j = overflow_bytes; do {
				++count[prev_cat][*key_p = *ui1_p++];
				prev_cat = CMP_PRED_CAT_m13(*key_p); ++key_p;  // do not increment within call to CAT
			} while (--j);
		} else {
			++count[prev_cat][*key_p = (ui1) diff];
			prev_cat = CMP_PRED_CAT_m13(*key_p); ++key_p;  // do not increment within call to CAT
		}
	}
	n_keysamp_bytes = (ui4) (key_p - (ui1 *) cps->params.keysample_buffer);
	
	// build sorted_count: interleave
	stats_entries = PRED_header->numbers_of_statistics_bins;
	for (total_stats_entries = i = 0; i < CMP_PRED_CATS_m13; ++i) {
		for (j = stats_entries[i] = 0, k = 255, m = 128; m--; ++j, --k) {
			if (count[i][j]) {
				sorted_count[i][stats_entries[i]].count = count[i][j];
				sorted_count[i][stats_entries[i]++].value = (si1) j;
			}
			if (count[i][k]) {
				sorted_count[i][stats_entries[i]].count = count[i][k];
				sorted_count[i][stats_entries[i]++].value = (si1) k;
			}
		}
		total_stats_entries += stats_entries[i];
	}

	// build sorted_count: bubble sort
	for (i = 0; i < CMP_PRED_CATS_m13; ++i) {
		m = stats_entries[i];
		do {
			for (j = 0, k = 1; k < m; ++k) {
				if (sorted_count[i][k - 1].count < sorted_count[i][k].count) {
					temp_sorted_count = sorted_count[i][k - 1];
					sorted_count[i][k - 1] = sorted_count[i][k];
					sorted_count[i][k] = temp_sorted_count;
					j = k;  // highest swap index
				}
			}
		} while ((m = j) > 1);
	}
	
	// get separate count for each category
	for (i = 0; i < CMP_PRED_CATS_m13; ++i)
		for (cat_total_counts[i] = j = 0; j < stats_entries[i]; ++j)
			cat_total_counts[i] += sorted_count[i][j].count;
	
	// scale count so that each category's total_counts equals (RED_TOTAL_COUNTS - 1)
	for (i = 0; i < CMP_PRED_CATS_m13; ++i) {
		goal_total_counts[i] = CMP_RED_TOTAL_COUNTS_m13 - 1;
		if (no_zero_counts == TRUE_m13)
			goal_total_counts[i] -= (256 - stats_entries[i]);  // reserve one count in each model category for all zero count bins
		// TO DO: decide mapping scheme for unmapped symbols in symbol map
	}

	for (i = 0; i < CMP_PRED_CATS_m13; ++i) {
		if (!stats_entries[i])
			continue;
		for (scaled_total_counts = j = 0; j < stats_entries[i]; ++j) {
			sorted_count[i][j].count = (ui4) (((((ui8) goal_total_counts[i] << 1) * (ui8) sorted_count[i][j].count) + (ui8) cat_total_counts[i]) / ((ui8) cat_total_counts[i] << 1));
			if (sorted_count[i][j].count == 0)
				sorted_count[i][j].count = 1;
			scaled_total_counts += (si8)sorted_count[i][j].count;
		}
		extra_counts = ((si8) goal_total_counts[i] - (si8) scaled_total_counts);
		if (extra_counts > 0) {
			do {
				for (j = 0; (j < stats_entries[i]) && extra_counts; ++j) {
					++sorted_count[i][j].count;
					--extra_counts;
				}
			} while (extra_counts);
		} else if (extra_counts < 0) {
			extra_counts = -extra_counts;
			do {
				for (j = stats_entries[i] - 1; (j >= 0) && extra_counts; --j) {
					if (sorted_count[i][j].count > 1) {
						--sorted_count[i][j].count;
						--extra_counts;
					}
				}
			} while (extra_counts);
		}
	}
	
	// build symbol maps, count arrays & minimum ranges
	for (i = 0; i < CMP_PRED_CATS_m13; ++i) {
		for (cumulative_count[i][0] = j = 0; j < stats_entries[i]; ++j) {
			symbol_map[i][(ui1) sorted_count[i][j].value] = (ui1) j;
			cumulative_count[i][j + 1] = cumulative_count[i][j] + (ui8) (count[i][j] = sorted_count[i][j].count);
			minimum_range[i][j] = CMP_RED_TOTAL_COUNTS_m13 / count[i][j];
			if (CMP_RED_TOTAL_COUNTS_m13 > (count[i][j] * minimum_range[i][j]))
				++minimum_range[i][j];
		}
	}
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->params.model_region + CMP_PRED_MODEL_FIXED_HDR_BYTES_m13);
	for (i = 0; i < n_derivs; ++i)
		*init_val_p++ = cps->params.derivative_buffer[i];

	// write scaled counts & symbols into header
	bin_counts = (ui2 *) init_val_p;
	symbols = (ui1 *) (bin_counts + total_stats_entries);
	for (i = 0; i < CMP_PRED_CATS_m13; ++i) {
		for (j = 0; j < stats_entries[i]; ++j) {
			*bin_counts++ = (ui2) sorted_count[i][j].count;
			*symbols++ = sorted_count[i][j].value;
		}
	}
	
	// fill header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	bh->model_region_bytes = (ui2) (ui2) (symbols - cps->params.model_region);
	bh->total_header_bytes = (ui4) (symbols - (ui1 *) bh);
	PRED_header->n_keysample_bytes = n_keysamp_bytes;
	
	// range encode
	key_p = (ui1 *) cps->params.keysample_buffer;
	comp_p = (ui1 *) bh + bh->total_header_bytes;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m13;
	prev_cat = CMP_PRED_NIL_m13;
	
	for (i = n_keysamp_bytes; i;) {
		for (; range >= minimum_range[prev_cat][bin = symbol_map[prev_cat][*key_p]]; key_p++) {
			high_bound = low_bound + ((range * cumulative_count[prev_cat][bin + 1]) >> 16);
			if (bin)
				low_bound += (range * cumulative_count[prev_cat][bin]) >> 16;
			range = high_bound - low_bound;
			if (!--i)
				break;
			prev_cat = CMP_PRED_CAT_m13(*key_p);
		}
		if ((*low_bound_high_byte_p != *high_bound_high_byte_p) || !i) {
			ui1_p = low_bound_high_byte_p;
			*comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--;
			*comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--;
			range = CMP_RED_MAXIMUM_RANGE_m13;
			low_bound = 0;
		} else {
			do {
				*comp_p++ = *low_bound_high_byte_p;
				low_bound <<= 8;
				high_bound <<= 8;
				range <<= 8;
			} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
			low_bound &= CMP_RED_RANGE_MASK_m13;
		}
	}
	
	// finish header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	PRED_total_bytes = (si8) (comp_p - (ui1 *) bh);
	bh->total_block_bytes = (ui4) G_pad_m13((ui1 *) bh, PRED_total_bytes, 8);
	
	// calculate fall through encoding bytes
	if (cps->direcs.flags & CPS_DF_FALL_THROUGH_TO_BEST_ENCODING_m13) {
		for (raw_bits_per_samp = 0, i = (si8) cps->params.maximum_sample_value - (si8) cps->params.minimum_sample_value; i; i >>= 1)
			++raw_bits_per_samp;
		if (n_derivs) {
			for (bits_per_samp = 0, i = (si8) cps->params.maximum_difference_value - (si8) cps->params.minimum_difference_value; i; i >>= 1)
				++bits_per_samp;
			if (raw_bits_per_samp > bits_per_samp)  // this can happen in very noisy data
				use_raw = FALSE_m13;
			else
				use_raw = TRUE_m13;
		} else {
			use_raw = TRUE_m13;
		}
		if (use_raw == TRUE_m13) {
			bits_per_samp = raw_bits_per_samp;
			n_derivs = 0;
			n_deriv_samps = n_samps;
		}
		MBE_data_bits = (si8) n_deriv_samps * (si8) bits_per_samp;
		fall_through_bytes = (MBE_data_bits + 7) >> 3;
		header_bytes = cps->params.model_region - (ui1 *) bh;  // fixed block bytes + variable region before model
		fall_through_bytes += header_bytes + CMP_MBE_MODEL_FIXED_HDR_BYTES_m13 + (n_derivs * 4);
		if ((rem = fall_through_bytes & 7))  // pad bytes
			fall_through_bytes += 8 - rem;
		if (fall_through_bytes < bh->total_block_bytes) {
			bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
			bh->block_flags |= CMP_BF_MBE_ENCODING_m13;
			MBE_header = (CMP_MBE_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
			if (use_raw == TRUE_m13) {
				// cps->input_buffer = unchanged
				MBE_header->minimum_value = cps->params.minimum_sample_value;
				MBE_header->derivative_level = 0;
			} else {
				cps->input_buffer = cps->params.derivative_buffer;
				MBE_header->minimum_value = cps->params.minimum_difference_value;
				MBE_header->derivative_level = n_derivs;
			}
			MBE_header->bits_per_sample = bits_per_samp;
			MBE_header->flags = CMP_MBE_FLAGS_PREPROCESSED_MASK_m13;
			CMP_MBE_encode_m13(cps);
		}
	}

	return_m13(TRUE_m13);
}


tern  CMP_PRED2_encode_m13(CPS_m13 *cps)
{
	tern				no_zero_counts, use_raw;
	ui1				*low_bound_high_byte_p, *high_bound_high_byte_p, *ui1_p, prev_cat, n_derivs;
	ui1				*key_p, *comp_p, *symbols, **symbol_map, overflow_bytes;
	ui2				*bin_counts, *stats_entries;
	ui4				n_samps, n_keysamp_bytes, **count, n_deriv_samps, PRED_total_bytes, total_stats_entries, header_bytes;
	ui4				cat_total_counts[CMP_PRED_CATS_m13], goal_total_counts[CMP_PRED_CATS_m13], bin, fall_through_bytes, rem;
	si4				*deriv_p, *init_val_p, diff, bits_per_samp, raw_bits_per_samp;
	ui8				**cumulative_count, **minimum_range;
	ui8				range, high_bound, low_bound;
	si8				i, j, k, m, extra_counts, scaled_total_counts, MBE_data_bits;
	CMP_STATISTICS_BIN_m13		**sorted_count, temp_sorted_count;
	CMP_FIXED_BH_m13		*bh;
	CMP_PRED_MODEL_FIXED_HDR_m13	*PRED_header;
	CMP_MBE_MODEL_FIXED_HDR_m13	*MBE_header;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// CMP compress from input buffer to block header
	// (compression algorithms are responsible for filling in: algorithm block flag, total_block_bytes, total_header_bytes, model_region_bytes, & model details)

	// set algorithm block flag
	bh = cps->block_header;
	bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
	bh->block_flags |= CMP_BF_PRED2_ENCODING_m13;
	
	PRED_header = (CMP_PRED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
	n_samps = bh->number_of_samples;
	PRED_header->flags = (ui1) 0;

	// zero or one or samples
	if (n_samps <= 1) {
		bh->model_region_bytes = (ui2) CMP_PRED_MODEL_FIXED_HDR_BYTES_m13;
		if (bh->number_of_samples == 1) {
			*((si4 *) (cps->params.model_region + bh->model_region_bytes)) = cps->input_buffer[0];  // note: no statistics
			bh->model_region_bytes += sizeof(si4);
		}
		PRED_header->n_keysample_bytes = 0;
		PRED_header->derivative_level = 0;
		PRED_header->n_nil_statistics_bins = PRED_header->n_pos_statistics_bins = PRED_header->n_neg_statistics_bins = 0;
		bh->total_header_bytes = (ui4) (cps->params.model_region - (ui1 *) bh) + bh->model_region_bytes;
		bh->total_block_bytes = G_pad_m13((ui1 *) bh, bh->total_header_bytes, 8);
		return_m13(TRUE_m13);
	}
	
	// calculate derivatives
	n_derivs = CMP_differentiate_m13(cps);

	// set up PRED arrays
	count = (ui4 **) cps->params.count;
	cumulative_count = (ui8 **) cps->params.cumulative_count;
	minimum_range = (ui8 **) cps->params.minimum_range;
	sorted_count = (CMP_STATISTICS_BIN_m13 **) cps->params.sorted_count;
	symbol_map = (ui1 **) cps->params.symbol_map;

	// set model parameters
	PRED_header->derivative_level = n_derivs;
	no_zero_counts = FALSE_m13;
	if (cps->direcs.flags & CMP_PRED_FLAGS_NO_ZERO_COUNTS_m13) {
		no_zero_counts = TRUE_m13;
		PRED_header->flags |= CMP_PRED_FLAGS_NO_ZERO_COUNTS_m13;
	}
	overflow_bytes = CMP_get_overflow_bytes_m13(cps, CMP_COMPRESSION_MODE_m13, CMP_PRED_COMPRESSION_m13);

	// generate count & build keysample array
	memset((void *) count[0], 0, CMP_RED_MAX_STATS_BINS_m13 * CMP_PRED_CATS_m13 * sizeof(ui4));
	key_p = (ui1 *) cps->params.keysample_buffer;
	deriv_p = cps->params.derivative_buffer + n_derivs;
	prev_cat = CMP_PRED_NIL_m13;
	n_deriv_samps = n_samps - (ui4) n_derivs;
	for (i = n_deriv_samps; i--;) {
		diff = *deriv_p++;
		if (diff < -127 || diff > 127) {
			ui1_p = (ui1 *) &diff;
			++count[prev_cat][*key_p++ = CMP_UI1_KEYSAMPLE_FLAG_m13];
			prev_cat = CMP_PRED_NEG_m13;
			j = overflow_bytes; do {
				++count[prev_cat][*key_p = *ui1_p++];
				prev_cat = CMP_PRED_CAT_m13(*key_p); ++key_p;  // do not increment within call to CAT
			} while (--j);
		} else {
			++count[prev_cat][*key_p = (ui1) diff];
			prev_cat = CMP_PRED_CAT_m13(*key_p); ++key_p;  // do not increment within call to CAT
		}
	}
	n_keysamp_bytes = (ui4) (key_p - (ui1 *) cps->params.keysample_buffer);
	
	// build sorted_count: interleave
	stats_entries = PRED_header->numbers_of_statistics_bins;
	for (total_stats_entries = i = 0; i < CMP_PRED_CATS_m13; ++i) {
		for (j = stats_entries[i] = 0, k = 255, m = 128; m--; ++j, --k) {
			if (count[i][j]) {
				sorted_count[i][stats_entries[i]].count = count[i][j];
				sorted_count[i][stats_entries[i]++].value = (si1) j;
			}
			if (count[i][k]) {
				sorted_count[i][stats_entries[i]].count = count[i][k];
				sorted_count[i][stats_entries[i]++].value = (si1) k;
			}
		}
		total_stats_entries += stats_entries[i];
	}

	// build sorted_count: bubble sort
	for (i = 0; i < CMP_PRED_CATS_m13; ++i) {
		m = stats_entries[i];
		do {
			for (j = 0, k = 1; k < m; ++k) {
				if (sorted_count[i][k - 1].count < sorted_count[i][k].count) {
					temp_sorted_count = sorted_count[i][k - 1];
					sorted_count[i][k - 1] = sorted_count[i][k];
					sorted_count[i][k] = temp_sorted_count;
					j = k;  // highest swap index
				}
			}
		} while ((m = j) > 1);
	}
	
	// get separate count for each category
	for (i = 0; i < CMP_PRED_CATS_m13; ++i)
		for (cat_total_counts[i] = j = 0; j < stats_entries[i]; ++j)
			cat_total_counts[i] += sorted_count[i][j].count;
	
	// scale count so that each category's total_counts equals (RED_TOTAL_COUNTS - 1)
	for (i = 0; i < CMP_PRED_CATS_m13; ++i) {
		goal_total_counts[i] = CMP_RED_TOTAL_COUNTS_m13 - 1;
		if (no_zero_counts == TRUE_m13)
			goal_total_counts[i] -= (256 - stats_entries[i]);  // reserve one count in each model category for all zero count bins
		// TO DO: decide mapping scheme for unmapped symbols in symbol map
	}

	for (i = 0; i < CMP_PRED_CATS_m13; ++i) {
		if (!stats_entries[i])
			continue;
		for (scaled_total_counts = j = 0; j < stats_entries[i]; ++j) {
			sorted_count[i][j].count = (ui4) (((((ui8) goal_total_counts[i] << 1) * (ui8) sorted_count[i][j].count) + (ui8) cat_total_counts[i]) / ((ui8) cat_total_counts[i] << 1));
			if (sorted_count[i][j].count == 0)
				sorted_count[i][j].count = 1;
			scaled_total_counts += (si8) sorted_count[i][j].count;
		}
		extra_counts = ((si8) goal_total_counts[i] - (si8) scaled_total_counts);
		if (extra_counts > 0) {
			do {
				for (j = 0; (j < stats_entries[i]) && extra_counts; ++j) {
					++sorted_count[i][j].count;
					--extra_counts;
				}
			} while (extra_counts);
		} else if (extra_counts < 0) {
			extra_counts = -extra_counts;
			do {
				for (j = stats_entries[i] - 1; (j >= 0) && extra_counts; --j) {
					if (sorted_count[i][j].count > 1) {
						--sorted_count[i][j].count;
						--extra_counts;
					}
				}
			} while (extra_counts);
		}
	}
	
	// build symbol maps, count arrays & minimum ranges
	for (i = 0; i < CMP_PRED_CATS_m13; ++i) {
		for (cumulative_count[i][0] = j = 0; j < stats_entries[i]; ++j) {
			symbol_map[i][(ui1) sorted_count[i][j].value] = (ui1) j;
			cumulative_count[i][j + 1] = cumulative_count[i][j] + (ui8) (count[i][j] = sorted_count[i][j].count);
			minimum_range[i][j] = CMP_RED_TOTAL_COUNTS_m13 / count[i][j];
			if (CMP_RED_TOTAL_COUNTS_m13 > (count[i][j] * minimum_range[i][j]))
				++minimum_range[i][j];
		}
	}
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->params.model_region + CMP_PRED_MODEL_FIXED_HDR_BYTES_m13);
	for (i = 0; i < n_derivs; ++i)
		*init_val_p++ = cps->params.derivative_buffer[i];

	// write scaled counts & symbols into header
	bin_counts = (ui2 *) init_val_p;
	symbols = (ui1 *) (bin_counts + total_stats_entries);
	for (i = 0; i < CMP_PRED_CATS_m13; ++i) {
		for (j = 0; j < stats_entries[i]; ++j) {
			*bin_counts++ = (ui2) sorted_count[i][j].count;
			*symbols++ = sorted_count[i][j].value;
		}
	}
	
	// fill header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	bh->model_region_bytes = (ui2) (ui2) (symbols - cps->params.model_region);
	bh->total_header_bytes = (ui4) (symbols - (ui1 *) bh);
	PRED_header->n_keysample_bytes = n_keysamp_bytes;
	
	// range encode
	key_p = (ui1 *) cps->params.keysample_buffer;
	comp_p = (ui1 *) bh + bh->total_header_bytes;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m13;
	prev_cat = CMP_PRED_NIL_m13;
	
	for (i = n_keysamp_bytes; i;) {
		for (; range >= minimum_range[prev_cat][bin = symbol_map[prev_cat][*key_p]]; key_p++) {
			high_bound = low_bound + ((range * cumulative_count[prev_cat][bin + 1]) >> 16);
			if (bin)
				low_bound += (range * cumulative_count[prev_cat][bin]) >> 16;
			range = high_bound - low_bound;
			if (!--i)
				break;
			prev_cat = CMP_PRED_CAT_m13(*key_p);
		}
		// full dump
		if (low_bound == high_bound || *low_bound_high_byte_p != *high_bound_high_byte_p || !i) {
			--high_bound;  // ensure goal < high bound on decode
			ui1_p = high_bound_high_byte_p;
			*comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--;
			*comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--;
			range = CMP_RED_MAXIMUM_RANGE_m13;
			low_bound = 0;
		} else {  // partial dump
			do {
				*comp_p++ = *high_bound_high_byte_p;
				low_bound <<= 8;
				high_bound <<= 8;
			} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
			low_bound &= CMP_RED_RANGE_MASK_m13;
			high_bound &= CMP_RED_RANGE_MASK_m13;
			range = high_bound - low_bound;
		}
	}
	
	// finish header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	PRED_total_bytes = (si8) (comp_p - (ui1 *) bh);
	bh->total_block_bytes = (ui4) G_pad_m13((ui1 *) bh, PRED_total_bytes, 8);
	
	// calculate fall through encoding bytes
	if (cps->direcs.flags & CPS_DF_FALL_THROUGH_TO_BEST_ENCODING_m13) {
		for (raw_bits_per_samp = 0, i = (si8) cps->params.maximum_sample_value - (si8) cps->params.minimum_sample_value; i; i >>= 1)
			++raw_bits_per_samp;
		if (n_derivs) {
			for (bits_per_samp = 0, i = (si8) cps->params.maximum_difference_value - (si8) cps->params.minimum_difference_value; i; i >>= 1)
				++bits_per_samp;
			if (raw_bits_per_samp > bits_per_samp)  // this can happen in very noisy data
				use_raw = FALSE_m13;
			else
				use_raw = TRUE_m13;
		} else {
			use_raw = TRUE_m13;
		}
		if (use_raw == TRUE_m13) {
			bits_per_samp = raw_bits_per_samp;
			n_derivs = 0;
			n_deriv_samps = n_samps;
		}
		MBE_data_bits = (si8) n_deriv_samps * (si8) bits_per_samp;
		fall_through_bytes = (MBE_data_bits + 7) >> 3;
		header_bytes = cps->params.model_region - (ui1 *) bh;  // fixed block bytes + variable region before model
		fall_through_bytes += header_bytes + CMP_MBE_MODEL_FIXED_HDR_BYTES_m13 + (n_derivs * 4);
		if ((rem = fall_through_bytes & 7))  // pad bytes
			fall_through_bytes += 8 - rem;
		if (fall_through_bytes < bh->total_block_bytes) {
			bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
			bh->block_flags |= CMP_BF_MBE_ENCODING_m13;
			MBE_header = (CMP_MBE_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
			if (use_raw == TRUE_m13) {
				// cps->input_buffer = unchanged
				MBE_header->minimum_value = cps->params.minimum_sample_value;
				MBE_header->derivative_level = 0;
			} else {
				cps->input_buffer = cps->params.derivative_buffer;
				MBE_header->minimum_value = cps->params.minimum_difference_value;
				MBE_header->derivative_level = n_derivs;
			}
			MBE_header->bits_per_sample = bits_per_samp;
			MBE_header->flags = CMP_MBE_FLAGS_PREPROCESSED_MASK_m13;
			CMP_MBE_encode_m13(cps);
		}
	}

	return_m13(TRUE_m13);
}


CPS_m13	*CMP_realloc_cps_m13(FPS_m13 *fps, ui4 compression_mode, si8 data_samples, ui4 block_samples)
{
	tern			realloc_flag, freed;
	ui4			new_val;
	si4			i;
	si8			new_compressed_bytes, new_keysample_bytes, new_decompressed_samples;
	si8			mem_units_used, mem_units_avail, pad_samples;
	CPS_m13			*cps;
	PROC_GLOBS_m13	*proc_globs;
	CHAN_m13		*chan;
	SESS_m13		*sess;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (fps->uh->type_code != TS_DATA_TYPE_CODE_m13) {
		G_set_error_m13(E_UNKN_m13, "fps must be time series data");
		return_m13(NULL);
	}
	cps = fps->params.cps;
	if (cps == NULL)
		return_m13(NULL);
	
	realloc_flag = FALSE_m13;
	new_compressed_bytes = new_keysample_bytes = new_decompressed_samples = 0;
	
	if (cps->params.allocated_block_samples < block_samples)
		realloc_flag = TRUE_m13;
	
	switch (cps->direcs.flags & CPS_DF_ALGORITHM_MASK_m13) {
		case CPS_DF_RED1_ALGORITHM_m13:
		case CPS_DF_RED2_ALGORITHM_m13:
		case CPS_DF_PRED1_ALGORITHM_m13:
		case CPS_DF_PRED2_ALGORITHM_m13:
		case CPS_DF_VDS_ALGORITHM_m13:
			new_val = CMP_MAX_KEYSAMPLE_BYTES_m13(block_samples);
			if (cps->params.allocated_keysample_bytes < new_val) {
				new_keysample_bytes = new_val;
				realloc_flag = TRUE_m13;
			}
			break;
	}
	
	switch (compression_mode) {
		case CMP_COMPRESSION_MODE_m13:
			if (cps->params.allocated_compressed_bytes) {
				mem_units_used = (ui1 *) cps->block_header - fps->ts_data;
				mem_units_avail = cps->params.allocated_compressed_bytes - mem_units_used;
				new_val = CMP_MAX_COMPRESSED_BYTES_m13(block_samples, 1);
				if (mem_units_avail < new_val) {
					new_compressed_bytes = new_val + mem_units_used;
					realloc_flag = TRUE_m13;
				}
			}
			if (cps->params.allocated_decompressed_samples) {
				mem_units_used = cps->decompressed_ptr - cps->decompressed_data;
				mem_units_avail = cps->params.allocated_decompressed_samples - mem_units_used;
				if (mem_units_avail < block_samples) {
					new_decompressed_samples = mem_units_used + block_samples;
					realloc_flag = TRUE_m13;
				}
			}
			break;
		case CMP_DECOMPRESSION_MODE_m13:
			if (cps->params.allocated_decompressed_samples != CMP_SELF_MANAGED_MEMORY_m13) {
				mem_units_used = cps->decompressed_ptr - cps->decompressed_data;
				mem_units_avail = cps->params.allocated_decompressed_samples - mem_units_used;
				if (mem_units_avail < data_samples) {
					new_decompressed_samples = mem_units_used + data_samples;
					realloc_flag = TRUE_m13;
				}
			}
			break;
		default:
			G_set_error_m13(E_CMP_m13, "invalid compression mode specified\n");
			return_m13(NULL);
	}
	
	if (realloc_flag == FALSE_m13)
		return_m13(cps);

	// reallocate (free & alloc for speed - don't copy data)
	if (new_compressed_bytes) // FPS_reallocate_m13() resets cps->block_header for time series data fps
		FPS_realloc_m13(fps, new_compressed_bytes);
	
	if (new_keysample_bytes) {
		free_m13((void * ) cps->params.keysample_buffer);
		if ((cps->params.keysample_buffer = (si1 *) calloc_m13((size_t) new_keysample_bytes, sizeof(ui1))) == NULL)
			goto CMP_REALLOC_CPS_FAIL_m13;
		cps->params.allocated_keysample_bytes = new_keysample_bytes;
	}
	
	if (new_decompressed_samples) {
		if (cps->decompressed_data)
			free_m13((void * ) cps->params.cache);
		if ((cps->decompressed_data = cps->decompressed_ptr = cps->params.cache = (si4 *) calloc_m13((size_t) new_decompressed_samples, sizeof(si4))) == NULL)
			goto CMP_REALLOC_CPS_FAIL_m13;
		cps->params.allocated_decompressed_samples = new_decompressed_samples;
	}
		
	// reallocate the following if they were previously allocated
	if (cps->params.allocated_block_samples < block_samples) {
		if (cps->params.detrended_buffer) {
			free_m13((void * ) cps->params.detrended_buffer);
			if ((cps->params.detrended_buffer = (si4 *) calloc_m13((size_t) block_samples, sizeof(si4))) == NULL)
				goto CMP_REALLOC_CPS_FAIL_m13;
		}
		if (cps->params.derivative_buffer) {
			free_m13((void * ) cps->params.derivative_buffer);
			if ((cps->params.derivative_buffer = (si4 *) calloc_m13((size_t) block_samples, sizeof(si4))) == NULL)
				goto CMP_REALLOC_CPS_FAIL_m13;
		}
		if (cps->params.scaled_amplitude_buffer) {
			free_m13((void * ) cps->params.scaled_amplitude_buffer);
			if ((cps->params.scaled_amplitude_buffer = (si4 *) calloc_m13((size_t) block_samples, sizeof(si4))) == NULL)
				goto CMP_REALLOC_CPS_FAIL_m13;
		}
		if (cps->params.scaled_frequency_buffer) {
			free_m13((void * ) cps->params.scaled_frequency_buffer);
			if ((cps->params.scaled_frequency_buffer = (si4 *) calloc_m13((size_t) block_samples, sizeof(si4))) == NULL)
				goto CMP_REALLOC_CPS_FAIL_m13;
		}
		if (cps->params.VDS_input_buffers) {
			if (compression_mode == CMP_COMPRESSION_MODE_m13)
				pad_samples = CMP_VDS_LOWPASS_ORDER_m13 * 6;
			else
				pad_samples = CMP_MAK_PAD_SAMPLES_m13;
			CMP_allocate_buffers_m13(cps->params.VDS_input_buffers, CMP_VDS_INPUT_BUFFERS_m13, (si8) (block_samples + pad_samples), sizeof(sf8), FALSE_m13, FALSE_m13);
			CMP_allocate_buffers_m13(cps->params.VDS_output_buffers, CMP_VDS_OUTPUT_BUFFERS_m13, (si8) block_samples, sizeof(sf8), FALSE_m13, FALSE_m13);
		}
		cps->params.allocated_block_samples = block_samples;
	}
	
	return_m13(cps);
	
CMP_REALLOC_CPS_FAIL_m13:

	// try freeing caches on inactive channels
	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	chan = proc_globs->current_session.index_channel;
	freed = FALSE_m13;
	if (chan) {
		sess = (SESS_m13 *) chan;
		if (sess->type_code == SESS_TYPE_CODE_m13) {
			for (i = 0; i < sess->n_ts_chans; ++i) {
				chan = sess->ts_chans[i];
				if (chan->type_code == TS_CHAN_TYPE_CODE_m13)
					if ((chan->flags & LH_CHAN_ACTIVE_m13) == 0)
						if (CMP_free_cps_cache_m13(cps) == TRUE_m13)
							freed = TRUE_m13;
			}
		}
	}

	if (freed == TRUE_m13) {
		cps = CMP_realloc_cps_m13(fps, compression_mode, data_samples, block_samples);
		if (cps)
			return_m13(cps);
	}

	return_m13(NULL);
}


// Algorithm from Niklaus Wirth's book: "Algorithms + data structures = programs".
// Code here is adapted from code by Nicolas Devillard. Public domain.
sf8 CMP_quantval_m13(sf8 *x, si8 len, sf8 quantile, tern preserve_input, sf8 *buff)
{
	tern  free_buff;
	sf8 q, fk, lo_p, lo_v, *lp, *mp, *last_mp, *lo_kp, *hi_kp;
	si8 lo_k;
	register sf8  v, t, *xip, *xjp;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (len == 1)
		return_m13(*x);
	
	free_buff = FALSE_m13;
	if (preserve_input == TRUE_m13) {
		if (buff == NULL) {
			buff = (sf8 *) malloc((size_t) len << 3);
			free_buff = TRUE_m13;
		}
		memcpy((void *) buff, (void *) x, (size_t) (len << 3));
		x = buff;
	}
	
	if (quantile == (sf8)1.0) {
		lo_k = len - 2;
		lo_p = (sf8) 0.0;
	} else {
		fk = quantile * (sf8) (len - 1);
		lo_k = (si8) fk;
		lo_p = (sf8) 1.0 - (fk - (sf8) lo_k);
	}
	
	if (len == 2) {
		if (x[0] <= x[1])
			return_m13((x[0] * lo_p) + (x[1] * (1.0 - lo_p)));
		return_m13((x[1] * lo_p) + (x[0] * (1.0 - lo_p)));
	}
	
	lp = x;
	last_mp = mp = x + len - 1;
	lo_kp = x + lo_k;
	hi_kp = lo_kp + 1;
	while (lp < mp) {
		v = *lo_kp;
		xip = lp;
		xjp = mp;
		do {
			for (; *xip < v; ++xip);
			for (; v < *xjp; --xjp);
			if (xip <= xjp) {
				t = *xip;
				*xip++ = *xjp;
				*xjp-- = t;
			}
		} while (xip <= xjp);
		
		if (xjp < lo_kp)
			lp = xip;
		if (hi_kp < xip)
			last_mp = mp;
		if (lo_kp < xip)
			mp = xjp;
	}
	lo_v = *lo_kp;
	
	lp = lo_kp; mp = last_mp;
	while (lp < mp) {
		v = *hi_kp;
		xip = lp;
		xjp = mp;
		do {
			for (; *xip < v; ++xip);
			for (; v < *xjp; --xjp);
			if (xip <= xjp) {
				t = *xip;
				*xip++ = *xjp;
				*xjp-- = t;
			}
		} while (xip <= xjp);
		
		if (xjp < hi_kp)
			lp = xip;
		if (hi_kp < xip)
			mp = xjp;
	}
	
	q = (lo_v * lo_p) + (*hi_kp * ((sf8) 1.0 - lo_p));
	
	if (free_buff == TRUE_m13)
		free((void *) buff);
	
	return_m13(q);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
ui4	CMP_random_ui4_m13(ui4 *m_w, ui4 *m_z)
{
	ui4	rv;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// see G_expand_password_m13() for initialization & usage
	
	*m_w = (ui4) 0x00004650 * (*m_w & (ui4) 0x0000FFFF) + (*m_w >> (ui4) 0x10);
	if (*m_w == (ui4) 0 || *m_w == (ui4) 0x464FFFFF)  // bad values
		*m_w = (ui4) 0x01020304;  // good value

	*m_z = (ui4) 0x00009069 * (*m_z & (ui4) 0x0000FFFF) + (*m_z >> 0x10);
	if (*m_z == (ui4) 0 || *m_z == (ui4) 0x9068FFFF)  // bad values
		*m_z = (ui4) 0x05060708;  // good value
	
	rv = (*m_z << (ui4) 0x10) + *m_w;
	
	return_m13(rv);
}


tern	CMP_rectify_m13(si4 *input_buffer, si4 *output_buffer, si8 len)
{
	si4  *si4_p1, *si4_p2;
	si8  i;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// rectify data from input_buffer to output_buffer
	// if input_buffer == output_buffer rectification will be done in place
	
	si4_p1 = input_buffer;
	si4_p2 = output_buffer;
	for (i = len; i--; ++si4_p1)
		*si4_p2++ = ABS_m13(*si4_p1);
	
	return_m13(TRUE_m13);
}


tern	CMP_RED1_decode_m13(CPS_m13 *cps)
{
	tern				pos_derivs, no_zero_counts;
	ui1				*comp_p, *low_bound_high_byte_p, *high_bound_high_byte_p, *goal_bound_high_byte_p;
	ui1				*ui1_p1, *ui1_p2, *symbol_map, n_derivs, overflow_bytes;
	si1				*si1_p1, *si1_p2, *key_p;
	ui2				*count;
	ui4				n_samps, n_keysample_bytes;
	si4				*si4_p, overflow_val, sign_bit, sign_bytes, *init_val_p;
	ui8				*minimum_range, *cumulative_count;
	ui8				low_bound, high_bound, prev_high_bound, goal_bound, range;
	si8				i, j, n_stats_entries;
	CMP_FIXED_BH_m13		*bh;
	CMP_RED_MODEL_FIXED_HDR_m13	*RED_header;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// CMP decompress from bh to decompressed_ptr
	bh = cps->block_header;
	n_samps = bh->number_of_samples;
	
	// zero or one or samples
	if (n_samps <= 1) {
		if (bh->number_of_samples == 1)
			cps->decompressed_ptr[0] = *((si4 *) (cps->params.model_region + CMP_RED_MODEL_FIXED_HDR_BYTES_m13));
		cps->params.derivative_level = 0;
		return_m13(TRUE_m13);
	}

	RED_header = (CMP_RED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
	n_derivs = RED_header->derivative_level;
	n_keysample_bytes = RED_header->n_keysample_bytes;
	n_stats_entries = (si8) RED_header->n_statistics_bins;
	
	// set parameters for return
	cps->params.derivative_level = RED_header->derivative_level;
	
	// get block flags
	no_zero_counts = FALSE_m13;
	if (RED_header->flags & CMP_RED_FLAGS_NO_ZERO_COUNTS_m13)
		no_zero_counts = TRUE_m13;
	pos_derivs = FALSE_m13;
	if (RED_header->flags & CMP_RED_FLAGS_POSITIVE_DERIVATIVES_m13)
		pos_derivs = TRUE_m13;
	overflow_bytes = CMP_get_overflow_bytes_m13(cps, CMP_DECOMPRESSION_MODE_m13, CMP_RED_COMPRESSION_m13);
	sign_bit = (ui4) 1 << ((overflow_bytes << 3) - 1);
	if (overflow_bytes == 4)
		sign_bytes = (ui4) 0;
	else  // Windows: shift of 32 bits is equated to shift of 0, so have to do this
		sign_bytes = (ui4) 0xFFFFFFFF << (overflow_bytes << 3);
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->params.model_region + CMP_RED_MODEL_FIXED_HDR_BYTES_m13);
	for (i = 0; i < n_derivs; ++i)
		cps->decompressed_ptr[i] = *init_val_p++;

	// build symbol map, count array, & minimum ranges
	count = (ui2 *) init_val_p;
	symbol_map = (ui1 *) (count + n_stats_entries);
	if (no_zero_counts == TRUE_m13) {  // TO DO: decide mapping scheme for unmapped symbols in symbol map
		for (i = n_stats_entries; i < 256; ++i)  // TO DO: copy count & symbol map to arrays with 256 elements
			count[i] = 1;
	}
	cumulative_count = (ui8 *) cps->params.cumulative_count;
	minimum_range = (ui8 *) cps->params.minimum_range;
	for (cumulative_count[0] = i = 0; i < n_stats_entries; ++i) {
		cumulative_count[i + 1] = cumulative_count[i] + (ui8) count[i];
		minimum_range[i] = CMP_RED_TOTAL_COUNTS_m13 / count[i];
		if (CMP_RED_TOTAL_COUNTS_m13 > (count[i] * minimum_range[i]))
			++minimum_range[i];
	}

	// range decode
	key_p = cps->params.keysample_buffer;
	prev_high_bound = goal_bound = low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m13;
	comp_p = symbol_map + n_stats_entries;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	goal_bound_high_byte_p = ((ui1 *) &goal_bound) + 5;
	ui1_p1 = goal_bound_high_byte_p;
	j = 6; do {
		*ui1_p1-- = *comp_p++;
	} while (--j);
	
	for (i = n_keysample_bytes; i;) {
		for (j = 0; range >= minimum_range[j];) {
			high_bound = low_bound + ((range * cumulative_count[j + 1]) >> 16);
			if (high_bound > goal_bound) {
				range = high_bound - (low_bound = prev_high_bound);
				*key_p = symbol_map[j];
				if (!--i)
					goto RED1_RANGE_DECODE_DONE_m13;
				++key_p;
				j = 0;
			} else {
				prev_high_bound = high_bound;
				++j;
			}
		}
		high_bound = low_bound + range;
		if (*low_bound_high_byte_p != *high_bound_high_byte_p) {
			ui1_p1 = goal_bound_high_byte_p;
			j = 6; do {
				*ui1_p1-- = *comp_p++;
			} while (--j);
			low_bound = 0;
			range = CMP_RED_MAXIMUM_RANGE_m13;
		} else {
			do {
				low_bound <<= 8;
				high_bound <<= 8;
				goal_bound = (goal_bound << 8) | (ui8) *comp_p++;
				range <<= 8;
			} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
			low_bound &= CMP_RED_RANGE_MASK_m13;
			goal_bound &= CMP_RED_RANGE_MASK_m13;
		}
		prev_high_bound = low_bound;
	} RED1_RANGE_DECODE_DONE_m13:
		
	// generate derivatives from keysample data
	si4_p = cps->decompressed_ptr + n_derivs;
	if (pos_derivs == TRUE_m13) {
		ui1_p1 = (ui1 *) cps->params.keysample_buffer;
		for (i = n_samps - n_derivs; i--;) {
			if (*ui1_p1 == CMP_POS_DERIV_KEYSAMPLE_FLAG_m13) {
				++ui1_p1;
				overflow_val = 0;
				ui1_p2 = (ui1 *) &overflow_val;
				j = overflow_bytes; do {
					*ui1_p2++ = *ui1_p1++;
				} while (--j);
				*si4_p++ = overflow_val;
			} else {
				*si4_p++ = (si4) *ui1_p1++;
			}
		}
	} else {
		si1_p1 = (si1 *) cps->params.keysample_buffer;
		for (i = n_samps - n_derivs; i--;) {
			if (*si1_p1 == CMP_SI1_KEYSAMPLE_FLAG_m13) {
				overflow_val = 0;
				++si1_p1;
				si1_p2 = (si1 *) &overflow_val;
				j = overflow_bytes; do {
					*si1_p2++ = *si1_p1++;
				} while (--j);
				if (overflow_val & sign_bit)
					overflow_val |= sign_bytes;
				*si4_p++ = overflow_val;
			} else {
				*si4_p++ = (si4) *si1_p1++;
			}
		}
	}
	
	// integrate derivatives
	CMP_integrate_m13(cps);
	
	return_m13(TRUE_m13);
}


tern  CMP_RED2_decode_m13(CPS_m13 *cps)
{
	tern				pos_derivs, no_zero_counts, multiply_method;
	ui1				*comp_p, *low_bound_high_byte_p, *high_bound_high_byte_p, *goal_bound_high_byte_p;
	ui1				*ui1_p1, *ui1_p2, *symbol_map, n_derivs, overflow_bytes;
	si1				*si1_p1, *si1_p2, *key_p;
	ui2				*count;
	ui4				n_samps, n_keysample_bytes;
	si4				*si4_p, overflow_val, sign_bit, sign_bytes, *init_val_p;
	ui8				*minimum_range, *cumulative_count;
	ui8				low_bound, high_bound, prev_high_bound, goal_bound, range, target_cc;
	si8				i, j, n_stats_entries;
	sf8				average_steps, multiply_time;
	CMP_FIXED_BH_m13		*bh;
	CMP_RED_MODEL_FIXED_HDR_m13	*RED_header;
	HW_PERFORMANCE_SPECS_m13	*perf_specs;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// CMP decompress from bh to decompressed_ptr
	bh = cps->block_header;
	n_samps = bh->number_of_samples;
	
	// zero or one or samples
	if (n_samps <= 1) {
		if (bh->number_of_samples == 1)
			cps->decompressed_ptr[0] = *((si4 *) (cps->params.model_region + CMP_RED_MODEL_FIXED_HDR_BYTES_m13));
		cps->params.derivative_level = 0;
		return_m13(TRUE_m13);
	}

	RED_header = (CMP_RED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
	n_derivs = RED_header->derivative_level;
	n_keysample_bytes = RED_header->n_keysample_bytes;
	n_stats_entries = (si8) RED_header->n_statistics_bins;
	
	// set parameters for return
	cps->params.derivative_level = RED_header->derivative_level;
	
	// get block flags
	no_zero_counts = FALSE_m13;
	if (RED_header->flags & CMP_RED_FLAGS_NO_ZERO_COUNTS_m13)
		no_zero_counts = TRUE_m13;
	pos_derivs = FALSE_m13;
	if (RED_header->flags & CMP_RED_FLAGS_POSITIVE_DERIVATIVES_m13)
		pos_derivs = TRUE_m13;
	overflow_bytes = CMP_get_overflow_bytes_m13(cps, CMP_DECOMPRESSION_MODE_m13, CMP_RED_COMPRESSION_m13);
	sign_bit = (ui4) 1 << ((overflow_bytes << 3) - 1);
	if (overflow_bytes == 4)
		sign_bytes = (ui4) 0;
	else  // Windows: shift of 32 bits is equated to shift of 0, so have to do this
		sign_bytes = (ui4) 0xFFFFFFFF << (overflow_bytes << 3);
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->params.model_region + CMP_RED_MODEL_FIXED_HDR_BYTES_m13);
	for (i = 0; i < n_derivs; ++i)
		cps->decompressed_ptr[i] = *init_val_p++;

	// build symbol map, count array, & minimum ranges
	count = (ui2 *) init_val_p;
	symbol_map = (ui1 *) (count + n_stats_entries);
	if (no_zero_counts == TRUE_m13) {  // TO DO: decide mapping scheme for unmapped symbols in symbol map
		for (i = n_stats_entries; i < 256; ++i)  // TO DO: copy count & symbol map to arrays with 256 elements
			count[i] = 1;
	}
	cumulative_count = (ui8 *) cps->params.cumulative_count;
	minimum_range = (ui8 *) cps->params.minimum_range;
	for (cumulative_count[0] = i = 0; i < n_stats_entries; ++i) {
		cumulative_count[i + 1] = cumulative_count[i] + (ui8) count[i];
		minimum_range[i] = CMP_RED_TOTAL_COUNTS_m13 / count[i];
		if (CMP_RED_TOTAL_COUNTS_m13 > (count[i] * minimum_range[i]))
			++minimum_range[i];
	}

	// determine decompression method
	perf_specs = &globals_m13->tables->HW_params.performance_specs;
	if (perf_specs->integer_multiplications_per_sec == 0.0)
		HW_get_performance_specs_m13(FALSE_m13);
	for (average_steps = (sf8) 0.0, i = 0; i < n_stats_entries; ++i)
		average_steps += (sf8) (i * (si8) count[i]);
	average_steps /= (sf8) CMP_RED_TOTAL_COUNTS_m13;
	multiply_time = average_steps * perf_specs->nsecs_per_integer_multiplication;
	if (multiply_time < perf_specs->nsecs_per_integer_division)
		multiply_method = TRUE_m13;
	else
		multiply_method = FALSE_m13;
	
	// range decode
	key_p = cps->params.keysample_buffer;
	prev_high_bound = goal_bound = low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m13;
	comp_p = symbol_map + n_stats_entries;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	goal_bound_high_byte_p = ((ui1 *) &goal_bound) + 5;
	ui1_p1 = goal_bound_high_byte_p;
	*ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++;
	*ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++;

	if (multiply_method == TRUE_m13) {
		for (j = 0, i = n_keysample_bytes; i;) {
			while (range >= minimum_range[j]) {
				high_bound = low_bound + ((range * cumulative_count[j + 1]) >> 16);
				if (high_bound > goal_bound) {
					*key_p++ = symbol_map[j];
					if (!--i)
						goto RED2_RANGE_DECODE_DONE_m13;
					range = high_bound - (low_bound = prev_high_bound);
					j = 0;
				} else {
					prev_high_bound = high_bound;
					++j;
				}
			}
			high_bound = low_bound + range;
			if (low_bound == high_bound || *low_bound_high_byte_p != *high_bound_high_byte_p) {
				ui1_p1 = goal_bound_high_byte_p;
				*ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++;
				*ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++;
				low_bound = 0;
				range = CMP_RED_MAXIMUM_RANGE_m13;
			} else {
				do {
					low_bound <<= 8;
					high_bound <<= 8;
					goal_bound = (goal_bound << 8) | (ui8) *comp_p++;
				} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
				low_bound &= CMP_RED_RANGE_MASK_m13;
				high_bound &= CMP_RED_RANGE_MASK_m13;
				goal_bound &= CMP_RED_RANGE_MASK_m13;
				range = high_bound - low_bound;
			}
			prev_high_bound = low_bound;
			if (j)
				prev_high_bound += (range * cumulative_count[j]) >> 16;
		}
	} else {  // division method
		for (j = 0, i = n_keysample_bytes; i;) {
			while (range >= minimum_range[j]) {
				high_bound = low_bound + ((range * cumulative_count[j + 1]) >> 16);
				if (high_bound > goal_bound) {
					*key_p++ = symbol_map[j];
					if (!--i)
						goto RED2_RANGE_DECODE_DONE_m13;
					range = high_bound - (low_bound = prev_high_bound);
					target_cc = ((goal_bound - low_bound) << 16) / range;
					for (j = 1; j < n_stats_entries; ++j)
						if (target_cc <= cumulative_count[j])
							break;
					if (--j)
						prev_high_bound += (range * cumulative_count[j]) >> 16;
				} else {
					prev_high_bound = high_bound;
					++j;
				}
			}
			high_bound = low_bound + range;
			if (low_bound == high_bound || *low_bound_high_byte_p != *high_bound_high_byte_p) {
				ui1_p1 = goal_bound_high_byte_p;
				*ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++;
				*ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++; *ui1_p1-- = *comp_p++;
				low_bound = 0;
				range = CMP_RED_MAXIMUM_RANGE_m13;
			} else {
				do {
					low_bound <<= 8;
					high_bound <<= 8;
					goal_bound = (goal_bound << 8) | (ui8) *comp_p++;
				} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
				low_bound &= CMP_RED_RANGE_MASK_m13;
				high_bound &= CMP_RED_RANGE_MASK_m13;
				goal_bound &= CMP_RED_RANGE_MASK_m13;
				range = high_bound - low_bound;
			}
			prev_high_bound = low_bound;
			target_cc = ((goal_bound - low_bound) << 16) / range;
			for (j = 1; j < n_stats_entries; ++j)
				if (target_cc <= cumulative_count[j])
					break;
			if (--j)
				prev_high_bound += (range * cumulative_count[j]) >> 16;
		}
	}
	RED2_RANGE_DECODE_DONE_m13:
		
	// generate derivatives from keysample data
	si4_p = cps->decompressed_ptr + n_derivs;
	if (pos_derivs == TRUE_m13) {
		ui1_p1 = (ui1 *) cps->params.keysample_buffer;
		for (i = n_samps - n_derivs; i--;) {
			if (*ui1_p1 == CMP_POS_DERIV_KEYSAMPLE_FLAG_m13) {
				++ui1_p1;
				overflow_val = 0;
				ui1_p2 = (ui1 *) &overflow_val;
				j = overflow_bytes; do {
					*ui1_p2++ = *ui1_p1++;
				} while (--j);
				*si4_p++ = overflow_val;
			} else {
				*si4_p++ = (si4) *ui1_p1++;
			}
		}
	} else {
		si1_p1 = (si1 *) cps->params.keysample_buffer;
		for (i = n_samps - n_derivs; i--;) {
			if (*si1_p1 == CMP_SI1_KEYSAMPLE_FLAG_m13) {
				overflow_val = 0;
				++si1_p1;
				si1_p2 = (si1 *) &overflow_val;
				j = overflow_bytes; do {
					*si1_p2++ = *si1_p1++;
				} while (--j);
				if (overflow_val & sign_bit)
					overflow_val |= sign_bytes;
				*si4_p++ = overflow_val;
			} else {
				*si4_p++ = (si4) *si1_p1++;
			}
		}
	}
	
	// integrate derivatives
	CMP_integrate_m13(cps);
	
	return_m13(TRUE_m13);
}


tern	CMP_RED1_encode_m13(CPS_m13 *cps)
{
	tern				pos_derivs, no_zero_counts, use_raw;
	ui1				*low_bound_high_byte_p, *high_bound_high_byte_p, *ui1_p, ks_flag;
	ui1				*key_p, n_derivs, *comp_p, *symbols, *symbol_map, overflow_bytes;
	ui2				*bin_counts;
	ui4				*count, n_keysamp_bytes, RED_total_bytes, header_bytes;
	ui4				n_samps, n_deriv_samps, goal_total_counts, bin, fall_through_bytes, rem;
	si4				*deriv_p, *init_val_p, diff, bits_per_samp, raw_bits_per_samp;
	si4				low_d, high_d;
	ui8				*cumulative_count, *minimum_range;
	ui8				total_counts, range, high_bound, low_bound;
	si8				i, j, k, n_stats_entries, extra_counts, scaled_total_counts, MBE_data_bits;
	CMP_STATISTICS_BIN_m13		*sorted_count, temp_sorted_count;
	CMP_FIXED_BH_m13		*bh;
	CMP_RED_MODEL_FIXED_HDR_m13	*RED_header;
	CMP_MBE_MODEL_FIXED_HDR_m13	*MBE_header;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// compress from input_buffer to bh
	
	// set algorithm block flag
	bh = cps->block_header;
	bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
	bh->block_flags |= CMP_BF_RED1_ENCODING_m13;

	RED_header = (CMP_RED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
	n_samps = bh->number_of_samples;
	RED_header->flags = (ui1) 0;

	// zero or one or samples
	if (n_samps <= 1) {
		bh->model_region_bytes = (ui2) CMP_RED_MODEL_FIXED_HDR_BYTES_m13;
		if (bh->number_of_samples == 1) {
			*((si4 *) (cps->params.model_region + bh->model_region_bytes)) = cps->input_buffer[0];  // note: no statistics
			bh->model_region_bytes += sizeof(si4);
		}
		RED_header->n_keysample_bytes = 0;
		RED_header->derivative_level = 0;
		RED_header->n_statistics_bins = 0;
		bh->total_header_bytes = (ui4) (cps->params.model_region - (ui1 *) bh) + bh->model_region_bytes;
		bh->total_block_bytes = G_pad_m13((ui1 *) bh, bh->total_header_bytes, 8);
		return_m13(TRUE_m13);
	}

	// calculate derivatives
	n_derivs = CMP_differentiate_m13(cps);

	// set up RED arrays
	count = (ui4 *) cps->params.count;
	cumulative_count = (ui8 *) cps->params.cumulative_count;
	minimum_range = (ui8 *) cps->params.minimum_range;
	sorted_count = (CMP_STATISTICS_BIN_m13 *) cps->params.sorted_count;
	symbol_map = (ui1 *) cps->params.symbol_map;

	// set model parameters
	RED_header->derivative_level = n_derivs;
	pos_derivs = FALSE_m13;
	if (n_derivs && cps->params.minimum_difference_value > 0) {
		pos_derivs = TRUE_m13;
		RED_header->flags |= CMP_RED_FLAGS_POSITIVE_DERIVATIVES_m13;
	}
	no_zero_counts = FALSE_m13;
	if (cps->direcs.flags & CPS_DF_NO_ZERO_COUNTS_m13) {
		no_zero_counts = TRUE_m13;
		RED_header->flags |= CMP_RED_FLAGS_NO_ZERO_COUNTS_m13;
	}
	overflow_bytes = CMP_get_overflow_bytes_m13(cps, CMP_COMPRESSION_MODE_m13, CMP_RED_COMPRESSION_m13);

	// generate count & build keysample array
	if (pos_derivs == TRUE_m13) {
		low_d = 1; high_d = 255;
		ks_flag = CMP_POS_DERIV_KEYSAMPLE_FLAG_m13;  // == 0 (non-overflow range: 1 to 255)
	} else {
		low_d = -127; high_d = 127;
		ks_flag = CMP_UI1_KEYSAMPLE_FLAG_m13;  // == -128 (non-overflow range: -127 to +127)
	}
	memset((void *) count, 0, CMP_RED_MAX_STATS_BINS_m13 * sizeof(ui4));
	
	key_p = (ui1 *) cps->params.keysample_buffer;
	deriv_p = cps->params.derivative_buffer + n_derivs;
	n_deriv_samps = n_samps - n_derivs;
	for (i = n_deriv_samps; i--;) {
		diff = *deriv_p++;
		if (diff < low_d || diff > high_d) {
			ui1_p = (ui1 *) &diff;
			++count[*key_p++ = ks_flag];
			j = overflow_bytes; do {
				++count[*key_p++ = *ui1_p++];
			} while (--j);
		} else {
			++count[*key_p++ = (ui1) diff];
		}
	}
	n_keysamp_bytes = (ui4) (key_p - (ui1 *) cps->params.keysample_buffer);

	// build sorted_count
	if (pos_derivs == TRUE_m13) {
		for (i = n_stats_entries = 0; i < 256; ++i) {
			if (count[i]) {
				sorted_count[n_stats_entries].count = count[i];
				sorted_count[n_stats_entries++].pos_value = (ui1) i;
			}
		}
	} else {  // pos_derivs == FALSE_m13: interleave (to speed up sort)
		for (i = n_stats_entries = 0, j = 255, k = 128; k--; ++i, --j) {
			if (count[i]) {
				sorted_count[n_stats_entries].count = count[i];
				sorted_count[n_stats_entries++].value = (si1) i;
			}
			if (count[j]) {
				sorted_count[n_stats_entries].count = count[j];
				sorted_count[n_stats_entries++].value = (si1) j;
			}
		}
	}
	RED_header->n_statistics_bins = (ui2) n_stats_entries;
	
	// build sorted_count: bubble sort
	i = n_stats_entries;
	do {
		for (j = 0, k = 1; k < i; ++k) {
			if (sorted_count[k - 1].count < sorted_count[k].count) {
				temp_sorted_count = sorted_count[k - 1];
				sorted_count[k - 1] = sorted_count[k];
				sorted_count[k] = temp_sorted_count;
				j = k;  // highest swap index
			}
		}
	} while ((i = j) > 1);
		
	// scale count so that total counts equals (RED_TOTAL_COUNTS - 1)
	goal_total_counts = CMP_RED_TOTAL_COUNTS_m13 - 1;
	if (no_zero_counts == TRUE_m13) {
		goal_total_counts -= (256 - n_stats_entries); // reserve one count in model for all zero count bins
		// TO DO: decide mapping scheme for unmapped symbols in symbol map
	}
	total_counts = (ui8) n_keysamp_bytes;
	for (scaled_total_counts = i = 0; i < n_stats_entries; ++i) {
		sorted_count[i].count = (ui4) (((((ui8) goal_total_counts << 1) * (ui8) sorted_count[i].count) + total_counts) / (total_counts << 1));
		if (sorted_count[i].count == 0)
			sorted_count[i].count = 1;
		scaled_total_counts += (si8) sorted_count[i].count;
	}
	extra_counts = ((si8) goal_total_counts - (si8) scaled_total_counts);
	if (extra_counts > 0) {
		do {
			for (i = 0; (i < n_stats_entries) && extra_counts; ++i) {
				++sorted_count[i].count;
				--extra_counts;
			}
		} while (extra_counts);
	} else if (extra_counts < 0) {
		extra_counts = -extra_counts;
		do {
			for (i = n_stats_entries - 1; (i >= 0) && extra_counts; --i) {
				if (sorted_count[i].count > 1) {
					--sorted_count[i].count;
					--extra_counts;
				}
			}
		} while (extra_counts);
	}
	
	// build symbol map, count array & minimum ranges
	for (cumulative_count[0] = i = 0; i < n_stats_entries; ++i) {
		symbol_map[sorted_count[i].pos_value] = (ui1) i;
		cumulative_count[i + 1] = cumulative_count[i] + (ui8) (count[i] = sorted_count[i].count);
		minimum_range[i] = CMP_RED_TOTAL_COUNTS_m13 / count[i];
		if (CMP_RED_TOTAL_COUNTS_m13 > (count[i] * minimum_range[i]))
			++minimum_range[i];
	}
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->params.model_region + CMP_RED_MODEL_FIXED_HDR_BYTES_m13);
	for (i = 0; i < n_derivs; ++i)
		*init_val_p++ = cps->params.derivative_buffer[i];

	// write scaled counts & symbols into header
	bin_counts = (ui2 *) init_val_p;
	symbols = (ui1 *) (bin_counts + n_stats_entries);
	for (i = 0; i < n_stats_entries; ++i) {
		*bin_counts++ = (ui2) sorted_count[i].count;
		*symbols++ = sorted_count[i].value;
	}
	
	// fill header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	bh->model_region_bytes = (ui2) (symbols - cps->params.model_region);
	bh->total_header_bytes = (ui4) (symbols - (ui1 *) bh);
	RED_header->n_keysample_bytes = n_keysamp_bytes;

	// range encode
	key_p = (ui1 *) cps->params.keysample_buffer;
	comp_p = symbols;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m13;
	
	for (i = n_keysamp_bytes; i;) {
		for (; range >= minimum_range[bin = symbol_map[*key_p]]; key_p++) {
			high_bound = low_bound + ((range * cumulative_count[bin + 1]) >> 16);
			if (bin)
				low_bound += (range * cumulative_count[bin]) >> 16;
			range = high_bound - low_bound;
			if (!--i)
				break;
		}
		if ((*low_bound_high_byte_p != *high_bound_high_byte_p) || !i) {
			ui1_p = low_bound_high_byte_p;
			j = 6; do {
				*comp_p++ = *ui1_p--;
			} while (--j);
			range = CMP_RED_MAXIMUM_RANGE_m13;
			low_bound = 0;
		} else {
			do {
				*comp_p++ = *low_bound_high_byte_p;
				low_bound <<= 8;
				high_bound <<= 8;
				range <<= 8;
			} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
			low_bound &= CMP_RED_RANGE_MASK_m13;
		}
	}
		
	// finish header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	RED_total_bytes = (si8) (comp_p - (ui1 *) bh);
	bh->total_block_bytes = (ui4) G_pad_m13((ui1 *) bh, RED_total_bytes, 8);
	
	// calculate fall through encoding bytes
	if (cps->direcs.flags & CPS_DF_FALL_THROUGH_TO_BEST_ENCODING_m13) {
		for (raw_bits_per_samp = 0, i = (si8) cps->params.maximum_sample_value - (si8) cps->params.minimum_sample_value; i; i >>= 1)
			++raw_bits_per_samp;
		if (n_derivs) {
			for (bits_per_samp = 0, i = (si8) cps->params.maximum_difference_value - (si8) cps->params.minimum_difference_value; i; i >>= 1)
				++bits_per_samp;
			if (raw_bits_per_samp > bits_per_samp)  // this can happen in very noisy data
				use_raw = FALSE_m13;
			else
				use_raw = TRUE_m13;
		} else {
			use_raw = TRUE_m13;
		}
		if (use_raw == TRUE_m13) {
			bits_per_samp = raw_bits_per_samp;
			n_derivs = 0;
			n_deriv_samps = n_samps;
		}
		MBE_data_bits = (si8) n_deriv_samps * (si8) bits_per_samp;
		fall_through_bytes = (MBE_data_bits + 7) >> 3;
		header_bytes = cps->params.model_region - (ui1 *) bh;  // fixed block bytes + variable region before model
		fall_through_bytes += header_bytes + CMP_MBE_MODEL_FIXED_HDR_BYTES_m13 + (n_derivs * 4);
		if ((rem = fall_through_bytes & 7))  // pad bytes
			fall_through_bytes += 8 - rem;
		if (fall_through_bytes < bh->total_block_bytes) {
			bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
			bh->block_flags |= CMP_BF_MBE_ENCODING_m13;
			MBE_header = (CMP_MBE_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
			if (use_raw == TRUE_m13) {
				// cps->input_buffer = unchanged
				MBE_header->minimum_value = cps->params.minimum_sample_value;
				MBE_header->derivative_level = 0;
			} else {
				cps->input_buffer = cps->params.derivative_buffer;
				MBE_header->minimum_value = cps->params.minimum_difference_value;
				MBE_header->derivative_level = n_derivs;
			}
			MBE_header->bits_per_sample = bits_per_samp;
			MBE_header->flags = CMP_MBE_FLAGS_PREPROCESSED_MASK_m13;
			CMP_MBE_encode_m13(cps);
			return_m13(TRUE_m13);
		}
	}
		
	return_m13(TRUE_m13);
}


tern  CMP_RED2_encode_m13(CPS_m13 *cps)
{
	tern				pos_derivs, no_zero_counts, use_raw;
	ui1				*low_bound_high_byte_p, *high_bound_high_byte_p, *ui1_p, ks_flag;
	ui1				*key_p, n_derivs, *comp_p, *symbols, *symbol_map, overflow_bytes;
	ui2				*bin_counts;
	ui4				*count, n_keysamp_bytes, RED_total_bytes, header_bytes;
	ui4				n_samps, n_deriv_samps, goal_total_counts, bin, fall_through_bytes, rem;
	si4				*deriv_p, *init_val_p, diff, bits_per_samp, raw_bits_per_samp;
	si4				low_d, high_d;
	ui8				*cumulative_count, *minimum_range;
	ui8				total_counts, range, high_bound, low_bound;
	si8				i, j, k, n_stats_entries, extra_counts, scaled_total_counts, MBE_data_bits;
	CMP_STATISTICS_BIN_m13		*sorted_count, temp_sorted_count;
	CMP_FIXED_BH_m13		*bh;
	CMP_RED_MODEL_FIXED_HDR_m13	*RED_header;
	CMP_MBE_MODEL_FIXED_HDR_m13	*MBE_header;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// compress from input_buffer to bh
	
	// set algorithm block flag
	bh = cps->block_header;
	bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
	bh->block_flags |= CMP_BF_RED2_ENCODING_m13;

	RED_header = (CMP_RED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
	n_samps = bh->number_of_samples;
	RED_header->flags = (ui1) 0;

	// zero or one or samples
	if (n_samps <= 1) {
		bh->model_region_bytes = (ui2) CMP_RED_MODEL_FIXED_HDR_BYTES_m13;
		if (bh->number_of_samples == 1) {
			*((si4 *) (cps->params.model_region + bh->model_region_bytes)) = cps->input_buffer[0];  // note: no statistics
			bh->model_region_bytes += sizeof(si4);
		}
		RED_header->n_keysample_bytes = 0;
		RED_header->derivative_level = 0;
		RED_header->n_statistics_bins = 0;
		bh->total_header_bytes = (ui4) (cps->params.model_region - (ui1 *) bh) + bh->model_region_bytes;
		bh->total_block_bytes = G_pad_m13((ui1 *) bh, bh->total_header_bytes, 8);
		return_m13(TRUE_m13);
	}

	// calculate derivatives
	n_derivs = CMP_differentiate_m13(cps);

	// set up RED arrays
	count = (ui4 *) cps->params.count;
	cumulative_count = (ui8 *) cps->params.cumulative_count;
	minimum_range = (ui8 *) cps->params.minimum_range;
	sorted_count = (CMP_STATISTICS_BIN_m13 *) cps->params.sorted_count;
	symbol_map = (ui1 *) cps->params.symbol_map;

	// set model parameters
	RED_header->derivative_level = n_derivs;
	pos_derivs = FALSE_m13;
	if (n_derivs && cps->params.minimum_difference_value > 0) {
		pos_derivs = TRUE_m13;
		RED_header->flags |= CMP_RED_FLAGS_POSITIVE_DERIVATIVES_m13;
	}
	no_zero_counts = FALSE_m13;
	if (cps->direcs.flags & CPS_DF_NO_ZERO_COUNTS_m13) {
		no_zero_counts = TRUE_m13;
		RED_header->flags |= CMP_RED_FLAGS_NO_ZERO_COUNTS_m13;
	}
	overflow_bytes = CMP_get_overflow_bytes_m13(cps, CMP_COMPRESSION_MODE_m13, CMP_RED_COMPRESSION_m13);

	// generate count & build keysample array
	if (pos_derivs == TRUE_m13) {
		low_d = 1; high_d = 255;
		ks_flag = CMP_POS_DERIV_KEYSAMPLE_FLAG_m13;  // == 0 (non-overflow range: 1 to 255)
	} else {
		low_d = -127; high_d = 127;
		ks_flag = CMP_UI1_KEYSAMPLE_FLAG_m13;  // == -128 (non-overflow range: -127 to +127)
	}
	memset((void *) count, 0, CMP_RED_MAX_STATS_BINS_m13 * sizeof(ui4));
	
	key_p = (ui1 *) cps->params.keysample_buffer;
	deriv_p = cps->params.derivative_buffer + n_derivs;
	n_deriv_samps = n_samps - n_derivs;
	for (i = n_deriv_samps; i--;) {
		diff = *deriv_p++;
		if (diff < low_d || diff > high_d) {
			ui1_p = (ui1 *) &diff;
			++count[*key_p++ = ks_flag];
			j = overflow_bytes; do {
				++count[*key_p++ = *ui1_p++];
			} while (--j);
		} else {
			++count[*key_p++ = (ui1) diff];
		}
	}
	n_keysamp_bytes = (ui4) (key_p - (ui1 *) cps->params.keysample_buffer);

	// build sorted_count
	if (pos_derivs == TRUE_m13) {
		for (i = n_stats_entries = 0; i < 256; ++i) {
			if (count[i]) {
				sorted_count[n_stats_entries].count = count[i];
				sorted_count[n_stats_entries++].pos_value = (ui1) i;
			}
		}
	} else {  // pos_derivs == FALSE_m13: interleave (to speed up sort)
		for (i = n_stats_entries = 0, j = 255, k = 128; k--; ++i, --j) {
			if (count[i]) {
				sorted_count[n_stats_entries].count = count[i];
				sorted_count[n_stats_entries++].value = (si1) i;
			}
			if (count[j]) {
				sorted_count[n_stats_entries].count = count[j];
				sorted_count[n_stats_entries++].value = (si1) j;
			}
		}
	}
	RED_header->n_statistics_bins = (ui2) n_stats_entries;
	
	// build sorted_count: bubble sort
	i = n_stats_entries;
	do {
		for (j = 0, k = 1; k < i; ++k) {
			if (sorted_count[k - 1].count < sorted_count[k].count) {
				temp_sorted_count = sorted_count[k - 1];
				sorted_count[k - 1] = sorted_count[k];
				sorted_count[k] = temp_sorted_count;
				j = k;  // highest swap index
			}
		}
	} while ((i = j) > 1);
		
	// scale count so that total counts equals (RED_TOTAL_COUNTS - 1)
	goal_total_counts = CMP_RED_TOTAL_COUNTS_m13 - 1;
	if (no_zero_counts == TRUE_m13) {
		goal_total_counts -= (256 - n_stats_entries); // reserve one count in model for all zero count bins
		// TO DO: decide mapping scheme for unmapped symbols in symbol map
	}
	total_counts = (ui8) n_keysamp_bytes;
	for (scaled_total_counts = i = 0; i < n_stats_entries; ++i) {
		sorted_count[i].count = (ui4) (((((ui8) goal_total_counts << 1) * (ui8) sorted_count[i].count) + total_counts) / (total_counts << 1));
		if (sorted_count[i].count == 0)
			sorted_count[i].count = 1;
		scaled_total_counts += (si8) sorted_count[i].count;
	}
	extra_counts = ((si8) goal_total_counts - (si8) scaled_total_counts);
	if (extra_counts > 0) {
		do {
			for (i = 0; (i < n_stats_entries) && extra_counts; ++i) {
				++sorted_count[i].count;
				--extra_counts;
			}
		} while (extra_counts);
	} else if (extra_counts < 0) {
		extra_counts = -extra_counts;
		do {
			for (i = n_stats_entries - 1; (i >= 0) && extra_counts; --i) {
				if (sorted_count[i].count > 1) {
					--sorted_count[i].count;
					--extra_counts;
				}
			}
		} while (extra_counts);
	}
	
	// build symbol map, count array & minimum ranges
	for (cumulative_count[0] = i = 0; i < n_stats_entries; ++i) {
		symbol_map[sorted_count[i].pos_value] = (ui1) i;
		cumulative_count[i + 1] = cumulative_count[i] + (ui8) (count[i] = sorted_count[i].count);
		minimum_range[i] = CMP_RED_TOTAL_COUNTS_m13 / count[i];
		if (CMP_RED_TOTAL_COUNTS_m13 > (count[i] * minimum_range[i]))
			++minimum_range[i];
	}
	
	// copy initial derivative values to output buffer
	init_val_p = (si4 *) (cps->params.model_region + CMP_RED_MODEL_FIXED_HDR_BYTES_m13);
	for (i = 0; i < n_derivs; ++i)
		*init_val_p++ = cps->params.derivative_buffer[i];

	// write scaled counts & symbols into header
	bin_counts = (ui2 *) init_val_p;
	symbols = (ui1 *) (bin_counts + n_stats_entries);
	for (i = 0; i < n_stats_entries; ++i) {
		*bin_counts++ = (ui2) sorted_count[i].count;
		*symbols++ = sorted_count[i].value;
	}
	
	// fill header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	bh->model_region_bytes = (ui2) (symbols - cps->params.model_region);
	bh->total_header_bytes = (ui4) (symbols - (ui1 *) bh);
	RED_header->n_keysample_bytes = n_keysamp_bytes;

	// range encode
	key_p = (ui1 *) cps->params.keysample_buffer;
	comp_p = symbols;
	low_bound_high_byte_p = ((ui1 *) &low_bound) + 5;
	high_bound_high_byte_p = ((ui1 *) &high_bound) + 5;
	low_bound = 0;
	range = CMP_RED_MAXIMUM_RANGE_m13;
	
	for (i = n_keysamp_bytes; i;) {
		for (; range >= minimum_range[bin = symbol_map[*key_p]]; key_p++) {
			high_bound = low_bound + ((range * cumulative_count[bin + 1]) >> 16);
			if (bin)
				low_bound += (range * cumulative_count[bin]) >> 16;
			range = high_bound - low_bound;
			if (!--i)
				break;
		}
		// full dump
		if (low_bound == high_bound || *low_bound_high_byte_p != *high_bound_high_byte_p || !i) {
			--high_bound;  // ensure goal < high bound on decode
			ui1_p = high_bound_high_byte_p;
			*comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--;
			*comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--; *comp_p++ = *ui1_p--;
			range = CMP_RED_MAXIMUM_RANGE_m13;
			low_bound = 0;
		} else {  // partial dump
			do {
				*comp_p++ = *high_bound_high_byte_p;
				low_bound <<= 8;
				high_bound <<= 8;
			} while (*low_bound_high_byte_p == *high_bound_high_byte_p);
			low_bound &= CMP_RED_RANGE_MASK_m13;
			high_bound &= CMP_RED_RANGE_MASK_m13;
			range = high_bound - low_bound;
		}
	}
		
	// finish header (compression algorithms are responsible for filling in: algorithm block flag, total_bytes, header_bytes, model_region_bytes, & model details)
	RED_total_bytes = (si8) (comp_p - (ui1 *) bh);
	bh->total_block_bytes = (ui4) G_pad_m13((ui1 *) bh, RED_total_bytes, 8);
	
	// calculate fall through encoding bytes
	if (cps->direcs.flags & CPS_DF_FALL_THROUGH_TO_BEST_ENCODING_m13) {
		for (raw_bits_per_samp = 0, i = (si8) cps->params.maximum_sample_value - (si8) cps->params.minimum_sample_value; i; i >>= 1)
			++raw_bits_per_samp;
		if (n_derivs) {
			for (bits_per_samp = 0, i = (si8) cps->params.maximum_difference_value - (si8) cps->params.minimum_difference_value; i; i >>= 1)
				++bits_per_samp;
			if (raw_bits_per_samp > bits_per_samp)  // this can happen in very noisy data
				use_raw = FALSE_m13;
			else
				use_raw = TRUE_m13;
		} else {
			use_raw = TRUE_m13;
		}
		if (use_raw == TRUE_m13) {
			bits_per_samp = raw_bits_per_samp;
			n_derivs = 0;
			n_deriv_samps = n_samps;
		}
		MBE_data_bits = (si8) n_deriv_samps * (si8) bits_per_samp;
		fall_through_bytes = (MBE_data_bits + 7) >> 3;
		header_bytes = cps->params.model_region - (ui1 *) bh;  // fixed block bytes + variable region before model
		fall_through_bytes += header_bytes + CMP_MBE_MODEL_FIXED_HDR_BYTES_m13 + (n_derivs * 4);
		if ((rem = fall_through_bytes & 7))  // pad bytes
			fall_through_bytes += 8 - rem;
		if (fall_through_bytes < bh->total_block_bytes) {
			bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
			bh->block_flags |= CMP_BF_MBE_ENCODING_m13;
			MBE_header = (CMP_MBE_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
			if (use_raw == TRUE_m13) {
				// cps->input_buffer = unchanged
				MBE_header->minimum_value = cps->params.minimum_sample_value;
				MBE_header->derivative_level = 0;
			} else {
				cps->input_buffer = cps->params.derivative_buffer;
				MBE_header->minimum_value = cps->params.minimum_difference_value;
				MBE_header->derivative_level = n_derivs;
			}
			MBE_header->bits_per_sample = bits_per_samp;
			MBE_header->flags = CMP_MBE_FLAGS_PREPROCESSED_MASK_m13;
			CMP_MBE_encode_m13(cps);
		}
	}
		
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern  CMP_retrend_si4_m13(si4 *in_y, si4 *out_y, si8 len, sf8 m, sf8 b)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// retrend data from input_buffer to output_buffer
	// if input_buffer == output_buffer retrending data will be done in place
	
	while (len--)
		*out_y++ = CMP_round_si4_m13((sf8) *in_y++ + (b += m));
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern  CMP_retrend_2_sf8_m13(sf8 *in_x, sf8 *in_y, sf8 *out_y, si8 len, sf8 m, sf8 b)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// retrend data from in_y to out_y at specific x locations
	// if input_buffer == output_buffer retrending data will be done in place
	
	while (len--)
		*out_y++ = CMP_round_si4_m13((sf8) *in_y++ + (m * (sf8) *in_x++) + b);
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si2  CMP_round_si2_m13(sf8 val)
{
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (isnan(val))
		return_m13(NAN_SI2_m13);
	
	if (val >= (sf8) 0.0) {
		if ((val += (sf8) 0.5) > (sf8) POS_INF_SI2_m13)
			return_m13(POS_INF_SI2_m13);
	} else {
		if ((val -= (sf8) 0.5) < (sf8) NEG_INF_SI2_m13)
			return_m13(NEG_INF_SI2_m13);
	}
	
	return_m13((si2) val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4  CMP_round_si4_m13(sf8 val)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (isnan(val))
		return_m13(NAN_SI4_m13);
	
	if (val >= (sf8) 0.0) {
		if ((val += (sf8) 0.5) > (sf8) POS_INF_SI4_m13)
			return_m13(POS_INF_SI4_m13);
	} else {
		if ((val -= (sf8) 0.5) < (sf8) NEG_INF_SI4_m13)
			return_m13(NEG_INF_SI4_m13);
	}
	
	return_m13((si4) val);
}


tern  CMP_scale_amplitude_si4_m13(si4 *input_buffer, si4 *output_buffer, si8 len, sf8 scale_factor, CPS_m13 *cps)
{
	si4	*si4_p1, *si4_p2;
	sf4	sf4_scale;
	sf8	inv_scale_factor;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// scale from input_buffer to output_buffer
	// if input_buffer == output_buffer scaling will be done in place
	
	// store scale in block parameter region
	// NOTE: block parameter region must be setup first
	if (cps) {
		// demote precision
		sf4_scale = (sf4) scale_factor;
		// store
		*((sf4 *) cps->block_parameters + cps->params.block_parameter_map[CMP_PF_AMPLITUDE_SCALE_IDX_m13]) = scale_factor;
		// promote back to sf8 (having only sf4 precision)
		scale_factor = (sf8) sf4_scale;
	}
	
	si4_p1 = input_buffer;
	si4_p2 = output_buffer;
	inv_scale_factor = (sf8) 1.0 / scale_factor;  // multiplication much faster than division on some systems
	while (len--)
		*si4_p2++ = CMP_round_si4_m13((sf8) *si4_p1++ * inv_scale_factor);

	return_m13(TRUE_m13);
}


tern  CMP_scale_frequency_si4_m13(si4 *input_buffer, si4 *output_buffer, si8 len, sf8 scale_factor, CPS_m13 *cps)
{
	sf4	sf4_scale;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// scale from input_buffer to output_buffer
	// if input_buffer == output_buffer scaling will be done in place
	
	// store scale in block parameter region
	// NOTE: block parameter region must be setup first
	if (cps) {
		// demote precision
		sf4_scale = (sf4) scale_factor;
		// store
		*((sf4 *) cps->block_parameters + cps->params.block_parameter_map[CMP_PF_FREQUENCY_SCALE_IDX_m13]) = scale_factor;
		// promote back to sf8 (having only sf4 precision)
		scale_factor = (sf8) sf4_scale;
	}
	
	// actual frequency scaling not written yet
	
	return_m13(TRUE_m13);
}


tern  CMP_set_variable_region_m13(CPS_m13 *cps)
{
	ui1			*var_reg_ptr;
	CMP_FIXED_BH_m13	*bh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	bh = cps->block_header;
	
	// reset variable region parameters
	bh->number_of_records = cps->params.user_number_of_records;
	bh->record_region_bytes = cps->params.user_record_region_bytes;
	bh->parameter_flags = cps->params.user_parameter_flags;
	bh->protected_region_bytes = cps->params.protected_region_bytes;
	bh->discretionary_region_bytes = cps->params.user_discretionary_region_bytes;
	
	// records region
	var_reg_ptr = (ui1 *) bh + CMP_BLOCK_FIXED_HDR_BYTES_m13;  // pointer to start of variable region
	cps->block_records = var_reg_ptr;
	var_reg_ptr += bh->record_region_bytes;
	
	// parameter region
	cps->block_parameters = (ui4 *) var_reg_ptr;
	
	// set library parameter flags
	if (cps->direcs.flags & CPS_DF_DETREND_DATA_m13)
		bh->parameter_flags |= (CMP_PF_INTERCEPT_m13 | CMP_PF_GRADIENT_m13);
	else
		bh->parameter_flags &= ~(CMP_PF_INTERCEPT_m13 | CMP_PF_GRADIENT_m13);
	
	if (cps->direcs.flags & CPS_DF_SET_AMPLITUDE_SCALE_m13 || cps->direcs.flags & CPS_DF_FIND_AMPLITUDE_SCALE_m13)
		bh->parameter_flags |= CMP_PF_AMPLITUDE_SCALE_m13;
	else
		bh->parameter_flags &= ~CMP_PF_AMPLITUDE_SCALE_m13;
	
	if (cps->direcs.flags & CPS_DF_SET_FREQUENCY_SCALE_m13 || cps->direcs.flags & CPS_DF_FIND_FREQUENCY_SCALE_m13)
		bh->parameter_flags |= CMP_PF_FREQUENCY_SCALE_m13;
	else
		bh->parameter_flags &= ~CMP_PF_FREQUENCY_SCALE_m13;
	
	if (cps->direcs.flags & CPS_DF_INCLUDE_NOISE_SCORES_m13)
		bh->parameter_flags |= CMP_PF_NOISE_SCORES_m13;
	else
		bh->parameter_flags &= ~CMP_PF_NOISE_SCORES_m13;
	
	CMP_generate_parameter_map_m13(cps);
	var_reg_ptr += bh->parameter_region_bytes;
	
	// protected region
	// cps->protected_region = var_reg_ptr;
	var_reg_ptr += bh->protected_region_bytes;
	
	// discretionary region
	cps->discretionary_region = var_reg_ptr;
	var_reg_ptr += bh->discretionary_region_bytes;
	
	// variable region bytes
	cps->params.variable_region_bytes = CMP_VARIABLE_REGION_BYTES_v1_m13(bh);
	
	// model region
	// NOTE: model region is NOT considered part of the variable region, but compression algorithms rely on this pointer being set
	// NOTE: model region bytes is set by compression function
	cps->params.model_region = var_reg_ptr;
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern  CMP_sf8_to_si2_m13(sf8 *sf8_arr, si2 *si2_arr, si8 len, tern round)
{
	sf8	val, pos_inf, neg_inf;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (round == FALSE_m13) {
		while (len--)
			*si2_arr++ = (si2) *sf8_arr++;
		
		return_m13(TRUE_m13);
	}
	
	pos_inf = (sf8) POS_INF_SI2_m13;
	neg_inf = (sf8) NEG_INF_SI2_m13;

	while (len--) {
		val = *sf8_arr++;
		if (isnan(val)) {
			*si2_arr++ = NAN_SI2_m13;
			continue;
		}
		if (val >= (sf8) 0.0) {
			if ((val += (sf8) 0.5) > pos_inf) {
				*si2_arr++ = POS_INF_SI2_m13;
				continue;
			}
		} else if ((val -= (sf8) 0.5) < neg_inf) {
			*si2_arr++ = NEG_INF_SI2_m13;
			continue;
		}
		*si2_arr++ = (si2) val;
	}
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern  CMP_sf8_to_sf4_m13(sf8 *sf8_arr, sf4 *sf4_arr, si8 len, tern round)
{
	sf8	val, pos_inf, neg_inf;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (round == FALSE_m13) {
		while (len--)
			*sf4_arr++ = (sf4) *sf8_arr++;
		
		return_m13(TRUE_m13);
	}

	pos_inf = (sf8) FLT_MAX;
	neg_inf = (sf8) -FLT_MAX;
	
	while (len--) {
		val = *sf8_arr++;
		if (isnan(val)) {
			*sf4_arr++ = NAN;
			continue;
		}
		if (val >= (sf8) 0.0) {
			if ((val += (sf8) 0.5) > pos_inf) {
				*sf4_arr++ = (sf4) pos_inf;
				continue;
			}
		} else if ((val -= (sf8) 0.5) < neg_inf) {
			*sf4_arr++ = (sf4) neg_inf;
			continue;
		}
		*sf4_arr++ = (sf4) val;
	}
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern  CMP_sf8_to_si4_m13(sf8 *sf8_arr, si4 *si4_arr, si8 len, tern round)
{
	sf8	val, pos_inf, neg_inf;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (round == FALSE_m13) {
		while (len--)
			*si4_arr++ = (si4) *sf8_arr++;
		
		return_m13(TRUE_m13);
	}

	pos_inf = (sf8) POS_INF_SI4_m13;
	neg_inf = (sf8) NEG_INF_SI4_m13;

	while (len--) {
		val = *sf8_arr++;
		if (isnan(val)) {
			*si4_arr++ = NAN_SI4_m13;
			continue;
		}
		if (val >= (sf8) 0.0) {
			if ((val += (sf8) 0.5) > pos_inf) {
				*si4_arr++ = POS_INF_SI4_m13;
				continue;
			}
		} else if ((val -= (sf8) 0.5) < neg_inf) {
			*si4_arr++ = NEG_INF_SI4_m13;
			continue;
		}
		*si4_arr++ = (si4) val;
	}
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern  CMP_sf8_to_si4_and_scale_m13(sf8 *sf8_arr, si4 *si4_arr, si8 len, sf8 scale)
{
	sf8	val, pos_inf, neg_inf;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	pos_inf = (sf8) POS_INF_SI4_m13;
	neg_inf = (sf8) NEG_INF_SI4_m13;
	
	while (len--) {
		val = *sf8_arr++ * scale;
		if (isnan(val)) {
			*si4_arr++ = NAN_SI4_m13;
			continue;
		}
		if (val >= (sf8) 0.0) {
			if ((val += (sf8) 0.5) > pos_inf) {
				*si4_arr++ = POS_INF_SI4_m13;
				continue;
			}
		} else if ((val -= (sf8) 0.5) < neg_inf) {
			*si4_arr++ = NEG_INF_SI4_m13;
			continue;
		}
		*si4_arr++ = (si4) val;
	}
	
	return_m13(TRUE_m13);
}


tern  CMP_show_block_header_m13(LH_m13 *lh, CMP_FIXED_BH_m13 *bh)
{
	si1	hex_str[HEX_STR_BYTES_m13(UID_BYTES_m13, 0)], time_str[TIME_STRING_BYTES_m13], bin_str[BIN_STR_BYTES_m13(sizeof(ui4), 3)];
	ui4	i, mask;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	printf_m13("--------------- CMP Fixed Block Header - START ---------------\n");
	STR_hex_m13(hex_str, (ui1 *) &bh->block_start_UID, UID_BYTES_m13, NULL, TRUE_m13);
	printf_m13("Block Start UID: 0x%s\n", hex_str);
	if (bh->block_CRC == CRC_NO_ENTRY_m13)
		printf_m13("Block CRC: no entry\n");
	else {
		STR_hex_m13(hex_str, (ui1 *) &bh->block_CRC, CRC_BYTES_m13, NULL, TRUE_m13);
		printf_m13("Block CRC: 0x%s\n", hex_str);
	}
	printf_m13("Block Flag Bits: ");
	for (i = 0, mask = 1; i < 32; ++i, mask <<= 1) {
		if (bh->block_flags & mask)
			printf_m13("%d ", i);
	}
	STR_bin_m13(bin_str, (void *) &bh->block_flags, sizeof(ui4), " - ", TRUE_m13);
	printf_m13(" (value: %s)\n", bin_str);
	if (bh->start_time == UUTC_NO_ENTRY_m13)
		printf_m13("Start Time: no entry\n");
	else {
		if (lh) {
			STR_time_m13(lh, bh->start_time, time_str, TRUE_m13, FALSE_m13, FALSE_m13);
			printf_m13("Start Time: %ld (¬µUTC), %s\n", bh->start_time, time_str);
		} else {
			printf_m13("Start Time: %ld (oUTC), %s\n", bh->start_time);
		}
	}
	printf_m13("Acquisition Channel Number: %u\n", bh->acquisition_channel_number);
	printf_m13("Total Block Bytes: %u\n", bh->total_block_bytes);
	printf_m13("Number of Samples: %u\n", bh->number_of_samples);
	printf_m13("Number of Records: %hu\n", bh->number_of_records);
	printf_m13("Record Region Bytes: %hu\n", bh->record_region_bytes);
	printf_m13("Parameter Flag Bits: ");
	for (i = 0, mask = 1; i < 32; ++i, mask <<= 1) {
		if (bh->parameter_flags & mask)
			printf_m13("%d ", i);
	}
	STR_bin_m13(bin_str, (void *) &bh->parameter_flags, sizeof(ui4), " - ", TRUE_m13);
	printf_m13(" (value: %s)\n", bin_str);
	printf_m13("Parameter Region Bytes: %hu\n", bh->parameter_region_bytes);
	printf_m13("Protected Region Bytes: %hu\n", bh->protected_region_bytes);
	printf_m13("Discretionary Region Bytes: %hu\n", bh->discretionary_region_bytes);
	printf_m13("Model Region Bytes: %hu\n", bh->model_region_bytes);
	printf_m13("Total Header Bytes: %u\n", bh->total_header_bytes);
	printf_m13("---------------- CMP Fixed Block Header - END ----------------\n\n");
	
	return_m13(TRUE_m13);
}


tern  CMP_show_block_model_m13(CPS_m13 *cps, tern recursed_call)
{
	ui1				*VDS_model_region;
	si1				*symbols, *time_alg, *amp_alg, *indent, bin_str[BIN_STR_BYTES_m13(sizeof(ui4), 3)];
	ui2 				*counts;
	ui4				algorithm, mask, amp_alg_flag, time_alg_flag;
	si4				*derivs;
	si8 				i, total_counts;
	CMP_FIXED_BH_m13		*bh;
	CMP_RED_MODEL_FIXED_HDR_m13	*RED_header;
	CMP_PRED_MODEL_FIXED_HDR_m13	*PRED_header;
	CMP_MBE_MODEL_FIXED_HDR_m13	*MBE_header;
	CMP_VDS_MODEL_FIXED_HDR_m13	*VDS_header;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	bh = cps->block_header;

	// "recursed_call" argument is used internally for VDS models => call with FALSE_m13
	if (recursed_call == TRUE_m13) {
		indent = "\t";
	} else {
		indent = "";
		printf_m13("------------------- CMP Block Model - START ------------------\n");
	}
	switch (bh->block_flags & CMP_BF_ALGORITHMS_MASK_m13) {
		case CMP_BF_RED1_ENCODING_m13:
		case CMP_BF_RED2_ENCODING_m13:
			RED_header = (CMP_RED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
			if (bh->block_flags & CMP_BF_RED1_ENCODING_m13)
				printf_m13("%sModel: Range Encoded Derivatives 1 (RED1)\n", indent);
			else
				printf_m13("%sModel: Range Encoded Derivatives 2 (RED2)\n", indent);
			printf_m13("%sNumber of Keysample Bytes: %u\n", indent, RED_header->n_keysample_bytes);
			printf_m13("%sDerivative Level: %hhu\n", indent, RED_header->derivative_level);
			if (RED_header->derivative_level > 0) {
				derivs = (si4 *) (cps->params.model_region + CMP_RED_MODEL_FIXED_HDR_BYTES_m13);
				if (RED_header->derivative_level == 1) {
					printf_m13("%sDerivative Initial Value: %d", indent, derivs[0]);
				} else {
					printf_m13("%sDerivative Initial Values: %d", indent, derivs[0]);
					for (i = 1; i < RED_header->derivative_level; ++i)
						printf_m13(", %d", derivs[i]);
				}
				printf_m13("\n");
			}
			printf_m13("%sRED Model Flag Bits: ", indent);
			for (i = 0, mask = 1; i < 16; ++i, mask <<= 1) {
				if (RED_header->flags & mask)
					printf_m13("%d ", i);
			}
			STR_bin_m13(bin_str, (void *) &RED_header->flags, sizeof(ui2), " - ", TRUE_m13);
			printf_m13(" (value: %s)\n", bin_str);
			printf_m13("\n%sNumber of Statistics Bins: %hu  (counts are scaled)\n", indent, RED_header->n_statistics_bins);
			// end fixed RED model fields
			counts = (ui2 *) (cps->params.model_region + CMP_RED_MODEL_FIXED_HDR_BYTES_m13 + (RED_header->derivative_level * 4));
			symbols = (si1 *) (counts + RED_header->n_statistics_bins);
			for (i = 0; i < RED_header->n_statistics_bins; ++i)
				printf_m13("%sbin %03d:  symbol: %hhd\tcount: %hu\n", indent, i, *symbols++, *counts++);
			break;
			
		case CMP_BF_PRED1_ENCODING_m13:
		case CMP_BF_PRED2_ENCODING_m13:
			PRED_header = (CMP_PRED_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
			if (bh->block_flags & CMP_BF_PRED1_ENCODING_m13)
				printf_m13("%sModel: Predictive Range Encoded Derivatives 1 (PRED1)\n", indent);
			else
				printf_m13("%sModel: Predictive Range Encoded Derivatives 2 (PRED2)\n", indent);
			printf_m13("%sNumber of Keysample Bytes: %u\n", indent, PRED_header->n_keysample_bytes);
			printf_m13("%sDerivative Level: %hhu\n", indent, PRED_header->derivative_level);
			if (PRED_header->derivative_level > 0) {
				derivs = (si4 *) (cps->params.model_region + CMP_PRED_MODEL_FIXED_HDR_BYTES_m13);
				if (PRED_header->derivative_level == 1) {
					printf_m13("%sDerivative Initial Value: %d", indent, derivs[0]);
				} else {
					printf_m13("%sDerivative Initial Values: %d", indent, derivs[0]);
					for (i = 1; i < PRED_header->derivative_level; ++i)
						printf_m13(", %d", derivs[i]);
				}
				printf_m13("\n");
			}
			printf_m13("%sPRED Model Flag Bits: ", indent);
			for (i = 0, mask = 1; i < 16; ++i, mask <<= 1) {
				if (PRED_header->flags & mask)
					printf_m13("%d ", i);
			}
			STR_bin_m13(bin_str, (void *) &PRED_header->flags, sizeof(ui2), " - ", TRUE_m13);
			printf_m13(" (value: %s)\n", bin_str);
			// end fixed PRED model fields
			counts = (ui2 *) (cps->params.model_region + CMP_PRED_MODEL_FIXED_HDR_BYTES_m13 + (PRED_header->derivative_level * 4));
			total_counts = (si8) (PRED_header->n_nil_statistics_bins + PRED_header->n_pos_statistics_bins + PRED_header->n_neg_statistics_bins);
			symbols = (si1 *) (counts + total_counts);
			printf_m13("\n%sNumber of NIL Statistics Bins: %hu  (counts are scaled)\n", indent, PRED_header->n_nil_statistics_bins);
			for (i = 0; i < PRED_header->n_nil_statistics_bins; ++i)
				printf_m13("%sbin %03d:  symbol: %hhd\tcount: %hu\n", indent, i, *symbols++, *counts++);
			printf_m13("\n%sNumber of POS Statistics Bins: %hu  (counts are scaled)\n", indent, PRED_header->n_pos_statistics_bins);
			for (i = 0; i < PRED_header->n_pos_statistics_bins; ++i)
				printf_m13("%sbin %03d:  symbol: %hhd\tcount: %hu\n", indent, i, *symbols++, *counts++);
			printf_m13("\n%sNumber of NEG Statistics Bins: %hu  (counts are scaled)\n", indent, PRED_header->n_neg_statistics_bins);
			for (i = 0; i < PRED_header->n_neg_statistics_bins; ++i)
				printf_m13("%sbin %03d:  symbol: %hhd\tcount: %hu\n", indent, i, *symbols++, *counts++);
			break;
			
		case CMP_BF_MBE_ENCODING_m13:
			MBE_header = (CMP_MBE_MODEL_FIXED_HDR_m13 *) cps->params.model_region;
			printf_m13("%sModel: Minimal Bit Encoding (MBE)\n", indent);
			printf_m13("%sMinimum Value: %d\n", indent, MBE_header->minimum_value);
			printf_m13("%sBits per Sample: %hhu\n", indent, MBE_header->bits_per_sample);
			printf_m13("%sDerivative Level: %hhu\n", indent, MBE_header->derivative_level);
			if (MBE_header->derivative_level > 0) {
				derivs = (si4 *) (cps->params.model_region + CMP_MBE_MODEL_FIXED_HDR_BYTES_m13);
				printf_m13("%sDerivative Initial Values: %d", indent, derivs[0]);
				for (i = 1; i < MBE_header->derivative_level; ++i)
					printf_m13(", %d", derivs[i]);
				printf_m13("\n");
			}
			printf_m13("%sMBE Model Flag Bits: ", indent);
			for (i = 0, mask = 1; i < 16; ++i, mask <<= 1) {
				if (MBE_header->flags & mask)
					printf_m13("%d ", i);
			}
			STR_bin_m13(bin_str, (void *) &MBE_header->flags, sizeof(ui2), " - ", TRUE_m13);
			printf_m13(" (value: %s)\n", bin_str);
			break;
			
		case CMP_BF_VDS_ENCODING_m13:
			VDS_model_region = cps->params.model_region;
			VDS_header = (CMP_VDS_MODEL_FIXED_HDR_m13 *) VDS_model_region;
			algorithm = VDS_header->flags & CMP_VDS_AMPLITUDE_ALGORITHMS_MASK_m13;
			switch (algorithm) {
				case CMP_VDS_FLAGS_AMPLITUDE_RED1_m13:
				case CMP_VDS_FLAGS_AMPLITUDE_RED2_m13:
					amp_alg = "RED";
					amp_alg_flag = CMP_BF_RED2_ENCODING_m13;  // either fine, headers same
					break;
				case CMP_VDS_FLAGS_AMPLITUDE_PRED1_m13:
				case CMP_VDS_FLAGS_AMPLITUDE_PRED2_m13:
					amp_alg = "PRED";
					amp_alg_flag = CMP_BF_PRED2_ENCODING_m13;  // either fine, headers same
					break;
				case CMP_VDS_FLAGS_AMPLITUDE_MBE_m13:
					amp_alg = "MBE";
					amp_alg_flag = CMP_BF_MBE_ENCODING_m13;
					break;
			}
			algorithm = VDS_header->flags & CMP_VDS_TIME_ALGORITHMS_MASK_m13;
			switch (algorithm) {
				case CMP_VDS_FLAGS_TIME_RED1_m13:
				case CMP_VDS_FLAGS_TIME_RED2_m13:
					time_alg = "RED";
					time_alg_flag = CMP_BF_RED2_ENCODING_m13;  // either fine, headers same
					break;
				case CMP_VDS_FLAGS_TIME_PRED1_m13:
				case CMP_VDS_FLAGS_TIME_PRED2_m13:
					time_alg = "PRED";
					time_alg_flag = CMP_BF_PRED2_ENCODING_m13;  // either fine, headers same
					break;
				case CMP_VDS_FLAGS_TIME_MBE_m13:
					time_alg = "MBE";
					time_alg_flag = CMP_BF_MBE_ENCODING_m13;
					break;
			}
			printf_m13("Model: Vectorized Data Stream (VDS)\n");
			printf_m13("Number of VDS Samples: %u\n", VDS_header->n_VDS_samples);
			printf_m13("Amplitude Block Total Bytes: %u\n", VDS_header->amplitude_block_total_bytes);
			printf_m13("Amplitude Block Model: %s\n", amp_alg);
			printf_m13("Amplitude Block Model Bytes: %hu\n", VDS_header->amplitude_block_model_bytes);
			printf_m13("Time Block Model: %s\n", time_alg);
			printf_m13("Time Block Model Bytes: %hu\n", VDS_header->time_block_model_bytes);
			printf_m13("VDS Model Flag Bits: ");
			for (i = 0, mask = 1; i < 32; ++i, mask <<= 1) {
				if (VDS_header->flags & mask)
					printf_m13("%d ", i);
			}
			STR_bin_m13(bin_str, (void *) &VDS_header->flags, sizeof(ui4), " - ", TRUE_m13);
			printf_m13(" (value: %s)\n", bin_str);
			// show amplitude model
			printf_m13("\t============== VDS Amplitude Block Model - START =============\n");
			cps->params.model_region = VDS_model_region + CMP_VDS_MODEL_FIXED_HDR_BYTES_m13;
			bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
			bh->block_flags |= amp_alg_flag;
			CMP_show_block_model_m13(cps, TRUE_m13);
			printf_m13("\t=============== VDS Amplitude Block Model - END ==============\n");
			// show time model
			printf_m13("\t================ VDS Time Block Model - START ================\n");
			cps->params.model_region += VDS_header->amplitude_block_total_bytes;
			bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
			bh->block_flags |= time_alg_flag;
			CMP_show_block_model_m13(cps, TRUE_m13);
			printf_m13("\t================= VDS Time Block Model - END =================\n");
			// restore base VDS model
			cps->params.model_region = VDS_model_region;
			bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
			bh->block_flags |= CMP_BF_VDS_ENCODING_m13;
			break;
		default:
			G_set_error_m13(E_CMP_m13, "unrecognized model (%u)", bh->block_flags & CMP_BF_ALGORITHMS_MASK_m13);
			break;
	}
	if (recursed_call != TRUE_m13)
		printf_m13("-------------------- CMP Block Model - END -------------------\n\n");
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern  CMP_si4_to_sf8_m13(si4 *si4_arr, sf8 *sf8_arr, si8 len)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	while (len--)
		*sf8_arr++ = (sf8) *si4_arr++;
	
	return_m13(TRUE_m13);
}


// Code adapted from Numerical Recipes in C. Public domain.
sf8  *CMP_spline_interp_sf8_m13(sf8 *in_arr, si8 in_arr_len, sf8 *out_arr, si8 out_arr_len, CMP_BUFFERS_m13 *spline_bufs)
{
	tern	free_buffers;
	si8	i, lo_pt, hi_pt;
	sf8	*prev_y, *y, *next_y, *ty, out_x, out_x_inc, h, a, b;
	sf8	*d2y, *td2y, *prev_d2y, *next_d2y, *tu, *u, *prev_u, p, *tout;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// this version assumes input array is uniformly sampled; output array is uniformly sampled at new frequency
	// if out_arr is null, it is allocated and returned
	// if passing, allocate 3 buffers with (in_arr_len + CMP_SPLINE_TAIL_LEN_m13) elements of type sf8
	
	if (out_arr == NULL)
		out_arr = (sf8 *) malloc_m13((size_t) (out_arr_len << 3));

	if (in_arr_len <= 1) {
		if (in_arr_len == 0)
			return_m13(out_arr);
		for (i = 0; i < out_arr_len; ++i)
			out_arr[i] = in_arr[0];
		return_m13(out_arr);
	}
	if (in_arr_len == out_arr_len) {
		memcpy(out_arr, in_arr, in_arr_len << 3);
		return_m13(out_arr);
	}
	
	free_buffers = FALSE_m13;
	if (spline_bufs == NULL)
		free_buffers = TRUE_m13;
	spline_bufs = CMP_allocate_buffers_m13(spline_bufs, 3, in_arr_len + CMP_SPLINE_TAIL_LEN_m13, sizeof(sf8), FALSE_m13, FALSE_m13);  // also reallocates
	y = (sf8 *) spline_bufs->buffer[0];
	d2y = (sf8 *) spline_bufs->buffer[1];
	u = (sf8 *) spline_bufs->buffer[2];
	memcpy((void *) y, (void *) in_arr, (size_t) (in_arr_len << 3));

	for (h = 2.0 * y[in_arr_len - 1], i = 0; i < CMP_SPLINE_TAIL_LEN_m13; ++i)
		y[in_arr_len + i] = h - y[in_arr_len - 2 - i];
	
	// spline
	d2y[0] = u[0] = 0.0;
	prev_d2y = d2y;
	td2y = prev_d2y + 1;
	prev_y = y;
	ty = prev_y + 1;
	next_y = ty + 1;
	prev_u = u;
	tu = prev_u + 1;
	
	in_arr_len += CMP_SPLINE_TAIL_LEN_m13;
	for (i = in_arr_len; i--;) {
		p = (*prev_d2y++ * 0.5) + 2.0;
		*td2y++ = -0.5 / p;
		*tu = (*next_y++ - *ty) - (*ty - *prev_y++);
		++ty;
		*tu = (3.0 * *tu - 0.5 * *prev_u++) / p;
		++tu;
	}
	*td2y = 0.0;
	
	next_d2y = d2y + in_arr_len - 1;
	td2y = next_d2y - 1;
	tu = u + in_arr_len - 2;
	for (i = in_arr_len - 1; i--;) {
		*td2y = (*td2y * *next_d2y--) + *tu--;
		--td2y;
	}
	in_arr_len -= CMP_SPLINE_TAIL_LEN_m13;
	
	// splint
	out_x_inc = (sf8) in_arr_len / (sf8) out_arr_len;
	out_x = -out_x_inc;
	tout = out_arr;
	for (i = out_arr_len; i--;) {
		hi_pt = (lo_pt = (si4) (out_x += out_x_inc)) + 1;
		b = 1.0 - (a = (sf8) hi_pt - out_x);
		*tout++ = (a * y[lo_pt] + b * y[hi_pt] + ((a * a * a - a) * d2y[lo_pt] + (b * b * b - b) * d2y[hi_pt]) / 6.0);
	}
	
	// clean up
	if (free_buffers == TRUE_m13)
		CMP_free_buffers_m13(&spline_bufs);
	
	return_m13(out_arr);
}


// Code adapted from Numerical Recipes in C. Public domain.
si4  *CMP_spline_interp_si4_m13(si4 *in_arr, si8 in_arr_len, si4 *out_arr, si8 out_arr_len, CMP_BUFFERS_m13 *spline_bufs)
{
	tern	free_buffers;
	si4	*tin, *tout;
	si8	i, lo_pt, hi_pt;
	sf8	*prev_y, *y, *next_y, *ty, out_x, out_x_inc, h, a, b;
	sf8	*d2y, *td2y, *prev_d2y, *next_d2y, *tu, *u, *prev_u, p;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// this version assumes input array is uniformly sampled; output array is uniformly sampled at new frequency
	// if out_arr is null, it is allocated and returned
	
	if (out_arr == NULL)
		out_arr = (si4 *) malloc_m13((size_t) (out_arr_len << 2));

	if (in_arr_len <= 1) {
		if (in_arr_len == 0)
			return_m13(out_arr);
		for (i = 0; i < out_arr_len; ++i)
			out_arr[i] = in_arr[0];
		return_m13(out_arr);
	}
	if (in_arr_len == out_arr_len) {
		memcpy(out_arr, in_arr, in_arr_len << 2);
		return_m13(out_arr);
	}

	free_buffers = FALSE_m13;
	if (spline_bufs == NULL)
		free_buffers = TRUE_m13;
	spline_bufs = CMP_allocate_buffers_m13(spline_bufs, 3, in_arr_len, sizeof(sf8), FALSE_m13, FALSE_m13);  // also reallocates
	y = (sf8 *) spline_bufs->buffer[0];
	d2y = (sf8 *) spline_bufs->buffer[1];
	u = (sf8 *) spline_bufs->buffer[2];
	memcpy((void *) y, (void *) in_arr, (size_t) (in_arr_len << 3));

	for (tin = in_arr, ty = y, i = in_arr_len; i--;)
		*ty++ = (sf8) *tin++;
	
	for (h = 2.0 * y[in_arr_len - 1], i = 0; i < CMP_SPLINE_TAIL_LEN_m13; ++i)
		y[in_arr_len + i] = h - y[in_arr_len - 2 - i];
	
	// spline
	d2y[0] = u[0] = 0.0;
	prev_d2y = d2y;
	td2y = prev_d2y + 1;
	prev_y = y;
	ty = prev_y + 1;
	next_y = ty + 1;
	prev_u = u;
	tu = prev_u + 1;
	
	in_arr_len += CMP_SPLINE_TAIL_LEN_m13;
	for (i = 1; i <= in_arr_len - 2; i++) {
		p = (*prev_d2y++ * 0.5) + 2.0;
		*td2y++ = -0.5 / p;
		*tu = (*next_y++ - *ty) - (*ty - *prev_y++);
		++ty;
		*tu = (3.0 * *tu - 0.5 * *prev_u++) / p;
		++tu;
	}
	*td2y = 0.0;
	
	next_d2y = d2y + in_arr_len - 1;
	td2y = next_d2y - 1;
	tu = u + in_arr_len - 2;
	for (i = in_arr_len - 2; i >= 0; i--) {
		*td2y = (*td2y * *next_d2y--) + *tu--;
		--td2y;
	}
	in_arr_len -= CMP_SPLINE_TAIL_LEN_m13;
	
	// splint
	out_x_inc = (sf8) in_arr_len / (sf8) out_arr_len;
	out_x = -out_x_inc;
	tout = out_arr;
	for (i = 0; i < out_arr_len; i++) {
		hi_pt = (lo_pt = (si4) (out_x += out_x_inc)) + 1;
		b = 1.0 - (a = (sf8) hi_pt - out_x);
		*tout++ = (si4) ((a * y[lo_pt] + b * y[hi_pt] + ((a * a * a - a) * d2y[lo_pt] + (b * b * b - b) * d2y[hi_pt]) / 6.0) + 0.5);
	}
	
	// clean up
	if (free_buffers == TRUE_m13)
		CMP_free_buffers_m13(&spline_bufs);

	return_m13(out_arr);
}


sf8	CMP_splope_m13(sf8 *xa, sf8 *ya, sf8 *d2y, sf8 x, si8 lo_pt, si8 hi_pt)
{
	sf8	a, b, c, d, e, f, g, h;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// slope of splined array (characterized by d2y), at point x
	// useful for many things, but in particular finding precise locations of critical points in splined data

	a = xa[lo_pt];
	b = xa[hi_pt];
	c = ya[lo_pt];
	d = ya[hi_pt];
	e = d2y[lo_pt];
	f = d2y[hi_pt];
	g = b - a;

	h = (x * (e * b - f * a) + d - c) / g;
	h += (x * x * (f - e) + f * a * a - e * b * b) / (2.0 * g);
	h += g * (e - f) / 6.0;

	return_m13(h);
}


sf8	CMP_trace_amplitude_m13(sf8 *y, sf8 *buffer, si8 len, tern detrend)
{
	tern	free_buffer;
	si8		i;
	sf8		amp, *sf8_p1, *sf8_p2;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns the median of absolute value of the trace (after detrending, if requested)
	// if y == buffer: destructive to y
	// if buffer == NULL: buffer allocated & freed
	
	// allocate
	if (buffer == NULL) {
		buffer = (sf8 *) malloc((size_t) (len << 3));
		free_buffer = TRUE_m13;
	} else {
		free_buffer = FALSE_m13;
	}
	
	// detrend
	if (detrend == TRUE_m13) {
		CMP_detrend_sf8_m13(y, buffer, len);
		y = buffer;
	}
	
	// get absolute value trace
	sf8_p1 = buffer;
	sf8_p2 = y;
	for (i = len; i--;) {
		if (*sf8_p2 < (sf8) 0.0)
			*sf8_p1++ = -(*sf8_p2++);
		else
			*sf8_p1++ = *sf8_p2++;
	}
	
	// get amplitude
	amp = CMP_quantval_m13(buffer, len, 0.5, FALSE_m13, NULL);
	
	// clean up
	if (free_buffer == TRUE_m13)
		free((void *) buffer);
	
	return_m13(amp);
}


si8 CMP_ts_sort_m13(si4 *x, si8 len, CMP_NODE_m13 *nodes, CMP_NODE_m13 *head, CMP_NODE_m13 *tail, si4 return_sorted_ts, ...)
{
	tern  		free_nodes;
	CMP_NODE_m13	*last_node, *next_node, *prev_node, *np;
	si8 		i, j, n_nodes;
	sf8 		new_val;
	si4		*sorted_x;
	va_list 	v_args;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// setup
	if (nodes == NULL) {
		nodes = (CMP_NODE_m13 *) calloc_m13((size_t)len, sizeof(CMP_NODE_m13));
		free_nodes = TRUE_m13;
	} else {
		free_nodes = FALSE_m13;
	}
	
	np = nodes;
	head->next = tail;
	head->val = (si4) NAN_SI4_m13;  // This is 0x80000000 because NEG_INF_SI4_m13 (0x80000001) could theoretically fail
	tail->val = (si4) POS_INF_SI4_m13;  // This is 0x7FFFFFFF
	tail->prev = head;
	
	// build linked list
	for (last_node = head, i = len; i--;) {
		new_val = *x++;
		if (new_val == last_node->val) {
			++last_node->count;
			continue;
		} else if (new_val > last_node->val) {
			for (next_node = last_node->next; new_val > next_node->val; next_node = next_node->next);
			if (new_val == next_node->val) {
				++next_node->count;
				last_node = next_node;
				continue;
			}
			prev_node = next_node->prev;
		} else {  // new_val < last_node->val
			for (prev_node = last_node->prev; new_val < prev_node->val; prev_node = prev_node->prev);
			if (new_val == prev_node->val) {
				++prev_node->count;
				last_node = prev_node;
				continue;
			}
			next_node = prev_node->next;
		}
		np->next = next_node;
		np->prev = prev_node;
		np->val = new_val;
		np->count = 1;
		last_node = prev_node->next = next_node->prev = np++;
	}
	n_nodes = np - nodes;
	
	// expand nodes back to sorted array, if requested
	if (return_sorted_ts == TRUE_m13) {
		va_start(v_args, return_sorted_ts);
		sorted_x = va_arg(v_args, si4 *);
		va_end(v_args);
		if (sorted_x == NULL) {
			G_warning_message_m13("%s(): passed sorted array pointer is NULL\n", __FUNCTION__);
		} else {
			for (i = n_nodes, np = head->next; i--; np = np->next)
				for (j = np->count; j--;)
					*sorted_x++ = np->val;
		}
	}
	
	if (free_nodes == TRUE_m13)
		free_m13((void *) nodes);
	
	return_m13(n_nodes);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	CMP_unlock_buffers_m13(CMP_BUFFERS_m13 *buffers)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// unlock
	if (buffers->locked != FALSE_m13) {
		buffers->locked = munlock_m13((void *) buffers->buffer, buffers->total_allocated_bytes);
		buffers->locked = FALSE_m13;
	}

	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern  CMP_unscale_amplitude_si4_m13(si4 *input_buffer, si4 *output_buffer, si8 len, sf8 scale_factor)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// unscale from input_buffer to output_buffer
	// if input_buffer == output_buffer unscaling will be done in place
	
	while (len--)
		*output_buffer++ = CMP_round_si4_m13((sf8) *input_buffer++ * scale_factor);

	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern  CMP_unscale_amplitude_sf8_m13(sf8 *input_buffer, sf8 *output_buffer, si8 len, sf8 scale_factor)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// unscale from input_buffer to output_buffer
	// if input_buffer == output_buffer unscaling will be done in place
	
	while (len--)
		*output_buffer++ = *input_buffer++ * scale_factor;

	return_m13(TRUE_m13);
}


tern  CMP_unscale_frequency_si4_m13(si4 *input_buffer, si4 *output_buffer, si8 len, sf8 scale_factor)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// not written yet
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
CMP_FIXED_BH_m13	*CMP_update_CPS_pointers_m13(FPS_m13 *fps, ui1 flags)
{
	CMP_FIXED_BH_m13	*bh;
	CPS_m13			*cps;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (fps->uh->type_code != TS_DATA_TYPE_CODE_m13) {
		G_set_error_m13(E_UNKN_m13, "fps must be time series data");
		return_m13(NULL);
	}
	cps = fps->params.cps;
	
	bh = cps->block_header;
	if (flags & CMP_UPDATE_ORIGINAL_PTR_m13)
		cps->original_ptr += bh->number_of_samples;
	else if (flags & CMP_RESET_ORIGINAL_PTR_m13)
		cps->original_ptr = cps->original_data;
	
	if (flags & CMP_UPDATE_BLOCK_HDR_PTR_m13)
		cps->block_header = (CMP_FIXED_BH_m13 *) ((ui1 *) cps->block_header + bh->total_block_bytes);
	else if (flags & CMP_RESET_BLOCK_HDR_PTR_m13)
		cps->block_header = (CMP_FIXED_BH_m13 *) fps->data_ptrs;
	
	if (flags & CMP_UPDATE_DECOMPRESSED_PTR_m13)
		cps->decompressed_ptr += bh->number_of_samples;
	else if (flags & CMP_RESET_DECOMPRESSED_PTR_m13)
		cps->decompressed_ptr = cps->decompressed_data = cps->params.cache;

	return_m13(cps->block_header);
}


tern	CMP_VDS_decode_m13(CPS_m13 *cps)
{
	ui1				*VDS_model_region;
	ui4				VDS_total_header_bytes, n_samples, algorithm;
	ui4				start_sample;
	si4				*si4_p;
	sf4				*sf4_p;
	si8				i, *si8_p, offset, *in_x;
	sf8				amplitude_scale, *in_y, *out_x, *out_y, *sf8_p, val;
	void				*saved_cumulative_count_p, *saved_minimum_range_p;
	CMP_FIXED_BH_m13		*bh;
	CMP_BUFFERS_m13			*VDS_in_bufs, *VDS_out_bufs;
	CMP_VDS_MODEL_FIXED_HDR_m13	*VDS_header;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// save values set by CMP_decode_m13();
	bh = cps->block_header;
	n_samples = (si8) bh->number_of_samples;
	VDS_model_region = cps->params.model_region;  // set by CMP_decode_m13()
	VDS_header = (CMP_VDS_MODEL_FIXED_HDR_m13 *) VDS_model_region;
	VDS_total_header_bytes = bh->total_header_bytes;
	
	// decode amplitude data
	bh->number_of_samples = VDS_header->n_VDS_samples;
	cps->params.model_region = (ui1 *) bh + (si8) VDS_total_header_bytes;
	bh->total_header_bytes = VDS_total_header_bytes + VDS_header->amplitude_block_model_bytes;
	bh->model_region_bytes = VDS_header->amplitude_block_model_bytes;
	algorithm = VDS_header->flags & CMP_VDS_AMPLITUDE_ALGORITHMS_MASK_m13;
	switch (algorithm) {
		case CMP_VDS_FLAGS_AMPLITUDE_RED1_m13:  // older VDS used RED for amplitudes - this should go away eventually
		case CMP_VDS_FLAGS_AMPLITUDE_RED2_m13:
			// change PRED buffers to RED
			saved_cumulative_count_p = cps->params.cumulative_count;
			saved_minimum_range_p = cps->params.minimum_range;
			cps->params.cumulative_count = *((void **) saved_cumulative_count_p);
			cps->params.minimum_range = *((void **) saved_minimum_range_p);
			// decode
			if (algorithm == CMP_VDS_FLAGS_AMPLITUDE_RED1_m13)
				CMP_RED1_decode_m13(cps);
			else
				CMP_RED2_decode_m13(cps);
			// restore PRED buffers
			cps->params.cumulative_count = saved_cumulative_count_p;
			cps->params.minimum_range = saved_minimum_range_p;
			break;
		case CMP_VDS_FLAGS_AMPLITUDE_PRED1_m13:
			CMP_PRED1_decode_m13(cps);
			break;
		case CMP_VDS_FLAGS_AMPLITUDE_PRED2_m13:
			CMP_PRED2_decode_m13(cps);
			break;
		case CMP_VDS_FLAGS_AMPLITUDE_MBE_m13:
			CMP_MBE_decode_m13(cps);
			break;
	}

	// set up VDS buffers
	cps->params.VDS_input_buffers = CMP_allocate_buffers_m13(cps->params.VDS_input_buffers, CMP_VDS_INPUT_BUFFERS_m13, (si8) (VDS_header->n_VDS_samples + CMP_MAK_PAD_SAMPLES_m13), sizeof(sf8), FALSE_m13, FALSE_m13);
	cps->params.VDS_output_buffers = CMP_allocate_buffers_m13(cps->params.VDS_output_buffers, CMP_VDS_OUTPUT_BUFFERS_m13, (si8) n_samples, sizeof(sf8), FALSE_m13, FALSE_m13);
	VDS_in_bufs = cps->params.VDS_input_buffers;
	in_y = (sf8 *) VDS_in_bufs->buffer[CMP_MAK_IN_Y_BUF];  // location specified by mak_interp()
	in_x = (si8 *) VDS_in_bufs->buffer[CMP_MAK_IN_X_BUF];  // location specified by mak_interp()
	VDS_out_bufs = cps->params.VDS_output_buffers;
	out_y = (sf8 *) VDS_out_bufs->buffer[CMP_MAK_OUT_Y_BUF];  // location specified by mak_interp()
	out_x = (sf8 *) VDS_out_bufs->buffer[CMP_MAK_OUT_X_BUF];  // location specified by mak_interp()

	// copy amplitudes to sf8 buffer
	CMP_si4_to_sf8_m13(cps->decompressed_ptr, in_y, (si8) VDS_header->n_VDS_samples);

	// apply amplitude scaling (if applied) here (b/c fewer samples)
	if (bh->parameter_flags & CMP_PF_AMPLITUDE_SCALE_m13) {
		sf4_p = (sf4 *) cps->block_parameters;
		offset = (si8) cps->params.block_parameter_map[CMP_PF_AMPLITUDE_SCALE_IDX_m13];
		amplitude_scale = (sf8) *(sf4_p + offset);
		CMP_unscale_amplitude_sf8_m13(in_y, in_y, (si8) VDS_header->n_VDS_samples, amplitude_scale);
	}

	// decode time data
	bh->total_header_bytes = VDS_total_header_bytes + VDS_header->amplitude_block_total_bytes + VDS_header->time_block_model_bytes;
	cps->params.model_region = (ui1 *) bh + (si8) VDS_total_header_bytes + (si8) VDS_header->amplitude_block_total_bytes;
	bh->model_region_bytes = VDS_header->time_block_model_bytes;
	algorithm = VDS_header->flags & CMP_VDS_TIME_ALGORITHMS_MASK_m13;
	switch (algorithm) {
		case CMP_VDS_FLAGS_TIME_RED1_m13:
		case CMP_VDS_FLAGS_TIME_RED2_m13:
			// change PRED amplitude buffers to RED time buffers
			saved_cumulative_count_p = cps->params.cumulative_count;
			saved_minimum_range_p = cps->params.minimum_range;
			cps->params.cumulative_count = *((void **) saved_cumulative_count_p);
			cps->params.minimum_range = *((void **) saved_minimum_range_p);
			if (algorithm == CMP_VDS_FLAGS_TIME_RED1_m13)
				CMP_RED1_decode_m13(cps);
			else
				CMP_RED2_decode_m13(cps);
			// restore PRED amplitude buffers
			cps->params.cumulative_count = saved_cumulative_count_p;
			cps->params.minimum_range = saved_minimum_range_p;
			break;
		case CMP_VDS_FLAGS_TIME_MBE_m13:
			CMP_MBE_decode_m13(cps);
			break;
	}
	
	// copy times to si8 buffer
	si8_p = in_x;
	si4_p = cps->decompressed_ptr;
	for (i = VDS_header->n_VDS_samples; i--;)
		*si8_p++ = (si8) *si4_p++;

	// reconstruct trace
	if (cps->direcs.flags & CPS_DF_CPS_CACHING_m13) {
		start_sample = 0;
	} else {
		start_sample = cps->params.block_start_index;
		if (cps->params.block_end_index != 0xFFFFFFFF)
			n_samples = cps->params.block_end_index + 1;
		n_samples -= start_sample;
	}
	
	// build out array & interpolate
	sf8_p = out_x;  // create mak out_x array
	val = (sf8) start_sample - (sf8) 1.0;
	for (i = n_samples; i--;)
		*sf8_p++ = (val += (sf8) 1.0);
	CMP_mak_interp_sf8_m13(VDS_in_bufs, (si8) VDS_header->n_VDS_samples, VDS_out_bufs, (si8) n_samples);

	// copy interpolated data to decompressed buffer
	CMP_sf8_to_si4_m13(out_y, cps->decompressed_ptr, n_samples, TRUE_m13);

	// restore bh
	bh->number_of_samples = n_samples;
	bh->total_header_bytes = VDS_total_header_bytes;
	bh->model_region_bytes = (ui2) CMP_VDS_MODEL_FIXED_HDR_BYTES_m13;
	cps->params.model_region = VDS_model_region;

	return_m13(TRUE_m13);
}


tern	CMP_VDS_encode_m13(CPS_m13 *cps)
{
	tern				change_made;
	ui1				*VDS_model_region, *VDS_amplitude_model_region, *VDS_time_model_region;
	ui4				VDS_n_samples, VDS_total_header_bytes;
	ui4				VDS_total_block_bytes, algorithm;
	si4				*si4_p, rounds, maximum_rounds;
	sf4				*sf4_p;
	si8				i, j, k, new_in_len, block_samps, poles, pad_samps, in_len, offset;
	si8				*in_x, *new_in_x, *si8_p1, *si8_p2, scale;
	sf8				VDS_alg_thresh, *out_x, *template, *sf8_p1, *sf8_p2, *sf8_p3, *in_y, *out_y;
	sf8				*abs_diffs, *quantval_buf, diff, thresh, baseline, *resids, max_dx, max_dy;
	void				*saved_count_p, *saved_sorted_count_p, *saved_symbol_map_p, *saved_cumulative_count_p, *saved_minimum_range_p;
	CMP_BUFFERS_m13			*VDS_in_bufs, *VDS_out_bufs;
	CMP_FIXED_BH_m13		*bh;
	CMP_VDS_MODEL_FIXED_HDR_m13	*VDS_header;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// VDS Buffer Map:
	// 	VDS_in_bufs[CMP_MAK_IN_Y_BUF] == VDS_in_bufs[0]: mak() in_y
	// 	VDS_in_bufs[CMP_MAK_IN_X_BUF] == VDS_in_bufs[1]: mak() in_x
	// 	VDS_in_bufs[8]:	template

 	// redirect to PRED for lossless encoding
	if (cps->params.VDS_threshold == (sf8) 0.0) {
		cps->direcs.flags &= ~CPS_DF_ALGORITHM_MASK_m13;
		cps->direcs.flags |= CPS_DF_PRED_ALGORITHM_m13;
		algorithm = CMP_PRED_COMPRESSION_m13;  // change directive so don't do this for every block
		CMP_PRED2_encode_m13(cps);
		return_m13(TRUE_m13);
	}

	// convert user to algorithm threshold
	VDS_alg_thresh = CMP_VDS_get_theshold_m13(cps);

	// redirect to MBE for tiny blocks
	bh = cps->block_header;
	block_samps = (si8) bh->number_of_samples;
	if (block_samps < CMP_VDS_MINIMUM_SAMPLES_m13) {
		bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
		bh->block_flags |= CMP_BF_MBE_ENCODING_m13;
		CMP_MBE_encode_m13(cps);
		return_m13(TRUE_m13);
	}
	
	// allocate
	poles = FILT_POLES_m13(CMP_VDS_LOWPASS_ORDER_m13, 1);
	pad_samps = FILT_FILT_PAD_SAMPLES_m13(poles);
	cps->params.VDS_input_buffers = CMP_allocate_buffers_m13(cps->params.VDS_input_buffers, CMP_VDS_INPUT_BUFFERS_m13, block_samps + pad_samps, sizeof(sf8), FALSE_m13, FALSE_m13);
	cps->params.VDS_output_buffers = CMP_allocate_buffers_m13(cps->params.VDS_output_buffers, CMP_VDS_OUTPUT_BUFFERS_m13, block_samps, sizeof(sf8), FALSE_m13, FALSE_m13);
	VDS_in_bufs = cps->params.VDS_input_buffers;
	VDS_out_bufs = cps->params.VDS_output_buffers;

	// convert block samples to sf8 array
	in_y = (sf8 *) VDS_in_bufs->buffer[0];
	CMP_si4_to_sf8_m13(cps->input_buffer, in_y, block_samps);

	// generate template
	CMP_VDS_generate_template_m13(cps, block_samps);
	
	// get baseline
	template = (sf8 *) VDS_in_bufs->buffer[8];
	abs_diffs = (sf8 *) VDS_in_bufs->buffer[2];
	sf8_p1 = in_y;
	sf8_p2 = template;
	sf8_p3 = abs_diffs;
	for (i = block_samps; i--;) {
		diff = *sf8_p1++ - *sf8_p2++;
		*sf8_p3++ = (diff >= (sf8) 0.0) ? diff : -diff;
	}
	quantval_buf = (sf8 *) VDS_in_bufs->buffer[3];
	baseline = CMP_quantval_m13(abs_diffs, block_samps, 0.5, TRUE_m13, quantval_buf);

	// find critical points
	in_x = (si8 *) VDS_in_bufs->buffer[1];
	CMP_find_crits_m13(template, block_samps, &in_len, in_x);

	// put critical points into input mak arrays
	sf8_p1 = in_y;
	si8_p1 = in_x;
	for (i = in_len; i--;)
		*sf8_p1++ = template[*si8_p1++];

	// get absolute differences of critical point y values
	sf8_p1 = in_y;
	sf8_p2 = in_y + 1;
	sf8_p3 = abs_diffs;
	for (i = in_len; --i;) {
		diff = *sf8_p2++ - *sf8_p1++;
		*sf8_p3++ = (diff >= (sf8) 0.0) ? diff : -diff;
	}
	
	// eliminate spurious critical points
	sf8_p1 = abs_diffs;
	si8_p1 = si8_p2 = in_x + 1;
	thresh = baseline * VDS_alg_thresh;
	for (i = in_len; --i; ++si8_p1)
		if (*sf8_p1++ > thresh)
			*si8_p2++ = *si8_p1;
	in_len = si8_p2 - in_x;
	if (in_x[in_len - 1] != (block_samps - 1))
		in_x[in_len++] = block_samps - 1;

	// create out_x array
	out_x = (sf8 *) VDS_out_bufs->buffer[1];
	sf8_p1 = out_x + block_samps;
	for (i = block_samps; i--;)
		*--sf8_p1 = (sf8) i;
	
	// refine fit
	new_in_x = (si8 *) VDS_in_bufs->buffer[2];
	out_y = (sf8 *) VDS_out_bufs->buffer[0];
	resids = (sf8 *) VDS_out_bufs->buffer[2];
	maximum_rounds = cps->params.maximum_goal_attempts;
	rounds = 0;
	do {
		// copy anchors into mak input array
		sf8_p1 = in_y;
		si8_p1 = in_x;
		for (i = in_len; i--;)
			*sf8_p1++ = template[*si8_p1++];

		// fit anchor points
		CMP_mak_interp_sf8_m13(VDS_in_bufs, in_len, VDS_out_bufs, block_samps);

		// calculate residuals
		sf8_p1 = template;
		sf8_p2 = out_y;
		sf8_p3 = resids;
		for (i = block_samps; --i;) {
			diff = *sf8_p1++ - *sf8_p2++;
			*sf8_p3++ = (diff >= (sf8) 0.0) ? diff : -diff;
		}

		// add anchors
		change_made = FALSE_m13;
		new_in_x[0] = in_x[0];
		for (new_in_len = i = 1; i < in_len; ++i) {
			// add point that deviates maximally in segment, if it exceeds threshold
			for (max_dy = 0, k = in_x[i], j = in_x[i - 1] + 1; j < k; ++j) {
				if (resids[j] > max_dy) {
					max_dx = j;
					max_dy = resids[j];
				}
			}
			if (max_dy > thresh) {
				new_in_x[new_in_len++] = max_dx;
				change_made = TRUE_m13;
			}
			new_in_x[new_in_len++] = in_x[i];
		}

		// copy new anchor set into in_x
		if (change_made == TRUE_m13) {
			memcpy((void *) in_x, (void *) new_in_x, (size_t) (new_in_len << 3));
			in_len = new_in_len;
		}
	} while ((change_made == TRUE_m13) && (++rounds <= maximum_rounds));
	
	// could not reach requested fidelity: redirect to PRED for lossless encoding (this block only)
	if ((change_made == TRUE_m13) && (rounds > maximum_rounds)) {
		G_warning_message_m13("%s(): could not achieve requested fidelity in %d rounds => redirecting block to PRED\n", __FUNCTION__, maximum_rounds);
		CMP_PRED2_encode_m13(cps);
		return_m13(TRUE_m13);
	}

	// scale data (if requested)
	if (cps->direcs.flags & CPS_DF_VDS_SCALE_BY_BASELINE_m13) {
		if (baseline > (sf8) 1.0) {
			cps->direcs.flags |= CPS_DF_SET_AMPLITUDE_SCALE_m13;
			cps->params.amplitude_scale = (sf4) baseline;
			CMP_set_variable_region_m13(cps);
		} else {
			cps->direcs.flags &= ~CPS_DF_SET_AMPLITUDE_SCALE_m13;
			cps->params.amplitude_scale = (sf4) 1.0;
		}
	}
	if (cps->direcs.flags & CPS_DF_SET_AMPLITUDE_SCALE_m13) {
		sf4_p = (sf4 *) cps->block_parameters;
		offset = (si8) cps->params.block_parameter_map[CMP_PF_AMPLITUDE_SCALE_IDX_m13];
		*(sf4_p + offset) = cps->params.amplitude_scale;
		scale = (sf8) cps->params.amplitude_scale;
		sf8_p1 = in_y;
		for (i = in_len; i--;)
			*sf8_p1++ /= scale;
	}
	
	// copy data to input buffer
	cps->input_buffer = (si4 *) VDS_in_bufs->buffer[8];  // use VDS template buffer (finished with template for this round)
	CMP_sf8_to_si4_m13(in_y, cps->input_buffer, in_len, TRUE_m13);

	// get VDS model info
	VDS_n_samples = (ui4) in_len;
	bh = cps->block_header;
	VDS_model_region = cps->params.model_region;
	VDS_total_header_bytes = (ui4) (VDS_model_region - (ui1 *) bh) + (ui4) CMP_VDS_MODEL_FIXED_HDR_BYTES_m13;
	VDS_total_block_bytes = VDS_total_header_bytes;
	VDS_header = (CMP_VDS_MODEL_FIXED_HDR_m13 *) VDS_model_region;
	VDS_header->n_VDS_samples = VDS_n_samples;
	VDS_header->flags = 0;

	// encode amplitudes
	bh->number_of_samples = VDS_n_samples;
	VDS_amplitude_model_region = (ui1 *) bh + VDS_total_block_bytes;
	cps->params.model_region = VDS_amplitude_model_region;
	CMP_PRED2_encode_m13(cps); // start with PRED2 for amplitude - may fall through
	VDS_header->amplitude_block_total_bytes = bh->total_block_bytes - VDS_total_block_bytes;
	VDS_header->amplitude_block_model_bytes = bh->model_region_bytes;
	VDS_total_block_bytes = bh->total_block_bytes;
	VDS_header->flags &= ~CMP_VDS_AMPLITUDE_ALGORITHMS_MASK_m13;
	algorithm = bh->block_flags & CMP_BF_ALGORITHMS_MASK_m13;
	switch (algorithm) {
		case CMP_BF_PRED2_ENCODING_m13:
			VDS_header->flags |= CMP_VDS_FLAGS_AMPLITUDE_PRED2_m13;
			break;
		case CMP_BF_MBE_ENCODING_m13:
			VDS_header->flags |= CMP_VDS_FLAGS_AMPLITUDE_MBE_m13;
			break;
	}
	
	// encode times
	si4_p = cps->input_buffer;
	si8_p1 = in_x;
	for (i = VDS_n_samples; i--;)
		*si4_p++ = (si4) *si8_p1++;
	
	// change PRED amplitude buffers to RED time buffers
	saved_count_p = cps->params.count;
	saved_sorted_count_p = cps->params.sorted_count;
	saved_symbol_map_p = cps->params.symbol_map;
	saved_cumulative_count_p = cps->params.cumulative_count,
	saved_minimum_range_p = cps->params.minimum_range,
	cps->params.count = *((void **) saved_count_p);
	cps->params.sorted_count = *((void **) saved_sorted_count_p);
	cps->params.symbol_map = *((void **) saved_symbol_map_p);
	cps->params.cumulative_count = *((void **) saved_cumulative_count_p);
	cps->params.minimum_range = *((void **) saved_minimum_range_p);

	VDS_time_model_region = (ui1 *) bh + VDS_total_block_bytes;
	cps->params.model_region = VDS_time_model_region;
	CMP_RED2_encode_m13(cps); // start with RED2 for times - may fall through
	VDS_header->time_block_model_bytes = bh->model_region_bytes;
	VDS_header->flags &= ~CMP_VDS_TIME_ALGORITHMS_MASK_m13;
	algorithm = bh->block_flags & CMP_BF_ALGORITHMS_MASK_m13;
	switch (algorithm) {
		case CMP_BF_RED2_ENCODING_m13:
			VDS_header->flags |= CMP_VDS_FLAGS_TIME_RED2_m13;
			break;
		case CMP_BF_MBE_ENCODING_m13:
			VDS_header->flags |= CMP_VDS_FLAGS_TIME_MBE_m13;
			break;
	}
	
	// restore PRED amplitude buffers
	cps->params.count = saved_count_p;
	cps->params.sorted_count = saved_sorted_count_p;
	cps->params.symbol_map = saved_symbol_map_p;
	cps->params.cumulative_count = saved_cumulative_count_p;
	cps->params.minimum_range = saved_minimum_range_p;

	// set block back to VDS values
	bh->block_flags &= ~CMP_BF_ALGORITHMS_MASK_m13;
	bh->block_flags |= CMP_BF_VDS_ENCODING_m13;
	bh->number_of_samples = (ui4) block_samps;
	bh->total_header_bytes = VDS_total_header_bytes;
	bh->model_region_bytes = (ui2) CMP_VDS_MODEL_FIXED_HDR_BYTES_m13;
	cps->params.model_region = VDS_model_region;
	
	return_m13(TRUE_m13);
}


tern	CMP_VDS_generate_template_m13(CPS_m13 *cps, si8 data_len)
{
	tern			LFP_filter, realloc_flag;
	si8			i, j, block_samps, *extrema, n_extrema, min_cutoff;
	sf8			*y, *smooth, *transients, *template, samp_freq, LFP_high_fc;
	sf8			*sf8_p1, *sf8_p2, *sf8_p3;
	FILTPS_m13		*min_filtps, *lfp_filtps;
	CMP_FIXED_BH_m13	*bh;

	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Function assumes VDS buffers are allocated
	// Buffer Map:
	// 	VDS_in_bufs[CMP_MAK_IN_Y_BUF] == VDS_in_bufs[0]: y
	// 	VDS_in_bufs[CMP_MAK_IN_X_BUF] == VDS_in_bufs[1]: x (not used, but don't touch)
	// 	VDS_in_bufs[2]:	excise_transients() smooth_data & LFP filt_data
	// 	VDS_in_bufs[3]:	excise_transients() transients
	// 	VDS_in_bufs[4]:	excise_transients() extrema
	//	VDS_in_bufs[7]:	filter() buffer
	//	VDS_in_bufs[8]:	template buffer
	
	samp_freq = cps->params.VDS_sampling_frequency;
	LFP_high_fc = cps->params.VDS_LFP_high_fc;
	bh = cps->block_header;
	block_samps = (si8) bh->number_of_samples;
	y = (sf8 *) cps->params.VDS_input_buffers->buffer[0];

	LFP_filter = FALSE_m13;
	if (LFP_high_fc != (sf8) 0.0)
		LFP_filter = TRUE_m13;
	
	// get filter processing struct: minimal filter
	min_cutoff = samp_freq / (sf8) FILT_VDS_MIN_SAMPS_PER_CYCLE_m13;
	realloc_flag = FALSE_m13;
	if (cps->params.n_filtps < (FILT_VDS_TEMPLATE_MIN_PS_m13 + 1) || cps->params.filtps == NULL) {
		realloc_flag = TRUE_m13;
		cps->params.n_filtps = FILT_VDS_TEMPLATE_MIN_PS_m13 + 1;
		cps->params.filtps = (FILTPS_m13 **) realloc((void *) cps->params.filtps, sizeof(void *) * cps->params.n_filtps);
		min_filtps = (FILTPS_m13 *) (cps->params.filtps[FILT_VDS_TEMPLATE_MIN_PS_m13] = NULL);
	} else {
		min_filtps = (FILTPS_m13 *) cps->params.filtps[FILT_VDS_TEMPLATE_MIN_PS_m13];
		if (min_filtps == NULL)
			realloc_flag = TRUE_m13;
		else if (min_filtps->order != CMP_VDS_LOWPASS_ORDER_m13)
			realloc_flag = TRUE_m13;
		else if (min_filtps->type != FILT_LOWPASS_TYPE_m13)
			realloc_flag = TRUE_m13;
		else if (min_filtps->sampling_frequency != samp_freq)
			realloc_flag = TRUE_m13;
		else if (min_filtps->cutoffs[0] != min_cutoff)
			realloc_flag = TRUE_m13;
	}
	if (realloc_flag == TRUE_m13) {
		if (min_filtps)
			FILT_free_m13(&min_filtps, FALSE_m13, FALSE_m13, FALSE_m13);
		cps->params.filtps[FILT_VDS_TEMPLATE_MIN_PS_m13] = (void *) FILT_init_m13(CMP_VDS_LOWPASS_ORDER_m13, FILT_LOWPASS_TYPE_m13, samp_freq, block_samps, FALSE_m13, FALSE_m13, FALSE_m13, (RETURN_ON_FAIL_m13 | SUPPRESS_WARNING_OUTPUT_m13), min_cutoff);
		min_filtps = (FILTPS_m13 *) cps->params.filtps[FILT_VDS_TEMPLATE_MIN_PS_m13];
	}
	
	// get filter processing struct: LFP filter (user specified cutoff)
	if (LFP_filter == TRUE_m13) {
		realloc_flag = FALSE_m13;
		if (cps->params.n_filtps < (FILT_VDS_TEMPLATE_LFP_PS_m13 + 1)) {
			realloc_flag = TRUE_m13;
			cps->params.n_filtps = FILT_VDS_TEMPLATE_LFP_PS_m13 + 1;
			cps->params.filtps = (FILTPS_m13 **) realloc((void *) cps->params.filtps, sizeof(void *) * cps->params.n_filtps);
			cps->params.filtps[FILT_VDS_TEMPLATE_LFP_PS_m13] = NULL;
			lfp_filtps = (FILTPS_m13 *) cps->params.filtps[FILT_VDS_TEMPLATE_LFP_PS_m13];
		} else {
			lfp_filtps = (FILTPS_m13 *) cps->params.filtps[FILT_VDS_TEMPLATE_LFP_PS_m13];
			if (lfp_filtps == NULL)
				realloc_flag = TRUE_m13;
			else if (lfp_filtps->order != CMP_VDS_LOWPASS_ORDER_m13)
				realloc_flag = TRUE_m13;
			else if (lfp_filtps->type != FILT_LOWPASS_TYPE_m13)
				realloc_flag = TRUE_m13;
			else if (lfp_filtps->sampling_frequency != samp_freq)
				realloc_flag = TRUE_m13;
			else if (lfp_filtps->cutoffs[0] != LFP_high_fc)
				realloc_flag = TRUE_m13;
		}
		if (realloc_flag == TRUE_m13) {
			if (lfp_filtps)
				FILT_free_m13(&lfp_filtps, FALSE_m13, FALSE_m13, FALSE_m13);
			cps->params.filtps[FILT_VDS_TEMPLATE_LFP_PS_m13] = (void *) FILT_init_m13(CMP_VDS_LOWPASS_ORDER_m13, FILT_LOWPASS_TYPE_m13, samp_freq, block_samps, FALSE_m13, FALSE_m13, FALSE_m13, (RETURN_ON_FAIL_m13 | SUPPRESS_WARNING_OUTPUT_m13), LFP_high_fc);
			lfp_filtps = (FILTPS_m13 *) cps->params.filtps[FILT_VDS_TEMPLATE_LFP_PS_m13];
		}
		// put smooth data into offset position
		smooth = (sf8 *) cps->params.VDS_input_buffers->buffer[2];
		lfp_filtps->filt_data = smooth;  // smooth data will end up in buffer 2
		lfp_filtps->orig_data = FILT_OFFSET_ORIG_DATA_m13(lfp_filtps);  // offset smooth data for filtering
		cps->params.VDS_input_buffers->buffer[2] = (void *) lfp_filtps->orig_data;  // offset smooth data (buffer 2) pointer
	}
	
	// excise transients
	FILT_excise_transients_m13(cps, data_len, &n_extrema);
	extrema = (si8 *) cps->params.VDS_input_buffers->buffer[4];
	transients = (sf8 *) cps->params.VDS_input_buffers->buffer[3];

	// set up template minimal filter
	template = (sf8 *) cps->params.VDS_input_buffers->buffer[8];
	min_filtps->filt_data = template;
	min_filtps->orig_data = FILT_OFFSET_ORIG_DATA_m13(min_filtps);
	
	if (LFP_filter == TRUE_m13) {
		// lowpass filter smooth data
		cps->params.VDS_input_buffers->buffer[2] = smooth;  // reset buffer 2 pointer (smooth data)
		lfp_filtps->data_length = data_len;
		lfp_filtps->buffer = (sf8 *) cps->params.VDS_input_buffers->buffer[7];
		FILT_filtfilt_m13(lfp_filtps);
	
		// add transients and smooth data into template
		sf8_p1 = smooth;
		sf8_p2 = transients;
		sf8_p3 = min_filtps->orig_data;  // offset template
		for (i = data_len; i--;)
			*sf8_p3++ = *sf8_p1++ + *sf8_p2++;
	} else {
		// copy input data into offset template
		memcpy((void *) min_filtps->orig_data, (void *) y, (size_t) (data_len << 3));  // offset template
	}
	
	// minimal filter template
	min_filtps->data_length = data_len;
	min_filtps->buffer = (sf8 *) cps->params.VDS_input_buffers->buffer[7];
	FILT_filtfilt_m13(min_filtps);
	
	// fix extrema in template
	for (i = 0; i < n_extrema; ++i) {
		j = extrema[i];
		template[j] = y[j];
	}
	
	// Exit Buffer Map:
	// 	VDS_in_bufs[CMP_MAK_IN_Y_BUF] == VDS_in_bufs[0]: y (not touched)
	// 	VDS_in_bufs[CMP_MAK_IN_X_BUF] == VDS_in_bufs[1]: x (not touched)
	// 	VDS_in_bufs[2 - 7]: available
	//	VDS_in_bufs[8]:	template
	
	return_m13(TRUE_m13);
}


sf8	CMP_VDS_get_theshold_m13(CPS_m13 *cps)
{
	static tern			thresh_change_noted = FALSE_m13;
	tern			no_filt;
	si4				i, low_i, high_i;
	sf8				prop, user_thresh, alg_thresh;
	CMP_VDS_THRESHOLD_MAP_ENTRY_m13	*thresh_map;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (globals_m13->tables->CMP_VDS_threshold_map == NULL)
		CMP_init_tables_m13();
	thresh_map = globals_m13->tables->CMP_VDS_threshold_map;
	
	user_thresh = cps->params.VDS_threshold;
	if (cps->params.VDS_LFP_high_fc == 0.0)
		no_filt = TRUE_m13;
	else
		no_filt = FALSE_m13;

	if (user_thresh > (sf8) 10.0) {
		if (thresh_change_noted == FALSE_m13) {
			if (user_thresh == (sf8) 11.0)
				G_message_m13("%s(): This threshold goes to 11 :)\n", __FUNCTION__);
			else
				G_warning_message_m13("%s(): the VDS threshold range is 0 to 10 => setting to 10\n", __FUNCTION__);
			thresh_change_noted = TRUE_m13;
		}
		cps->params.VDS_threshold = 10.0;
		if (no_filt == TRUE_m13)
			return_m13(thresh_map[CMP_VDS_THRESHOLD_MAP_TABLE_ENTRIES_m13 - 1].algorithm_threshold_no_filt);
		else
			return_m13(thresh_map[CMP_VDS_THRESHOLD_MAP_TABLE_ENTRIES_m13 - 1].algorithm_threshold_LFP);
	}

	if (user_thresh < (sf8) 0.0) {
		G_warning_message_m13("%s: the VDS threshold range is 0 to 10 => setting to 0\n", __FUNCTION__);
		if (no_filt == TRUE_m13)
			return_m13(thresh_map[0].algorithm_threshold_no_filt);
		else
			return_m13(thresh_map[0].algorithm_threshold_LFP);
	}

	for (i = 1; i < CMP_VDS_THRESHOLD_MAP_TABLE_ENTRIES_m13; ++i)
		if (user_thresh < thresh_map[i].user_threshold)
			break;
	
	high_i = i;
	low_i = i - 1;
	if (user_thresh == thresh_map[low_i].user_threshold) {
		if (no_filt == TRUE_m13)
			return_m13(thresh_map[low_i].algorithm_threshold_no_filt);
		else
			return_m13(thresh_map[low_i].algorithm_threshold_LFP);
	}
	
	// interpolate
	prop = (user_thresh - thresh_map[low_i].user_threshold) / (thresh_map[high_i].user_threshold - thresh_map[low_i].user_threshold);
	if (no_filt == TRUE_m13) {
		alg_thresh = (1.0 - prop) * thresh_map[low_i].algorithm_threshold_no_filt;
		alg_thresh += prop * thresh_map[high_i].algorithm_threshold_no_filt;
	} else {
		alg_thresh = (1.0 - prop) * thresh_map[low_i].algorithm_threshold_LFP;
		alg_thresh += prop * thresh_map[high_i].algorithm_threshold_LFP;
	}
	
	return_m13(alg_thresh);
}


sf8	CMP_z2p_m13(sf8 z)
{
	sf8	fna, fnb, fnc, t, p;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (z < (sf8) 0.0)
		z = -z;
	
	t = (sf8) 1.0 / ((sf8) 1.0 + ((sf8) 0.2316419 * z));
	fna = (sf8) -1.82125598 + (t * (sf8) 1.33027443);
	fnb = (sf8) 0.3989423 * t * exp(-z * z / (sf8) 2.0);
	fnc = fnb * ((sf8) 0.31938153 + (t * ((sf8) -0.35656378 + (t * ((sf8) 1.78147794 + (t * fna))))));
	p = fnc * (sf8) 2.0;
	
	return_m13(p);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern  CMP_zero_buffers_m13(CMP_BUFFERS_m13 *buffers)
{
	ui1	*zero_start;
	ui8	pointer_bytes, bytes_to_zero;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	pointer_bytes = buffers->n_buffers * sizeof(void *);
	bytes_to_zero = buffers->total_allocated_bytes - pointer_bytes;
	zero_start = (ui1 *) buffers->buffer + pointer_bytes;
	
	memset((void *) zero_start, 0, (size_t) bytes_to_zero);
	
	return_m13(TRUE_m13);
}



//********************************//
// MARK: CHECKSUM FUNCTIONS  (CRC)
//********************************//

// ATTRIBUTION
//
// Basic CRC-32 manipulation routines
// by Mark Adler (madler@alumni.caltech.edu)
// placed in the public domain 29 Apr 2015
//
// "This library provides general CRC calculation & validation functions and an
// operation to combine the CRCs of two sequences of bytes into a single CRC.
// The routines in this libary only work with the particular CRC-32 polynomial
// provided here."
//
// Minor modifications for compatibility with the MED Library.


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
ui4	CRC_calculate_m13(const ui1 *block_ptr, si8 block_bytes)
{
	ui4	crc;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	crc = CRC_update_m13(block_ptr, block_bytes, CRC_START_VALUE_m13);

	return_m13(crc);
}


ui4 CRC_combine_m13(ui4 block_1_crc, ui4 block_2_crc, si8 block_2_bytes)
{
	ui4 n, col;
	ui4 even[32];  // even-power-of-two zeros operator
	ui4 odd[32]; // odd-power-of-two zeros operator
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// degenerate case (also disallow negative lengths)
	if (block_2_bytes <= 0)
		return_m13(block_1_crc);
	
	// put operator for one zero bit in odd
	odd[0] = CRC_POLYNOMIAL_m13;
	col = 1;
	for (n = 1; n < 32; n++) {
		odd[n] = col;
		col <<= 1;
	}
	
	// put operator for two zero bits in even
	CRC_matrix_square_m13(even, odd);
	
	// put operator for four zero bits in odd
	CRC_matrix_square_m13(odd, even);
	
	// apply block_2_bytes zeros to crc1 (first square will put the operator for one zero byte, eight zero bits, in even)
	do {
		// apply zeros operator for this bit of block_2_bytes
		CRC_matrix_square_m13(even, odd);
		if (block_2_bytes & 1)
			block_1_crc = CRC_matrix_times_m13(even, block_1_crc);
		block_2_bytes >>= 1;
		
		// if no more bits set, then done
		if (block_2_bytes == 0)
			break;
		
		// another iteration of the loop with odd and even swapped
		CRC_matrix_square_m13(odd, even);
		if (block_2_bytes & 1)
			block_1_crc = CRC_matrix_times_m13(odd, block_1_crc);
		block_2_bytes >>= 1;
		
		// if no more bits set, then done
	} while (block_2_bytes != 0);
	
	return_m13(block_1_crc ^ block_2_crc);
}


tern	CRC_init_tables_m13(void)
{
	ui4			**crc_table, c, n, k;
	size_t			len, dim1_bytes, dim2_bytes, content_bytes;
	GLOBAL_TABLES_m13	*tables;


	tables = globals_m13->tables;
	if (tables->CRC_table)
		return(TRUE_m13);

	pthread_mutex_lock_m13(&tables->mutex);
	if (tables->CRC_table) {  // may have been done by another thread while waiting
		pthread_mutex_unlock_m13(&tables->mutex);
		return(TRUE_m13);
	}

	if (tables->CRC_table == NULL) {
		
		// allocate (2D but not AT)
		dim1_bytes = CRC_TABLES_m13 * sizeof(ui4 *) ;
		dim2_bytes = CRC_TABLE_ENTRIES_m13 * sizeof(ui4);
		content_bytes = CRC_TABLES_m13 * dim2_bytes;
		len = dim1_bytes + content_bytes;
		crc_table = (ui4 **) malloc(len);
		if (crc_table == NULL) {
			pthread_mutex_unlock_m13(&tables->mutex);
			return(FALSE_m13);
		}
		crc_table[0] = (ui4 *) (crc_table + CRC_TABLES_m13);
		for (k = 1; k < CRC_TABLES_m13; ++k)
			crc_table[k] = crc_table[k - 1] + CRC_TABLE_ENTRIES_m13;

		// generate a crc for every 8-bit value
		for (n = 0; n < CRC_TABLE_ENTRIES_m13; n++) {
			for (c = n, k = 0; k < 8; k++)
				c = c & 1 ? CRC_POLYNOMIAL_m13 ^ (c >> 1) : c >> 1;
			crc_table[0][n] = c;
		}
		
		// generate crc for each value followed by one, two, and three zeros, and then the byte reversal of those as well as the first table
		for (n = 0; n < CRC_TABLE_ENTRIES_m13; n++) {
			c = crc_table[0][n];
			crc_table[4][n] = CRC_SWAP32_m13(c);
			for (k = 1; k < 4; k++) {
				c = crc_table[0][c & 0xff] ^ (c >> 8);
				crc_table[k][n] = c;
				crc_table[k + 4][n] = CRC_SWAP32_m13(c);
			}
		}
		
		tables->CRC_table = crc_table;
	}
	
	pthread_mutex_unlock_m13(&tables->mutex);

	return(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void  CRC_matrix_square_m13(ui4 *square, const ui4 *mat)
{
	ui4 n;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	for (n = 0; n < 32; n++)
		square[n] = CRC_matrix_times_m13(mat, mat[n]);
	
	return_void_m13;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
ui4  CRC_matrix_times_m13(const ui4 *mat, ui4 vec)
{
	ui4 sum;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	sum = 0;
	while (vec) {
		if (vec & 1)
			sum ^= *mat;
		vec >>= 1;
		mat++;
	}
	
	return_m13(sum);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
ui4	CRC_update_m13(const ui1 *block_ptr, si8 block_bytes, ui4 current_crc)
{
	register ui4  		c;
	register const ui4	**crc_table, *ui4_buf;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (globals_m13->tables->CRC_table == NULL)
		CRC_init_tables_m13();
	
	crc_table = (const ui4 **) globals_m13->tables->CRC_table;

	c = ~current_crc;
	
	// bring block_ptr to 4 byte alignment
	while (block_bytes && ((ui8) block_ptr & (ui8) 3)) {
		c = crc_table[0][(c ^ (ui4) *block_ptr++) & (ui4) 0xff] ^ (c >> 8);
		block_bytes--;
	}

	// calculate CRC in 32 byte chunks
	ui4_buf = (const ui4 *) block_ptr;
	for (; block_bytes >= 4; block_bytes -= 4) {
		c ^= *ui4_buf++;
		c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24];
	}
	
	// process remaining bytes as single bytes
	block_ptr = (const ui1 *) ui4_buf;
	while (block_bytes--)
		c = crc_table[0][(c ^ (ui4) *block_ptr++) & (ui4) 0xff] ^ (c >> 8);
	
	return_m13(~c);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	CRC_validate_m13(const ui1 *block_ptr, si8 block_bytes, ui4 crc_to_validate)
{
	ui4	crc;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	crc = CRC_calculate_m13(block_ptr, block_bytes);
	
	if (crc == crc_to_validate)
		return_m13(TRUE_m13);
	
	return_m13(FALSE_m13);
}



//*******************************//
// MARK: DATABASE FUNCTIONS  (DB)
//*******************************//

// Currently these functions only support postgres databases.

#ifdef DATABASE_m13
tern	DB_check_result_m13(PGresult *result)
{
	tern		result_ok;
	si1			*res_type;
	ExecStatusType		rstat;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	result_ok = TRUE_m13;
	rstat = PQresultStatus(result);
	switch (rstat) {
		case PGRES_EMPTY_QUERY:
			res_type = "PGRES_EMPTY_QUERY";
			result_ok = FALSE_m13;
			break;
		case PGRES_COMMAND_OK:
			res_type = "PGRES_COMMAND_OK";
			break;
		case PGRES_TUPLES_OK:
			res_type = "PGRES_TUPLES_OK";
			break;
		case PGRES_COPY_OUT:
			res_type = "PGRES_COPY_OUT";
			break;
		case PGRES_COPY_IN:
			res_type = "PGRES_COPY_IN";
			break;
		case PGRES_BAD_RESPONSE:
			res_type = "PGRES_BAD_RESPONSE";
			result_ok = FALSE_m13;
			break;
		case PGRES_NONFATAL_ERROR:
			res_type = "PGRES_NONFATAL_ERROR";
			result_ok = FALSE_m13;
			break;
		case PGRES_FATAL_ERROR:
			res_type = "PGRES_FATAL_ERROR";
			result_ok = FALSE_m13;
			break;
		case PGRES_COPY_BOTH:
			res_type = "PGRES_COPY_BOTH";
			break;
		default:
			res_type = "UNKNOWN RESULT TYPE";
			result_ok = FALSE_m13;
			break;
	}
	
	if (result_ok == FALSE_m13)
		G_warning_message_m13("%s(): postgres result: %s", __FUNCTION__, res_type);
	
	return_m13(result_ok);
}
#endif


#ifdef DATABASE_m13
PGresult	*DB_execute_command_m13(PGconn *conn, si1 *command, si4 *rows, si4 expected_rows)
{
	extern GLOBALS_m13	*globals_m13;
	PGresult		*result;
	tern			result_ok;
	si4			local_rows;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	result = PQexec(conn, command);
	result_ok = DB_check_result_m13(result);
	
	if (result_ok == FALSE_m13) {
		PQclear(result);
		if (rows)
			*rows = 0;
		G_set_error_m13(E_DB_m13, "command \"%s\" failed", command);
		return_m13(NULL);
	}

	local_rows = PQntuples(result);
	if (rows)
		*rows = local_rows;
	
	if (expected_rows != DB_EXPECTED_ROWS_NO_ENTRY_m13) {
		if (local_rows != expected_rows) {
			G_warning_message_m13("\trows (%d) != expected_rows (%d)\n", *rows, expected_rows);
		}
	}

	return_m13(result);
}
#endif



//**********************************//
// MARK: DATA MATRIX FUNCTIONS  (DM)
//**********************************//

pthread_rval_m13	DM_channel_thread_m13(void *ptr)
{
	tern			filter, trace_ranges;
	ui1				*data_base, *min_base, *max_base;
	si2				*si2_p1, *si2_p2, *si2_p3;
	si4				i, seg_idx, filt_type, *seg_samps, n_cutoffs, order, filt_poles, pad_samps, bint_mode;
	si4				*si4_p1, *si4_p2, *si4_p3;
	sf4				*sf4_p1, *sf4_p2, *sf4_p3;
	si8				j, k, chan_idx, n_raw_samps, n_seg_samps, required_in_buf_len, chan_offset, samp_offset;
	size_t				n_out_bufs, maj_ptr_bytes;
	si8				*si8_p;
	sf8				*raw_samps, *rsp, raw_samp_freq, cutoff_ratio, cr2, sf_ratio, scale, b, m, q;
	sf8				fc1, fc2, *sf8_p1, *sf8_p2, *sf8_p3, *sf8_p4, *sf8_p5, *sf8_p6, x, inc;
	sf8				*out_buf, *out_mins, *out_maxs, *unfiltered_raw_samps, trace_min, trace_max;
	CHAN_m13			*chan;
	SEG_m13			*seg;
	SLICE_m13			*slice;
	CPS_m13	*cps;
	FILTPS_m13  *filtps;
	DATA_MATRIX_m13			*dm;
	PROC_THREAD_INFO_m13		*pi;
	DM_CHANNEL_THREAD_INFO_m13	*ci;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	pi = (PROC_THREAD_INFO_m13 *) ptr;
	pi->status = PROC_THREAD_RUNNING_m13;
	
	ci = (DM_CHANNEL_THREAD_INFO_m13 *) (pi->arg);
	dm = ci->dm;
	chan = ci->chan;
	chan_idx = ci->chan_idx;
	slice = &chan->slice;
	seg_idx = G_segment_index_m13(slice->start_seg_num, (LH_m13 *) chan);
	raw_samp_freq = chan->segs[seg_idx]->metadata_fps->metadata->time_series_section_2.sampling_frequency;  // use first open segment so don't require ephemeral metadata
	n_raw_samps = SLICE_SAMP_COUNT_m13(slice);
	
	// Note: trace ranges are rarely used for long: so don't leave memory allocated if not needed
	if (dm->flags & DM_TRACE_RANGES_m13) {
		trace_ranges = TRUE_m13;
	} else {
		trace_ranges = FALSE_m13;
		if (dm->out_bufs[chan_idx])
			if (dm->out_bufs[chan_idx]->n_buffers != 1)
				CMP_free_buffers_m13(dm->out_bufs + chan_idx);  // will be allocated below
	}

	// set up for filtering
	required_in_buf_len = n_raw_samps;
	filter = FALSE_m13;
	order = 3;
	fc1 = fc2 = (sf8) 0.0;
	if (dm->flags & DM_FILT_MASK_m13) {
		switch (dm->flags & DM_FILT_MASK_m13) {
			case DM_FILT_ANTIALIAS_m13:
			case DM_FILT_LOWPASS_m13:
				filt_type = FILT_LOWPASS_TYPE_m13;
				fc1 = dm->filter_high_fc;
				n_cutoffs = 1;
				break;
			case DM_FILT_HIGHPASS_m13:
				filt_type = FILT_HIGHPASS_TYPE_m13;
				fc1 = dm->filter_low_fc;
				n_cutoffs = 1;
				break;
			case DM_FILT_BANDPASS_m13:
				filt_type = FILT_BANDPASS_TYPE_m13;
				fc1 = dm->filter_low_fc;
				fc2 = dm->filter_high_fc;
				n_cutoffs = 2;
				break;
			case DM_FILT_BANDSTOP_m13:
				filt_type = FILT_BANDSTOP_TYPE_m13;
				fc1 = dm->filter_low_fc;
				fc2 = dm->filter_high_fc;
				n_cutoffs = 2;
				break;
		}
		cutoff_ratio = fc1 / raw_samp_freq;  // fc1 always less than fc2
		cr2 = (sf8) 0.0;
		if (n_cutoffs == 2)
			cr2 = fc2 / raw_samp_freq;
		if (cutoff_ratio < (sf8) 0.5 && cr2 < (sf8) 0.5) {  // can't filter above Nyquist
			filter = TRUE_m13;
			if (cutoff_ratio >= (sf8) 3.14e-05)  // empirically determined
				order = 4;
			filt_poles = FILT_POLES_m13(order, n_cutoffs);
			pad_samps = FILT_FILT_PAD_SAMPLES_m13(filt_poles);
			required_in_buf_len += pad_samps;
		}
	}
	if (dm->flags & DM_FILT_ANTIALIAS_m13)
		if (dm->sample_count >= n_raw_samps)  // upsampling - no need to antialias
			filter = FALSE_m13;

	// allocate processing buffers
	dm->in_bufs[chan_idx] = CMP_allocate_buffers_m13(dm->in_bufs[chan_idx], 3, required_in_buf_len, sizeof(sf8), FALSE_m13, FALSE_m13);
	n_out_bufs = 1;
	if (trace_ranges == TRUE_m13)
		n_out_bufs = 3;
	dm->out_bufs[chan_idx] = CMP_allocate_buffers_m13(dm->out_bufs[chan_idx], n_out_bufs, dm->valid_sample_count, sizeof(sf8), FALSE_m13, FALSE_m13);

	// initialize filter
	if (filter == TRUE_m13) {
		filtps = FILT_init_m13(order, filt_type, raw_samp_freq, n_raw_samps, FALSE_m13, FALSE_m13, FALSE_m13, (SUPPRESS_OUTPUT_m13 | RETURN_ON_FAIL_m13), fc1, fc2);
		if (filtps == NULL) {
			G_warning_message_m13("%s(): filter error => not filtering\n", __FUNCTION__);
			raw_samps = dm->in_bufs[chan_idx]->buffer[0];
			filter = FALSE_m13;
		} else {
			filtps->filt_data = dm->in_bufs[chan_idx]->buffer[1];
			filtps->buffer = dm->in_bufs[chan_idx]->buffer[2];
			if (trace_ranges == TRUE_m13)  // need a copy of raw data for trace ranges
				filtps->orig_data = dm->in_bufs[chan_idx]->buffer[0];
			else  // put data directly into filt_data array to skip initial copy in FILT_filtfilt_m13()
				filtps->orig_data = FILT_OFFSET_ORIG_DATA_m13(filtps);
			raw_samps = filtps->orig_data;
		}
	} else {  // no filtering
		raw_samps = dm->in_bufs[chan_idx]->buffer[0];
	}

	// put segmented channel si4 data into a single sf8 array
	rsp = raw_samps;
	for (i = 0, j = seg_idx; i < slice->n_segs; ++i, ++j) {
		seg = chan->segs[j];
		cps = seg->ts_data_fps->params.cps;
		seg_samps = cps->decompressed_data;
		n_seg_samps = SLICE_SAMP_COUNT_S_m13(seg->slice);
		for (k = n_seg_samps; k--;)
			*rsp++ = (sf8) *seg_samps++;
	}

	// filter
	if (filter == TRUE_m13) {
		FILT_filtfilt_m13(filtps);
		raw_samps = filtps->filt_data;
		FILT_free_m13(&filtps, FALSE_m13, FALSE_m13, FALSE_m13);
	}

	// set up output buffers
	if ((dm->flags & DM_FMT_CHANNEL_MAJOR_m13) && (dm->flags & DM_TYPE_SF8_m13)) {
		// special case - put results directly in output array
		chan_offset = chan_idx * dm->sample_count;
		if (dm->flags & DM_2D_INDEXING_m13) {
			out_buf = *((sf8 **) dm->data) + chan_offset;
			if (trace_ranges == TRUE_m13) {
				out_mins =  *((sf8 **) dm->range_minima) + chan_offset;
				out_maxs =  *((sf8 **) dm->range_maxima) + chan_offset;
			}
		} else {
			out_buf = (sf8 *) dm->data + chan_offset;
			if (trace_ranges == TRUE_m13) {
				out_mins = (sf8 *) dm->range_minima + chan_offset;
				out_maxs = (sf8 *) dm->range_maxima + chan_offset;
			}
		}
	} else {
		out_buf = dm->out_bufs[chan_idx]->buffer[0];
		if (trace_ranges == TRUE_m13) {
			out_mins = dm->out_bufs[chan_idx]->buffer[1];
			out_maxs = dm->out_bufs[chan_idx]->buffer[2];
		}
	}
	
	// binterpolate
	switch (dm->flags & DM_INTRP_BINTRP_MASK_d1) {
		case DM_INTRP_BINTRP_MDPT_m13:
			bint_mode = CMP_CENT_MODE_MIDPOINT_m13;
			break;
			break;
		case DM_INTRP_BINTRP_MEDN_m13:
			bint_mode = CMP_CENT_MODE_MEDIAN_m13;
			break;
		case DM_INTRP_BINTRP_FAST_m13:
			bint_mode = CMP_CENT_MODE_FASTEST_m13;
			break;
		case DM_INTRP_BINTRP_MEAN_m13:
			bint_mode = CMP_CENT_MODE_MEAN_m13;
			break;
	}
	if (trace_ranges == TRUE_m13)
		unfiltered_raw_samps = (sf8 *) dm->in_bufs[chan_idx]->buffer[0];
	switch (dm->flags & DM_INTRP_MASK_m13) {
		case DM_INTRP_LINEAR_m13:
			CMP_lin_interp_sf8_m13(raw_samps, n_raw_samps, out_buf, dm->valid_sample_count);
			if (trace_ranges == TRUE_m13)
				CMP_binterpolate_sf8_m13(unfiltered_raw_samps, n_raw_samps, NULL, dm->valid_sample_count, CMP_CENT_MODE_NONE_m13, trace_ranges, out_mins, out_maxs);
			break;
		case DM_INTRP_MAKIMA_m13:
			// set up makima buffers
			dm->mak_in_bufs[chan_idx] = CMP_allocate_buffers_m13(dm->mak_in_bufs[chan_idx], CMP_MAK_INPUT_BUFFERS_m13, n_raw_samps + CMP_MAK_PAD_SAMPLES_m13, sizeof(sf8), FALSE_m13, FALSE_m13);
			dm->mak_out_bufs[chan_idx] = CMP_allocate_buffers_m13(dm->mak_out_bufs[chan_idx], CMP_MAK_OUTPUT_BUFFERS_m13, dm->valid_sample_count, sizeof(sf8), FALSE_m13, FALSE_m13);
			dm->mak_in_bufs[chan_idx]->buffer[CMP_MAK_IN_Y_BUF] = raw_samps;  // this is OK with CMP_BUFFERS_m13
			sf8_p1 = (sf8 *) dm->mak_in_bufs[chan_idx]->buffer[CMP_MAK_IN_X_BUF];
			for (x = (sf8) -1.0, i = n_raw_samps; i--;)
				*sf8_p1++ = (x += (sf8) 1.0);
			sf8_p1 = (sf8 *) dm->mak_out_bufs[chan_idx]->buffer[CMP_MAK_OUT_X_BUF];
			inc = (sf8) n_raw_samps / (sf8) (dm->valid_sample_count - 1);
			for (x = (sf8) -inc, i = dm->valid_sample_count; i--;)
				*sf8_p1++ = (x += inc);
			dm->mak_out_bufs[chan_idx]->buffer[CMP_MAK_OUT_Y_BUF] = out_buf;  // this is OK with CMP_BUFFERS_m13
			// interpolate
			CMP_mak_interp_sf8_m13(dm->mak_in_bufs[chan_idx], n_raw_samps, dm->mak_out_bufs[chan_idx], dm->valid_sample_count);
			if (trace_ranges == TRUE_m13)
				CMP_binterpolate_sf8_m13(unfiltered_raw_samps, n_raw_samps, NULL, dm->valid_sample_count, CMP_CENT_MODE_NONE_m13, trace_ranges, out_mins, out_maxs);
			break;
		case DM_INTRP_SPLINE_m13:
			dm->spline_bufs[chan_idx] = CMP_allocate_buffers_m13(dm->spline_bufs[chan_idx], 3, n_raw_samps + CMP_SPLINE_TAIL_LEN_m13, sizeof(sf8), FALSE_m13, FALSE_m13);
			CMP_spline_interp_sf8_m13(raw_samps, n_raw_samps, out_buf, dm->valid_sample_count, dm->spline_bufs[chan_idx]);
			if (trace_ranges == TRUE_m13)
				CMP_binterpolate_sf8_m13(unfiltered_raw_samps, n_raw_samps, NULL, dm->valid_sample_count, CMP_CENT_MODE_NONE_m13, trace_ranges, out_mins, out_maxs);
			break;
		case DM_INTRP_BINTRP_MDPT_m13:
		case DM_INTRP_BINTRP_MEAN_m13:
		case DM_INTRP_BINTRP_MEDN_m13:
		case DM_INTRP_BINTRP_FAST_m13:
			CMP_binterpolate_sf8_m13(raw_samps, n_raw_samps, out_buf, dm->valid_sample_count, bint_mode, trace_ranges, out_mins, out_maxs);
			break;
		case DM_INTRP_UP_MAKIMA_DN_LINEAR_m13:
			sf_ratio = dm->sampling_frequency / raw_samp_freq;
			if (sf_ratio > DM_INTRP_MAKIMA_UPSAMPLE_SF_RATIO_m13) {
				// set up makima buffers
				dm->mak_in_bufs[chan_idx] = CMP_allocate_buffers_m13(dm->mak_in_bufs[chan_idx], CMP_MAK_INPUT_BUFFERS_m13, n_raw_samps + CMP_MAK_PAD_SAMPLES_m13, sizeof(sf8), FALSE_m13, FALSE_m13);
				dm->mak_out_bufs[chan_idx] = CMP_allocate_buffers_m13(dm->mak_out_bufs[chan_idx], CMP_MAK_OUTPUT_BUFFERS_m13, dm->valid_sample_count, sizeof(sf8), FALSE_m13, FALSE_m13);
				dm->mak_in_bufs[chan_idx]->buffer[CMP_MAK_IN_Y_BUF] = (void *) raw_samps;  // this is OK with CMP_BUFFERS_m13
				si8_p = (si8 *) dm->mak_in_bufs[chan_idx]->buffer[CMP_MAK_IN_X_BUF] + (n_raw_samps - 1);
				for (i = n_raw_samps; i--;)
					*si8_p-- = i;
				sf8_p1 = (sf8 *) dm->mak_out_bufs[chan_idx]->buffer[CMP_MAK_OUT_X_BUF];
				inc = ((sf8) (n_raw_samps - 1) / (sf8) (dm->valid_sample_count - 1));
				for (x = -inc, i = dm->valid_sample_count; i--;)
					*sf8_p1++ = (x += inc);
				dm->mak_out_bufs[chan_idx]->buffer[CMP_MAK_OUT_Y_BUF] = (void *) out_buf;  // this is OK with CMP_BUFFERS_m13
				// interpolate
				CMP_mak_interp_sf8_m13(dm->mak_in_bufs[chan_idx], n_raw_samps, dm->mak_out_bufs[chan_idx], dm->valid_sample_count);
			} else {
				CMP_lin_interp_sf8_m13(raw_samps, n_raw_samps, out_buf, dm->valid_sample_count);
			}
			if (trace_ranges == TRUE_m13)
				CMP_binterpolate_sf8_m13(unfiltered_raw_samps, n_raw_samps, NULL, dm->valid_sample_count, CMP_CENT_MODE_NONE_m13, trace_ranges, out_mins, out_maxs);
			break;
		case DM_INTRP_UP_SPLINE_DN_LINEAR_m13:  // default (faster & less memory than DM_INTRP_UP_MAKIMA_DN_LINEAR_m13, but not as pretty)
		default:
			sf_ratio = dm->sampling_frequency / raw_samp_freq;
			if (sf_ratio >= DM_INTRP_SPLINE_UPSAMPLE_SF_RATIO_m13) {
				dm->spline_bufs[chan_idx] = CMP_allocate_buffers_m13(dm->spline_bufs[chan_idx], 3, n_raw_samps + CMP_SPLINE_TAIL_LEN_m13, sizeof(sf8), FALSE_m13, FALSE_m13);
				CMP_spline_interp_sf8_m13(raw_samps, n_raw_samps, out_buf, dm->valid_sample_count, dm->spline_bufs[chan_idx]);
			} else {
				CMP_lin_interp_sf8_m13(raw_samps, n_raw_samps, out_buf, dm->valid_sample_count);
			}
			if (trace_ranges == TRUE_m13)
				CMP_binterpolate_sf8_m13(unfiltered_raw_samps, n_raw_samps, NULL, dm->valid_sample_count, CMP_CENT_MODE_NONE_m13, trace_ranges, out_mins, out_maxs);
			break;
	}
	
	// scale
	scale = dm->scale_factor;
	if (dm->flags & DM_SCALE_m13 && scale != 1.0) {
		sf8_p1 = out_buf;
		i = dm->valid_sample_count;
		if (trace_ranges == TRUE_m13) {
			sf8_p2 = out_mins;
			sf8_p3 = out_maxs;
			while (i--) {
				*sf8_p1++ *= scale;
				*sf8_p2++ *= scale;
				*sf8_p3++ *= scale;
			}
		} else {
			while (i--)
				*sf8_p1++ *= scale;
		}
	}
	
	// detrend
	if (dm->flags & DM_DETREND_m13) {
		CMP_lad_reg_sf8_m13(out_buf, dm->valid_sample_count, &m, &b);
		sf8_p1 = out_buf;
		i = dm->valid_sample_count;
		if (trace_ranges == TRUE_m13) {
			sf8_p2 = out_mins;
			sf8_p3 = out_maxs;
			while (i--) {
				*sf8_p1++ -= (q = (b += m));
				*sf8_p2++ -= q;
				*sf8_p3++ -= q;
			}
		} else {
			while (i--)
				*sf8_p1++ -= (b += m);
		}
	}
	
	// trace extrema
	if (dm->flags & DM_TRACE_EXTREMA_m13) {
		sf8_p1 = out_buf;
		trace_min = trace_max = *sf8_p1++;
		for (i = dm->valid_sample_count - 1; i--; ++sf8_p1) {
			if (trace_min > *sf8_p1)
				trace_min = *sf8_p1;
			else if (trace_max < *sf8_p1)
				trace_max = *sf8_p1;
		}
		switch (dm->flags & DM_TYPE_MASK_m13) {
			case DM_TYPE_SI2_m13:
				((si2 *) dm->trace_minima)[chan_idx] = CMP_round_si2_m13(trace_min);
				((si2 *) dm->trace_maxima)[chan_idx] = CMP_round_si2_m13(trace_max);
				break;
			case DM_TYPE_SI4_m13:
				((si4 *) dm->trace_minima)[chan_idx] = CMP_round_si4_m13(trace_min);
				((si4 *) dm->trace_maxima)[chan_idx] = CMP_round_si4_m13(trace_max);
				break;
			case DM_TYPE_SF4_m13:
				((sf4 *) dm->trace_minima)[chan_idx] = (sf4) trace_min;
				((sf4 *) dm->trace_maxima)[chan_idx] = (sf4) trace_max;
				break;
			case DM_TYPE_SF8_m13:
				((sf8 *) dm->trace_minima)[chan_idx] = trace_min;
				((sf8 *) dm->trace_maxima)[chan_idx] = trace_max;
				break;
			default:
				G_warning_message_m13("%s(): invalid element size => returning\n");
				ci->dm = NULL;
				pi->status = PROC_THREAD_FAILED_m13;
				thread_return_null_m13;
		}
	}

	// put data in target arrays
	data_base = (ui1 *) dm->data;
	min_base = (ui1 *) dm->range_minima;
	max_base = (ui1 *) dm->range_maxima;
	if (dm->flags & DM_2D_INDEXING_m13) {
		maj_ptr_bytes = dm->maj_dim * sizeof(void *);
		data_base += maj_ptr_bytes;
		min_base += maj_ptr_bytes;
		max_base += maj_ptr_bytes;
	}
	if (dm->flags & DM_FMT_CHANNEL_MAJOR_m13)
		chan_offset = chan_idx * dm->sample_count;
	else  // DM_FMT_SAMPLE_MAJOR_m13
		samp_offset = dm->channel_count;
	
	switch (dm->flags & DM_TYPE_MASK_m13) {
		case DM_TYPE_SI2_m13:
			if (dm->flags & DM_FMT_CHANNEL_MAJOR_m13) {
				sf8_p1 = out_buf;
				si2_p1 = (si2 *) data_base + chan_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m13) {
					sf8_p2 = out_mins;
					si2_p2 = (si2 *) min_base + chan_offset;
					sf8_p3 = out_maxs;
					si2_p3 = (si2 *) max_base + chan_offset;
					while (i--) {
						*si2_p1++ = CMP_round_si2_m13(*sf8_p1++);
						*si2_p2++ = CMP_round_si2_m13(*sf8_p2++);
						*si2_p3++ = CMP_round_si2_m13(*sf8_p3++);
					}
				} else {
					while (i--)
						*si2_p1++ = CMP_round_si2_m13(*sf8_p1++);
				}
			} else {  // DM_FMT_SAMPLE_MAJOR_m13
				sf8_p1 = out_buf;
				si2_p1 = ((si2 *) data_base + chan_idx) - samp_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m13) {
					sf8_p2 = out_mins;
					si2_p2 = (si2 *) min_base + chan_idx - samp_offset;
					sf8_p3 = out_maxs;
					si2_p3 = (si2 *) max_base + chan_idx - samp_offset;
					while (i--) {
						*(si2_p1 += samp_offset) = CMP_round_si2_m13(*sf8_p1++);
						*(si2_p2 += samp_offset) = CMP_round_si2_m13(*sf8_p2++);
						*(si2_p3 += samp_offset) = CMP_round_si2_m13(*sf8_p3++);
					}
				} else {
					while (i--)
						*(si2_p1 += samp_offset) = CMP_round_si2_m13(*sf8_p1++);
				}
			}
			break;
		case DM_TYPE_SI4_m13:
			if (dm->flags & DM_FMT_CHANNEL_MAJOR_m13) {
				sf8_p1 = out_buf;
				si4_p1 = (si4 *) data_base + chan_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m13) {
					sf8_p2 = out_mins;
					si4_p2 = (si4 *) min_base + chan_offset;
					sf8_p3 = out_maxs;
					si4_p3 = (si4 *) max_base + chan_offset;
					while (i--) {
						*si4_p1++ = CMP_round_si4_m13(*sf8_p1++);
						*si4_p2++ = CMP_round_si4_m13(*sf8_p2++);
						*si4_p3++ = CMP_round_si4_m13(*sf8_p3++);
					}
				} else {
					while (i--)
						*si4_p1++ = CMP_round_si2_m13(*sf8_p1++);
				}
			} else {  // DM_FMT_SAMPLE_MAJOR_m13
				sf8_p1 = out_buf;
				si4_p1 = ((si4 *) data_base + chan_idx) - samp_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m13) {
					sf8_p2 = out_mins;
					si4_p2 = (si4 *) min_base + chan_idx - samp_offset;
					sf8_p3 = out_maxs;
					si4_p3 = (si4 *) max_base + chan_idx - samp_offset;
					while (i--) {
						*(si4_p1 += samp_offset) = CMP_round_si4_m13(*sf8_p1++);
						*(si4_p2 += samp_offset) = CMP_round_si4_m13(*sf8_p2++);
						*(si4_p3 += samp_offset) = CMP_round_si4_m13(*sf8_p3++);
					}
				} else {
					while (i--)
						*(si4_p1 += samp_offset) = CMP_round_si4_m13(*sf8_p1++);
				}

			}
			break;
		case DM_TYPE_SF4_m13:
			if (dm->flags & DM_FMT_CHANNEL_MAJOR_m13) {
				sf8_p1 = out_buf;
				sf4_p1 = (sf4 *) data_base + chan_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m13) {
					sf8_p2 = out_mins;
					sf4_p2 = (sf4 *) min_base + chan_offset;
					sf8_p3 = out_maxs;
					sf4_p3 = (sf4 *) max_base + chan_offset;
					while (i--) {
						*sf4_p1++ = (sf4) *sf8_p1++;
						*sf4_p2++ = (sf4) *sf8_p2++;
						*sf4_p3++ = (sf4) *sf8_p3++;
					}
				} else {
					while (i--)
						*sf4_p1++ = (sf4) *sf8_p1++;
				}
			} else {  // DM_FMT_SAMPLE_MAJOR_m13
				sf8_p1 = out_buf;
				sf4_p1 = ((sf4 *) data_base + chan_idx) - samp_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m13) {
					sf8_p2 = out_mins;
					sf4_p2 = (sf4 *) min_base + chan_idx - samp_offset;
					sf8_p3 = out_maxs;
					sf4_p3 = (sf4 *) max_base + chan_idx - samp_offset;
					while (i--) {
						*(sf4_p1 += samp_offset) = (sf4) *sf8_p1++;
						*(sf4_p2 += samp_offset) = (sf4) *sf8_p2++;
						*(sf4_p3 += samp_offset) = (sf4) *sf8_p3++;
					}
				} else {
					while (i--)
						*(sf4_p1 += samp_offset) = (sf4) *sf8_p1++;
				}

			}
			break;
		case DM_TYPE_SF8_m13:
			// DM_FMT_CHANNEL_MAJOR_m13 written directly into output buffers
			if (dm->flags & DM_FMT_SAMPLE_MAJOR_m13) {
				sf8_p1 = out_buf;
				sf8_p4 = ((sf8 *) data_base + chan_idx) - samp_offset;
				i = dm->valid_sample_count;
				if (trace_ranges == TRUE_m13) {
					sf8_p2 = out_mins;
					sf8_p5 = (sf8 *) min_base + chan_idx - samp_offset;
					sf8_p3 = out_maxs;
					sf8_p6 = (sf8 *) max_base + chan_idx - samp_offset;
					while (i--) {
						*(sf8_p4 += samp_offset) = *sf8_p1++;
						*(sf8_p5 += samp_offset) = *sf8_p2++;
						*(sf8_p6 += samp_offset) = *sf8_p3++;
					}
				} else {
					while (i--)
						*(sf8_p4 += samp_offset) = *sf8_p1++;
				}
			}
			break;
	}

	pi->status = PROC_THREAD_SUCCEEDED_m13;
	
	thread_return_null_m13;
}


tern	DM_free_matrix_m13(DATA_MATRIX_m13 **matrix_ptr)
{
	si8			i;
	DATA_MATRIX_m13		*matrix;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (matrix_ptr == NULL) {
		G_set_error_m13(E_UNKN_m13, "matrix_ptr is NULL");
		return_m13(FALSE_m13);
	}
	matrix = *matrix_ptr;
	if (matrix == NULL) {
		G_set_error_m13(E_UNKN_m13, "matrix is NULL");
		return_m13(FALSE_m13);
	}

	if (matrix->data)
		free_m13(matrix->data);
	
	if (matrix->range_minima)
		free_m13(matrix->range_minima);
	
	if (matrix->range_maxima)
		free_m13(matrix->range_maxima);
	
	if (matrix->contigua)
		free_m13((void *) matrix->contigua);

	if (matrix->in_bufs) {
		for (i = 0; i < matrix->n_proc_bufs; ++i) {
			CMP_free_buffers_m13(matrix->in_bufs + i);
			CMP_free_buffers_m13(matrix->out_bufs + i);
		}
		free_m13((void *) matrix->in_bufs);
		free_m13((void *) matrix->out_bufs);
	}
	
	if (matrix->mak_in_bufs) {
		for (i = 0; i < matrix->n_proc_bufs; ++i) {
			CMP_free_buffers_m13(matrix->mak_in_bufs + i);
			CMP_free_buffers_m13(matrix->mak_out_bufs + i);
		}
		free_m13((void *) matrix->mak_in_bufs);
		free_m13((void *) matrix->mak_out_bufs);
	}

	if (matrix->spline_bufs) {
		for (i = 0; i < matrix->n_proc_bufs; ++i)
			CMP_free_buffers_m13(matrix->spline_bufs + i);
		free_m13((void *) matrix->spline_bufs);
	}

	if (freeable_m13((void *) matrix) == TRUE_m13)
		free_m13((void *) matrix);
	
	*matrix_ptr = NULL;
	
	return_m13(TRUE_m13);
}


DATA_MATRIX_m13 *DM_get_matrix_m13(DATA_MATRIX_m13 *matrix, SESS_m13 *sess, SLICE_m13 *slice, si4 varargs, ...)  // varargs: si8 out_samp_count, sf8 out_sf, ui8 flags, sf8 scale, sf8 fc1, sf8 fc2
{
	tern				changed_to_absolute_time, padding_required, ret_val;
	ui1				*data_base, *minima_base, *maxima_base;
	si2				si2_pad;
	si4				search_mode, seg_idx, si4_pad;
	sf4				sf4_pad;
	ui8				tmp_ui8;
	si8				i, j, old_maj_dim, old_min_dim, old_el_size, old_offset, new_offset, samp_offset;
	si8				req_num_samps, ref_num_samps, bytes_per_sample, bytes_per_channel, data_end, contig_samples;
	si8				gap_start, gap_end, gap_len, common_offset, gap_offset, req_duration, tmp_si8;
	si8				start_sample_number, end_sample_number, data_start;
	sf8 				ratio, duration, fc1, fc2, req_samp_secs, ref_samp_secs, ref_samp_freq, sf8_pad, tmp_sf8;
	ui8				saved_matrix_flags;
	void				*pattern;
	size_t				new_data_bytes, trace_extrema_bytes, n_elements, pattern_sz, bytes_to_move;
	va_list				v_args;
	PROC_GLOBS_m13			*proc_globs;
	CHAN_m13			*chan, *ref_chan;
	SLICE_m13			passed_slice_copy, *req_slice, *sess_slice;
	PROC_THREAD_INFO_m13		*proc_thread_infos, *pi;
	DM_CHANNEL_THREAD_INFO_m13	*chan_thread_infos, *ci;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// USAGE:
	// Session must have been opened by caller (so mapping mechanism, active channels, etc. are set), but session is not read.
	// The desired extents are specified in the session SLICE by the caller.
	// DM_get_matrix_m13() may need to change the time extents of the slice depending on the DM flags and discontinuities.
	// DM_get_matrix_m13() will call G_read_session_m13() once the required times have been determined.

	// NOTE:
	// DM_EXTMD_COUNT_AND_FREQ_m13: If the caller wants a fixed number of valid output samples, at a specific output frequency, they should set this flag,
	// and fill in both of these values. DM_get_matrix_m13() will use the slice start time, or start sample number, but adjust the end time if there are
	// discontinuities. The session time slice will reflect what actually occured upon return.
	// DM_EXTMD_COUNT_AND_FREQ_m13 is not compatible with DM_DSCNT_NAN_m13 or DM_DSCNT_ZERO_m13. If these are set the function will return.
	// If discontinuity information is desired with DM_EXTMD_COUNT_AND_FREQ_m13, set DM_DSCNT_CONTIG_m13. This is because DM_EXTMD_COUNT_AND_FREQ_m13
	// implies the caller wants only valid sample values & also, if padding were requested, the number of output samples could be enormous.
	
	// NOTE: This function handles a lot of options. I don't like creating subfunctions with pieces that won't be used anywhere else.
	// As a result, it is behemoth, and somewhat difficult to follow.  Apologies to my fellow coders that need to dig into it.
	
	// DM_get_matrix_m13() varargs: si8 out_samp_count, sf8 out_sf, ui8 flags, sf8 scale, sf8 fc1, sf8 fc2
	//
	// IMPORTANT: pass correct types for varargs - compiler cannot promote / convert to proper type because it doesn't know what they should be
	//
	// varargs DM_FILT_LOWPASS_m13 set: fc1 == high_cutoff
	// varargs DM_FILT_HIGHPASS_m13 set: fc1 == low_cutoff
	// varargs DM_FILT_BANDPASS_m13 set: fc1 == low_cutoff, fc2 == high_cutoff
	// varargs DM_FILT_BANDSTOP_m13 set: fc1 == low_cutoff, fc2 == high_cutoff
	// varargs matrix == NULL: flags, out_samp_count, out_samp_freq are passed (fc1 & fc2 must be filled in, but if not used, 0.0 should be passed as place holders)

	if (sess == NULL) {
		G_set_error_m13(E_UNKN_m13, "session is not open");
		return_m13(NULL);
	}
	if (slice == NULL)  // if no slice passed, session slice is used, but may be modified
		slice = &sess->slice;
	if ((search_mode = G_search_mode_m13(slice)) == FALSE_m13)  // ensure there's a valid limit pair
		return_m13(NULL);
	
	proc_globs = G_proc_globs_m13((LH_m13 *) sess);

	// allocate matrix structure
	if (matrix == NULL)
		matrix = (DATA_MATRIX_m13 *) calloc_m13((size_t) 1, sizeof(DATA_MATRIX_m13));
	if (varargs == TRUE_m13) {  // varargs: si8 out_samp_count, sf8 out_sf, ui8 flags, sf8 scale, sf8 fc1, sf8 fc2
		// pass zero for anything you don't want to change
		va_start(v_args, varargs);
		tmp_si8 = va_arg(v_args, si8);
		if (tmp_si8)
			matrix->sample_count = tmp_si8;
		tmp_sf8 = va_arg(v_args, sf8);
		if (tmp_sf8 > 0.0)
			matrix->sampling_frequency = tmp_sf8;
		tmp_ui8 = va_arg(v_args, ui8);
		if (tmp_ui8)
			matrix->flags = tmp_ui8;
		tmp_sf8 = va_arg(v_args, sf8);
		if (tmp_sf8 != 0.0)  // to change from scaling to non-scaling, you must pass 1.0 for the scale factor, otherwise it is interpreted as a skip
			matrix->scale_factor = tmp_sf8;
		fc1 = va_arg(v_args, sf8);
		fc2 = va_arg(v_args, sf8);
		va_end(v_args);
	}
	old_maj_dim = matrix->maj_dim;
	old_min_dim = matrix->min_dim;
	old_el_size = matrix->el_size;
	
	// clear contigua, if present
	ref_chan = proc_globs->current_session.index_channel;
	if (ref_chan->contigua) {
		free_m13((void *) ref_chan->contigua);
		ref_chan->contigua = NULL;
		ref_chan->n_contigua = 0;
	}
	if (matrix->contigua) {
		free_m13((void *) matrix->contigua);
		matrix->contigua = NULL;
		matrix->n_contigua = 0;
	}
	
	// check maximum input defaults
	if (matrix->sample_count == DM_MAXIMUM_INPUT_COUNT_m13 || matrix->sampling_frequency == DM_MAXIMUM_INPUT_FREQUENCY_m13) {
		if (matrix->sample_count == DM_MAXIMUM_INPUT_COUNT_m13) {  // change count to frequency mode
			matrix->flags &= ~DM_EXTMD_SAMP_COUNT_m13;
			matrix->flags |= DM_EXTMD_SAMP_FREQ_m13;
			matrix->sample_count = 0;
		}
		matrix->sampling_frequency = proc_globs->active_channels.maximum_sampling_frequency;
	}
		
	switch (matrix->flags & DM_EXTMD_MASK_m13) {
		case DM_EXTMD_SAMP_COUNT_m13:
			if (matrix->sample_count <= 0) {
				G_set_error_m13(E_UNKN_m13, "DM_EXTMD_SAMP_COUNT_m13 must specify matrix sample count");
				return_m13(NULL);
			}
			break;
		case DM_EXTMD_SAMP_FREQ_m13:
			if (matrix->sampling_frequency <= (sf8) 0.0) {
				G_set_error_m13(E_UNKN_m13, "DM_EXTMD_SAMP_FREQ_m13 must specify matrix sampling frequency");
				return_m13(NULL);
			}
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "invalid extents mode (DM_EXTMD_SAMP_COUNT_m13 or DM_EXTMD_SAMP_FREQ_m13)");
			return_m13(NULL);
	}
	if ((matrix->flags & (DM_EXTMD_ABSOLUTE_LIMITS_m13 | DM_EXTMD_RELATIVE_LIMITS_m13)) == 0) {
		G_set_error_m13(E_UNKN_m13, "either DM_EXTMD_ABSOLUTE_LIMITS_m13 or DM_EXTMD_RELATIVE_LIMITS_m13 extents mode must be selected");
		return_m13(NULL);

	}
	if ((matrix->flags & DM_EXTMD_ABSOLUTE_LIMITS_m13) && (matrix->flags & DM_EXTMD_RELATIVE_LIMITS_m13)) {
		G_set_error_m13(E_UNKN_m13, "DM_EXTMD_ABSOLUTE_LIMITS_m13 and DM_EXTMD_RELATIVE_LIMITS_m13 extents modes are mutually exclusive");
		return_m13(NULL);
	}
	
	// set slice parameters by extents limits
	passed_slice_copy = *slice;  // passed slice not modified
	req_slice = &passed_slice_copy;  // this slice may be modified
	
	// change requested limits to time
	if (req_slice->conditioned == FALSE_m13)
		G_condition_slice_m13(req_slice, (LH_m13 *) sess);
	if (req_slice->start_time == BEGINNING_OF_TIME_m13)
		req_slice->start_time = proc_globs->current_session.start_time;
	if (req_slice->end_time == END_OF_TIME_m13)
		req_slice->end_time = proc_globs->current_session.end_time;
	if (search_mode == TIME_SEARCH_m13)
		req_samp_secs = (sf8) SLICE_DUR_m13(req_slice) / (sf8) 1000000.0;  // requested time in seconds
	else  // search_mode == SAMPLE_SEARCH_m13
		req_num_samps = SLICE_SAMP_COUNT_m13(req_slice);  // requested samples read (on reference channel)
	seg_idx = G_segment_index_m13(FIRST_OPEN_SEG_m13, (LH_m13 *) sess);
	ref_samp_freq = ref_chan->segs[seg_idx]->metadata_fps->metadata->time_series_section_2.sampling_frequency;  // use first open segment so don't require ephemeral metadata
	
	// change all limits to time
	changed_to_absolute_time = FALSE_m13;
	padding_required = FALSE_m13;
	if (matrix->flags & DM_PAD_MASK_m13) {
		G_build_contigua_m13((LH_m13 *) ref_chan);  // always need contigua for padding
		if (ref_chan->n_contigua > 1)
			padding_required = TRUE_m13;
		else if (req_slice->start_time < ref_chan->contigua[0].start_time)
			padding_required = TRUE_m13;
		else if (req_slice->end_time > ref_chan->contigua[0].end_time)
			padding_required = TRUE_m13;
		// convert slice to absolute time
		if (padding_required == TRUE_m13) {
			if (search_mode == SAMPLE_SEARCH_m13 || matrix->flags & DM_EXTMD_RELATIVE_LIMITS_m13) {
				if (search_mode == SAMPLE_SEARCH_m13)
					req_duration = (si8) ((((sf8) req_num_samps / ref_samp_freq) * (sf8) 1000000.0) + (sf8) 0.5);
				else  // TIME_SEARCH_m13
					req_duration = SLICE_DUR_m13(req_slice);
				req_slice->end_time = (req_slice->start_time + req_duration) - 1;
				req_slice->start_samp_num = req_slice->end_samp_num = SAMPLE_NUMBER_NO_ENTRY_m13;
				req_slice->n_segs = UNKNOWN_m13;
				search_mode = TIME_SEARCH_m13;
				saved_matrix_flags = matrix->flags;
				matrix->flags &= ~DM_EXTMD_RELATIVE_LIMITS_m13;
				matrix->flags |= DM_EXTMD_ABSOLUTE_LIMITS_m13;
				changed_to_absolute_time = TRUE_m13;
				G_warning_message_m13("%s(): discontinuity in slice => temporarily changed limits to absolute time\n", __FUNCTION__);
			}
		}
	} else if (search_mode == SAMPLE_SEARCH_m13) {
		req_slice->start_time = G_uutc_for_sample_number_m13((LH_m13 *) sess, req_slice->start_samp_num, FIND_START_m13);
		req_slice->end_time = G_uutc_for_sample_number_m13((LH_m13 *) sess, req_slice->end_samp_num, FIND_END_m13);
	} else if (matrix->flags & DM_EXTMD_RELATIVE_LIMITS_m13) {
		start_sample_number = G_sample_number_for_uutc_m13((LH_m13 *) sess, req_slice->start_time, FIND_CURRENT_m13);
		duration = (sf8) SLICE_DUR_m13(req_slice) / (sf8) 1e6;  // convert to seconds
		end_sample_number = start_sample_number + (si8) ((ref_samp_freq * duration) + (sf8) 0.5) - (si8) 1;  // relative samples
		req_slice->end_time = G_uutc_for_sample_number_m13((LH_m13 *) sess, end_sample_number, FIND_END_m13);
	}
	req_slice->start_samp_num = req_slice->end_samp_num = SAMPLE_NUMBER_NO_ENTRY_m13;  // all extents now changed to time (for variable frequency channels)
	req_slice->n_segs = UNKNOWN_m13;

	// read session
	if (G_read_session_m13(sess, req_slice) == NULL)
		return_m13(NULL);
	sess_slice = &sess->slice;  // filled in with actual values
	
	// return a NULL matrix if there is no data found
	if (sess_slice->n_segs == UNKNOWN_m13)
		return_m13(NULL);
	
	// get output sample count & sampling frequency
	ref_num_samps = SLICE_SAMP_COUNT_S_m13(ref_chan->slice);  // actual samples read (on reference channel)
	ref_samp_secs = (sf8) ref_num_samps / ref_samp_freq;  // elapsed sample time, ignoring discontinuities
	switch (matrix->flags & DM_EXTMD_MASK_m13) {
		case DM_EXTMD_SAMP_COUNT_m13:
			if (search_mode == TIME_SEARCH_m13)
				ratio = ref_samp_secs / req_samp_secs;
			else  // search_mode == SAMPLE_SEARCH_m13
				ratio = (sf8) ref_num_samps / (sf8) req_num_samps;
			matrix->valid_sample_count = (si8) round((sf8) matrix->sample_count * ratio);
			if (matrix->valid_sample_count > matrix->sample_count)
				matrix->valid_sample_count = matrix->sample_count;  // rounding error - valid count can only be less than or equal to requested count
			if ((matrix->flags & DM_PAD_MASK_m13) == 0)  // sample count doesn't change if padded
				matrix->sample_count = matrix->valid_sample_count;
			matrix->sampling_frequency = (sf8) matrix->valid_sample_count / ref_samp_secs;
			break;
		case DM_EXTMD_SAMP_FREQ_m13:
			matrix->valid_sample_count = (si8) round(matrix->sampling_frequency * ref_samp_secs);
			if (matrix->flags & DM_PAD_MASK_m13) {
				if (search_mode == SAMPLE_SEARCH_m13)
					req_samp_secs = (sf8) req_num_samps / ref_samp_freq;
				matrix->sample_count = (si8) round(matrix->sampling_frequency * req_samp_secs);
			} else {
				matrix->sample_count = matrix->valid_sample_count;
			}
			break;
	}

	// set scaling
	if (matrix->scale_factor == 0.0)  // calloc value
		matrix->scale_factor = 1.0;  // no scaling

	// set filter cutoffs
	if (matrix->flags & DM_FILT_MASK_m13) {
		if (varargs == TRUE_m13) {  // caller passed cutoffs as varargs
			switch (matrix->flags & DM_FILT_MASK_m13) {
				case DM_FILT_LOWPASS_m13:
					if (fc1 > 0.0)
						matrix->filter_high_fc = fc1;
					break;
				case DM_FILT_HIGHPASS_m13:
					if (fc1 > 0.0)
						matrix->filter_low_fc = fc1;
					break;
				case DM_FILT_BANDPASS_m13:
				case DM_FILT_BANDSTOP_m13:
					if (fc1 > 0.0)
						matrix->filter_low_fc = fc1;
					if (fc2 > 0.0)
						matrix->filter_high_fc = fc2;
					break;
			}
		}
		switch (matrix->flags & DM_FILT_MASK_m13) {
			case DM_FILT_ANTIALIAS_m13:
				matrix->filter_high_fc = matrix->sampling_frequency / FILT_ANTIALIAS_FREQ_DIVISOR_DEFAULT_m13;
			case DM_FILT_LOWPASS_m13:
				matrix->filter_low_fc = NAN;  // nan("");
				break;
			case DM_FILT_HIGHPASS_m13:
				matrix->filter_high_fc = NAN;  // nan("");
				break;
			case DM_FILT_BANDPASS_m13:
			case DM_FILT_BANDSTOP_m13:
				break;
		}
	}

	// get active channel count
	for (matrix->channel_count = i = 0; i < sess->n_ts_chans; ++i) {
		chan = sess->ts_chans[i];
		if (chan->flags & LH_CHAN_ACTIVE_m13)
			++matrix->channel_count;
	}
	if (matrix->channel_count == 0) {
		G_set_error_m13(E_UNKN_m13, "invalid channel count");
		return_m13(NULL);
	}

	// get matrix dimensions
	if ((matrix->flags & DM_FMT_MASK_m13) == 0) {  // does not check if multiple flags set
		G_set_error_m13(E_UNKN_m13, "invalid format");
		return_m13(NULL);
	}
	if (matrix->flags & DM_FMT_SAMPLE_MAJOR_m13) {
		matrix->maj_dim = matrix->sample_count;
		matrix->min_dim = matrix->channel_count;
	} else {  // DM_FMT_CHANNEL_MAJOR_m13
		matrix->maj_dim = matrix->channel_count;
		matrix->min_dim = matrix->sample_count;
	}
	
	// get element size
	switch (matrix->flags & DM_TYPE_MASK_m13) {
		case DM_TYPE_SI2_m13:
			matrix->el_size = 2;
			break;
		case DM_TYPE_SI4_m13:
		case DM_TYPE_SF4_m13:
			matrix->el_size = 4;
			break;
		case DM_TYPE_SF8_m13:
			matrix->el_size = 8;
			break;
		default:
			G_warning_message_m13("%s(): invalid element size => returning\n", __FUNCTION__);
			return_m13(NULL);
	}
	
	// allocate channel processing buffer pointers
	if (matrix->n_proc_bufs < matrix->channel_count) {
		if (matrix->in_bufs == NULL) {
			matrix->in_bufs = (CMP_BUFFERS_m13 **) calloc_m13((size_t) matrix->channel_count, sizeof(CMP_BUFFERS_m13 *));
			matrix->out_bufs = (CMP_BUFFERS_m13 **) calloc_m13((size_t) matrix->channel_count, sizeof(CMP_BUFFERS_m13 *));
			if (matrix->flags & (DM_INTRP_MAKIMA_m13 | DM_INTRP_UP_MAKIMA_DN_LINEAR_m13)) {
				matrix->mak_in_bufs = (CMP_BUFFERS_m13 **) calloc_m13((size_t) matrix->channel_count, sizeof(CMP_BUFFERS_m13 *));
				matrix->mak_out_bufs = (CMP_BUFFERS_m13 **) calloc_m13((size_t) matrix->channel_count, sizeof(CMP_BUFFERS_m13 *));
			}
			if (matrix->flags & (DM_INTRP_SPLINE_m13 | DM_INTRP_UP_SPLINE_DN_LINEAR_m13))
				matrix->spline_bufs = (CMP_BUFFERS_m13 **) calloc_m13((size_t) matrix->channel_count, sizeof(CMP_BUFFERS_m13 *));
		} else {
			matrix->in_bufs = (CMP_BUFFERS_m13 **) recalloc_m13(matrix->in_bufs, matrix->n_proc_bufs, matrix->channel_count, sizeof(CMP_BUFFERS_m13 *));
			matrix->out_bufs = (CMP_BUFFERS_m13 **) recalloc_m13(matrix->out_bufs, matrix->n_proc_bufs, matrix->channel_count, sizeof(CMP_BUFFERS_m13 *));
			if (matrix->flags & (DM_INTRP_MAKIMA_m13 | DM_INTRP_UP_MAKIMA_DN_LINEAR_m13)) {
				matrix->mak_in_bufs = (CMP_BUFFERS_m13 **) recalloc_m13((void *) matrix->mak_in_bufs, matrix->n_proc_bufs, matrix->channel_count, sizeof(CMP_BUFFERS_m13 *));
				matrix->mak_in_bufs = (CMP_BUFFERS_m13 **) recalloc_m13((void *) matrix->mak_out_bufs, matrix->n_proc_bufs, matrix->channel_count, sizeof(CMP_BUFFERS_m13 *));
			}
			if (matrix->flags & (DM_INTRP_SPLINE_m13 | DM_INTRP_UP_SPLINE_DN_LINEAR_m13))
				matrix->spline_bufs = (CMP_BUFFERS_m13 **) recalloc_m13(matrix->spline_bufs, matrix->n_proc_bufs, matrix->channel_count, sizeof(CMP_BUFFERS_m13 *));
		}
		matrix->n_proc_bufs = matrix->channel_count;
	}
	if (matrix->flags & DM_TRACE_EXTREMA_m13) {
		if (matrix->n_proc_bufs < matrix->channel_count || matrix->el_size > old_el_size) {
			if (matrix->trace_minima) {
				free_m13(matrix->trace_minima);
				free_m13(matrix->trace_maxima);
				matrix->trace_minima = matrix->trace_maxima = NULL;
			}
		}
		if (matrix->trace_minima == NULL) {
			trace_extrema_bytes = matrix->channel_count * matrix->el_size;
			matrix->trace_minima = malloc_m13(trace_extrema_bytes);
			matrix->trace_maxima = malloc_m13(trace_extrema_bytes);
		}
	}

	// allocate matrix return contents
	new_data_bytes = matrix->maj_dim * matrix->min_dim * matrix->el_size;
	if (matrix->flags & DM_2D_INDEXING_m13) {
		new_data_bytes += matrix->maj_dim * sizeof(void *);
		if (matrix->maj_dim != old_maj_dim || matrix->min_dim != old_min_dim || matrix->el_size != old_el_size)  // everthing must match
			matrix->data_bytes = 0;  // force failure below
	}
	if (matrix->data_bytes < (si8) new_data_bytes) {
		matrix->data_bytes = (si8) new_data_bytes;
		if (matrix->data) {
			free_m13((void *) matrix->data);
			if (matrix->range_minima) {  // always paired
				free_m13((void *) matrix->range_minima);
				free_m13((void *) matrix->range_maxima);
				matrix->range_minima = matrix->range_maxima = NULL;
			}
		}
		if (matrix->flags & DM_2D_INDEXING_m13)
			matrix->data = (void *) malloc_2D_m13(matrix->maj_dim, matrix->min_dim * matrix->el_size);
		else
			matrix->data = malloc_m13(new_data_bytes);
		if (matrix->flags & DM_TRACE_RANGES_m13) {
			if (matrix->flags & DM_2D_INDEXING_m13) {
				matrix->range_minima = (void *) malloc_2D_m13(matrix->maj_dim, matrix->min_dim * matrix->el_size);
				matrix->range_maxima = (void *) malloc_2D_m13(matrix->maj_dim, matrix->min_dim * matrix->el_size);
			} else {
				matrix->range_minima = malloc_m13(new_data_bytes);
				matrix->range_maxima = malloc_m13(new_data_bytes);
			}
		}
	}

	// set up thread infos
	pi = proc_thread_infos = (PROC_THREAD_INFO_m13 *) calloc((size_t) matrix->channel_count, sizeof(PROC_THREAD_INFO_m13));
	ci = chan_thread_infos = (DM_CHANNEL_THREAD_INFO_m13 *) calloc((size_t) matrix->channel_count, sizeof(DM_CHANNEL_THREAD_INFO_m13));
	for (i = j = 0; i < matrix->channel_count; ++j) {
		chan = sess->ts_chans[j];
		if (chan->flags & LH_CHAN_ACTIVE_m13) {
			pi->thread_f = DM_channel_thread_m13;
			pi->thread_label = "DM_channel_thread_m13";
			pi->priority = PROC_HIGH_PRIORITY_m13;
			pi->arg = (void *) ci;
			ci->dm = matrix;
			ci->chan = chan;
			ci->chan_idx = i++;
			++pi; ++ci;
		}
	}
		
	// launch channel threads; don't wait for completion (unless running with no threads)
	ret_val = PROC_distribute_jobs_m13(proc_thread_infos, matrix->channel_count, 0, FALSE_m13, proc_globs->miscellaneous.threading);  // default reserved cores
	if (ret_val == FALSE_m13) {
		G_set_error_m13(E_UNKN_m13, "channel thread error");
		return_m13(NULL);
	}

	// contigua
	if (matrix->flags & (DM_DSCNT_MASK_m13 | DM_PAD_MASK_m13)) {
		if (ref_chan->n_contigua == 0)  // zeroed on function entry, ref_chan contigua retrieved above if padding
			G_build_contigua_m13((LH_m13 *) ref_chan);
		// copy contigua & make indices matrix relative
		matrix->n_contigua = ref_chan->n_contigua;
		matrix->contigua = (CONTIGUON_m13 *) calloc_m13((size_t) matrix->n_contigua, sizeof(CONTIGUON_m13));
		memcpy((void *) matrix->contigua, (void *) ref_chan->contigua, (size_t) ref_chan->n_contigua * sizeof(CONTIGUON_m13));
		tmp_sf8 = matrix->sampling_frequency / (sf8) 1e6;  // samples per microsecond
		if (matrix->flags & DM_PAD_MASK_m13) {
			for (i = 0; i < matrix->n_contigua; ++i) {
				matrix->contigua[i].start_samp_num = (si8) round((matrix->contigua[i].start_time - sess_slice->start_time) * tmp_sf8);
				matrix->contigua[i].end_samp_num = (si8) round((matrix->contigua[i].end_time - sess_slice->start_time) * tmp_sf8);
			}
		} else {  // not padded
			for (samp_offset = i = 0; i < matrix->n_contigua; ++i) {
				matrix->contigua[i].start_samp_num = samp_offset;
				duration = (sf8) ((matrix->contigua[i].end_time - matrix->contigua[i].start_time) + 1);
				samp_offset += (si8) round(duration * tmp_sf8);
			}
			for (i = 0; i < (matrix->n_contigua - 1); ++i) {
				matrix->contigua[i].end_samp_num = matrix->contigua[i + 1].start_samp_num - 1;
				if (matrix->contigua[i].end_samp_num < matrix->contigua[i].start_samp_num)  // can happen if highly decimated
					matrix->contigua[i].end_samp_num = matrix->contigua[i].start_samp_num;
			}
		}
		// compensate for rounding errors
		matrix->contigua[0].start_samp_num = 0;
		matrix->contigua[matrix->n_contigua - 1].end_samp_num = matrix->sample_count - 1;
	}

	// wait for channel threads
	ret_val = PROC_wait_jobs_m13(proc_thread_infos, matrix->channel_count);
	free((void *) proc_thread_infos);
	free((void *) chan_thread_infos);

	// check results
	if (ret_val == FALSE_m13) {
		G_set_error_m13(E_UNKN_m13, "channel thread error");
		return_m13(NULL);
	}

	if (padding_required == FALSE_m13)
		return_m13(matrix);

	// padding (big pain in the ass)
	
	// set up patterns
	switch (matrix->flags & DM_TYPE_MASK_m13) {
		case DM_TYPE_SI2_m13:
			si2_pad = (si2) 0;
			if (matrix->flags & DM_DSCNT_NAN_m13)
				si2_pad = NAN_SI2_m13;
			pattern = (void *) &si2_pad;
			pattern_sz = 2;
			break;
		case DM_TYPE_SI4_m13:
			si4_pad = (si4) 0;
			if (matrix->flags & DM_DSCNT_NAN_m13)
				si4_pad = NAN_SI4_m13;
			pattern = (void *) &si4_pad;
			pattern_sz = 4;
			break;
		case DM_TYPE_SF4_m13:
			sf4_pad = (sf4) 0.0;
			if (matrix->flags & DM_DSCNT_NAN_m13)
				sf4_pad = NAN;
			pattern = (void *) &sf4_pad;
			pattern_sz = 4;
			break;
		case DM_TYPE_SF8_m13:
			sf8_pad = (sf8) 0.0;
			if (matrix->flags & DM_DSCNT_NAN_m13)
				sf8_pad = NAN;
			pattern = (void *) &sf8_pad;
			pattern_sz = 8;
			break;

	}
	
	// set up for indexing
	data_base = (ui1 *) matrix->data;
	if (matrix->flags & DM_2D_INDEXING_m13) {
		if (matrix->flags & DM_FMT_SAMPLE_MAJOR_m13)
			data_base += matrix->sample_count * sizeof(void *);
		else  // DM_FMT_CHANNEL_MAJOR_m13
			data_base += matrix->channel_count * sizeof(void *);
	}
	if (matrix->flags & DM_TRACE_RANGES_m13) {
		minima_base = (ui1 *) matrix->range_minima;
		if (matrix->flags & DM_2D_INDEXING_m13) {
			if (matrix->flags & DM_FMT_SAMPLE_MAJOR_m13)
				minima_base += matrix->sample_count * sizeof(void *);
			else  // DM_FMT_CHANNEL_MAJOR_m13
				minima_base += matrix->channel_count * sizeof(void *);
		}
		maxima_base = (ui1 *) matrix->range_maxima;
		if (matrix->flags & DM_2D_INDEXING_m13) {
			if (matrix->flags & DM_FMT_SAMPLE_MAJOR_m13)
				maxima_base += matrix->sample_count * sizeof(void *);
			else  // DM_FMT_CHANNEL_MAJOR_m13
				maxima_base += matrix->channel_count * sizeof(void *);
		}
	}

	// loop backwards over contigua
	data_end = matrix->valid_sample_count;
	gap_end = matrix->sample_count;
	for (i = matrix->n_contigua; i--;) {
		contig_samples = (matrix->contigua[i].end_samp_num - matrix->contigua[i].start_samp_num) + 1;
		data_start = data_end - contig_samples;
		gap_start = matrix->contigua[i].end_samp_num + 1;
		gap_len = gap_end - gap_start;
		if (matrix->flags & DM_FMT_SAMPLE_MAJOR_m13) {
			// move block
			bytes_per_sample = matrix->channel_count * matrix->el_size;
			old_offset = data_start * bytes_per_sample;
			new_offset = matrix->contigua[i].start_samp_num * bytes_per_sample;
			bytes_to_move = bytes_per_sample * contig_samples;
			memcpy((void *) (data_base + new_offset), (void *) (data_base + old_offset), bytes_to_move);
			if (matrix->flags & DM_TRACE_RANGES_m13) {
				memcpy((void *) (minima_base + new_offset), (void *) (minima_base + old_offset), bytes_to_move);
				memcpy((void *) (maxima_base + new_offset), (void *) (maxima_base + old_offset), bytes_to_move);
			}
			// fill gap after (if any)
			if (gap_len) {
				n_elements = gap_len * matrix->channel_count;
				gap_offset = gap_start * bytes_per_sample;
				memset_m13(data_base + gap_offset, pattern_sz, -n_elements, pattern);
				if (matrix->flags & DM_TRACE_RANGES_m13) {
					memset_m13(minima_base + gap_offset, pattern_sz, -n_elements, pattern);
					memset_m13(maxima_base + gap_offset, pattern_sz, -n_elements, pattern);
				}
			}
		} else {  // DM_FMT_CHANNEL_MAJOR_m13
			// move blocks
			bytes_per_sample = matrix->el_size;
			bytes_per_channel = bytes_per_sample * matrix->sample_count;
			common_offset = bytes_per_channel * matrix->channel_count;
			old_offset = common_offset + (data_start * bytes_per_sample);
			new_offset = common_offset + (bytes_per_sample * matrix->contigua[i].start_samp_num);
			gap_offset = common_offset + (gap_start * bytes_per_sample);
			bytes_to_move = bytes_per_sample * contig_samples;
			for (j = matrix->channel_count; j--;) {
				old_offset -= bytes_per_channel;
				new_offset -= bytes_per_channel;
				memcpy((void *) (data_base + new_offset), (void *) (data_base + old_offset), bytes_to_move);
				if (matrix->flags & DM_TRACE_RANGES_m13) {
					memcpy((void *) (minima_base + new_offset), (void *) (minima_base + old_offset), bytes_to_move);
					memcpy((void *) (maxima_base + new_offset), (void *) (maxima_base + old_offset), bytes_to_move);
				}
				// fill gap after (if any)
				if (gap_len) {
					gap_offset -= bytes_per_channel;
					memset_m13(data_base + gap_offset, pattern_sz, -gap_len, pattern);
					if (matrix->flags & DM_TRACE_RANGES_m13) {
						memset_m13(minima_base + gap_offset, pattern_sz, -gap_len, pattern);
						memset_m13(maxima_base + gap_offset, pattern_sz, -gap_len, pattern);
					}
				}
			}
		}
		gap_end = matrix->contigua[i].start_samp_num;  // gap end is first sample after end of gap
		data_end -= (contig_samples - 1);  // data end is first sample after end contiguon
	}

	// fill gap before (if any)
	gap_start = 0;
	gap_len = gap_end - gap_start;
	if (gap_len) {
		if (matrix->flags & DM_FMT_SAMPLE_MAJOR_m13) {
			bytes_per_sample = matrix->channel_count * matrix->el_size;
			n_elements = gap_len * matrix->channel_count;
			gap_offset = gap_start * bytes_per_sample;
			memset_m13(data_base + gap_offset, pattern_sz, -n_elements, pattern);
			if (matrix->flags & DM_TRACE_RANGES_m13) {
				memset_m13(minima_base + gap_offset, pattern_sz, -n_elements, pattern);
				memset_m13(maxima_base + gap_offset, pattern_sz, -n_elements, pattern);
			}
		} else {  // DM_FMT_CHANNEL_MAJOR_m13
			bytes_per_sample = matrix->el_size;
			bytes_per_channel = bytes_per_sample * matrix->sample_count;
			common_offset = bytes_per_channel * matrix->channel_count;
			gap_offset = common_offset + (gap_start * bytes_per_sample);
			for (j = matrix->channel_count; j--;) {
				gap_offset -= bytes_per_channel;
				memset_m13(data_base + gap_offset, pattern_sz, -gap_len, pattern);
				if (matrix->flags & DM_TRACE_RANGES_m13) {
					memset_m13(minima_base + gap_offset, pattern_sz, -gap_len, pattern);
					memset_m13(maxima_base + gap_offset, pattern_sz, -gap_len, pattern);
				}
			}
		}
	}

	if (changed_to_absolute_time == TRUE_m13)
		matrix->flags = saved_matrix_flags;  // restore matrix flags


	return_m13(matrix);
}


tern	DM_show_flags_m13(ui8 flags)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	printf_m13("\nData Matrix Flags:\n------------------\n");
	if (flags == DM_NO_FLAGS_m13) {
		printf_m13("no data matrix flags set\n");
		return_m13(FALSE_m13);
	}
	if (flags & DM_TYPE_SI2_m13)
		printf_m13("DM_TYPE_SI2_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_TYPE_SI2_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_TYPE_SI4_m13)
		printf_m13("DM_TYPE_SI4_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_TYPE_SI4_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_TYPE_SF4_m13)
		printf_m13("DM_TYPE_SF4_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_TYPE_SF4_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_TYPE_SF8_m13)
		printf_m13("DM_TYPE_SF8_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_TYPE_SF8_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_2D_INDEXING_m13)
		printf_m13("DM_2D_INDEXING_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_2D_INDEXING_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_FMT_SAMPLE_MAJOR_m13)
		printf_m13("DM_FMT_SAMPLE_MAJOR_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_FMT_SAMPLE_MAJOR_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_FMT_CHANNEL_MAJOR_m13)
		printf_m13("DM_FMT_CHANNEL_MAJOR_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_FMT_CHANNEL_MAJOR_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_EXTMD_SAMP_COUNT_m13)
		printf_m13("DM_EXTMD_SAMP_COUNT_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_EXTMD_SAMP_COUNT_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_EXTMD_SAMP_FREQ_m13)
		printf_m13("DM_EXTMD_SAMP_FREQ_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_EXTMD_SAMP_FREQ_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_EXTMD_ABSOLUTE_LIMITS_m13)
		printf_m13("DM_EXTMD_ABSOLUTE_LIMITS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_EXTMD_ABSOLUTE_LIMITS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_EXTMD_RELATIVE_LIMITS_m13)
		printf_m13("DM_EXTMD_RELATIVE_LIMITS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_EXTMD_RELATIVE_LIMITS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_SCALE_m13)
		printf_m13("DM_SCALE_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_SCALE_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_FILT_LOWPASS_m13)
		printf_m13("DM_FILT_LOWPASS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_FILT_LOWPASS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_FILT_HIGHPASS_m13)
		printf_m13("DM_FILT_HIGHPASS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_FILT_HIGHPASS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_FILT_BANDPASS_m13)
		printf_m13("DM_FILT_BANDPASS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_FILT_BANDPASS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_FILT_BANDSTOP_m13)
		printf_m13("DM_FILT_BANDSTOP_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_FILT_BANDSTOP_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_FILT_ANTIALIAS_m13)
		printf_m13("DM_FILT_ANTIALIAS_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_FILT_ANTIALIAS_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_INTRP_LINEAR_m13)
		printf_m13("DM_INTRP_LINEAR_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_INTRP_LINEAR_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_INTRP_MAKIMA_m13)
		printf_m13("DM_INTRP_MAKIMA_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_INTRP_MAKIMA_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_INTRP_SPLINE_m13)
		printf_m13("DM_INTRP_SPLINE_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_INTRP_SPLINE_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_INTRP_UP_MAKIMA_DN_LINEAR_m13)
		printf_m13("DM_INTRP_UP_MAKIMA_DN_LINEAR_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_INTRP_UP_MAKIMA_DN_LINEAR_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_INTRP_UP_SPLINE_DN_LINEAR_m13)
		printf_m13("DM_INTRP_UP_SPLINE_DN_LINEAR_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_INTRP_UP_SPLINE_DN_LINEAR_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_INTRP_BINTRP_MDPT_m13)
		printf_m13("DM_INTRP_BINTRP_MDPT_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_INTRP_BINTRP_MDPT_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_INTRP_BINTRP_MEAN_m13)
		printf_m13("DM_INTRP_BINTRP_MEAN_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_INTRP_BINTRP_MEAN_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_INTRP_BINTRP_MEDN_m13)
		printf_m13("DM_INTRP_BINTRP_MEDN_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_INTRP_BINTRP_MEDN_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_INTRP_BINTRP_FAST_m13)
		printf_m13("DM_INTRP_BINTRP_FAST_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_INTRP_BINTRP_FAST_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_TRACE_RANGES_m13)
		printf_m13("DM_TRACE_RANGES_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_TRACE_RANGES_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_TRACE_EXTREMA_m13)
		printf_m13("DM_TRACE_EXTREMA_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_TRACE_EXTREMA_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_DETREND_m13)
		printf_m13("DM_DETREND_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_DETREND_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_DSCNT_CONTIG_m13)
		printf_m13("DM_DSCNT_CONTIG_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_DSCNT_CONTIG_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_DSCNT_NAN_m13)
		printf_m13("DM_DSCNT_NAN_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_DSCNT_NAN_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);
	if (flags & DM_DSCNT_ZERO_m13)
		printf_m13("DM_DSCNT_ZERO_m13: %strue%s\n", TC_RED_m13, TC_RESET_m13);
	else
		printf_m13("DM_DSCNT_ZERO_m13: %sfalse%s\n", TC_BLUE_m13, TC_RESET_m13);

	printf_m13("\n");
	
	return_m13(TRUE_m13);
}


DATA_MATRIX_m13 *DM_transpose_m13(DATA_MATRIX_m13 **in_matrix_p, DATA_MATRIX_m13 **out_matrix_p)
{
	tern		false_in_place;
	DATA_MATRIX_m13		*in_matrix, *out_matrix;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// if in_matrix == out_matrix, done in place; if out_matrix == NULL, allocated and returned
	// if out_matrix is passed, it is presumed to have same memory allocation as in_matrix

	if (in_matrix_p == NULL) {
		G_set_error_m13(E_UNKN_m13, "in_matrix pointer is NULL");
		return_m13(NULL);
	}
	in_matrix = *in_matrix_p;
	if (in_matrix == NULL) {
		G_set_error_m13(E_UNKN_m13, "in_matrix is NULL");
		return_m13(NULL);
	}
	if (out_matrix_p == NULL)
		out_matrix = NULL;
	else
		out_matrix = *out_matrix_p;
	
	false_in_place = FALSE_m13;
	if (in_matrix == out_matrix) {
		if (in_matrix->flags & DM_2D_INDEXING_m13) {  // in-place algorithm does not handle 2D indexing
			out_matrix = NULL;  // force allocation of out matrix below
			false_in_place = TRUE_m13;
		} else {
			DM_transpose_in_place_m13(in_matrix, in_matrix->data);
			if (in_matrix->flags & DM_TRACE_RANGES_m13) {
				DM_transpose_in_place_m13(in_matrix, in_matrix->range_minima);
				DM_transpose_in_place_m13(in_matrix, in_matrix->range_maxima);
			}
			return_m13(in_matrix);
		}
	}
	
	if (out_matrix) {  // 2D indexing requires reallocation for transposition
		if (out_matrix->flags & DM_2D_INDEXING_m13) {
			if (in_matrix->maj_dim != out_matrix->min_dim || in_matrix->min_dim != out_matrix->maj_dim)
				DM_free_matrix_m13(&out_matrix);
		}
	}
	
	if (out_matrix == NULL) {
		out_matrix = (DATA_MATRIX_m13 *) calloc_m13((size_t) 1, sizeof(DATA_MATRIX_m13));
		out_matrix->channel_count = in_matrix->channel_count;
		out_matrix->sample_count = in_matrix->sample_count;
		out_matrix->filter_low_fc = in_matrix->filter_low_fc;
		out_matrix->filter_high_fc = in_matrix->filter_high_fc;
		out_matrix->flags = in_matrix->flags;
		out_matrix->maj_dim = in_matrix->min_dim;
		out_matrix->min_dim = in_matrix->maj_dim;
		out_matrix->el_size = in_matrix->el_size;
		out_matrix->data_bytes = in_matrix->data_bytes;
		if (out_matrix->flags & DM_2D_INDEXING_m13)
			out_matrix->data = (void *) malloc_2D_m13(out_matrix->maj_dim, out_matrix->min_dim * out_matrix->el_size);
		else
			out_matrix->data = malloc_m13(out_matrix->data_bytes);
		if (out_matrix->flags & DM_TRACE_RANGES_m13) {
			if (out_matrix->flags & DM_2D_INDEXING_m13) {
				out_matrix->range_minima = (void *) malloc_2D_m13(out_matrix->maj_dim, out_matrix->min_dim * out_matrix->el_size);
				out_matrix->range_maxima = (void *) malloc_2D_m13(out_matrix->maj_dim, out_matrix->min_dim * out_matrix->el_size);
			} else {
				out_matrix->range_minima = (void *) malloc_m13(out_matrix->data_bytes);
				out_matrix->range_maxima = (void *) malloc_m13(out_matrix->data_bytes);
			}
		}
		if (out_matrix->flags & DM_TRACE_EXTREMA_m13) {
			out_matrix->trace_minima = malloc_m13((size_t) (out_matrix->channel_count * out_matrix->el_size));
			memcpy((void *) out_matrix->trace_minima, (void *) in_matrix->trace_minima, (size_t) (out_matrix->channel_count * out_matrix->el_size));
			out_matrix->trace_maxima = malloc_m13((size_t) (out_matrix->channel_count * out_matrix->el_size));
			memcpy((void *) out_matrix->trace_maxima, (void *) in_matrix->trace_maxima, (size_t) (out_matrix->channel_count * out_matrix->el_size));
		}
		out_matrix->n_contigua = in_matrix->n_contigua;
		if (out_matrix->n_contigua) {
			out_matrix->contigua = malloc_m13((size_t) out_matrix->n_contigua * sizeof(CONTIGUON_m13));
			memcpy((void *) out_matrix->contigua, (void *) in_matrix->contigua, (size_t) (out_matrix->n_contigua * sizeof(CONTIGUON_m13)));
		}
		out_matrix->n_proc_bufs = 0;  // don't reallocate processing buffers: DM_get_matrix_m13() will do it if it's called
	}
	
	// transpose
	DM_transpose_out_of_place_m13(in_matrix, out_matrix, in_matrix->data, out_matrix->data);
	if (out_matrix->flags & DM_TRACE_RANGES_m13) {
		DM_transpose_out_of_place_m13(in_matrix, out_matrix, in_matrix->range_minima, out_matrix->range_minima);
		DM_transpose_out_of_place_m13(in_matrix, out_matrix, in_matrix->range_maxima, out_matrix->range_maxima);
	}
	
	if (out_matrix_p)
		*out_matrix_p = out_matrix;
	if (false_in_place == TRUE_m13) {
		DM_free_matrix_m13(&in_matrix);
		*in_matrix_p = out_matrix;
	}
	
	// return
	return_m13(out_matrix);
}


tern	DM_transpose_in_place_m13(DATA_MATRIX_m13 *matrix, void *base)
{
	ui1	*swap_arr;
	si2	*si2_p, si2_tmp_val, si2_last_val;
	si4	*si4_p, si4_tmp_val, si4_last_val;
	sf4	*sf4_p, sf4_tmp_val, sf4_last_val;
	sf8	*sf8_p, sf8_tmp_val, sf8_last_val;
	si8	data_len, swap_cnt, maj_dim, min_dim, old_pos, new_pos, old_maj_idx, old_min_idx, lowest_swapped;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// make swap array
	data_len = matrix->maj_dim * matrix->min_dim;
	swap_arr = (ui1 *) calloc((size_t) data_len, sizeof(ui1));

	// transpose
	maj_dim = matrix->maj_dim;
	min_dim = matrix->min_dim;
	swap_cnt = 0;
	lowest_swapped = old_pos = 0;
	switch (matrix->flags & DM_TYPE_MASK_m13) {
		case DM_TYPE_SI2_m13:
			si2_p = (si2 *) base;
			si2_last_val = si2_p[old_pos];
			while (swap_cnt < data_len) {
				if (swap_arr[old_pos]) {
					for (old_pos = lowest_swapped; swap_arr[++old_pos];);
					lowest_swapped = old_pos;  // will be swapped
					si2_last_val = si2_p[old_pos];
				} else {
					old_maj_idx = old_pos / min_dim;
					old_min_idx = old_pos % min_dim;
					new_pos = (old_min_idx * old_maj_idx) + old_maj_idx;
					si2_tmp_val = si2_p[new_pos];
					si2_p[new_pos] = si2_last_val;
					si2_last_val = si2_tmp_val;
					swap_arr[old_pos] = 1;
					old_pos = new_pos;
					++swap_cnt;
				}
			}
			break;
		case DM_TYPE_SI4_m13:
			si4_p = (si4 *) base;
			si4_last_val = si4_p[old_pos];
			while (swap_cnt < data_len) {
				if (swap_arr[old_pos]) {
					for (old_pos = lowest_swapped; swap_arr[++old_pos];);
					lowest_swapped = old_pos;  // will be swapped
					si4_last_val = si4_p[old_pos];
				} else {
					old_maj_idx = old_pos / min_dim;
					old_min_idx = old_pos % min_dim;
					new_pos = (old_min_idx * old_maj_idx) + old_maj_idx;
					si4_tmp_val = si4_p[new_pos];
					si4_p[new_pos] = si4_last_val;
					si4_last_val = si4_tmp_val;
					swap_arr[old_pos] = 1;
					old_pos = new_pos;
					++swap_cnt;
				}
			}
			break;
		case DM_TYPE_SF4_m13:
			sf4_p = (sf4 *) base;
			sf4_last_val = sf4_p[old_pos];
			while (swap_cnt < data_len) {
				if (swap_arr[old_pos]) {
					for (old_pos = lowest_swapped; swap_arr[++old_pos];);
					lowest_swapped = old_pos;  // will be swapped
					sf4_last_val = sf4_p[old_pos];
				} else {
					old_maj_idx = old_pos / min_dim;
					old_min_idx = old_pos % min_dim;
					new_pos = (old_min_idx * old_maj_idx) + old_maj_idx;
					sf4_tmp_val = sf4_p[new_pos];
					sf4_p[new_pos] = sf4_last_val;
					sf4_last_val = sf4_tmp_val;
					swap_arr[old_pos] = 1;
					old_pos = new_pos;
					++swap_cnt;
				}
			}
			break;
		case DM_TYPE_SF8_m13:
			sf8_p = (sf8 *) base;
			sf8_last_val = sf8_p[old_pos];
			while (swap_cnt < data_len) {
				if (swap_arr[old_pos]) {
					for (old_pos = lowest_swapped; swap_arr[++old_pos];);
					lowest_swapped = old_pos;  // will be swapped
					sf8_last_val = sf8_p[old_pos];
				} else {
					old_maj_idx = old_pos / min_dim;
					old_min_idx = old_pos % min_dim;
					new_pos = (old_min_idx * old_maj_idx) + old_maj_idx;
					sf8_tmp_val = sf8_p[new_pos];
					sf8_p[new_pos] = sf8_last_val;
					sf8_last_val = sf8_tmp_val;
					swap_arr[old_pos] = 1;
					old_pos = new_pos;
					++swap_cnt;
				}
			}
			break;
	}
	free((void *) swap_arr);
	
	// swap dimensions
	matrix->maj_dim = min_dim;
	matrix->min_dim = maj_dim;
	
	return_m13(TRUE_m13);
}


tern	DM_transpose_out_of_place_m13(DATA_MATRIX_m13 *in_matrix, DATA_MATRIX_m13 *out_matrix, void *in_base, void *out_base)
{
	si2	*si2_p1, *si2_p2;
	si4	*si4_p1, *si4_p2;
	sf4	*sf4_p1, *sf4_p2;
	sf8	*sf8_p1, *sf8_p2;
	si8	i, j, out_min_dim, out_maj_dim;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// this function is used internally in DM_tranpose_m13()
	// this function could be threaded
	
	out_min_dim = out_matrix->min_dim = in_matrix->maj_dim;
	out_maj_dim = out_matrix->maj_dim = in_matrix->min_dim;
	if (in_matrix->flags & DM_2D_INDEXING_m13)
		in_base = (void *) ((ui1 *) in_base + (in_matrix->maj_dim * sizeof(void *)));
	if (out_matrix->flags & DM_2D_INDEXING_m13)
		out_base = (void *) ((ui1 *) out_base + (out_matrix->maj_dim * sizeof(void *)));

	switch (out_matrix->flags & DM_TYPE_MASK_m13) {
		case DM_TYPE_SI2_m13:
			si2_p1 = (si2 *) in_base;
			for (i = 0; i < out_min_dim; ++i) {
				si2_p2 = (si2 *) out_base + i;
				for (j = out_maj_dim; j--; si2_p2 += out_min_dim)
					*si2_p2 = *si2_p1++;
			}
			break;
		case DM_TYPE_SI4_m13:
			si4_p1 = (si4 *) in_base;
			for (i = 0; i < out_min_dim; ++i) {
				si4_p2 = (si4 *) out_base + i;
				for (j = out_maj_dim; j--; si4_p2 += out_min_dim)
					*si4_p2 = *si4_p1++;
			}
			break;
		case DM_TYPE_SF4_m13:
			sf4_p1 = (sf4 *) in_base;
			for (i = 0; i < out_min_dim; ++i) {
				sf4_p2 = (sf4 *) out_base + i;
				for (j = out_maj_dim; j--; sf4_p2 += out_min_dim)
					*sf4_p2 = *sf4_p1++;
			}
			break;
		case DM_TYPE_SF8_m13:
			sf8_p1 = (sf8 *) in_base;
			for (i = 0; i < out_min_dim; ++i) {
				sf8_p2 = (sf8 *) out_base + i;
				for (j = out_maj_dim; j--; sf8_p2 += out_min_dim)
					*sf8_p2 = *sf8_p1++;
			}
			break;
	}
	
	return_m13(TRUE_m13);
}


//************************************//
// MARK: FILE FUNCTIONS  (FILE, FLOCK)
//************************************//

FILE_m13	*FILE_init_m13(FILE_m13 *fp, ...)  // varargs(fp == stream): si1 *path
{
	tern			is_stream, alloced;
	si4			fd;
	struct_stat_m13		sb;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (fp == NULL) {
		fp = (FILE_m13 *) calloc_m13((size_t) 1, sizeof(FILE_m13));
		if (fp == NULL)
			return_m13(NULL);
		alloced = TRUE_m13;
		is_stream = FALSE_m13;
	} else {
		alloced = FALSE_m13;
		is_stream = FILE_stream_m13(fp);
	}
	
	// initialize from existing FILE pointer (not certain this will be useful)
	if (is_stream == TRUE_m13) {
		si1		*path;
		FILE		*stream;
		
		// set file descriptor
		fd = fileno_m13(fp);
		if (fd < 0) {  // file not open
			G_set_error_m13(E_UNKN_m13, "file not open");
			return_m13(NULL);
		}
		
		// allocate
		stream = (FILE *) fp;  // save stream
		fp = (FILE_m13 *) calloc_m13((size_t) 1, sizeof(FILE_m13));
		fp->flags = FILE_FLAGS_ALLOCED_m13;
	
		// set FILE pointer & descriptor
		fp->fp = stream;
		fp->fd = fd;
		
		// set path
		if (fd == FILE_FD_STDIN_m13 ||  fd == FILE_FD_STDOUT_m13 || fd == FILE_FD_STDERR_m13) {  // handle standard streams
			switch (fd) {
				case FILE_FD_STDIN_m13:  // stdin
					strcpy(fp->path, "stdin");
					break;
				case FILE_FD_STDOUT_m13:  // stdout
					strcpy(fp->path, "stdout");
					break;
				case FILE_FD_STDERR_m13:  // stderr
					strcpy(fp->path, "stderr");
					break;
			}
		} else {
			va_list	v_args;
			
			va_start(v_args, fp);
			path = va_arg(v_args, si1 *);
			va_end(v_args);
			if (STR_empty_m13(path) == TRUE_m13) {
				#ifdef WINDOWS_m13
				HANDLE	h;
				
				h = (HANDLE) _get_osfhandle(fd);
				if (h != INVALID_HANDLE_VALUE)
					GetFinalPathNameByHandleA(h, fp->path, PATH_BYTES_m13, FILE_NAME_NORMALIZED);
				#endif
			} else {
				strcpy(fp->path, path);
			}
		}
		
		// set position
		fstat_m13(fd, &sb);
		fp->pos = (si8) ftell_m13(fp);
		
		// set length
		fp->len = (si8) sb.st_size;
		
		// set permissions
		fp->perms = (ui2) sb.st_mode & FILE_PERM_STAT_MASK_m13;  // file system permissions
		
		// set flags
		if (fd == FILE_FD_STDIN_m13 ||  fd == FILE_FD_STDOUT_m13 || fd == FILE_FD_STDERR_m13) {  // handle standard streams
			fp->flags |= FILE_FLAGS_STD_STREAM_m13;
			fp->len = fp->pos = 0;  // meaningless in these
			switch (fd) {
				case FILE_FD_STDIN_m13:  // stdin
					fp->flags |= FILE_FLAGS_READ_m13;
					break;
				case FILE_FD_STDOUT_m13:  // stdout
					fp->flags |= FILE_FLAGS_WRITE_m13;
					break;
				case FILE_FD_STDERR_m13:  // stderr
					fp->flags |= FILE_FLAGS_WRITE_m13;
					break;
			}
		} else {
			fp->flags = FILE_FLAGS_DEFAULT_m13;
			
			#if defined MACOS_m13 || defined LINUX_m13
			si4	fd_flags;
			
			// set open file mode
			fd_flags = fcntl(fd, F_GETFL);
			switch (fd_flags & O_ACCMODE) {
				case O_RDONLY:
					fp->flags |= FILE_FLAGS_READ_m13;
					break;
				case O_WRONLY:
					fp->flags |= FILE_FLAGS_WRITE_m13;
					break;
				case O_RDWR:
					fp->flags |= (FILE_FLAGS_READ_m13 | FILE_FLAGS_WRITE_m13);
					break;
			}
			#endif
			#ifdef WINDOWS_m13
			FILE_ACCESS_INFORMATION	access_info;
			ui8			curr_mode;
			
			if (WN_query_information_file_m13(fp, (si4) FileAccessInformation, (void *) &access_info)) {
				curr_mode = (ui8) access_info.AccessFlags;
				if (curr_mode & GENERIC_READ)
					fp->flags |= FILE_FLAGS_READ_m13;
				if (curr_mode & GENERIC_WRITE)
					fp->flags |= FILE_FLAGS_WRITE_m13;
			} else {  // use file system permissions => likely overly permissive for open
				if (fp->perms & (FILE_PERM_USR_READ_m13 | FILE_PERM_GRP_READ_m13 | FILE_PERM_OTH_READ_m13))
					fp->flags |= FILE_FLAGS_READ_m13;
				if (fp->perms & (FILE_PERM_USR_WRITE_m13 | FILE_PERM_GRP_WRITE_m13 | FILE_PERM_OTH_WRITE_m13))
					fp->flags |= FILE_FLAGS_WRITE_m13;
			}
			#endif
		}
		
	}
	
	// FILE_m13 (reset if passed or allocate if NULL)
	else {
		if (alloced == FALSE_m13) {
			if (fp->fd >= 0 && fp->fp)  // file still open
				fclose(fp->fp);
			// save alloced state
			if (fp->flags & FILE_FLAGS_ALLOCED_m13)
				alloced = TRUE_m13;
			memset((void *) fp, (si4) 0, sizeof(FILE_m13));  // sets fp->fp to NULL
		}
		
		// reset flags
		fp->flags = FILE_FLAGS_DEFAULT_m13;
		if (alloced == TRUE_m13)
			fp->flags |= FILE_FLAGS_ALLOCED_m13;
			
		// set other non-zero defaults
		fp->fp = NULL;
		fp->fd = FILE_FD_CLOSED_m13;
		fp->perms = FILE_PERM_DEFAULT_m13;
		
		// flags set on open: FILE_FLAGS_LOCK_m13, FILE_FLAGS_READ_m13, FILE_FLAGS_WRITE_m13
	}
	
	// fields that apply to both FILE & FILE_m13 init
	
	// set start id
	fp->tag = FILE_TAG_m13;

	// set access times flag
	fp->acc = UUTC_NO_ENTRY_m13;
	if (globals_m13->access_times == TRUE_m13)
		fp->flags |= FILE_FLAGS_TIME_m13;
		
	return_m13(fp);
}


tern	FILE_show_m13(FILE_m13 *fp)
{
	si1	tim_str[TIME_STRING_BYTES_m13];
	si1	bin_str[BIN_STR_BYTES_m13(sizeof(ui4), 1)];
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (fp == NULL) {
		printf_m13("FILE_m13 pointer is NULL\n");
		return_m13(FALSE_m13);
	}
	
	if (FILE_stream_m13(fp) == TRUE_m13) {
		printf_m13("passed pointer is a FILE pointer\n");
		return_m13(FALSE_m13);
	}
	
	printf_m13("Path: ");
	if (*fp->path)
		printf_m13("%s\n", fp->path);
	else
		printf_m13("no entry\n");
	printf_m13("ID: ");
	if (fp->fid)
		printf_m13("0x%x\n", fp->fid);
	else
		printf_m13("no entry\n");
	STR_bin_m13(bin_str, (ui1 *) &fp->flags, sizeof(ui2), " ", TRUE_m13);
	printf_m13("Flags (%s):\n", bin_str);
	if (fp->flags & FILE_FLAGS_STD_STREAM_m13)
		printf_m13("\tstandard stream\n");
	else if (fp->flags & FILE_FLAGS_MED_m13)
		printf_m13("\tMED file\n");
	else
		printf_m13("\tstandard file\n");
	if (fp->flags & FILE_FLAGS_ALLOCED_m13)
		printf_m13("\theap allocated\n");
	else
		printf_m13("\ten bloc or stack allocated\n");
	if (fp->flags & FILE_FLAGS_READ_m13)
		printf_m13("\treading enabled\n");
	else
		printf_m13("\treading disabled\n");
	if (fp->flags & FILE_FLAGS_WRITE_m13)
		printf_m13("\twriting enabled (random)\n");
	else if (fp->flags & FILE_FLAGS_APPEND_m13)
		printf_m13("\twriting enabled (append)\n");
	else
		printf_m13("\twriting disabled\n");
	if (fp->flags & FILE_FLAGS_LOCK_m13)
		printf_m13("\tlocking enabled\n");
	else
		printf_m13("\tlocking disabled\n");
	if (fp->flags & FILE_FLAGS_LEN_m13)
		printf_m13("\tlength-tracking enabled\n");
	else
		printf_m13("\tlength-tracking disabled\n");
	if (fp->flags & FILE_FLAGS_POS_m13)
		printf_m13("\tposition-tracking enabled\n");
	else
		printf_m13("\tposition-tracking disabled\n");
	if (fp->flags & FILE_FLAGS_TIME_m13)
		printf_m13("\taccess-tracking enabled\n");
	else
		printf_m13("\taccess-tracking disabled\n");

	printf_m13("Permissions:\tr w x\n");
	printf_m13("\tuser\t%c %c %c\n", ((fp->perms & FILE_PERM_USR_READ_m13) ? '+' : '-'), ((fp->perms & FILE_PERM_USR_WRITE_m13) ? '+' : '-'), ((fp->perms & FILE_PERM_USR_EXEC_m13) ? '+' : '-'));
	printf_m13("\tgroup\t%c %c %c\n", ((fp->perms & FILE_PERM_GRP_READ_m13) ? '+' : '-'), ((fp->perms & FILE_PERM_GRP_WRITE_m13) ? '+' : '-'), ((fp->perms & FILE_PERM_GRP_EXEC_m13) ? '+' : '-'));
	printf_m13("\tother\t%c %c %c\n", ((fp->perms & FILE_PERM_OTH_READ_m13) ? '+' : '-'), ((fp->perms & FILE_PERM_OTH_WRITE_m13) ? '+' : '-'), ((fp->perms & FILE_PERM_OTH_EXEC_m13) ? '+' : '-'));

	printf_m13("FILE Pointer: ");
	if (fp->fp)
		printf_m13("set\n");
	else
		printf_m13("not set\n");

	printf_m13("Descriptor: %d ", fp->fd);
	switch (fp->fd) {
		case FILE_FD_EPHEMERAL_m13:
			printf_m13("(ephemeral)\n");
			break;
		case FILE_FD_CLOSED_m13:
			printf_m13("(closed)\n");
			break;
		case FILE_FD_STDIN_m13:
			printf_m13("(stdin)\n");
			break;
		case FILE_FD_STDOUT_m13:
			printf_m13("(stdout)\n");
			break;
		case FILE_FD_STDERR_m13:
			printf_m13("(stderr)\n");
			break;
		default:
			if (fp->fd > 0)
				printf_m13("(open)\n");
			else
				printf_m13("(invalid)\n");
			break;
	}

	if (fp->flags & FILE_FLAGS_LEN_m13)
		printf_m13("Length: %ld\n", fp->len);

	if (fp->flags & FILE_FLAGS_POS_m13)
		printf_m13("Position: %ld\n", fp->pos);

	if (fp->flags & FILE_FLAGS_TIME_m13) {
		printf_m13("Access Time: ");
		if (fp->acc <= 0) {  // covers UUTC_NO_ENTRY_m13 & zero cases
			printf_m13("no entry\n");
		} else {
			STR_time_m13(NULL, fp->acc, tim_str, TRUE_m13, FALSE_m13, FALSE_m13);
			printf_m13("%ld (oUTC), %s\n", fp->acc, tim_str);
		}
	}

	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	FILE_stream_m13(void *fp)
{
	// returns TRUE_m13 if file pointer is actually a (FILE *)
	
	if (fp == NULL)
		return_m13(UNKNOWN_m13);
	
	// can't dereference standard streams
	if ((ui8) fp == (ui8) stdin)
		return(TRUE_m13);
	if ((ui8) fp == (ui8) stdout)
		return(TRUE_m13);
	if ((ui8) fp == (ui8) stderr)
		return(TRUE_m13);
	
	if (((FILE_m13 *) fp)->tag == FILE_TAG_m13)
		return(FALSE_m13);
	
	return(TRUE_m13);
}


//*******************************//
// MARK: FILTER FUNCTIONS  (FILT)
//*******************************//

// ATTRIBUTION
//
// Some of the filter code was adapted from Matlab functions.
// MathWorks Inc. (www.mathworks.com)
//
// The c code in this library was written entirely from scratch.

QUANTFILT_DATA_m13	*FILT_alloc_quantfilt_data_m13(si8 len, si8 span)
{
	QUANTFILT_DATA_m13	*qd;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	qd = (QUANTFILT_DATA_m13 *) calloc_m13((size_t) 1, sizeof(QUANTFILT_DATA_m13));
	
	qd->x = (sf8 *) calloc_m13((size_t) len, sizeof(sf8));

	qd->qx = (sf8 *) calloc_m13((size_t) len, sizeof(sf8));
	
	qd->nodes = (FILT_NODE_m13 *) calloc((size_t) (span + 1), sizeof(FILT_NODE_m13));
	
	return_m13(qd);
}


tern	FILT_balance_m13(sf8 **a, si4 poles)
{
	sf8  radix, sqrdx, c, r, g, f, s;
	si4 i, j, done;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	radix = FILT_RADIX_m13;
	sqrdx = radix * radix;
	done = 0;
	while (!done) {
		done = 1;
		for (i = 0; i < poles; i++) {
			r = c = (sf8) 0.0;
			for (j = 0; j < poles; j++)
				if (j != i) {
					c += FILT_ABS_m13(a[j][i]);
					r += FILT_ABS_m13(a[i][j]);
				}
			if (c != (sf8) 0.0 && r != (sf8) 0.0) {
				g = r / radix;
				f = (sf8) 1.0;
				s = c + r;
				while (c < g) {
					f *= radix;
					c *= sqrdx;
				}
				g = r * radix;
				while (c > g) {
					f /= radix;
					c /= sqrdx;
				}
				if (((c + r) / f) < ((sf8) 0.95 * s)) {
					done = 0;
					g = 1.0 / f;
					for (j = 0; j < poles; j++)
						a[i][j] *= g;
					for (j = 0; j < poles; j++)
						a[j][i] *= f;
				}
			}
		}
	}
	
	return_m13(TRUE_m13);
}


si4	FILT_butter_m13(FILTPS_m13 *filtps)
{
	si4			i, j, n_fcs, offset, idx, order, poles, is_odd;
	sf8			samp_freq, fcs[2], *den, sum_num, sum_den;
	sf8			u[2], pi, half_pi, bw, wn, w, *r, *num, ratio;
	sf8  		**a, **inv_a, **ta1, **ta2, *b, *bt, *c, t;
	FILT_COMPLEX_m13	csum_num, csum_den, cratio, *ckern;
	FILT_COMPLEX_m13	*p, tc, *eigs, *cden, *rc, *cnum;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// check input
	switch(filtps->type) {
		case FILT_LOWPASS_TYPE_m13:
		case FILT_BANDPASS_TYPE_m13:
		case FILT_HIGHPASS_TYPE_m13:
		case FILT_BANDSTOP_TYPE_m13:
			break;
		default:
			G_set_error_m13(E_FILT_m13, "unrecognized filter type: %d", filtps->type);
			return_m13(-1);
	}
	samp_freq = filtps->sampling_frequency;
	fcs[0] = filtps->cutoffs[0];
	n_fcs = ((filtps->type == FILT_LOWPASS_TYPE_m13) || (filtps->type == FILT_HIGHPASS_TYPE_m13)) ? 1 : 2;
	if (n_fcs == 2)
		fcs[1] = filtps->cutoffs[1];
	order = filtps->order;
	filtps->n_poles = poles = n_fcs * order;
	is_odd = order % 2;
	
	// step 1: get analog, pre-warped frequencies
	pi = (sf8) M_PI;
	half_pi = pi / (sf8) 2.0;
	for (i = 0; i < n_fcs; ++i)
		u[i] = (sf8) 4.0 * tan((pi * fcs[i]) / samp_freq);
	
	// step 2: convert to low-pass prototype estimate
	switch (filtps->type) {
		case FILT_LOWPASS_TYPE_m13:
			wn = u[0];
			break;
		case FILT_BANDPASS_TYPE_m13:
			bw = u[1] - u[0];
			wn = sqrt(u[0] * u[1]);
			break;
		case FILT_HIGHPASS_TYPE_m13:
			wn = u[0];
			break;
		case FILT_BANDSTOP_TYPE_m13:
			bw = u[1] - u[0];
			wn = sqrt(u[0] * u[1]);
			break;
	}
	
	// step 3: Get N-th order Butterworth analog lowpass prototype
	p = (FILT_COMPLEX_m13 *) calloc((size_t) order, sizeof(FILT_COMPLEX_m13));
	for (i = 1; i < order; i += 2) {
		p[i - 1].imag = ((pi * (sf8) i) / (sf8) (2 * order)) + half_pi;
		FILT_complex_exp_m13(p + i - 1, p + i - 1);
	}
	for (i = 1; i < order; i += 2) {
		p[i].real = p[i - 1].real;
		p[i].imag = -p[i - 1].imag;
	}
	if (is_odd)
		p[order - 1].real = (sf8) -1.0;

	j = order - 1;  // sort into ascending order, by real values
	if (is_odd) --j;
	for (i = 0; j > i; ++i, --j) {
		tc = p[i];
		p[i] = p[j];
		p[j] = tc;
	}
	
	// Transform to state-space
	a = (sf8 **) calloc_2D_m13((size_t) poles, (size_t) poles, sizeof(sf8));
	inv_a = (sf8 **) calloc_2D_m13((size_t) poles, (size_t) poles, sizeof(sf8));
	ta1 = (sf8 **) calloc_2D_m13((size_t) poles, (size_t) poles, sizeof(sf8));
	ta2 = (sf8 **) calloc_2D_m13((size_t) poles, (size_t) poles, sizeof(sf8));
	b = (sf8 *) calloc((size_t) poles, sizeof(sf8));
	bt = (sf8 *) calloc((size_t) poles, sizeof(sf8));
	c = (sf8 *) calloc((size_t) poles, sizeof(sf8));
	
	if ((offset = is_odd))
		a[0][0] = (sf8) -1.0;
	for (i = 0; i < order - 1; i += 2) {
		if ((idx = i + offset))
			a[i + offset][idx - 1] = (sf8) 1.0;
		a[i + offset][i + offset] = p[i].real + p[i + 1].real;
		a[i + offset][i + offset + 1] = (sf8) -1.0;
		a[i + offset + 1][i + offset] = (sf8) 1.0;
	}
	b[order - 1] = (sf8) 1.0;
	c[order - 1] = (sf8) 1.0;
	
	// step 4: Transform to lowpass, bandpass, highpass, or bandstop of desired Wn
	switch (filtps->type) {
		case FILT_LOWPASS_TYPE_m13:
			for (i = 0; i < order; ++i) {
				for (j = 0; j < order; ++j)
					a[i][j] *= wn;
				b[i] *= wn;
			}
			break;
		case FILT_BANDPASS_TYPE_m13:
			for (i = 0; i < order; ++i) {
				for (j = 0; j < order; ++j) {
					a[i][j] *= bw;
				}
				a[i][i + order] = wn;
				a[i + order][i] = -wn;
			}
			b[0] = bw;
			break;
		case FILT_HIGHPASS_TYPE_m13:
			for (i = 0; i < order; ++i) {
				c[i] = (sf8) -1.0;
				b[i] = wn;
			}
			for (i = is_odd; i < order; i += 2) {
				c[i + 1] = a[i][i];
				b[i] = (sf8) 0.0;
			}
			// d = (sf8) 1.0;
			FILT_invert_matrix_m13(a, inv_a, order);
			
			for (i = 0; i < order; ++i)
				for (j = 0; j < order; ++j)
					a[i][j] = wn * inv_a[i][j];
			break;
		case FILT_BANDSTOP_TYPE_m13:
			for (i = 0; i < order; ++i) {
				c[i] = (sf8) -1.0;
				b[i] = bw;
			}
			for (i = is_odd; i < order; i += 2) {
				c[i + 1] = a[i][i];
				b[i] = (sf8) 0.0;
			}
			FILT_invert_matrix_m13(a, inv_a, order);
			for (i = 0; i < order; ++i) {
				for (j = 0; j < order; ++j) {
					a[i][j] = bw * inv_a[i][j];
				}
				a[i][i + order] = wn;
				a[i + order][i] = -wn;
			}
			break;
	}

	// step 5: Use bilinear transformation to find discrete equivalent
	t = (sf8) 0.25;
	for (i = 0; i < poles; ++i) {
		for (j = 0; j < poles; ++j) {
			ta1[i][j] = t * a[i][j];
			ta2[i][j] = -ta1[i][j];
		}
		ta1[i][i] += (sf8) 1.0;
		ta2[i][i] += (sf8) 1.0;
	}
	
	FILT_invert_matrix_m13(ta2, inv_a, poles);
	
	FILT_mat_mult_m13((void *) inv_a, (void *) ta1, (void *) a, poles, poles, poles);
	
	FILT_mat_mult_m13((void *) c, (void *) inv_a, (void *) bt, 1, poles, poles);
	t = sqrt((sf8) 0.5);
	for (i = 0; i < poles; ++i)
		c[i] = bt[i] * t;
	
	FILT_mat_mult_m13((void *) bt, (void *) b, (void *) &t, 1, poles, 1);
	
	FILT_mat_mult_m13((void *) inv_a, (void *) b, (void *) bt, poles, poles, 1);
	t = (sf8) 1.0 / sqrt((sf8) 2.0);
	for (i = 0; i < poles; ++i)
		b[i] = bt[i] * t;
	
	// Transform to zero-pole-gain and polynomial forms
	eigs = (FILT_COMPLEX_m13 *) calloc((size_t) poles, sizeof(FILT_COMPLEX_m13));
	FILT_unsymmeig_m13(a, poles, eigs);
	
	den = (sf8 *) calloc_m13((size_t) (poles + 1), sizeof(sf8));
	cden = (FILT_COMPLEX_m13 *) calloc((size_t) (poles + 1), sizeof(FILT_COMPLEX_m13));
	cden[0].real = (sf8) 1.0;
	for (i = 0; i < poles; ++i) {
		for (j = i + 1; j--;) {
			FILT_complex_mult_m13(eigs + i, cden + j, &tc);
			cden[j + 1].real -= tc.real;
			cden[j + 1].imag -= tc.imag;
		}
	}
	for (i = 0; i <= poles; ++i)
		den[i] = cden[i].real;
	
	// generate numerator
	r = (sf8 *) calloc((size_t) (poles + 1), sizeof(sf8));
	rc = (FILT_COMPLEX_m13 *) calloc((size_t) (poles + 1), sizeof(FILT_COMPLEX_m13));
	wn = (sf8) 2.0 * atan2(wn, 4.0);
	
	switch (filtps->type) {
		case FILT_LOWPASS_TYPE_m13:
			for (i = 0; i < poles; ++i)
				r[i] = (sf8) -1.0;
			break;
		case FILT_BANDPASS_TYPE_m13:
			for (i = 0; i < order; ++i) {
				r[i] = (sf8) 1.0;
				r[i + order] = (sf8) -1.0;
			}
			w = -wn;
			break;
		case FILT_HIGHPASS_TYPE_m13:
			for (i = 0; i < poles; ++i)
				r[i] = (sf8) 1.0;
			w = -pi;
			break;
		case FILT_BANDSTOP_TYPE_m13:
			tc.real = (sf8) 0.0;
			tc.imag = wn;
			FILT_complex_exp_m13(&tc, &tc);
			for (i = 0; i < poles; i += 2) {
				rc[i].real = tc.real;
				rc[i].imag = tc.imag;
				rc[i + 1].real = tc.real;
				rc[i + 1].imag = -tc.imag;
			}
			break;
	}
	
	num = (sf8 *) calloc_m13((size_t) (poles + 1), sizeof(sf8));
	cnum = (FILT_COMPLEX_m13 *) calloc((size_t) (poles + 1), sizeof(FILT_COMPLEX_m13));
	if (filtps->type == FILT_BANDSTOP_TYPE_m13) {
		cnum[0].real = (sf8) 1.0;
		for (i = 0; i < poles; ++i) {
			for (j = i + 1; j--;) {
				FILT_complex_mult_m13(rc + i, cnum + j, &tc);
				cnum[j + 1].real -= tc.real;
				cnum[j + 1].imag -= tc.imag;
			}
		}
		for (i = 0; i <= poles; ++i)
			num[i] = cnum[i].real;
	} else {
		num[0] = (sf8) 1.0;
		for (i = 0; i < poles; ++i)
			for (j = i + 1; j--;)
				num[j + 1] -= r[i] * num[j];
	}
						
	// normalize
	ckern = (FILT_COMPLEX_m13 *) calloc((size_t) (poles + 1), sizeof(FILT_COMPLEX_m13));
	if ((filtps->type == FILT_LOWPASS_TYPE_m13) || (filtps->type == FILT_BANDSTOP_TYPE_m13)) {
		sum_num = sum_den = (sf8) 0.0;
		for (i = 0; i <= poles; ++i) {
			sum_num += num[i];
			sum_den += den[i];
		}
		ratio = sum_den / sum_num;
		for (i = 0; i <= poles; ++i)
			num[i] *= ratio;
	} else {
		tc.real = (sf8) 0.0;
		for (i = 0; i <= poles; ++i) {
			tc.imag = w * (sf8) i;
			FILT_complex_exp_m13(&tc, ckern + i);
			cnum[i].real = num[i];
			cnum[i].imag = (sf8) 0.0;
			cden[i].real = den[i];
			cden[i].imag = (sf8) 0.0;
		}
		csum_num.real = csum_den.real = csum_num.imag = csum_den.imag = (sf8) 0.0;
		for (i = 0; i <= poles; ++i) {
			FILT_complex_mult_m13(ckern + i, cnum + i, &tc);
			csum_num.real += tc.real;
			csum_num.imag += tc.imag;
			FILT_complex_mult_m13(ckern + i, cden + i, &tc);
			csum_den.real += tc.real;
			csum_den.imag += tc.imag;
		}
		FILT_complex_div_m13(&csum_den, &csum_num, &cratio);
		for (i = 0; i <= poles; ++i) {
			FILT_complex_mult_m13(cnum + i, &cratio, &tc);
			num[i] = tc.real;
		}
	}

	// clean up
	free_m13((void *) a);
	free_m13((void *) inv_a);
	free_m13((void *) ta1);
	free_m13((void *) ta2);
	free((void *) p);
	free((void *) b);
	free((void *) bt);
	free((void *) c);
	free((void *) cden);
	free((void *) cnum);
	free((void *) eigs);
	free((void *) r);
	free((void *) rc);
	free((void *) ckern);

	// check output
	for (i = 0; i <= poles; ++i) {
		if (isnan(num[i]) || isinf(num[i]) || isnan(den[i]) || isinf(den[i])) {
			if (filtps->behavior & RETURN_ON_FAIL_m13) {
				free_m13((void *) den);
				free_m13((void *) num);
				filtps->numerators = filtps->denominators = NULL;
				return_m13(FILT_BAD_FILTER_m13);
			} else {
				exit_m13(FILT_BAD_FILTER_m13);
			}
		}
	}
	filtps->numerators = num;
	filtps->denominators = den;
	
	return_m13(0);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	FILT_complex_div_m13(FILT_COMPLEX_m13 *a, FILT_COMPLEX_m13 *b, FILT_COMPLEX_m13 *quotient)  //  returns a / b
{
	FILT_COMPLEX_m13	ta, tb;
	sf8			den;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	ta = *a;  // copy in case in place
	tb = *b;
	den = (tb.real * tb.real) + (tb.imag * tb.imag);
	quotient->real = ((ta.real * tb.real) + (ta.imag * tb.imag)) / den;
	quotient->imag = ((ta.imag * tb.real) - (ta.real * tb.imag)) / den;
	
	
	return_void_m13;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	FILT_complex_exp_m13(FILT_COMPLEX_m13 *exponent, FILT_COMPLEX_m13 *ans)
{
	FILT_COMPLEX_m13	t;
	sf8  		c;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	t = *exponent;  // copy in case in place
	c = exp(t.real);
	ans->real = c * cos(t.imag);
	ans->imag = c * sin(t.imag);
	
	
	return_void_m13;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	FILT_complex_mult_m13(FILT_COMPLEX_m13 *a, FILT_COMPLEX_m13 *b, FILT_COMPLEX_m13 *product)
{
	FILT_COMPLEX_m13  ta, tb;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	ta = *a;  // copy in case in place
	tb = *b;
	product->real = (ta.real * tb.real) - (ta.imag * tb.imag);
	product->imag = (ta.real * tb.imag) + (ta.imag * tb.real);
	
	
	return_void_m13;
}


tern	FILT_elmhes_m13(sf8 **a, si4 poles)
{
	si4 i, j, m;
	sf8	x, y, t1;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	for (m = 1; m < (poles - 1); m++) {
		x = (sf8) 0.0;
		i = m;
		for (j = m; j < poles; j++) {
			if (FILT_ABS_m13(a[j][m-1]) > FILT_ABS_m13(x)) {
				x = a[j][m - 1];
				i = j;
			}
		}
		if (i != m) {
			for (j = m - 1; j < poles; j++) {
				t1 = a[i][j];
				a[i][j] = a[m][j];
				a[m][j] = t1;
			}
			for (j = 0; j < poles; j++) {
				t1 = a[j][i];
				a[j][i] = a[j][m];
				a[j][m] = t1;
			}
		}
		if (x != (sf8) 0.0) {
			for (i = m + 1; i < poles; i++) {
				y = a[i][m - 1];
				if (y != (sf8) 0.0) {
					y /= x;
					a[i][m - 1] = y;
					for (j = m; j < poles; j++)
						a[i][j] -= (y * a[m][j]);
					for (j = 0; j < poles; j++)
						a[j][m] += (y * a[j][i]);
				}
			}
		}
	}
	
	return_m13(TRUE_m13);
}


tern	FILT_excise_transients_m13(CPS_m13 *cps, si8 len, si8 *n_extrema)
{
	si8	i, j, span, ext_x, *ex, wind_start, wind_end, n_ext, wind_len;
	sf8	samp_freq, LFP_high_fc, *y, *qy, *sy, *ty, *jy, *try, ext_y;
	sf8	baseline, VDS_alg_thresh, thresh, *sf8_p1, *sf8_p2, *sf8_p3;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Function assumes VDS buffers are allocated
	// VDS Buffer Map:
	// 	VDS_in_bufs[0]:	in_y
	// 	VDS_in_bufs[1]: in_x (not used here, but don't touch)
	// 	VDS_in_bufs[2]:	excise_transients() smooth_data
	// 	VDS_in_bufs[3]:	excise_transients() transients
	// 	VDS_in_bufs[4]:	excise_transients() extrema
	// 	VDS_in_bufs[5-8]: scrap buffers (at this point in VDS)

	samp_freq = cps->params.VDS_sampling_frequency;
	LFP_high_fc = cps->params.VDS_LFP_high_fc;
	y = (sf8 *) cps->params.VDS_input_buffers->buffer[0];
	
	// median filter (to buffer 5)
	if (LFP_high_fc > (sf8) 0.0)
		span = (si8) round(samp_freq / LFP_high_fc);
	else
		span = (si8) round(samp_freq / (sf8) 500.0);  // assume 500 Hz is enough frequency resolution
	if (span < 12)
		span = 12;  // minimum of 3 cycles at 4 samples/cycle
	if (len < span) {  // not tested
		memcpy(cps->params.VDS_input_buffers->buffer[2], cps->params.VDS_input_buffers->buffer[0], (size_t) (len << 3));  // copy original data to smooth_data
		memset(cps->params.VDS_input_buffers->buffer[3], 0, (size_t) (len << 3));  // zero transients
		memset(cps->params.VDS_input_buffers->buffer[4], 0, (size_t) (len << 3));  // zero extrema
		*n_extrema = 0;
		return_m13(TRUE_m13);
	}
	qy = (sf8 *) cps->params.VDS_input_buffers->buffer[5];
	FILT_quantfilt_m13(y, qy, len, (sf8) 0.5, span, FILT_TRUNCATE_m13);
	
	// generate smooth trace (to buffer 2)
	sy = (sf8 *) cps->params.VDS_input_buffers->buffer[2];
	sf8_p1 = y;
	sf8_p2 = qy;
	sf8_p3 = sy;
	for (i = len; i--;)
		*sf8_p3++ = *sf8_p1++ - *sf8_p2++;
	
	// generate threshold trace (to buffer 6)
	ty = (sf8 *) cps->params.VDS_input_buffers->buffer[6];
	sf8_p1 = sy;
	sf8_p2 = ty;
	for (i = len; i--; ++sf8_p1)
		*sf8_p2++ = (*sf8_p1 >= 0.0) ? *sf8_p1 : -*sf8_p1;

	// get baseline & threshold (buffer 7 used as scrap)
	jy = (sf8 *) cps->params.VDS_input_buffers->buffer[7];
	baseline = CMP_quantval_m13(ty, len, (sf8) 0.5, TRUE_m13, jy);
	VDS_alg_thresh = CMP_VDS_get_theshold_m13(cps);
	thresh = ((VDS_alg_thresh + (sf8) 6.0) / (sf8) 2.0) * baseline;
	
	// zero transients array (buffer 3)
	try = (sf8 *) cps->params.VDS_input_buffers->buffer[3];
	memset((void *) try, 0, (size_t) (len << 3));

	// set up extrema array (buffer 4)
	n_ext = 0;
	ex = (si8 *) cps->params.VDS_input_buffers->buffer[4];
	
	// excision loop
	for (i = 0; i < len;) {
		if (ty[i] > thresh) {
			wind_start = wind_end = i;
			if (sy[i] >= 0) {  // find transient window (upgoing)
				for (; wind_start >= 0; --wind_start)
					if (sy[wind_start] < 0)
						break;
				for (; wind_start >= 0; --wind_start)
					if (sy[wind_start] > 0)
						break;
				for (; wind_end < len; ++wind_end)
					if (sy[wind_end] < 0)
						break;
				for (; wind_end < len; ++wind_end)
					if (sy[wind_end] > 0)
						break;
			} else {  // find transient window (downgoing)
				for (; wind_start; --wind_start)
					if (sy[wind_start] > 0)
						break;
				for (; wind_start; --wind_start)
					if (sy[wind_start] < 0)
						break;
				for (; wind_end < len; ++wind_end)
					if (sy[wind_end] > 0)
						break;
				for (; wind_end < len; ++wind_end)
					if (sy[wind_end] < 0)
						break;
			}
			// correct for window overshoot
			++wind_start;
			--wind_end;
			
			// copy smooth contents into transients array & get extrema
			wind_len = (wind_end - wind_start) - 1;
			if (wind_len > 1) {
				ext_x = wind_start;
				ext_y = sy[wind_start];
				if (sy[i] >= 0) {  // upgoing
					for (j = wind_start; j <= wind_end; ++j) {
						try[j] = sy[j];
						if (ext_y < sy[j]) {
							ext_y = sy[j];
							ext_x = j;
						}
					}
				} else {  // downgoing
					for (j = wind_start; j <= wind_end; ++j) {
						try[j] = sy[j];
						if (ext_y > sy[j]) {
							ext_y = sy[j];
							ext_x = j;
						}
					}
				}
				// add extreme values
				ex[n_ext++] = ext_x;
			}
						
			// update for next loop
			i = wind_end;
			
		} else {  // ty[i] <= thresh
			++i;
		}
	}
	
	// finish smooth trace: add quantfilt trace back, or replace with quantfilt trace in transient windows
	sf8_p1 = try;
	sf8_p2 = qy;
	sf8_p3 = sy;
	for (i = len; i--;) {
		if (*sf8_p1++ == (sf8) 0.0)
			*sf8_p3++ += *sf8_p2++;
		else
			*sf8_p3++ = *sf8_p2++;
	}
	*n_extrema = n_ext;

	return_m13(TRUE_m13);
}

				
si4	FILT_filtfilt_m13(FILTPS_m13 *filtps)
{
	tern  	free_z_flag, free_buf_flag;
	si4	  	padded_data_len, pad_len, pad_lenx2, poles;
	si8	  	i, j, k, m, data_len;
	sf8	  	dx2, zc[FILT_MAX_ORDER_m13 * 2], t1, t2;
	sf8 	  	*num, *den, *data, *filt_data, *z, *buf, *dp, *fdp;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// filter data from filtps->orig_data into filtps->filt_data
	// if filtps->orig_data == filtps->filt_data, filtering done in place, but the target array must have room for the pads
	// if orig_data == (filt_data + pad_len) caller put data directly into the filt_data array with room for pad - skip initial copy
	// pad_len == (order * n_cutoffs * 3) => see FILT_OFFSET_ORIG_DATA_m13() macro.
	
	// error check
	if (filtps->orig_data == NULL) {
		if (!(filtps->behavior & SUPPRESS_WARNING_OUTPUT_m13))
			G_warning_message_m13("%s(): no data passed", __FUNCTION__);
		if (!(filtps->behavior & RETURN_ON_FAIL_m13))
			exit_m13(1);
		return_m13(FILT_BAD_DATA_m13);
	}
	poles = filtps->n_poles;
	pad_len = poles * FILT_PAD_SAMPLES_PER_POLE_m13;
	pad_lenx2 = pad_len << 1;
	data_len = filtps->data_length;
	if (data_len < pad_len) {
		if (!(filtps->behavior & SUPPRESS_WARNING_OUTPUT_m13)) {
			if (filtps->type == FILT_LOWPASS_TYPE_m13 || filtps->type == FILT_HIGHPASS_TYPE_m13)
				G_warning_message_m13("%s(): At least %d data points required for a filter of order %d\n", __FUNCTION__, pad_len, filtps->order);
			else
				G_warning_message_m13("%s(): At least %d data points required for a filter of order %d with two cutoffs\n", __FUNCTION__, pad_len, filtps->order);
		}
		if (!(filtps->behavior & RETURN_ON_FAIL_m13))
			exit_m13(1);
		memmove(filtps->filt_data, filtps->orig_data, data_len * sizeof(sf8));
		return_m13(FILT_BAD_DATA_m13);
	}
	
	num = filtps->numerators;
	den = filtps->denominators;
	filt_data = filtps->filt_data;
	free_z_flag = FALSE_m13;
	if (filtps->initial_conditions == NULL) {
		FILT_generate_initial_conditions_m13(filtps);
		free_z_flag = TRUE_m13;
	}
	z = filtps->initial_conditions;
	free_buf_flag = FALSE_m13;
	if (filtps->buffer == NULL) {
		filtps->buffer = (sf8 *) calloc((size_t) data_len + pad_lenx2, sizeof(sf8));
		free_buf_flag = TRUE_m13;
	}
	buf = filtps->buffer;
	data = filtps->orig_data;
	
	// copy data to filt_data with room for pads
	if (data == filt_data) {  // just shift data by pad_len  [ equivalent: memmove((void *) (filt_data + pad_len), (void *) data, data_len * sizeof(sf8)); ]
		dp = data + data_len;
		fdp = dp + pad_len;
		for (i = data_len; i--;)
			*--fdp = *--dp;
	} else if (data != FILT_OFFSET_ORIG_DATA_m13(filtps)) {
		memcpy((void *) (filt_data + pad_len), (void *) data, data_len * sizeof(sf8));  // memcpy typically faster, but cannot overlap
	}
	// else: caller put data directly into the filt_data array with room for pad - skip copy
	
	// front pad
	dx2 = data[0] * (sf8) 2.0;
	for (i = 0, j = pad_len; j; ++i, --j)
		filt_data[i] = dx2 - data[j];
	// back pad
	padded_data_len = data_len + pad_lenx2;
	dx2 = data[data_len - 1] * (sf8) 2.0;
	for (i = data_len + pad_len, j = data_len - 2; i < padded_data_len; ++i, --j)
		filt_data[i] = dx2 - data[j];
	
	// copy and initialize initial conditions
	for (i = 0; i < poles; ++i)
		zc[i] = z[i] * filt_data[0];
	
	// forward filter from filt_data to buffer
	for (i = 0; i < padded_data_len; ++i) {
		t1 = filt_data[i];
		t2 = (num[0] * t1) + zc[0];
		for (j = 1; j < poles; ++j)
			zc[j - 1] = (num[j] * t1) - (den[j] * t2) + zc[j];
		zc[poles - 1] = (num[poles] * t1) - (den[poles] * t2);
		buf[i] = t2;
	}
	
	// copy and initialize initial conditions
	for (i = 0; i < poles; ++i)
		zc[i] = z[i] * buf[padded_data_len - 1];
	
	// reverse filter from buffer to filt_data
	for (i = padded_data_len - 1, k = pad_len; k--;) {
		t1 = buf[i--];
		t2 = (num[0] * t1) + zc[0];
		for (j = 1; j < poles; ++j)
			zc[j - 1] = (num[j] * t1) - (den[j] * t2) + zc[j];
		zc[poles - 1] = (num[poles] * t1) - (den[poles] * t2);
	}
	for (m = i - pad_len, k = data_len; k--;) {
		t1 = buf[i--];
		t2 = (num[0] * t1) + zc[0];
		for (j = 1; j < poles; ++j)
			zc[j - 1] = (num[j] * t1) - (den[j] * t2) + zc[j];
		zc[poles - 1] = (num[poles] * t1) - (den[poles] * t2);
		filt_data[m--] = t2;
	}
	
	// free as required
	if (free_z_flag == TRUE_m13) {
		free_m13((void *) z);
		filtps->initial_conditions = NULL;
	}
	if (free_buf_flag == TRUE_m13) {
		free((void *) buf);
		filtps->buffer = NULL;
	}
	
	return_m13(0);
}


tern	FILT_free_CPS_m13(CPS_m13 *cps, tern free_orig_data, tern free_filt_data, tern free_buffer)
{
	si4		i;
	FILTPS_m13	*filtps;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// free cps filtps's
	
	if (cps == NULL)
		return_m13(FALSE_m13);

	if (cps->params.filtps == NULL)
		return_m13(FALSE_m13);
	for (i = 0; i < cps->params.n_filtps; ++i) {
		filtps = (FILTPS_m13 *) cps->params.filtps[i];
		if (filtps)
			FILT_free_m13(&filtps, free_orig_data, free_filt_data, free_buffer);
	}
	free_m13((void *) cps->params.filtps);
	cps->params.filtps = NULL;
	cps->params.n_filtps = 0;
		
	return_m13(TRUE_m13);
}


tern	FILT_free_m13(FILTPS_m13 **filtps_ptr, tern free_orig_data, tern free_filt_data, tern free_buffer)
{
	FILTPS_m13	*filtps;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (filtps_ptr == NULL) {
		G_set_error_m13(E_FILT_m13, "filtps_ptr is NULL");
		return_m13(FALSE_m13);
	}
	filtps = *filtps_ptr;
	if (filtps == NULL) {
		G_set_error_m13(E_FILT_m13, "filtps is NULL");
		return_m13(FALSE_m13);
	}

	if (filtps->numerators)
		free_m13((void *) filtps->numerators);
	if (filtps->denominators)
		free_m13((void *) filtps->denominators);
	if (filtps->initial_conditions)
		free_m13((void *) filtps->initial_conditions);
	if (filtps->orig_data)
		if (free_orig_data == TRUE_m13)  // IMPORTANT: if keeping orig_data, caller should have a copy of address to free when they're done to avoid a memory leak
			if (filtps->orig_data != filtps->filt_data)  // simple filter-in-place arrangement
				if (filtps->orig_data != FILT_OFFSET_ORIG_DATA_m13(filtps))  // efficient filter-in-place arrangement
					free_m13((void *) filtps->orig_data);
	if (filtps->filt_data)
		if (free_filt_data == TRUE_m13)  // IMPORTANT: if keeping filt_data, caller should have a copy of address to free when they're done to avoid a memory leak
			free_m13((void *) filtps->filt_data);
	if (filtps->buffer)
		if (free_buffer == TRUE_m13)
			free_m13((void *) filtps->buffer);
	
	if (freeable_m13((void *) filtps) == TRUE_m13)
		free_m13((void *) filtps);
	
	*filtps_ptr = NULL;
	
	return_m13(TRUE_m13);
}


tern	FILT_free_quantfilt_data_m13(QUANTFILT_DATA_m13 **qd_ptr)
{
	QUANTFILT_DATA_m13	*qd;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (qd_ptr == NULL) {
		G_set_error_m13(E_FILT_m13, "qd_ptr is NULL");
		return_m13(FALSE_m13);
	}
	qd = *qd_ptr;
	if (qd == NULL) {
		G_set_error_m13(E_FILT_m13, "qd is NULL");
		return_m13(FALSE_m13);
	}

	if (qd->x)
		free_m13((void *) qd->x);
	if (qd->qx)
		free_m13((void *) qd->qx);
	if (qd->nodes)
		free_m13((void *) qd->nodes);

	if (freeable_m13((void *) qd) == TRUE_m13)
		free_m13((void *) qd);
	
	*qd_ptr = NULL;

	return_m13(TRUE_m13);
}


tern	FILT_generate_initial_conditions_m13(FILTPS_m13 *filtps)
{
	si4 i, j, poles;
	sf8	**q, *rhs, *z, *num, *den;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	poles = filtps->n_poles;
	num = filtps->numerators;
	den = filtps->denominators;
	q = (sf8 **) calloc_2D_m13((size_t) poles, (size_t) poles, sizeof(sf8));
	
	rhs = (sf8 *) calloc((size_t) poles, sizeof(sf8));
	z = filtps->initial_conditions = (sf8 *) calloc_m13((size_t) poles, sizeof(sf8));
	
	q[0][0] = (sf8) 1.0 + den[1];
	for (i = 1, j = 2; i < poles; ++i, ++j)
		q[i][0] = den[j];
	for (i = 1; i < poles; ++i) {
		q[i - 1][i] = (sf8) -1.0;
		q[i][i] = (sf8) 1.0;
	}
	for (i = 0, j = 1; i < poles; ++i, ++j)
		rhs[i] = num[j] - (num[0] * den[j]);
	
	FILT_invert_matrix_m13(q, q, poles);
	FILT_mat_mult_m13(q, rhs, z, poles, poles, 1);
		
	free_m13((void *) q);
	free((void *) rhs);
	
	return_m13(TRUE_m13);
}


tern	FILT_hqr_m13(sf8 **a, si4 poles, FILT_COMPLEX_m13 *eigs)
{
	si4 nn, m, l, k, j, its, i, mmin, max;
	sf8  z, y, x, w, v, u, t, s, r, q, p, anorm, eps, t1, t2, t3, t4;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	anorm = (sf8) 0.0;
	eps = FILT_EPS_SF8_m13;
	
	for (i = 0; i < poles; i++) {
		max = ((i - 1) > 0) ? (i - 1) : 0;
		for (j = max; j < poles; j++) {
			anorm += FILT_ABS_m13(a[i][j]);
		}
	}
	
	nn = poles - 1;
	t = (sf8) 0.0;
	while (nn >= 0) {
		its = 0;
		do {
			for (l = nn; l > 0; l--) {
				t1 = FILT_ABS_m13(a[l - 1][l - 1]);
				t2 = FILT_ABS_m13(a[l][l]);
				s = t1 + t2;
				if (s == (sf8) 0.0)
					s = anorm;
				t1 = FILT_ABS_m13(a[l][l - 1]);
				if (t1 <= (eps * s)) {
					a[l][l - 1] = (sf8) 0.0;
					break;
				}
			}
			x = a[nn][nn];
			if (l == nn) {
				eigs[nn].real = x + t;
				eigs[nn--].imag = (sf8) 0.0;
			} else {
				y = a[nn - 1][nn - 1];
				w = a[nn][nn - 1] * a[nn - 1][nn];
				if (l == (nn - 1)) {
					p = (sf8) 0.5 * (y - x);
					q = (p * p) + w;
					z = sqrt(FILT_ABS_m13(q));
					x += t;
					if (q >= (sf8) 0.0) {
						t1 = FILT_SIGN_m13(z, p);
						z = p + t1;
						eigs[nn - 1].real = eigs[nn].real = x + z;
						if (z != (sf8) 0.0)
							eigs[nn].real = x - w / z;
					} else {
						eigs[nn].real = x + p;
						eigs[nn].imag = -z;
						eigs[nn - 1].real = eigs[nn].real;
						eigs[nn - 1].imag = -eigs[nn].imag;
					}
					nn -= 2;
				} else {
					if (its == 30) {
						G_set_error_m13(E_FILT_m13, "too many iterations in hqr");
						return_m13(-1);
					}
					if (its == 10 || its == 20) {
						t += x;
						for (i = 0; i < nn + 1; i++)
							a[i][i] -= x;
						t1 = FILT_ABS_m13(a[nn][nn - 1]);
						t2 = FILT_ABS_m13(a[nn - 1][nn - 2]);
						s = t1 + t2;
						y = x = (sf8) 0.75 * s;
						w = (sf8) -0.4375 * s * s;
					}
					++its;
					for (m = nn - 2; m >= l; m--) {
						z = a[m][m];
						r = x - z;
						s = y - z;
						p = ((r * s - w) / a[m + 1][m]) + a[m][m + 1];
						q = a[m + 1][m + 1] - z - r - s;
						r = a[m + 2][m + 1];
						t1 = FILT_ABS_m13(p);
						t2 = FILT_ABS_m13(q);
						t3 = FILT_ABS_m13(r);
						s = t1 + t2 + t3;
						p /= s;
						q /= s;
						r /= s;
						if (m == l)
							break;
						t1 = FILT_ABS_m13(a[m][m - 1]);
						t2 = FILT_ABS_m13(q);
						t3 = FILT_ABS_m13(r);
						u = t1 * (t2 + t3);
						t1 = FILT_ABS_m13(p);
						t2 = FILT_ABS_m13(a[m - 1][m - 1]);
						t3 = FILT_ABS_m13(z);
						t4 = FILT_ABS_m13(a[m + 1][m + 1]);
						v = t1 * (t2 + t3 + t4);
						if (u <= (eps * v))
							break;
					}
					for (i = m; i < (nn - 1); i++) {
						a[i + 2][i] = (sf8) 0.0;
						if (i != m)
							a[i + 2][i - 1] = (sf8) 0.0;
					}
					for (k = m; k < nn; k++) {
						if (k != m) {
							p = a[k][k - 1];
							q = a[k + 1][k - 1];
							r = (sf8) 0.0;
							if (k + 1 != nn)
								r = a[k + 2][k - 1];
							t1 = FILT_ABS_m13(p);
							t2 = FILT_ABS_m13(q);
							t3 = FILT_ABS_m13(r);
							if ((x = t1 + t2 + t3) != (sf8) 0.0) {
								p /= x;
								q /= x;
								r /= x;
							}
						}
						t1 = sqrt((p * p) + (q * q) + (r * r));
						s = FILT_SIGN_m13(t1, p);
						if (s != 0.0) {
							if (k == m) {
								if (l != m)
									a[k][k - 1] = -a[k][k - 1];
							} else
								a[k][k - 1] = -s * x;
							p += s;
							x = p / s;
							y = q / s;
							z = r / s;
							q /= p;
							r /= p;
							for (j = k; j < (nn + 1); j++) {
								p = a[k][j] + (q * a[k + 1][j]);
								if ((k + 1) != nn) {
									p += r * a[k + 2][j];
									a[k + 2][j] -= p * z;
								}
								a[k + 1][j] -= p * y;
								a[k][j] -= p * x;
							}
							mmin = nn < (k + 3) ? nn : k + 3;
							for (i = l; i < (mmin + 1); i++) {
								p = (x * a[i][k]) + (y * a[i][k + 1]);
								if ((k + 1) != nn) {
									p += z * a[i][k + 2];
									a[i][k + 2] -= p * r;
								}
								a[i][k + 1] -= p * q;
								a[i][k] -= p;
							}
						}
					}
				}
			}
		} while ((l + 1) < nn);
	}
	
	return_m13(TRUE_m13);
}


FILTPS_m13  *FILT_init_m13(si4 order, si4 type, sf8 samp_freq, si8 data_len, tern alloc_orig_data, tern alloc_filt_data, tern alloc_buffer, ui4 behavior, sf8 cutoff_1, ...)
{
	si8			  pad_samples, buf_len;
	FILTPS_m13	*filtps;
	va_list			  arg_p;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// allocate
	filtps = (FILTPS_m13 *) calloc_m13((size_t) 1, sizeof(FILTPS_m13));  // calloc b/c need zeroes in all fields
	
	// populate
	if (behavior == CURRENT_BEHAVIOR_m13)  // filtps has it's own behavior because return criteria often vary with filter parameters
		filtps->behavior = G_current_behavior_m13();
	else
		filtps->behavior = behavior;
	filtps->order = filtps->n_poles = order;
	filtps->type = type;
	filtps->sampling_frequency = samp_freq;
	filtps->data_length = data_len;
	filtps->order = filtps->n_poles = order;
	filtps->cutoffs[0] = cutoff_1;
	
	if (type == FILT_BANDPASS_TYPE_m13 || type == FILT_BANDSTOP_TYPE_m13) {
		va_start(arg_p, cutoff_1);
		filtps->cutoffs[1] = va_arg(arg_p, sf8);
		va_end(arg_p);
		filtps->n_poles *= 2;  // (poles == order * cutoffs)
	}
	
	// build filter
	if (FILT_butter_m13(filtps) == FILT_BAD_FILTER_m13) {
		if (!(filtps->behavior & SUPPRESS_OUTPUT_m13))
			G_warning_message_m13("%s(): bad filter\n", __FUNCTION__);
		if (filtps->behavior & RETURN_ON_FAIL_m13) {
			free_m13((void *) filtps);
			return_m13(NULL);
		}
		if (!(filtps->behavior & RETURN_ON_FAIL_m13))
			exit_m13(-1);
	}
	FILT_generate_initial_conditions_m13(filtps);

	// allocate
	filtps->orig_data = filtps->filt_data = filtps->buffer = NULL;
	if (alloc_orig_data == TRUE_m13)
		filtps->orig_data = (sf8 *) malloc_m13((size_t) data_len << 3);
	pad_samples = 2 * (FILT_PAD_SAMPLES_PER_POLE_m13 * filtps->n_poles);  // (FILT_PAD_SAMPLES_PER_POLE_m13 for each pole at front & back)
	buf_len = data_len + pad_samples;  // filt_data & buffer must have room for pads
	if (alloc_filt_data == TRUE_m13)
		filtps->filt_data = (sf8 *) malloc_m13((size_t) buf_len << 3);
	if (alloc_buffer == TRUE_m13)
		filtps->buffer = (sf8 *) malloc_m13((size_t) buf_len << 3);

	return_m13(filtps);
}


tern	FILT_invert_matrix_m13(sf8 **a, sf8 **inv_a, si4 order)  // done in place if a == inv_a
{
	si4	*indxc, *indxr, *ipiv;
	si4	i, icol, irow, j, k, l, ll;
	sf8	big, dum, pivinv, temp;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	indxc = (si4 *) calloc((size_t) order, sizeof(si4));
	indxr = (si4 *) calloc((size_t) order, sizeof(si4));
	ipiv = (si4 *) calloc((size_t) order, sizeof(si4));
	
	if (inv_a != a) {
		for (i = 0; i < order; i++)
			for (j = 0; j < order; j++)
				inv_a[i][j] = a[i][j];
	}
	
	for (i = 0; i < order; i++) {
		big = (sf8) 0.0;
		for (j = 0; j < order; j++)
			if (ipiv[j] != 1)
				for (k = 0; k < order; k++) {
					if (ipiv[k] == 0) {
						if (FILT_ABS_m13(inv_a[j][k]) >= big) {
							big = FILT_ABS_m13(inv_a[j][k]);
							irow = j;
							icol = k;
						}
					}
				}
		++ipiv[icol];
		if (irow != icol) {
			for (l = 0; l < order; l++) {
				temp = inv_a[irow][l];
				inv_a[irow][l] = inv_a[icol][l];
				inv_a[icol][l] = temp;
			}
		}
		indxr[i] = irow;
		indxc[i] = icol;
		if (inv_a[icol][icol] == (sf8) 0.0) {
			G_set_error_m13(E_FILT_m13, "singular matrix");
			return_m13(-1);
		}
		pivinv = (sf8) 1.0 / inv_a[icol][icol];
		inv_a[icol][icol] = (sf8) 1.0;
		for (l = 0; l < order; l++)
			inv_a[icol][l] *= pivinv;
		for (ll = 0; ll < order; ll++) {
			if (ll != icol) {
				dum = inv_a[ll][icol];
				inv_a[ll][icol] = (sf8) 0.0;
				for (l = 0; l < order;l++)
					inv_a[ll][l] -= inv_a[icol][l] * dum;
			}
		}
	}
	
	for (l = order - 1; l >= 0; l--) {
		if (indxr[l] != indxc[l]) {
			for (k = 0; k < order; k++) {
				temp = inv_a[k][indxr[l]];
				inv_a[k][indxr[l]] = inv_a[k][indxc[l]];
				inv_a[k][indxc[l]] = temp;
			}
		}
	}
	
	free((void *) ipiv);
	free((void *) indxr);
	free((void *) indxc);
	
	return_m13(TRUE_m13);
}


// Special thanks to Tej Stead for his work on this algorithm
sf8	FILT_line_noise_filter_m13(sf8 *y, sf8 *fy, si8 len, sf8 samp_freq, sf8 line_freq, si8 cycles_per_template, tern calculate_score, tern fast_mode, CMP_BUFFERS_m13 *lnf_buffers)
{
	tern			free_buffers;
	ui1				score;
	si4				filt_order, n_harmonics;
	FILTPS_m13	*filtps;
	si8				i, j, k, int_samps_per_cycle, n_templates, template_trace_len, last_template_start;
	sf8				samps_per_cycle, min_y, max_y, *sf8_p1, *sf8_p2, *sf8_p3;
	sf8				*low_y, *high_y, **template_mtx, *template_trace, *template_buf;
	sf8				amp_y, amp_n, high_f, max_high_f, sum, offset;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// if zero passed for cycles_per_template, it is set to line frequency cycles in 1 second
	// returns score == proportion of line noise in unfiltered data (range 0 - 1; -1 indicates errpr, nan indicates no score)

	filt_order = 4;  // degenerate above 4 for these settings
	free_buffers = FALSE_m13;
	if (lnf_buffers == NULL)
		free_buffers = TRUE_m13;
	lnf_buffers = CMP_allocate_buffers_m13(lnf_buffers, 4, len + (6 * filt_order), sizeof(sf8), FALSE_m13, FALSE_m13);  // also reallocates
	
	if (cycles_per_template == 0)  // default
		cycles_per_template = (si4) round(line_freq);
	samps_per_cycle = samp_freq / line_freq;

	int_samps_per_cycle = (si8) round(samps_per_cycle);
	// if (samps_per_cycle ~= ((sf8) int_samps_per_cycle)) {
		// could upsample data to nearest integer factor
		// ... but won't make a significant difference
	// }
	n_templates = len / int_samps_per_cycle;
	if (n_templates < cycles_per_template) {
		memcpy((void *) fy, (void *) y, (size_t) (len << 3));
		return_m13((sf8) -1.0);  // no score
	}
	
	// get min & max of input trace
	sf8_p1 = y;
	min_y = max_y = *sf8_p1++;
	for (i = len; --i; ++sf8_p1) {
		if (*sf8_p1 < min_y)
			min_y = *sf8_p1;
		else if (*sf8_p1 > max_y)
			max_y = *sf8_p1;
	}

	// generate low frequency trace (pass below 1/2 line frequency)
	filtps = FILT_init_m13(filt_order, FILT_LOWPASS_TYPE_m13, samp_freq, len, FALSE_m13, FALSE_m13, FALSE_m13, CURRENT_BEHAVIOR_m13, (line_freq / (sf8) 2.0));
	filtps->orig_data = y;
	filtps->filt_data = (sf8 *) lnf_buffers->buffer[0];
	filtps->buffer = (sf8 *) lnf_buffers->buffer[1];
	FILT_filtfilt_m13(filtps);
	FILT_free_m13(&filtps, FALSE_m13, FALSE_m13, FALSE_m13);
	low_y = (sf8 *) lnf_buffers->buffer[0];

	// subtract low frequencies from input (into fy)
	sf8_p1 = fy;  // passed
	sf8_p2 = y;  // passed
	sf8_p3 = low_y;  // in buf 0
	for (i = len; i--;)
		*sf8_p1++ = *sf8_p2++ - *sf8_p3++;
	high_y = fy;

	// make template matrix
	n_templates = len / int_samps_per_cycle;
	template_mtx = (sf8 **) malloc(int_samps_per_cycle * sizeof(sf8 *));
	for (i = 0; i < int_samps_per_cycle; ++i)
		template_mtx[i] = (sf8 *) malloc(n_templates << 3);
	for (i = k = 0; i < n_templates; ++i)
		for (j = 0; j < int_samps_per_cycle; ++j, ++k)
			template_mtx[j][i] = high_y[k];

	// quantfilt along sample dimension
	template_buf = (sf8 *) lnf_buffers->buffer[1];
	for (i = 0; i < int_samps_per_cycle; ++i) {
		FILT_quantfilt_m13(template_mtx[i], template_buf, n_templates, 0.5, cycles_per_template, FILT_EXTRAPOLATE_m13);
		memcpy(template_mtx[i], template_buf, (n_templates << 3));
	}
	
	// build template trace (into buf 1)
	template_trace = (sf8 *) lnf_buffers->buffer[1];
	for (i = k = 0; i < n_templates; ++i)
		for (j = 0; j < int_samps_per_cycle; ++j, ++k)
			template_trace[k] = template_mtx[j][i];
	template_trace_len = int_samps_per_cycle * n_templates;
	last_template_start = template_trace_len - int_samps_per_cycle;
	for (i = last_template_start, j = template_trace_len; j < len; ++i, ++j)
		template_trace[j] = template_trace[i];
	
	// smooth template
	if (fast_mode == FALSE_m13) {  // The operations below make the cleanest data, but the difference is minor. If you need speed, use fast_mode.
		n_harmonics = 10;
		high_f = (sf8) n_harmonics * line_freq;
		max_high_f = samp_freq / (sf8) 5.0;  // limit to at least 5 samps/cycle
		if (high_f > max_high_f)
			high_f = max_high_f;
		filtps = FILT_init_m13(filt_order, FILT_LOWPASS_TYPE_m13, samp_freq, len, FALSE_m13, FALSE_m13, FALSE_m13, CURRENT_BEHAVIOR_m13, high_f);
		filtps->orig_data = template_trace;  // in buf 1
		filtps->filt_data = (sf8 *) lnf_buffers->buffer[2];
		filtps->buffer = (sf8 *) lnf_buffers->buffer[3];
		FILT_filtfilt_m13(filtps);
		FILT_free_m13(&filtps, FALSE_m13, FALSE_m13, FALSE_m13);
		template_trace = (sf8 *) lnf_buffers->buffer[2];  // bufs 1 & 3 now available
		
		// subtract any residual offset (mean is OK here, but just do full cycles)
		sum = 0.0;
		sf8_p1 = template_trace;
		for (i = template_trace_len; i--;)
			sum += *sf8_p1++;
		offset = sum / (sf8) template_trace_len;
		sf8_p1 = template_trace;
		for (i = len; i--;)
			*sf8_p1++ -= offset;
	} else {  // just do a quick 5 point moving average filter
		FILT_moving_average_m13(template_trace, (sf8 *) lnf_buffers->buffer[2], len, 5, FILT_TRUNCATE_m13);
		template_trace = (sf8 *) lnf_buffers->buffer[2];
	}
	
	// calculate score
	if (calculate_score == TRUE_m13) {  // If you need speed, and can do without the score, make this FALSE.
		// get amplitude of high_y
		amp_y = CMP_trace_amplitude_m13(high_y, (sf8 *) lnf_buffers->buffer[1], len, FALSE_m13);
		
		// get amplitude of template trace
		amp_n = CMP_trace_amplitude_m13(template_trace, (sf8 *) lnf_buffers->buffer[1], len, FALSE_m13);
		
		score = amp_n / (amp_n + amp_y);
	} else {
		score = NAN;
	}
			
	// subtract template, restore low frequencies, & correct overflows (from filtering)
	sf8_p1 = fy; // == high_y;
	sf8_p2 = low_y;  // in buf 0
	sf8_p3 = template_trace;  // now in buf 2
	for (i = len; i--; ++sf8_p1) {
		*sf8_p1 += (*sf8_p2++ - *sf8_p3++);
		if (*sf8_p1 < min_y)
			*sf8_p1 = min_y;
		else if (*sf8_p1 > max_y)
			*sf8_p1 = max_y;
	}
	
	// clean up
	for (i = 0; i < int_samps_per_cycle; ++i)
		free((void *) template_mtx[i]);
	free((void *) template_mtx);
	if (free_buffers == TRUE_m13)
		CMP_free_buffers_m13(&lnf_buffers);
	
	return_m13(score);
}


void	FILT_mat_mult_m13(void *a, void *b, void *product, si4 outer_dim1, si4 inner_dim, si4 outer_dim2)
{
	si4	i, j, k, v1, v2, vp;
	sf8	sum, t1, t2, *av, **am, *bv, **bm, *pv, **pm;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if ((outer_dim1 == 1) || (inner_dim == 1)) {
		av = (sf8 *) a;
		v1 = 1;
	} else {
		am = (sf8 **) a;
		v1 = 0;
	}
	if ((outer_dim2 == 1) || (inner_dim == 1)) {
		bv = (sf8 *) b;
		v2 = 1;
	} else {
		bm = (sf8 **) b;
		v2 = 0;
	}
	if ((outer_dim1 == 1) || (outer_dim2 == 1)) {
		pv = (sf8 *) product;
		vp = 1;
	} else {
		pm = (sf8 **) product;
		vp = 0;
	}
	
	for (i = 0; i < outer_dim1; ++i) {
		for (j = 0; j < outer_dim2; ++j) {
			sum = 0.0;
			for (k = 0; k < inner_dim; ++k) {
				t1 = (v1) ? av[k] : am[i][k];
				t2 = (v2) ? bv[k] : bm[k][j];
				sum += t1 * t2;
			}
			if (vp) {
				if (outer_dim1 == 1)
					pv[j] = sum;
				else
					pv[i] = sum;
			} else {
				pm[i][j] = sum;
			}
		}
	}
	
	
	return_void_m13;
}


sf8	*FILT_moving_average_m13(sf8 *x, sf8 *ax, si8 len, si8 span, si1 tail_option_code)
{
	si8	i;
	sf8	sum, length, val, *in_tail_p, *in_head_p, *out_p, *end_x_p;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (ax == NULL)
		ax = malloc((size_t) (len << 3));
		
	// make span odd
	if (!(span & 1))
		++span;
	
	// initial window
	in_tail_p = in_head_p = x;
	end_x_p = x + len;
	out_p = ax;
	
	switch (tail_option_code) {
		case FILT_TRUNCATE_m13:
			sum = *out_p++ = *in_head_p++;
			length = (sf8) 1.0;
			while (length < (sf8) span) {
				sum += *in_head_p++;
				sum += *in_head_p++;
				*out_p++ = sum / (length += (sf8) 2.0);
			}
			break;
		case FILT_EXTRAPOLATE_m13:
			sum = 0.0;
			for (i = span; i--;)
				sum += *in_head_p++;
			val = sum / (sf8) span;
			for (i = (span >> 1) + 1; i--;)
				*out_p++ = val;
			break;
		case FILT_ZEROPAD_m13:
			sum = 0.0;
			for (i = span; i--;)
				sum += *in_head_p++;
			memset((void *) ax, 0, (size_t) ((span >> 1) + 1) << 3);
			out_p = ax + ((span >> 1) + 1);
			break;
		default:
			G_set_error_m13(E_FILT_m13, "unrecognized tail option");
			return_m13(NULL);
	}
	
	// slide window
	length = (sf8) span;
	while (in_head_p < end_x_p) {
		sum -= *in_tail_p++;
		sum += *in_head_p++;
		*out_p++ = sum / length;
	}
	
	// terminal window
	switch (tail_option_code) {
		case FILT_TRUNCATE_m13:
			while (in_tail_p < end_x_p) {
				sum -= *in_tail_p++;
				sum -= *in_tail_p++;
				*out_p++ = sum / (length -= (sf8) 2.0);
			}
			*out_p = x[len - 1];
			break;
		case FILT_EXTRAPOLATE_m13:
			val = *(out_p - 1);
			end_x_p = ax + len;
			while (out_p < end_x_p)
				*out_p++ = val;
			break;
		case FILT_ZEROPAD_m13:
			val = 0.0;
			end_x_p = ax + len;
			while (out_p < end_x_p)
				*out_p++ = val;
			break;
	}

	return_m13(ax);
}


sf8  *FILT_noise_floor_filter_m13(sf8 *data, sf8 *filt_data, si8 data_len, sf8 rel_thresh, sf8 abs_thresh, CMP_BUFFERS_m13 *nff_buffers)
{
	register si8	i, j, k;
	tern	free_buffers;
	si8		n_peaks, n_troughs, *peak_xs, *trough_xs, x, xm1, dlm1;
	sf8		*peak_env, *trough_env, *mean_env, *env_diffs, base, baseline, dy, step, *quantval_buf, thresh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (filt_data == NULL)
		filt_data = (sf8 *) malloc((size_t) (data_len << 3));

	free_buffers = FALSE_m13;
	if (nff_buffers == NULL)
		free_buffers = TRUE_m13;
	nff_buffers = CMP_allocate_buffers_m13(nff_buffers, 4, data_len, sizeof(sf8), FALSE_m13, FALSE_m13);  // also reallocates
	peak_xs = (si8 *) nff_buffers->buffer[0];
	trough_xs = (si8 *) nff_buffers->buffer[1];
	peak_env = (sf8 *) nff_buffers->buffer[2];
	trough_env = (sf8 *) nff_buffers->buffer[3];
	
	// find critical points
	CMP_find_crits_2_m13(data, data_len, &n_peaks, peak_xs, &n_troughs, trough_xs);
	if (n_peaks == 0)
		return_m13(NULL);
	
	// create peak envelope
	peak_env[0] = data[0];
	x = peak_xs[0];
	for (i = 1; i < n_peaks; ++i) {
		xm1 = x;
		x = peak_xs[i];
		base = data[xm1];
		dy = data[x] - base;
		step = dy / (sf8) (x - xm1);
		for (j = xm1 + 1; j <= x; ++j)
			peak_env[j] = (base += step);
	}
	
	// create trough envelope
	trough_env[0] = data[0];
	x = trough_xs[0];
	for (i = 1; i < n_troughs; ++i) {
		xm1 = x;
		x = trough_xs[i];
		base = data[xm1];
		dy = data[x] - base;
		step = dy / (sf8) (x - xm1);
		for (j = xm1 + 1; j <= x; ++j)
			trough_env[j] = (base += step);
	}
	
	// transform envelopes to means & differences
	env_diffs = peak_env;
	mean_env = trough_env;
	for (i = 0; i < data_len; ++i) {
		env_diffs[i] -= trough_env[i];
		mean_env[i] += env_diffs[i] / (sf8) 2.0;
	}

	// get median of envelope difference time series
	if (rel_thresh > 0.0) {
		quantval_buf = (sf8 *) trough_xs;
		baseline = CMP_quantval_m13(env_diffs, data_len, 0.5, TRUE_m13, quantval_buf);
		thresh = (baseline / (sf8) 2.0) * rel_thresh;
	} else {
		thresh = abs_thresh;
	}

	// replace large dy with original data
	dlm1 = data_len - 1;;
	for (i = 1, j = 0, k = 2; i < dlm1; ++i, ++j, ++k) {
		if (env_diffs[i] > thresh) {
			if (env_diffs[j] <= thresh && env_diffs[k] <= thresh) // skip points that exceed thresh for just 1 sample
				continue;
			mean_env[i] = data[i];
		}
	}
	
	// copy to output
	memcpy((void *) filt_data, (void *) mean_env, (size_t) (data_len << 3));
	
	// release resources
	if (free_buffers == TRUE_m13)
		CMP_free_buffers_m13(&nff_buffers);
	
	return_m13(filt_data);
}


sf8	*FILT_quantfilt_m13(sf8 *x, sf8 *qx, si8 len, sf8 quantile, si8 span, si1 tail_option_code)
{
	FILT_NODE_m13	*nodes, head, tail, *new_node, *prev_new_node, *curr_node, *next_node, *prev_node, *low_q_node, *oldest_node;
	si8 	i, new_span, out_idx, in_idx, low_q_idx, oldest_idx, last_sliding_out_idx, odd_span;
	sf8 	new_val, prev_new_val, temp_idx, low_val_q, high_val_q, low_q_val, high_q_val, true_q_val, q_shift, oldest_val;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// setup
	if (len < span)
		span = len;
	if (qx == NULL) // caller responsible for freeing qx
		qx = (sf8 *) calloc_m13((size_t) len, sizeof(sf8));
	nodes = (FILT_NODE_m13 *) calloc((size_t) (span + 1), sizeof(FILT_NODE_m13));
	new_node = nodes;
	head.val = -DBL_MAX;
	head.next = new_node;
	tail.val = DBL_MAX;
	tail.prev = new_node;
	new_node->val = x[0];
	new_node->next = &tail;
	new_node->prev = &head;
	in_idx = 1;
	out_idx = 0;
	odd_span = span & 1;

	if (odd_span) {
		qx[out_idx++] = prev_new_val = new_node->val;
		prev_new_node = new_node++;
	} else {  // even span
		prev_new_node = new_node++;
		prev_new_val = prev_new_node->val;
		new_val = new_node->val = x[in_idx++];
		if (new_val < prev_new_val) {
			new_node->next = prev_new_node;
			new_node->prev = prev_new_node->prev;
			prev_new_node->prev = new_node;
			head.next = new_node;
		} else {
			new_node->next = prev_new_node->next;
			new_node->prev = prev_new_node;
			prev_new_node->next = new_node;
			tail.prev = new_node;
		}
		low_q_node = head.next;
		low_q_val = low_q_node->val;
		high_q_val = (low_q_node->next)->val;
		qx[out_idx++] = (((sf8) 1.0 - quantile) * low_q_val) + (quantile * high_q_val);
		prev_new_node = new_node++;
		prev_new_val = new_val;
	}

	// fill initial node array
	while (in_idx < span) {
		 
		// insert a new node
		new_val = new_node->val = x[in_idx++];
		curr_node = prev_new_node;
		if (new_val >= prev_new_val) {
			// search forward
			while (1) {
				next_node = curr_node->next;
				if (new_val < next_node->val)
					break;
				curr_node = next_node;
			}
			// insert new_node after curr_node
			new_node->prev = curr_node;
			new_node->next = next_node;
			curr_node->next = new_node;
			next_node->prev = new_node;
		} else {  // new_val < prev_new_val
			// search backward
			while (1) {
				prev_node = curr_node->prev;
				if (new_val >= prev_node->val)
					break;
				curr_node = prev_node;
			}
			// insert new_node before curr_node
			new_node->next = curr_node;
			new_node->prev = prev_node;
			curr_node->prev = new_node;
			prev_node->next = new_node;
		}
		
		// insert another new node
		prev_new_node = new_node++;
		prev_new_val = new_val;
		new_val = new_node->val = x[in_idx++];
		curr_node = prev_new_node;
		if (new_val >= prev_new_val) {
			// search forward
			while (1) {
				next_node = curr_node->next;
				if (new_val < next_node->val)
					break;
				curr_node = next_node;
			}
			// insert new_node after curr_node
			new_node->prev = curr_node;
			new_node->next = next_node;
			curr_node->next = new_node;
			next_node->prev = new_node;
		} else {  // new_val < prev_new_val
			// search backward
			while (1) {
				prev_node = curr_node->prev;
				if (new_val >= prev_node->val)
					break;
				curr_node = prev_node;
			}
			// insert new_node before curr_node
			new_node->next = curr_node;
			new_node->prev = prev_node;
			curr_node->prev = new_node;
			prev_node->next = new_node;
		}

		// calculate output
		if (quantile != (sf8) 1.0) {
			temp_idx = quantile * (sf8) (in_idx - 1);
			low_q_idx = (ui8) temp_idx;
			high_val_q = temp_idx - (sf8) low_q_idx;
			low_val_q = (sf8) 1.0 - high_val_q;
			curr_node = head.next;
			for (i = low_q_idx; i--;)
				curr_node = curr_node->next;
			low_q_val = (low_q_node = curr_node)->val;
			high_q_val = (low_q_node->next)->val;
			qx[out_idx++] = (low_q_val * low_val_q) + (high_q_val * high_val_q);
		} else {  // quantile == 1.0
			qx[out_idx++] = (curr_node = tail.prev)->val;
		}
		
		// update loop variables
		prev_new_node = new_node++;
		prev_new_val = new_val;
	}
	
	// handle other tail options (for initial window)
	if (tail_option_code == FILT_EXTRAPOLATE_m13) {
		true_q_val = qx[out_idx - 1];
		for (i = out_idx - 1; i--;)
			qx[i] = true_q_val;
	} else if (tail_option_code == FILT_ZEROPAD_m13) {
		for (i = out_idx - 1; i--;)
			qx[i] = (sf8) 0.0;
	}
		
	// slide window (main loop)
	oldest_idx = 0;
	oldest_node = nodes;
	oldest_val = oldest_node->val;
	low_q_node = curr_node;
	low_q_val = low_q_node->val;
	while (in_idx < len) {
		
		// insert new value into empty node
		new_node->val = new_val = x[in_idx];
		curr_node = prev_new_node;
		if (new_val >= prev_new_val) {
			// search forward
			while (1) {
				next_node = curr_node->next;
				if (new_val < next_node->val)
					break;
				curr_node = next_node;
			}
			// insert new_node after curr_node
			new_node->prev = curr_node;
			new_node->next = next_node;
			curr_node->next = new_node;
			next_node->prev = new_node;
		} else {  // new_val < prev_new_val
			// search backward
			while (1) {
				prev_node = curr_node->prev;
				if (new_val >= prev_node->val)
					break;
				curr_node = prev_node;
			}
			// insert new_node before curr_node
			new_node->next = curr_node;
			new_node->prev = prev_node;
			curr_node->prev = new_node;
			prev_node->next = new_node;
		}
		
		// update q node
		if (new_val >= low_q_val) {
			q_shift = (sf8) 0.5;
		} else {  // new_val < low_q_val
			q_shift = (sf8) -0.5;
		}
		if (oldest_val > low_q_val) {
			q_shift -= (sf8) 0.5;
		} else if (oldest_val < low_q_val) {
			q_shift += (sf8) 0.5;
		} else {  // oldest_val == low_q_val
			if (oldest_node == low_q_node) {
				q_shift *= (sf8) 2.0;
			} else {  // oldest_node != low_q_node
				q_shift += (sf8) 0.5;
			}
		}
		
		// remove oldest node
		(oldest_node->prev)->next = oldest_node->next;
		(oldest_node->next)->prev = oldest_node->prev;
		
		// update q node
		if (q_shift == (sf8) 1.0)
			low_q_node = low_q_node->next;
		else if (q_shift == (sf8) -1.0)
			low_q_node = low_q_node->prev;
		
		// output new q value
		if (quantile != (sf8) 1.0) {
			low_q_val = low_q_node->val;
			high_q_val = (low_q_node->next)->val;
			qx[out_idx] = (low_q_val * low_val_q) + (high_q_val * high_val_q);
		} else {  // quantile == 1.0
			qx[out_idx] = low_q_val = (low_q_node = tail.prev)->val;
		}
		
		// update rotating indices
		prev_new_node = new_node;
		prev_new_val = new_val;
		new_node = oldest_node;
		if (++oldest_idx > span)
		  oldest_idx = 0;
		oldest_node = nodes + oldest_idx;
		oldest_val = oldest_node->val;
		
		// update non-rotating indices
		++in_idx;
		++out_idx;
	}
	
	// build terminal window (for "truncate" tail option)
	last_sliding_out_idx = out_idx;
	if (tail_option_code == FILT_TRUNCATE_m13) {
		for (new_span = span - 3; new_span > 0; new_span -= 2) {
			
			// remove oldest node
			(oldest_node->prev)->next = oldest_node->next;
			(oldest_node->next)->prev = oldest_node->prev;
			if (++oldest_idx > span)
			  oldest_idx = 0;
			oldest_node = nodes + oldest_idx;

			// remove next oldest node
			(oldest_node->prev)->next = oldest_node->next;
			(oldest_node->next)->prev = oldest_node->prev;
			if (++oldest_idx > span)
			  oldest_idx = 0;
			oldest_node = nodes + oldest_idx;

			// calculate output
			if (quantile != (sf8) 1.0) {
				temp_idx = quantile * (sf8) new_span;
				low_q_idx = (ui8) temp_idx;
				high_val_q = temp_idx - (sf8) low_q_idx;
				low_val_q = (sf8) 1.0 - high_val_q;
				low_q_node = head.next;
				for (i = low_q_idx; i--;)
					low_q_node = low_q_node->next;
				low_q_val = low_q_node->val;
				high_q_val = (low_q_node->next)->val;
				qx[out_idx++] = (low_q_val * low_val_q) + (high_q_val * high_val_q);
			} else {  // quantile == 1.0
				qx[out_idx++] = (tail.prev)->val;
			}
		}
		qx[len - 1] = x[len - 1];
	}
	
	// handle other tail options (for terminal window)
	else if (tail_option_code == FILT_EXTRAPOLATE_m13) {
		true_q_val = qx[last_sliding_out_idx - 1];
		for (i = last_sliding_out_idx; i < len; ++i)
			qx[i] = true_q_val;
	} else if (tail_option_code == FILT_ZEROPAD_m13) {
		for (i = last_sliding_out_idx; i < len; ++i)
			qx[i] = (sf8) 0.0;
	}
	
	// clean up
	free(nodes);

	return_m13(qx);
}


QUANTFILT_DATA_m13	*FILT_quantfilt_head_m13(QUANTFILT_DATA_m13 *qd, ...)  // varargs: sf8 *x, sf8 *qx, si8 len, sf8 quantile, si8 span, si4 tail_option_code
{
	si1 		tail_option_code;
	si8 		i, len, span, out_idx, in_idx, low_q_idx, odd_span;
	sf8 		*x, *qx, quantile, new_val, prev_new_val, temp_idx, low_val_q, high_val_q, low_q_val, high_q_val, true_q_val;
	FILT_NODE_m13	*head, *tail, *new_node, *prev_new_node, *curr_node, *next_node, *prev_node, *low_q_node;
	va_list		v_args;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// setup
	if (qd == NULL) {
		qd = (QUANTFILT_DATA_m13 *) calloc_m13((size_t) 1, sizeof(QUANTFILT_DATA_m13));
		// get varargs
		va_start(v_args, qd);
		qd->x = va_arg(v_args, sf8 *);
		qd->qx = va_arg(v_args, sf8 *);
		qd->len = va_arg(v_args, si8);
		qd->quantile = va_arg(v_args, sf8);
		qd->span = va_arg(v_args, si8);
		qd->tail_option_code = (si1) va_arg(v_args, si4);
		va_end(v_args);
	}

	// allocate
	if (qd->qx == NULL)
		qd->qx = (sf8 *) calloc_m13((size_t) qd->len, sizeof(sf8));
	if (qd->nodes == NULL)
		qd->nodes = (FILT_NODE_m13 *) calloc((size_t) (qd->span + 1), sizeof(FILT_NODE_m13));

	// get temp variables
	len = qd->len;
	span = qd->span;
	if (len < span)
		span = len;
	tail_option_code = qd->tail_option_code;
	head = &qd->head;
	tail = &qd->tail;
	x = qd->x;
	qx = qd->qx;
	quantile = qd->quantile;

	new_node = qd->nodes;
	head->val = -DBL_MAX;
	head->next = new_node;
	tail->val = DBL_MAX;
	tail->prev = new_node;
	new_node->val = x[0];
	new_node->next = tail;
	new_node->prev = head;
	in_idx = 1;
	out_idx = 0;
	odd_span = span & 1;
	
	
	if (odd_span) {
		qx[out_idx++] = prev_new_val = new_node->val;
		prev_new_node = new_node++;
	} else {  // even span
		prev_new_node = new_node++;
		prev_new_val = prev_new_node->val;
		new_val = new_node->val = x[in_idx++];
		if (new_val < prev_new_val) {
			new_node->next = prev_new_node;
			new_node->prev = prev_new_node->prev;
			prev_new_node->prev = new_node;
			head->next = new_node;
		} else {
			new_node->next = prev_new_node->next;
			new_node->prev = prev_new_node;
			prev_new_node->next = new_node;
			tail->prev = new_node;
		}
		low_q_node = head->next;
		low_q_val = low_q_node->val;
		high_q_val = (low_q_node->next)->val;
		qx[out_idx++] = (((sf8) 1.0 - quantile) * low_q_val) + (quantile * high_q_val);
		prev_new_node = new_node++;
		prev_new_val = new_val;
	}
	
	// fill initial node array
	while (in_idx < span) {
		
		// insert a new node
		new_val = new_node->val = x[in_idx++];
		curr_node = prev_new_node;
		if (new_val >= prev_new_val) {
			// search forward
			while (1) {
				next_node = curr_node->next;
				if (new_val < next_node->val)
					break;
				curr_node = next_node;
			}
			// insert new_node after curr_node
			new_node->prev = curr_node;
			new_node->next = next_node;
			curr_node->next = new_node;
			next_node->prev = new_node;
		} else {  // new_val < prev_new_val
			// search backward
			while (1) {
				prev_node = curr_node->prev;
				if (new_val >= prev_node->val)
					break;
				curr_node = prev_node;
			}
			// insert new_node before curr_node
			new_node->next = curr_node;
			new_node->prev = prev_node;
			curr_node->prev = new_node;
			prev_node->next = new_node;
		}
		
		// insert another new node
		prev_new_node = new_node++;
		prev_new_val = new_val;
		new_val = new_node->val = x[in_idx++];
		curr_node = prev_new_node;
		if (new_val >= prev_new_val) {
			// search forward
			while (1) {
				next_node = curr_node->next;
				if (new_val < next_node->val)
					break;
				curr_node = next_node;
			}
			// insert new_node after curr_node
			new_node->prev = curr_node;
			new_node->next = next_node;
			curr_node->next = new_node;
			next_node->prev = new_node;
		} else {  // new_val < prev_new_val
			// search backward
			while (1) {
				prev_node = curr_node->prev;
				if (new_val >= prev_node->val)
					break;
				curr_node = prev_node;
			}
			// insert new_node before curr_node
			new_node->next = curr_node;
			new_node->prev = prev_node;
			curr_node->prev = new_node;
			prev_node->next = new_node;
		}
		
		// calculate output
		if (quantile != (sf8) 1.0) {
			temp_idx = quantile * (sf8) (in_idx - 1);
			low_q_idx = (ui8) temp_idx;
			high_val_q = temp_idx - (sf8) low_q_idx;
			low_val_q = (sf8) 1.0 - high_val_q;
			curr_node = head->next;
			for (i = low_q_idx; i--;)
				curr_node = curr_node->next;
			low_q_val = (low_q_node = curr_node)->val;
			high_q_val = (low_q_node->next)->val;
			qx[out_idx++] = (low_q_val * low_val_q) + (high_q_val * high_val_q);
		} else {  // quantile == 1.0
			qx[out_idx++] = (curr_node = tail->prev)->val;
		}
		
		// update loop variables
		prev_new_node = new_node++;
		prev_new_val = new_val;
	}
	
	// handle other tail options (for initial window)
	if (tail_option_code == FILT_EXTRAPOLATE_m13) {
		true_q_val = qx[out_idx - 1];
		for (i = out_idx - 1; i--;)
			qx[i] = true_q_val;
	} else if (tail_option_code == FILT_ZEROPAD_m13) {
		for (i = out_idx - 1; i--;)
			qx[i] = (sf8) 0.0;
	}
	
	// set structure variables
	qd->oldest_idx = 0;
	qd->oldest_node = qd->nodes;
	qd->curr_node = curr_node;
	qd->in_idx = in_idx;
	qd->out_idx = out_idx;
	qd->low_val_q = low_val_q;
	qd->high_val_q = high_val_q;

	return_m13(qd);
}
	

tern	FILT_quantfilt_mid_m13(QUANTFILT_DATA_m13 *qd)
{
	si8 	len, span, out_idx, in_idx, oldest_idx;
	sf8 	*x, *qx, quantile, new_val, prev_new_val, low_val_q, high_val_q, low_q_val, high_q_val, q_shift, oldest_val;
	FILT_NODE_m13	*nodes, *new_node, *prev_new_node, *tail, *curr_node, *next_node, *prev_node, *low_q_node, *oldest_node;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// get temp variables
	len = qd->len;
	span = qd->span;
	if (len < span)
		span = len;
	x = qd->x;
	qx = qd->qx;
	oldest_idx = qd->oldest_idx;
	nodes = qd->nodes;
	tail = &qd->tail;
	oldest_node = qd->oldest_node;
	low_q_node = qd->curr_node;
	in_idx = qd->in_idx;
	out_idx = qd->out_idx;
	quantile = qd->quantile;
	low_val_q = qd->low_val_q;
	high_val_q = qd->high_val_q;


	// slide window (main loop)
	low_q_val = low_q_node->val;
	while (in_idx < len) {
		
		// insert new value into empty node
		new_node->val = new_val = x[in_idx];
		curr_node = prev_new_node;
		if (new_val >= prev_new_val) {
			// search forward
			while (1) {
				next_node = curr_node->next;
				if (new_val < next_node->val)
					break;
				curr_node = next_node;
			}
			// insert new_node after curr_node
			new_node->prev = curr_node;
			new_node->next = next_node;
			curr_node->next = new_node;
			next_node->prev = new_node;
		} else {  // new_val < prev_new_val
			// search backward
			while (1) {
				prev_node = curr_node->prev;
				if (new_val >= prev_node->val)
					break;
				curr_node = prev_node;
			}
			// insert new_node before curr_node
			new_node->next = curr_node;
			new_node->prev = prev_node;
			curr_node->prev = new_node;
			prev_node->next = new_node;
		}
		
		// update q node
		if (new_val >= low_q_val) {
			q_shift = (sf8) 0.5;
		} else {  // new_val < low_q_val
			q_shift = (sf8) -0.5;
		}
		if (oldest_val > low_q_val) {
			q_shift -= (sf8) 0.5;
		} else if (oldest_val < low_q_val) {
			q_shift += (sf8) 0.5;
		} else {  // oldest_val == low_q_val
			if (oldest_node == low_q_node) {
				q_shift *= (sf8) 2.0;
			} else {  // oldest_node != low_q_node
				q_shift += (sf8) 0.5;
			}
		}
		
		// remove oldest node
		(oldest_node->prev)->next = oldest_node->next;
		(oldest_node->next)->prev = oldest_node->prev;
		
		// update q node
		if (q_shift == (sf8) 1.0)
			low_q_node = low_q_node->next;
		else if (q_shift == (sf8) -1.0)
			low_q_node = low_q_node->prev;
		
		// output new q value
		if (quantile != (sf8) 1.0) {
			low_q_val = low_q_node->val;
			high_q_val = (low_q_node->next)->val;
			qx[out_idx] = (low_q_val * low_val_q) + (high_q_val * high_val_q);
		} else {  // quantile == 1.0
			qx[out_idx] = low_q_val = (low_q_node = tail->prev)->val;
		}
		
		// update rotating indices
		prev_new_node = new_node;
		prev_new_val = new_val;
		new_node = oldest_node;
		if (++oldest_idx > span)
			oldest_idx = 0;
		oldest_node = nodes + oldest_idx;
		oldest_val = oldest_node->val;
		
		// update non-rotating indices
		++in_idx;
		++out_idx;
	}
	
	// set structure variables
	qd->oldest_idx = oldest_idx;
	qd->oldest_node = oldest_node;
	qd->curr_node = curr_node;
	qd->in_idx = in_idx;
	qd->out_idx = out_idx;
	
	return_m13(TRUE_m13);
}


tern	FILT_quantfilt_tail_m13(QUANTFILT_DATA_m13 *qd)
{
	si8 	i, len, span, new_span, out_idx, low_q_idx, oldest_idx, last_sliding_out_idx;
	sf8 	*x, *qx, quantile, temp_idx, low_val_q, high_val_q, low_q_val, high_q_val, true_q_val;
	FILT_NODE_m13	*nodes, *head, *tail, *low_q_node, *oldest_node;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// get temp variables
	x = qd->x;
	qx = qd->qx;
	nodes = qd->nodes;
	oldest_idx = qd->oldest_idx;
	oldest_node = qd->oldest_node;
	low_q_node = qd->curr_node;
	out_idx = qd->out_idx;
	quantile = qd->quantile;
	span = qd->span;
	len = qd->len;
	if (len < span)
		span = len;
	head = &qd->head;
	tail = &qd->tail;
	
	// build terminal window (for "truncate" tail option)
	last_sliding_out_idx = out_idx;
	if (qd->tail_option_code == FILT_TRUNCATE_m13) {
		for (new_span = span - 3; new_span > 0; new_span -= 2) {
			
			// remove oldest node
			(oldest_node->prev)->next = oldest_node->next;
			(oldest_node->next)->prev = oldest_node->prev;
			if (++oldest_idx > span)
			  oldest_idx = 0;
			oldest_node = nodes + oldest_idx;

			// remove next oldest node
			(oldest_node->prev)->next = oldest_node->next;
			(oldest_node->next)->prev = oldest_node->prev;
			if (++oldest_idx > span)
			  oldest_idx = 0;
			oldest_node = nodes + oldest_idx;

			// calculate output
			if (qd->quantile != (sf8) 1.0) {
				temp_idx = quantile * (sf8) new_span;
				low_q_idx = (ui8) temp_idx;
				high_val_q = temp_idx - (sf8) low_q_idx;
				low_val_q = (sf8) 1.0 - high_val_q;
				low_q_node = head->next;
				for (i = low_q_idx; i--;)
					low_q_node = low_q_node->next;
				low_q_val = low_q_node->val;
				high_q_val = (low_q_node->next)->val;
				qx[out_idx++] = (low_q_val * low_val_q) + (high_q_val * high_val_q);
			} else {  // quantile == 1.0
				qx[out_idx++] = (tail->prev)->val;
			}
		}
		qx[len - 1] = x[len - 1];
	}
	
	// handle other tail options (for terminal window)
	else if (qd->tail_option_code == FILT_EXTRAPOLATE_m13) {
		true_q_val = qx[last_sliding_out_idx - 1];
		for (i = last_sliding_out_idx; i < len; ++i)
			qx[i] = true_q_val;
	} else if (qd->tail_option_code == FILT_ZEROPAD_m13) {
		for (i = last_sliding_out_idx; i < len; ++i)
			qx[i] = (sf8) 0.0;
	}
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4 FILT_sf8_sort_m13(const void *n1, const void *n2)
{
	if (*((sf8 *) n1) > *((sf8 *) n2))
		return(1);
	else if (*((sf8 *) n1) < *((sf8 *) n2))
		return(-1);
	
	return(0);
}


tern	FILT_show_FILTPS_m13(FILTPS_m13 *filt_ps)
{
	si4	i;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	printf_m13("\n\n----------- Filter Processing Structure - START ----------\n");
	printf_m13("behavior: %u\n", filt_ps->behavior);
	printf_m13("order: %d\n", filt_ps->order);
	printf_m13("n_poles: %d\n", filt_ps->n_poles);
	printf_m13("type: %d\n", filt_ps->type);
	printf_m13("sampling_frequency: %lf\n", filt_ps->sampling_frequency);
	printf_m13("data_length: %ld\n", filt_ps->data_length);
	printf_m13("cutoffs[0]: %lf\n", filt_ps->cutoffs[0]);
	if (filt_ps->type == FILT_BANDPASS_TYPE_m13 || filt_ps->type == FILT_BANDSTOP_TYPE_m13)
		printf_m13("cutoffs[1]: %lf\n", filt_ps->cutoffs[1]);
	if (filt_ps->numerators == NULL) {
		printf_m13("numerators: NULL\n");
	} else {
		for (i = 0; i <= filt_ps->n_poles; ++i)
			printf_m13("numerators[%d]: %lf\n", i, filt_ps->numerators[i]);
	}
	if (filt_ps->denominators == NULL) {
		printf_m13("denominators: NULL\n");
	} else {
		for (i = 0; i <= filt_ps->n_poles; ++i)
			printf_m13("denominators[%d]: %lf\n", i, filt_ps->denominators[i]);
	}
	if (filt_ps->initial_conditions == NULL) {
		printf_m13("initial_conditions: NULL\n");
	} else {
		for (i = 0; i < filt_ps->n_poles; ++i)
			printf_m13("initial_conditions[%d]: %lf\n", i, filt_ps->initial_conditions[i]);
	}
	if (filt_ps->orig_data)
		printf_m13("orig_data: NULL\n");
	else
		printf_m13("orig_data: assigned\n");
	if (filt_ps->filt_data)
		printf_m13("filt_data: NULL\n");
	else
		printf_m13("filt_data: assigned\n");
	if (filt_ps->buffer)
		printf_m13("buffer: NULL\n");
	else
		printf_m13("buffer: assigned\n");
	printf_m13("------------ Filter Processing Structure - END -----------\n\n");

	return_m13(TRUE_m13);
}


tern	FILT_unsymmeig_m13(sf8 **a, si4 poles, FILT_COMPLEX_m13 *eigs)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	FILT_balance_m13(a, poles);
	FILT_elmhes_m13(a, poles);
	FILT_hqr_m13(a, poles, eigs);
	
	return_m13(TRUE_m13);
}



//***************************************//
// MARK: FILE PROCESSING FUNCTIONS  (FPS)
//***************************************//

FPS_m13	*FPS_clone_m13(FPS_m13 *proto_fps, si1 *path, si8 n_bytes, si8 copy_bytes, LH_m13  *parent)
{
	ui4		type_code;
	si8		min_bytes;
	FPS_m13		*fps;
	FPS_PARAMS_m13	*params;
	CPS_m13		*cps;
	UH_m13		*uh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// if path is empty:
	//	path will be proto_fps->path
	//	fps->uh->type_code will be proto_fps->uh->type_code
	// n_bytes = bytes to allocate in new fps, not including universal header
	// 	if n_bytes == 0, min_bytes will be allocated
	// 	if n_bytes == FPS_FULL_FILE_m13, enough memory for the full file will be allocated
	// copy_bytes = bytes to copy from prototype, not including universal header
	// if parent is NULL, parent will be proto_fps->parent

	if (proto_fps == NULL) {
		G_set_error_m13(E_UNKN_m13, "prototype FPS is NULL");
		return_m13(NULL);
	}
	
	fps = (FPS_m13 *) calloc_m13((size_t) 1, sizeof(FPS_m13));
	
	// copy FPS structure
	*fps = *proto_fps;

	// parameters that shouldn't be copied
	fps->path = fps->local_path;
	fps->name = fps->local_name;
	params = &fps->params;
	params->fp = NULL;
	params->mmap_n_blocks = 0;
	params->mmap_block_bitmap = NULL;

	// set path
	if (STR_empty_m13(path) == FALSE_m13) {
		strcpy(fps->path, path);
		G_path_parts_m13(path, NULL, fps->name, NULL);
	}
	type_code = fps->type_code = G_MED_type_code_from_string_m13(fps->path);
	
	// set parent
	fps->parent = parent;
	
	// allocate
	n_bytes += FPS_UH_BYTES_m13;  // passed value does not invclude universal header
	copy_bytes += FPS_UH_BYTES_m13;  // passed value does not invclude universal header
	min_bytes = FPS_UH_BYTES_m13;
	switch (type_code) {
		case TS_INDS_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
		case REC_INDS_TYPE_CODE_m13:
			min_bytes += INDEX_BYTES_m13;  // enough for one index
			break;
		case TS_METADATA_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
			min_bytes += METADATA_BYTES_m13;  // enough for metadata
			break;
		case REC_DATA_TYPE_CODE_m13:
			min_bytes += REC_LARGEST_RECORD_BYTES_m13;  // enough for at least one record
			break;
	}
	if (n_bytes == FPS_FULL_FILE_m13)
		n_bytes = G_file_length_m13(NULL, fps->path);
	if (n_bytes < min_bytes)
		n_bytes = min_bytes;
	if (copy_bytes > proto_fps->params.raw_data_bytes)
		copy_bytes = proto_fps->params.raw_data_bytes;
	if (n_bytes < copy_bytes)
		n_bytes = copy_bytes;
	
	params->raw_data = (void *) calloc_m13((size_t) n_bytes, sizeof(ui1));
	params->raw_data_bytes = n_bytes;
	
	// copy
	memcpy((void *) params->raw_data, (void *) proto_fps->params.raw_data, (size_t) copy_bytes);
	
	// set data pointers
	uh = fps->uh = (UH_m13 *) params->raw_data;
	fps->data_ptrs = (ui1 *) (uh + 1);
	
	// set universal header
	if (type_code)  // otherwise will get proto type code
		uh->type_code = type_code;
	uh->header_CRC = uh->body_CRC = CRC_START_VALUE_m13;
	uh->n_entries = 0;
	uh->maximum_entry_size = 0;
	G_generate_UID_m13(&uh->file_UID);
	uh->provenance_UID = uh->file_UID;  // if not originating file, change provenance_UID to file_UID of originating file
	
	// set type specific fields
	switch (type_code) {
		case TS_INDS_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
		case REC_INDS_TYPE_CODE_m13:
			uh->maximum_entry_size = INDEX_BYTES_m13;
			break;
		case TS_METADATA_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
			uh->maximum_entry_size = METADATA_BYTES_m13;
			break;
		case TS_DATA_TYPE_CODE_m13:
			cps = params->cps = calloc_m13((size_t) 1, sizeof(CPS_m13));
			cps->block_header = (CMP_FIXED_BH_m13 *) fps->data_ptrs;
			cps->params.allocated_compressed_bytes = n_bytes - FPS_UH_BYTES_m13;
			break;
		case VID_DATA_TYPE_CODE_m13:
		case REC_DATA_TYPE_CODE_m13:
			break;
		default:
			FPS_free_m13(&fps);
			G_set_error_m13(E_MED_m13, "unrecognized file type code (code = 0x%08x)", type_code);
			return_m13(NULL);
	}
	
	if (globals_m13->access_times == TRUE_m13)
		G_update_access_time_m13((LH_m13 *) fps);

	return_m13(fps);
}


tern	FPS_close_m13(FPS_m13 *fps)
{
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (fps == NULL)
		return_m13(FALSE_m13);
	
	if (FPS_is_open_m13(fps) == FALSE_m13)
		return_m13(FALSE_m13);

	fclose_m13(fps->params.fp);
	fps->params.fp = NULL;
		
	if (globals_m13->access_times == TRUE_m13)
		G_update_access_time_m13((LH_m13 *) fps);

	return_m13(TRUE_m13);
}


si4	FPS_compare_times_m13(const void *a, const void *b)
{
	si8		a_start_time, b_start_time;
	FPS_m13		*fps;
	
	
	fps = (FPS_m13 *) *((FPS_m13 **) a);
	a_start_time = fps->uh->segment_start_time;

	fps = (FPS_m13 *)  *((FPS_m13 **) b);
	b_start_time = fps->uh->segment_start_time;

	// qsort() requires an si4 return value, so can't just subtract
	if (a_start_time > b_start_time)
		return((si4) 1);
	
	if (a_start_time < b_start_time)
		return((si4) -1);
	
	return((si4) 0);
}


tern	FPS_free_m13(FPS_m13 **fps_ptr)
{
	FPS_m13 	*fps;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns FALSE_m13 if fps not freed
	
	if (fps_ptr == NULL) {
		G_set_error_m13(E_UNKN_m13, "fps_ptr is NULL");
		return_m13(FALSE_m13);
	}
	fps = *fps_ptr;
	if (fps == NULL) {
		G_set_error_m13(E_UNKN_m13, "fps is NULL");
		return_m13(FALSE_m13);
	}

	if (fps->uh)
		if (fps->uh->type_code == TS_DATA_TYPE_CODE_m13)  // CPS requires special freeing
			if (fps->params.cps)
				CMP_free_cps_m13(&fps->params.cps);
	
	if (fps->params.raw_data)
		free_m13((void *) fps->params.raw_data);
	
	if (fps->parent)
		if (fps->parent->type_code == PROC_GLOBS_TYPE_CODE_m13)  // top of hierarchy
			G_proc_globs_delete_m13((LH_m13 *) fps);
	
	if (fps->params.mmap_block_bitmap)
		free_m13((void *) fps->params.mmap_block_bitmap);
	
	// Note: always close when freeing; close_file directives used in reading / writing functions
	FPS_close_m13(fps);  // fine if already closed
	
	// free heap addresses & to NULL
	// stack & en_bloc addresses zeroed
	if (fps->flags & LH_ALLOCATED_m13) {
		free_m13((void *) fps);
		*fps_ptr = NULL;
	} else {
		memset((void *) fps, 0, sizeof(FPS_m13));
	}

	return_m13(TRUE_m13);
}


FPS_m13	*FPS_init_m13(FPS_m13 *fps, si1 *path, si1 *mode_str, si8 n_bytes, LH_m13 *parent)
{
	ui2		alloced_mask;
	ui4		type_code;
	si8		min_bytes;
	FILE_m13	*fp;
	EXT_CODE_m13	type;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// create or reset an FPS
	// if path is empty:
	//	path will be fps->path
	//	fps->uh->type_code will be fps->uh->type_code
	// n_bytes = bytes to allocate for body, not including universal header
	// 	if n_bytes == 0, FPS_UH_BYTES_m13 or min_bytes will be allocated
	// 	if n_bytes == FPS_FULL_FILE_m13, enough memory for the full file will be allocated
	// if parent is NULL, parent will be fps->parent
	// directives flags will be set from fps->parent

	if (fps == NULL) {
		fps = (FPS_m13 *) calloc_m13((size_t) 1, sizeof(FPS_m13));
		fps->path = fps->local_path;
		fps->name = fps->local_name;
	}
	
	// set path
	if (STR_empty_m13(path) == FALSE_m13) {
		strcpy(fps->path, path);
		G_path_parts_m13(path, NULL, fps->name, type.ext);
		fps->type_code = type.code;
	} else if (STR_empty_m13(fps->path) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "path is empty");
		return_m13(NULL);
	} else {  // path in fps->path
		if (fps->type_code == NO_TYPE_CODE_m13)
			fps->type_code = G_MED_type_code_from_string_m13(fps->path);
	}
	type_code = fps->type_code;

	// initialize directives & parameters
	FPS_init_params_m13(&fps->params);
	FPS_init_direcs_m13(&fps->direcs);

	// set open mode
	if (STR_empty_m13(mode_str) == TRUE_m13)
		mode_str = FPS_OPEN_STR_DEFAULT_m13;
	FPS_set_open_flags_m13(fps, mode_str);

	fp = fps->params.fp;
	fp->fd = FILE_FD_CLOSED_m13;
	fp->perms = FILE_PERM_DEFAULT_m13;

	// set parent & flags (use parent flags if passed)
	alloced_mask = fp->flags & FILE_FLAGS_ALLOCED_m13;
	if (parent) {
		fps->parent = parent;
		if (alloced_mask)
			fps->flags = parent->flags | FILE_FLAGS_ALLOCED_m13;
		else
			fps->flags = parent->flags & ~FILE_FLAGS_ALLOCED_m13;
	} else {
		fps->parent = NULL;
		fp->flags = FILE_FLAGS_DEFAULT_m13 | alloced_mask;
	}

	// allocate
	switch (type_code) {
		case TS_INDS_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
		case REC_INDS_TYPE_CODE_m13:
			min_bytes = INDEX_BYTES_m13;  // enough for one index
			break;
		case TS_METADATA_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
			min_bytes = METADATA_BYTES_m13;  // enough for metadata
			break;
		case REC_DATA_TYPE_CODE_m13:
			min_bytes = REC_LARGEST_RECORD_BYTES_m13;  // enough for at least one record
			break;
		default:
			min_bytes = 0;
			break;
	}

	if (n_bytes == FPS_FULL_FILE_m13)
		n_bytes = G_file_length_m13(NULL, fps->path) - FPS_UH_BYTES_m13;  // FPS_alloc assumes universal_header bytes
	if (n_bytes < min_bytes)
		n_bytes = min_bytes;
	FPS_realloc_m13(fps, n_bytes);	
	fps->uh->type_code = type_code;
		
	if (globals_m13->access_times == TRUE_m13)
		G_update_access_time_m13((LH_m13 *) fps);

	return_m13(fps);
}


FPS_DIRECS_m13	*FPS_init_direcs_m13(FPS_DIRECS_m13 *direcs)
{
	ui8	flags;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (direcs == NULL)  // caller responsible for freeing (unusual way to use this function)
		direcs = (FPS_DIRECS_m13 *) calloc_m13((size_t) 1, sizeof(FPS_DIRECS_m13));
	
	flags = (ui8) 0;
	
	// set directives to defaults
	if (FPS_DIRECS_CLOSE_AFTER_OPERATION_DEFAULT_m13 == TRUE_m13)
		flags |= FPS_DF_CLOSE_AFTER_OP_m13;
		
	if (FPS_DIRECS_FLUSH_AFTER_WRITE_DEFAULT_m13 == TRUE_m13)
		flags |= FPS_DF_FLUSH_AFTER_WRITE_m13;
			
	if (FPS_DIRECS_UPDATE_UH_DEFAULT_m13 == TRUE_m13)
		flags |= FPS_DF_UPDATE_UH_m13;
				
	if (FPS_DIRECS_LEAVE_DECRYPTED_DEFAULT_m13 == TRUE_m13)
		flags |= FPS_DF_LEAVE_DECRYPTED_m13;
				
	if (FPS_DIRECS_LEAVE_DECRYPTED_DEFAULT_m13 == TRUE_m13)
		flags |= FPS_DF_LEAVE_DECRYPTED_m13;
		
	if (FPS_DIRECS_MEMORY_MAP_DEFAULT_m13 == TRUE_m13)
		flags |= FPS_DF_MMAP_m13;
	
	flags |= FPS_DIRECS_OPEN_MODE_DEFAULT_m13;  // default is a bit pattern
	
	direcs->flags = flags;
	
	return_m13(direcs);
}


FPS_PARAMS_m13	*FPS_init_params_m13(FPS_PARAMS_m13 *params)
{
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (params) {
		// set zero default parameters
		if (params->raw_data) {
			free_m13((void *) params->raw_data);
			params->raw_data = NULL;
		}
		params->raw_data_bytes = 0;
		*params->mode_str = 0;
		if (params->cps)
			CMP_free_cps_m13(&params->cps);
		if (params->fp)
			fclose_m13(params->fp);
		if (params->mmap_block_bitmap) {
			free_m13((void *) params->mmap_block_bitmap);
			params->mmap_block_bitmap = NULL;
		}
		params->mmap_n_blocks = 0;
	} else {  // caller responsible for freeing (unusual way to use this function)
		params = (FPS_PARAMS_m13 *) calloc_m13((size_t) 1, sizeof(FPS_PARAMS_m13));
	}
	
	// set non-zero defaults
	params->fp = FILE_init_m13(params->fp);
	params->uh_read = params->full_file_read = FALSE_m13;
	params->mmap_block_bytes = GLOBALS_MMAP_BLOCK_BYTES_NO_ENTRY_m13;

	return_m13(params);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	FPS_is_open_m13(FPS_m13 *fps)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (fps)
		if (fps->params.fp)
			if (fps->params.fp->fp)
				return_m13(TRUE_m13);

	return_m13(FALSE_m13);
}


si8	FPS_mmap_read_m13(FPS_m13 *fps, si8 n_bytes)
{
	ui1			mode;
	const ui1		SKIP_MODE = 0, READ_MODE = 1;
	ui4			start_block, end_block;
	ui8			bit_mask, *bit_word, read_start, read_bytes;
	si8			i, len, offset, remaining_bytes, block_bytes;
	PROC_GLOBS_m13		*proc_globs;
	FPS_PARAMS_m13		*params;
	FILE_m13		*fp;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// functions like fread(); assumes file pointer is where is needs to be

	if (n_bytes == 0)
		return_m13(TRUE_m13);  // didn't fail, just nothing to do

	params = &fps->params;
	offset = params->fp->pos;
	len = params->fp->len;
	fp = params->fp;
	
	remaining_bytes = len - offset;
	if (n_bytes > remaining_bytes)
		n_bytes = remaining_bytes;
		
	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	block_bytes = (si8) proc_globs->miscellaneous.mmap_block_bytes;
	start_block = offset / block_bytes;
	end_block = (offset + n_bytes - 1) / block_bytes;
	offset = start_block * block_bytes;
	bit_mask = 1 << (start_block % 64);
	bit_word = params->mmap_block_bitmap + (start_block >> 6);
	
	if (*bit_word & bit_mask) {
		mode = SKIP_MODE;
	} else {
		mode = READ_MODE;
		read_start = offset;
	}
	for (i = start_block; i < end_block; ++i) {
		if (*bit_word & bit_mask) {  // block already read
			if (mode) {  // switch READ_MODE to SKIP_MODE: read unread blocks up to here
				read_bytes = offset - read_start;
				FPS_seek_m13(fps, read_start);
				fread_m13((void *) (params->raw_data + read_start), (size_t) 1, (size_t) read_bytes, fp);
				mode = SKIP_MODE;
			}
		} else {  // block not yet read
			if (!mode) {  // switch SKIP_MODE to READ_MODE: mark read start
				read_start = offset;
				mode = READ_MODE;
			}
			*bit_word |= bit_mask;  // block will be read, mark now
		}
		offset += block_bytes;
		if (!(bit_mask <<= 1)) {
			++bit_word;
			bit_mask = 1;
		}
	}
	
	// terminal read
	if (*bit_word & bit_mask) {  // block already read
		if (mode)  // READ_MODE
			read_bytes = offset - read_start;
		else  // SKIP_MODE
			read_bytes = 0;
	} else {  // block not yet read
		if (mode) {  // READ_MODE
			read_bytes = len - read_start;
		} else {  // SKIP_MODE
			read_start = offset;
			read_bytes = len - offset;
		}
		*bit_word |= bit_mask;  // mark block as read
	}
	if (read_bytes) {
		FPS_seek_m13(fps, read_start);
		fread_m13((void *) (fps->params.raw_data + read_start), (size_t) 1, (size_t) read_bytes, fp);
	}
	fp->pos = read_start + read_bytes;

	return_m13(n_bytes);  // probably read more, but parallels fread() return value
}


FPS_m13	*FPS_open_m13(si1 *path, si1 *mode_str, si8 n_bytes, LH_m13 *parent, ...)  // varargs(mode empty): ui8 fd_flags
{
	ui2			flags, permissions;
	ui4			mmap_block_bytes;
	ui8			fd_flags;
	FPS_m13			*fps;
	PROC_GLOBS_m13		*proc_globs;
	va_list			v_arg;
	struct_stat_m13		sb;
#ifdef WINDOWS_m13
	HANDLE			file_h;
	DISK_GEOMETRY		disk_geom = { 0 };
	ui4			dg_result;
#endif

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	fps = FPS_init_m13(NULL, path, mode_str, n_bytes, parent);

	if (fps == NULL)
		return_m13(NULL);

	if (STR_empty_m13(mode_str) == TRUE_m13) {
		va_start(v_arg, parent);
		fps->direcs.flags = va_arg(v_arg, ui8);
		va_end(v_arg);
		FPS_set_open_string_m13(fps, LH_NO_FLAGS_m13);
	} else {
		FPS_set_open_flags_m13(fps, mode_str);
	}
		
	fd_flags = fps->direcs.flags & FPS_OPEN_MODE_MASK_m13;
	switch (fd_flags) {
		case FPS_R_OPEN_MODE_m13:
			permissions = FILE_PERM_UG_R_m13;
			break;
		case FPS_W_OPEN_MODE_m13:
		case FPS_WN_OPEN_MODE_m13:
		case FPS_A_OPEN_MODE_m13:
			permissions = FILE_PERM_UG_W_m13;
			break;
		case FPS_RP_OPEN_MODE_m13:
		case FPS_WP_OPEN_MODE_m13:
		case FPS_WNP_OPEN_MODE_m13:
		case FPS_AP_OPEN_MODE_m13:
		case FPS_ACP_OPEN_MODE_m13:
			permissions = FILE_PERM_UG_RW_m13;
			break;
		case FPS_NO_OPEN_MODE_m13:
			FPS_free_m13(&fps);
			G_set_error_m13(E_UNKN_m13, "no open mode specified");
			return_m13(NULL);
		default:
			FPS_free_m13(&fps);
			G_set_error_m13(E_UNKN_m13, "multiple open modes specified");
			return_m13(NULL);
	}
	
	G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_ERROR_OUTPUT_m13);
	flags = fps->params.fp->flags | (FILE_FLAGS_LEN_m13 | FILE_FLAGS_POS_m13 | FILE_FLAGS_MED_m13); // MED library functions depend on len & pos fields being maintained
	fps->params.fp = fopen_m13(fps->path, NULL, fps->params.mode_str, (si4) flags, (si4) permissions);
	G_pop_behavior_m13();
	if (fps->params.fp == NULL) {
		FPS_free_m13(&fps);
		return_m13(NULL);
	}

	fstat_m13(fps->params.fp->fd, &sb);

	// memory mapping
	if (fps->direcs.flags & FPS_DF_MMAP_m13) {
		proc_globs = G_proc_globs_m13(parent);
		mmap_block_bytes = proc_globs->miscellaneous.mmap_block_bytes;
		if (mmap_block_bytes == GLOBALS_MMAP_BLOCK_BYTES_NO_ENTRY_m13) {
			#if defined MACOS_m13 || defined LINUX_m13
			mmap_block_bytes = (ui4) sb.st_blksize;
			#endif
			#ifdef WINDOWS_m13
			if ((file_h = (HANDLE) _get_osfhandle(fps->params.fp->fd)) != INVALID_HANDLE_VALUE) {
				dg_result = (ui4) DeviceIoControl(file_h, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &disk_geom, sizeof(DISK_GEOMETRY), &dg_result, (LPOVERLAPPED) NULL);
				if (dg_result == 1)
					mmap_block_bytes = (ui4) disk_geom.BytesPerSector;
			}
			#endif
			if (mmap_block_bytes <= 0)
				mmap_block_bytes = GLOBALS_MMAP_BLOCK_BYTES_DEFAULT_m13;
			proc_globs->miscellaneous.mmap_block_bytes = mmap_block_bytes;
		}
		fps->params.mmap_block_bytes = mmap_block_bytes;
		fps->params.mmap_n_blocks = (ui4) ((fps->params.fp->len + (si8) (mmap_block_bytes - 1)) / (si8) mmap_block_bytes);
		fps->params.mmap_block_bitmap = (ui8 *) calloc_m13((size_t) ((fps->params.mmap_n_blocks + 63) / 64), sizeof(ui8));
	}
		
	if (globals_m13->access_times == TRUE_m13)
		G_update_access_time_m13((LH_m13 *) fps);

	return_m13(fps);
}


FPS_m13	*FPS_read_m13(FPS_m13 *fps, si8 offset, si8 n_bytes, si8 n_items, void *dest, ...)  // varargs(fps invalid): si1 *path, si1 *mode_str, si1 *password, LH *parent
											    // varargs(offset == FPS_REL_START/CURR/END): si8 rel_bytes
{
	tern			free_fps, valid_fps, fps_alloced, rel_offset, readable;
	tern			file_opened, header_only, full_file, mem_map, data_read, CRC_valid;
	si1			*path, *mode_str, *password;
	ui4			type_code;
	si8			len, rel_bytes, header_offset, bytes_read, bytes_to_read;
	LH_m13			*parent;
	FPS_m13			*tmp_fps;
	PASSWORD_DATA_m13	*pwd;
	PROC_GLOBS_m13		*proc_globs;
	UH_m13			*uh;
	va_list			v_args;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// initialize function flags
	free_fps = valid_fps = file_opened = header_only = full_file = mem_map = data_read = FALSE_m13;
	if (fps == NULL)
		free_fps = TRUE_m13;
	else
		valid_fps = G_valid_level_code_m13(fps->type_code);  // pre-allocated, but uninitialized FPS

	// get varargs
	path = password = mode_str = NULL;
	parent = NULL;
	offset = REMOVE_DISCONT_m13(offset);
	rel_offset = FPS_REL_OFFSET_m13(offset);
	rel_bytes = 0;
	if (valid_fps == FALSE_m13 || rel_offset == TRUE_m13) {
		va_start(v_args, dest);
		// open arguments
		if (valid_fps == FALSE_m13) {
			path = va_arg(v_args, si1 *);
			mode_str = va_arg(v_args, si1 *);
			if (STR_empty_m13(mode_str) == TRUE_m13)
				mode_str = FPS_OPEN_STR_DEFAULT_m13;
			password = va_arg(v_args, si1 *);
			if (password)
				if (*password == 0)
					password = NULL;  // less checking below
			parent = va_arg(v_args, LH_m13 *);
		}
		// relative offset
		if (rel_offset == TRUE_m13)
			rel_bytes = va_arg(v_args, si8);
		va_end(v_args);
	}
	
	if (valid_fps == TRUE_m13) {
		// full file already read
		if (fps->params.full_file_read == TRUE_m13) {
			if (rel_offset == TRUE_m13)
				offset = FPS_resolve_offset_m13(fps, offset, rel_bytes);
			FPS_set_pointers_m13(fps, offset);
			return_m13(fps);
		}
	}
	
	// open
	if (FPS_is_open_m13(fps) == FALSE_m13) {
		if (fps) {
			if (valid_fps == FALSE_m13) {  // caller passed uninitialized fps (e.g. allocated en bloc)
				fps_alloced = freeable_m13((void *) fps);
				tmp_fps = FPS_open_m13(path, mode_str, n_bytes, parent);
				*fps = *tmp_fps;  // copy base structure to passed pointer
				free_m13(tmp_fps);  // free temporary base structure (i.e. don't use FPS_free_m13)
				if (fps_alloced == TRUE_m13)
					fps->flags |= LH_ALLOCATED_m13;
				else
					fps->flags &= ~LH_ALLOCATED_m13;
			} else if (FPS_reopen_m13(fps, FPS_OPEN_STR_DEFAULT_m13) == FALSE_m13) {
				return_m13(NULL);
			}
		} else {
			fps = FPS_open_m13(path, mode_str, n_bytes, parent);
		}
		if (fps == NULL)
			return_m13(NULL);
		file_opened = TRUE_m13;
	} else if (!(fps->params.fp->flags & FILE_FLAGS_READ_m13)) {  // no read flag - add
		if (fps->params.fp->flags & FILE_FLAGS_APPEND_m13)
			FPS_reopen_m13(fps, FPS_AP_OPEN_STR_m13);
		else if (fps->params.fp->flags & FILE_FLAGS_WRITE_m13)
			FPS_reopen_m13(fps, FPS_WNP_OPEN_STR_m13);
		else
			FPS_reopen_m13(fps, FPS_R_OPEN_STR_m13);
		file_opened = TRUE_m13;
	}
	len = fps->params.fp->len;
	type_code = fps->type_code;
	
	if (rel_offset == TRUE_m13)
		offset = FPS_resolve_offset_m13(fps, offset, rel_bytes);
	
	// get n_bytes
	if (n_bytes == FPS_AUTO_BYTES_m13)
		n_bytes = FPS_set_direcs_from_lh_flags_m13(fps, LH_NO_FLAGS_m13);
	switch (n_bytes) {
		case FPS_BYTES_NO_ENTRY_m13:
			if (n_items) {
				n_bytes = G_bytes_for_items_m13(fps, &n_items, offset);
				if (DATA_CODE_m13(type_code) == TRUE_m13)
					data_read = TRUE_m13;  // don't read data, but still read in universal header if needed
			} else {
				G_set_error_m13(E_READ_m13, "both n_bytes & n_items are zero");
				goto FPS_READ_FAIL_m13;
			}
			break;
		case FPS_UH_ONLY_m13:
			if (fps->params.uh_read == TRUE_m13)
				return_m13(fps);
			n_bytes = n_items = offset = 0;
			header_only = TRUE_m13;
			break;
		case FPS_FULL_FILE_m13:
			n_bytes = len - FPS_UH_BYTES_m13;
			offset = n_items = 0;
			full_file = TRUE_m13;
			break;
	}
	if (fps->direcs.flags & FPS_DF_MMAP_m13)
		mem_map = TRUE_m13;
	else
		mem_map = FALSE_m13;

	// allocate memory
	if (dest == NULL)
		dest = (void *) fps->data_ptrs;
	if (dest == (void *) fps->data_ptrs) {
		if (fps->params.raw_data_bytes < (n_bytes + FPS_UH_BYTES_m13))
			FPS_realloc_m13(fps, n_bytes);  // FPS_realloc_m13 assumes universal header bytes
	} else if (malloc_size_m13(dest) < n_bytes) {  // can't realloc non-FPS memory block
		G_set_error_m13(E_ALLOC_m13, "destination is too small for read");
		goto FPS_READ_FAIL_m13;
	}

	// read in universal header
	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	pwd = &proc_globs->password_data;
	uh = fps->uh;
	if (fps->params.uh_read == FALSE_m13) {
		if (header_only == TRUE_m13 || full_file == TRUE_m13 || file_opened == TRUE_m13) {
			bytes_to_read = FPS_UH_BYTES_m13;
			if (type_code == VID_DATA_TYPE_CODE_m13) {
				header_offset = len - FPS_UH_BYTES_m13;
			} else {
				header_offset = 0;
				if (offset == 0 && dest == (void *) fps->data_ptrs) {  // include rest of read here
					bytes_to_read += n_bytes;
					data_read = TRUE_m13;
				}
			}
			
			// read header (& subsequent data if appropriate)
			FPS_seek_m13(fps, header_offset);  // set fp to start of universal header
			if (mem_map == TRUE_m13)
				bytes_read = FPS_mmap_read_m13(fps, bytes_to_read);
			else
				bytes_read = fread_m13((void *) uh, sizeof(ui1), bytes_to_read, fps->params.fp);
			if (bytes_read != bytes_to_read)
				goto FPS_READ_FAIL_m13;
			
			// process password
			if (pwd->hints_exist == UNKNOWN_m13)
				if (METADATA_CODE_m13(type_code) == TRUE_m13 || pwd->processed == FALSE_m13)
					G_process_password_data_m13(fps, password);

			// current session directory globals
			if (proc_globs->current_session.UID != uh->session_UID)
				G_session_directory_m13(fps);
			
			// update session name
			if (proc_globs->current_session.names_differ == TRUE_m13 && globals_m13->update_header_names == TRUE_m13)
				G_update_session_name_m13(fps);
			
			// update MED version
			if (MED_VER_1_0_m13(uh) == TRUE_m13 && globals_m13->update_MED_version == TRUE_m13)
				G_update_MED_version_m13(fps);

			// live or abnormally terminated file
			if (uh->n_entries == 0)
				if (G_correct_universal_header_m13(fps) == FALSE_m13)
					goto FPS_READ_FAIL_m13;
			
			fps->params.uh_read = TRUE_m13;
		}
	}
	
	if (header_only == TRUE_m13) {
		if (fps->direcs.flags & FPS_DF_CLOSE_AFTER_OP_m13)
			FPS_close_m13(fps);
		return_m13(fps);
	}
	if (full_file == TRUE_m13) {
		n_items = uh->n_entries;
		offset = FPS_UH_BYTES_m13;
		fps->params.full_file_read = TRUE_m13;
		fps->direcs.flags &= ~FPS_DF_MMAP_m13;  // full file doesn't need memory mapping
		fps->direcs.flags |= FPS_DF_CLOSE_AFTER_OP_m13;  // full file reads are closed to keep open file count down
	}

	// set memory pointers
	FPS_set_pointers_m13(fps, offset);
		
	// read
	if (data_read == FALSE_m13) {
		FPS_seek_m13(fps, offset);
		if (mem_map == TRUE_m13)
			bytes_read = FPS_mmap_read_m13(fps, n_bytes);  // called by FPS_read_m13() after offset & n_bytes resolved
		else
			bytes_read = fread_m13(dest, sizeof(ui1), (size_t) n_bytes, fps->params.fp);
		if (bytes_read != n_bytes)
			G_set_error_m13(E_READ_m13, NULL);
	}
	
	// get n_items (preferably this is passed)
	if (n_items == 0)
		n_items = G_items_for_bytes_m13(fps, &n_bytes);
	fps->n_items = n_items;

	// validate CRCs
	if (globals_m13->CRC_mode & CRC_VALIDATE_m13) {
		CRC_valid = CRC_validate_m13(fps->params.raw_data + UH_HEADER_CRC_START_OFFSET_m13, UH_BYTES_m13 - UH_HEADER_CRC_START_OFFSET_m13, uh->header_CRC);
		if (CRC_valid == FALSE_m13)
			G_warning_message_m13("%s(): universal header CRC invalid for \"%s\"\n", __FUNCTION__, fps->path);
		CRC_valid = UNKNOWN_m13;
		switch (type_code) {
			case TS_DATA_TYPE_CODE_m13:
				CRC_valid = G_validate_time_series_data_CRCs_m13(fps);
				break;
			case VID_DATA_TYPE_CODE_m13:
				CRC_valid = G_validate_video_data_CRCs_m13(fps);
				break;
			case TS_INDS_TYPE_CODE_m13:
				if (full_file == TRUE_m13)
					CRC_valid = CRC_validate_m13(fps->data_ptrs, len - FPS_UH_BYTES_m13, uh->body_CRC);
				break;
			case REC_DATA_TYPE_CODE_m13:
				CRC_valid = G_validate_record_data_CRCs_m13(fps);
				break;
			case REC_INDS_TYPE_CODE_m13:
				if (full_file == TRUE_m13)
					CRC_valid = CRC_validate_m13(fps->data_ptrs, len - FPS_UH_BYTES_m13, uh->body_CRC);
				break;
			case TS_METADATA_TYPE_CODE_m13:
			case VID_METADATA_TYPE_CODE_m13:
				if (full_file == TRUE_m13)
					CRC_valid = CRC_validate_m13(fps->data_ptrs, len - FPS_UH_BYTES_m13, uh->body_CRC);
				break;
		}
		if (CRC_valid == FALSE_m13)
			G_warning_message_m13("%s(): body CRC invalid for \"%s\"\n", __FUNCTION__, fps->path);
	}

	// decrypt file types with possible encryption
	readable = TRUE_m13;
	switch (type_code) {
		case TS_DATA_TYPE_CODE_m13:
			if (uh->encryption_1 > NO_ENCRYPTION_m13)
				readable = G_decrypt_time_series_data_m13(fps);
			break;
		case VID_DATA_TYPE_CODE_m13:
			if (uh->encryption_1 > NO_ENCRYPTION_m13)
				readable = G_decrypt_video_data_m13(fps);
			break;
		case REC_DATA_TYPE_CODE_m13:
			readable = G_decrypt_record_data_m13(fps);
			break;
		case TS_METADATA_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
			if (uh->encryption_2 > NO_ENCRYPTION_m13 || uh->encryption_3 > NO_ENCRYPTION_m13)
				readable = G_decrypt_metadata_m13(fps);
			break;
	}
	if (readable == FALSE_m13) {
		G_set_error_m13(E_READ_m13, NULL);
		goto FPS_READ_FAIL_m13;
	}

	if (fps->direcs.flags & FPS_DF_CLOSE_AFTER_OP_m13)
		FPS_close_m13(fps);
	else if (globals_m13->access_times == TRUE_m13)
		G_update_access_time_m13((LH_m13 *) fps);

	return_m13(fps);

FPS_READ_FAIL_m13:
	
	if (free_fps == TRUE_m13)
		FPS_free_m13(&fps);
	
	return_m13(NULL);
}


tern	FPS_realloc_m13(FPS_m13 *fps, si8 n_bytes)
{
	CPS_m13		*cps;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// n_bytes does not include universal header bytes
	// also accepts FPS_FULL_FILE_m13 & FPS_UH_ONLY_m13

	if (fps == NULL) {
		G_set_error_m13(E_UNKN_m13, "FPS is NULL");
		return_m13(FALSE_m13);
	}
	
	if (n_bytes == FPS_FULL_FILE_m13)
		n_bytes = fps->params.fp->len;
	else if (n_bytes == FPS_UH_ONLY_m13)
		n_bytes = FPS_UH_BYTES_m13;
	else
		n_bytes += FPS_UH_BYTES_m13;
	
	if (n_bytes <= fps->params.raw_data_bytes)
		return_m13(TRUE_m13);
	
	fps->params.raw_data = realloc_m13(fps->params.raw_data, (size_t) n_bytes);
	
	fps->params.raw_data_bytes = n_bytes;
	fps->uh = (UH_m13 *) fps->params.raw_data;
	fps->data_ptrs = (ui1 *) (fps->uh + 1);
	
	// handle CPS
	if (fps->uh->type_code == TS_DATA_TYPE_CODE_m13) {
		cps = fps->params.cps;
		if (cps == NULL)
			fps->params.cps = (CPS_m13 *) calloc_m13((size_t) 1, sizeof(CPS_m13));
		cps->block_header = (CMP_FIXED_BH_m13 *) fps->data_ptrs;
		cps->params.allocated_compressed_bytes = n_bytes - FPS_UH_BYTES_m13;
	}

	return_m13(TRUE_m13);
}


tern	FPS_reopen_m13(FPS_m13 *fps, si1 *mode_str)
{
	FILE_m13	*fp;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (fps == NULL) {
		G_set_error_m13(E_UNKN_m13, "FPS is NULL");
		return_m13(FALSE_m13);
	}

	if (STR_empty_m13(mode_str) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "no mode passed");
		return_m13(FALSE_m13);
	} else {
		FPS_set_open_flags_m13(fps, mode_str);
	}
	
	fp = fps->params.fp;
	if (fp == NULL)
		fp = FILE_init_m13(NULL);
	
	fp = freopen_m13(fps->path, mode_str, fp);
	if (fp == NULL)
		return_m13(FALSE_m13);
	fps->params.fp = fp;
	
	if (globals_m13->access_times == TRUE_m13)
		G_update_access_time_m13((LH_m13 *) fps);

	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si8	FPS_resolve_offset_m13(FPS_m13 *fps, si8 offset, ...)  // varargs(offset == FPS_REL_START/CURR/END): si8 rel_bytes
{
	si8		len, rel_bytes;
	va_list		v_arg;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (FPS_is_open_m13(fps) == FALSE_m13) {
		G_set_error_m13(E_UNKN_m13, "FPS is not open");
		return_m13((si8) FALSE_m13);
	}

	len = fps->params.fp->len;
	if (FPS_REL_OFFSET_m13(offset) == TRUE_m13) {

		va_start(v_arg, offset);
		rel_bytes = va_arg(v_arg, si8);
		va_end(v_arg);
		
		switch (offset) {
			case FPS_APPEND_m13:
				offset = len;
				break;
			case FPS_REL_START_m13:
				offset = rel_bytes;
				break;
			case FPS_REL_CURR_m13:
				offset = fps->params.fp->pos + rel_bytes;
				break;
			case FPS_REL_END_m13:
				offset = len + rel_bytes;
				break;
		}
	} else {
		offset = REMOVE_DISCONT_m13(offset);  // probably already done
	}

	if (offset < 0 || offset > len) {
		G_set_error_m13(E_UNKN_m13, "offset exceeds file extents");
		return_m13(offset);
	}

	return_m13(offset);
}


si8	FPS_seek_m13(FPS_m13 *fps, si8 offset, ...)  // varargs(offset == FPS_REL_*): si8 rel_bytes
{
	si8		rel_bytes;
	va_list		v_arg;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (FPS_REL_OFFSET_m13(offset) == TRUE_m13) {
		va_start(v_arg, offset);
		rel_bytes = va_arg(v_arg, si8);
		va_end(v_arg);
		offset = FPS_resolve_offset_m13(fps, offset, rel_bytes);
	} else {
		offset = REMOVE_DISCONT_m13(offset);
	}

	if (fps->params.fp->pos == offset)
		return_m13(offset);
	
	fseek_m13(fps->params.fp, offset, SEEK_SET);
	
	return_m13(offset);
}


si8	FPS_set_direcs_from_lh_flags_m13(FPS_m13 *fps, ui8 lh_flags)
{
	tern		read_slice_flag, read_full_flag, mmap_flag;
	ui4		type_code, level_code;
	si8		n_bytes;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns n_bytes as either FPS_UH_BYTES or FPS_FULL_FILE_m13
	// does not require universal header to be read in
	
	n_bytes = FPS_BYTES_NO_ENTRY_m13;
	if (lh_flags == LH_NO_FLAGS_m13)
		lh_flags = fps->flags;
	else
		fps->flags = lh_flags;
	
	if ((lh_flags & (LH_ALL_READ_FLAGS_MASK_m13 | LH_ALL_MMAP_FLAGS_MASK_m13)) == 0)
		return_m13(n_bytes);
	
	level_code = G_level_m13(fps->path, &type_code);
	
	if (INDICES_CODE_m13(type_code) == TRUE_m13 || METADATA_CODE_m13(type_code) == TRUE_m13) {
		fps->direcs.flags |= FPS_DF_CLOSE_AFTER_OP_m13;
		fps->direcs.flags &= ~FPS_DF_MMAP_m13;
		return_m13(FPS_FULL_FILE_m13);
	}

	// record data
	if (type_code == REC_DATA_TYPE_CODE_m13) {
		read_slice_flag = read_full_flag = mmap_flag = FALSE_m13;
		switch (level_code) {
			case SESS_TYPE_CODE_m13:
				if (lh_flags & LH_READ_SLICE_SESS_RECS_m13)
					read_slice_flag = TRUE_m13;
				else if (lh_flags & LH_READ_FULL_SESS_RECS_m13)
					read_full_flag = TRUE_m13;
				if (lh_flags & LH_MMAP_SESS_RECS_m13)
					mmap_flag = TRUE_m13;
				break;
			case SSR_TYPE_CODE_m13:
				if (lh_flags & LH_READ_SLICE_SEG_SESS_RECS_m13)
					read_slice_flag = TRUE_m13;
				else if (lh_flags & LH_READ_FULL_SEG_SESS_RECS_m13)
					read_full_flag = TRUE_m13;
				if (lh_flags & LH_MMAP_SEG_SESS_RECS_m13)
					mmap_flag = TRUE_m13;
				break;
			case TS_CHAN_TYPE_CODE_m13:
			case VID_CHAN_TYPE_CODE_m13:
				if (lh_flags & LH_READ_SLICE_CHAN_RECS_m13)
					read_slice_flag = TRUE_m13;
				else if (lh_flags & LH_READ_FULL_CHAN_RECS_m13)
					read_full_flag = TRUE_m13;
				if (lh_flags & LH_MMAP_CHAN_RECS_m13)
					mmap_flag = TRUE_m13;
				break;
			case TS_SEG_TYPE_CODE_m13:
			case VID_SEG_TYPE_CODE_m13:
				if (lh_flags & LH_READ_SLICE_SEG_RECS_m13)
					read_slice_flag = TRUE_m13;
				else if (lh_flags & LH_READ_FULL_SEG_RECS_m13)
					read_full_flag = TRUE_m13;
				if (lh_flags & LH_MMAP_SEG_RECS_m13)
					mmap_flag = TRUE_m13;
				break;
		}
		if (read_slice_flag == TRUE_m13) {
			fps->direcs.flags &= ~FPS_DF_CLOSE_AFTER_OP_m13;
			if (mmap_flag == TRUE_m13)
				fps->direcs.flags |= FPS_DF_MMAP_m13;
			else
				fps->direcs.flags &= ~FPS_DF_MMAP_m13;
			return_m13(FPS_UH_ONLY_m13);
		}
		if (read_full_flag == TRUE_m13) {
			fps->direcs.flags |= FPS_DF_CLOSE_AFTER_OP_m13;
			fps->direcs.flags &= ~FPS_DF_MMAP_m13;
			return_m13(FPS_FULL_FILE_m13);
		}
	}
	
	// segment data types (TS_DATA_TYPE_CODE_m13 is only type left)
	if (lh_flags & LH_READ_SLICE_SEG_DATA_m13) {
		n_bytes = FPS_UH_ONLY_m13;
		fps->direcs.flags &= ~FPS_DF_CLOSE_AFTER_OP_m13;
		if (lh_flags & LH_MMAP_SEG_DATA_m13)
			fps->direcs.flags |= FPS_DF_MMAP_m13;
		else
			fps->direcs.flags &= ~FPS_DF_MMAP_m13;
		return_m13(FPS_UH_ONLY_m13);
	} else if (lh_flags & LH_READ_FULL_SEG_DATA_m13) {
		fps->direcs.flags |= FPS_DF_CLOSE_AFTER_OP_m13;
		fps->direcs.flags &= ~FPS_DF_MMAP_m13;
		return_m13(FPS_FULL_FILE_m13);
	}
		
	return_m13(0);  // should not get here - all file types covered above
}
		  
		  
ui8	FPS_set_open_flags_m13(FPS_m13 *fps, const si1 *mode_str)
{
	tern	mode_empty, read_mode, write_mode, append_mode, truncate_mode, no_truncate_mode;
	si1	*c, mode_count;
	ui8	flags;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// returns FPS directive open flags
	// if fps != NULL, flags are incorporated with other (non-open) flags & set in fps
	
	if (STR_empty_m13(mode_str) == TRUE_m13) {
		mode_empty = TRUE_m13;
		if (fps) {
			mode_str = fps->params.mode_str;
			mode_empty = STR_empty_m13(mode_str);
		}
		if (mode_empty == TRUE_m13) {
			G_set_error_m13(E_UNKN_m13, "no mode string available");
			return_m13(LH_NO_FLAGS_m13);
		}
	} else if (fps) {
		strcpy_m13(fps->params.mode_str, mode_str);  // trace trap if use system strcpy() here - need to figure out why
	}

	if (fps)
		flags = fps->direcs.flags & ~FPS_OPEN_MODE_MASK_m13;
	else
		flags = FPS_DF_NO_FLAGS_m13;
	
	read_mode = write_mode = append_mode = truncate_mode = no_truncate_mode = UNKNOWN_m13;
	c = (si1 *) mode_str - 1;
	while (*++c) {
		switch (*c) {
			case 'R':
			case 'r':
				read_mode = TRUE_m13;
				flags |= FPS_DF_READ_MODE_m13;
				break;
			case 'W':
			case 'w':
				write_mode = TRUE_m13;
				flags |= (FPS_DF_WRITE_MODE_m13 | FPS_DF_CREATE_MODE_m13 | FPS_DF_TRUNCATE_MODE_m13);
				break;
			case 'A':
			case 'a':
				append_mode = TRUE_m13;
				flags |= (FPS_DF_APPEND_MODE_m13 | FPS_DF_CREATE_MODE_m13);
				break;
			case 'N':
			case 'n':
				no_truncate_mode = TRUE_m13;
				break;
			case 'C':
			case 'c':
				truncate_mode = TRUE_m13;
				flags |= FPS_DF_TRUNCATE_MODE_m13;
				break;
			case '+':
				flags |= (FPS_DF_READ_MODE_m13 | FPS_DF_WRITE_MODE_m13);
				break;
			case 'T':  // ignored
			case 't':  // ignored
			case 'B':  // ignored
			case 'b':  // ignored
				break;
			default:
				G_set_error_m13(E_UNKN_m13, "unrecognized mode character");
				return_m13(FPS_DF_NO_FLAGS_m13);
				break;
		}
	}
	
	mode_count = read_mode + write_mode + append_mode;
	if (mode_count != 1) {
		G_set_error_m13(E_UNKN_m13, "more than one, or no, primary mode selected");
		return_m13(FPS_DF_NO_FLAGS_m13);
	}
	if (no_truncate_mode == TRUE_m13) {
		if (truncate_mode == TRUE_m13) {
			G_set_error_m13(E_UNKN_m13, "conflicting truncate modes selected");
			return_m13(FPS_DF_NO_FLAGS_m13);
		}
		flags &= ~FPS_DF_TRUNCATE_MODE_m13;
	}

	if (fps)
		fps->direcs.flags = flags;

	return_m13(flags);
}


si1	*FPS_set_open_string_m13(FPS_m13 *fps, ui8 flags)
{
	si1	*c, *mode_str;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (fps)
		mode_str = fps->params.mode_str;
	else
		mode_str = (si1 *) calloc_m13((size_t) 8, sizeof(si1));  // caller takes ownership
	
	if (flags == LH_NO_FLAGS_m13)
		if (fps)
			flags = fps->direcs.flags;
	flags &= FPS_OPEN_MODE_MASK_m13;
	if (flags == FPS_DF_NO_FLAGS_m13) {
		G_set_error_m13(E_UNKN_m13, "no mode flags available");
		return_m13(NULL);
	}

	c = mode_str;
	switch (flags) {
		case FPS_R_OPEN_MODE_m13:
			*c++ = 'r';
			break;
		case FPS_RP_OPEN_MODE_m13:
			*c++ = 'r';
			*c++ = '+';
			break;
		case FPS_W_OPEN_MODE_m13:
			*c++ = 'w';
			break;
		case FPS_WP_OPEN_MODE_m13:
			*c++ = 'w';
			*c++ = '+';
		case FPS_WN_OPEN_MODE_m13:
			*c++ = 'w';
			*c++ = 'n';
			break;
		case FPS_WNP_OPEN_MODE_m13:
			*c++ = 'w';
			*c++ = 'n';
			*c++ = '+';
			break;
		case FPS_A_OPEN_MODE_m13:
			*c++ = 'a';
			break;
		case FPS_AP_OPEN_MODE_m13:
			*c++ = 'a';
			*c++ = '+';
		case FPS_AC_OPEN_MODE_m13:
			*c++ = 'a';
			*c++ = 'c';
			break;
		case FPS_ACP_OPEN_MODE_m13:
			*c++ = 'a';
			*c++ = 'c';
			*c++ = '+';
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "unrecocgnized open flag pattern (0x%016lx)", flags);
			return_m13(NULL);
	}
	*c = 0;
			
	return_m13(mode_str);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	FPS_set_pointers_m13(FPS_m13 *fps, si8 offset)  // offset is presumed to be absolute
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (fps->params.full_file_read == TRUE_m13 || fps->direcs.flags & FPS_DF_MMAP_m13) {
		fps->data_ptrs = fps->params.raw_data + offset;  // uh is at end of file
		if (fps->type_code == VID_DATA_TYPE_CODE_m13)
			fps->data_ptrs += FPS_UH_BYTES_m13;  // vid universal header read into beginning of raw data, but exists at end of file
	} else {
		fps->data_ptrs = fps->params.raw_data + FPS_UH_BYTES_m13;
	}

	if (fps->params.cps)
		fps->params.cps->block_header = (CMP_FIXED_BH_m13 *) fps->ts_data;
	
	return_m13(TRUE_m13);
}


tern	FPS_show_m13(FPS_m13 *fps)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	printf_m13("----------- File Processing Structure - START ----------\n");
	G_show_level_header_m13((LH_m13 *) fps);
	if (*fps->path)
		printf_m13("Path: %s\n", fps->path);
	else
		printf_m13("Path: not set\n");
	if (*fps->name)
		printf_m13("Name: %s\n", fps->name);
	else
		printf_m13("Name: not set\n");
	if (fps->uh)
		G_show_universal_header_m13(fps, NULL);
	else
		printf_m13("Universal Header: null\n");
	FPS_show_direcs_m13(fps);
	FPS_show_params_m13(fps);
	printf_m13("Number of Items: %ld\n", fps->n_items);
	if (fps->data_ptrs)
		printf_m13("Data Pointers: %lu\n", (ui8) fps->data_ptrs);
	else
		printf_m13("Data Pointers: null\n");
	printf_m13("------------ File Processing Structure - END -----------\n");
	
	return_m13(TRUE_m13);
}


tern	FPS_show_direcs_m13(FPS_m13 *fps)
{
	ui8	flags;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	flags = fps->direcs.flags;
	
	printf_m13("---------------- FPS Directives - START ----------------\n");
	printf_m13("read mode: %s\n", STR_bool_m13(flags & FPS_DF_READ_MODE_m13));
	printf_m13("write mode: %s\n", STR_bool_m13(flags & FPS_DF_WRITE_MODE_m13));
	printf_m13("append mode: %s\n", STR_bool_m13(flags & FPS_DF_APPEND_MODE_m13));
	printf_m13("create mode: %s\n", STR_bool_m13(flags & FPS_DF_CREATE_MODE_m13));
	printf_m13("truncate mode: %s\n", STR_bool_m13(flags & FPS_DF_TRUNCATE_MODE_m13));
	printf_m13("close after operation: %s\n", STR_bool_m13(flags & FPS_DF_CLOSE_AFTER_OP_m13));
	printf_m13("flush after write: %s\n", STR_bool_m13(flags & FPS_DF_FLUSH_AFTER_WRITE_m13));
	printf_m13("update universal header: %s\n", STR_bool_m13(flags & FPS_DF_UPDATE_UH_m13));
	printf_m13("leave decrypted: %s\n", STR_bool_m13(flags & FPS_DF_LEAVE_DECRYPTED_m13));
	printf_m13("free CPS: %s\n", STR_bool_m13(flags & FPS_DF_FREE_CPS_m13));
	printf_m13("memory map: %s\n", STR_bool_m13(flags & FPS_DF_MMAP_m13));
	printf_m13("----------------- FPS Directives - END -----------------\n");

	return_m13(TRUE_m13);
}


tern	FPS_show_params_m13(FPS_m13 *fps)
{
	FPS_PARAMS_m13	*params;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	params = &fps->params;
	
	printf_m13("---------------- FPS Parameters - START ----------------\n");
	printf_m13("mode string: \"%s\"\n", params->mode_str);
	printf_m13("universal header read: %s\n", STR_tern_m13(params->uh_read));
	printf_m13("full file read: %s\n", STR_tern_m13(params->full_file_read));
	printf_m13("raw data bytes: %ld\n", params->raw_data_bytes);
	if (params->raw_data)
		printf_m13("raw data: allocated\n");
	else
		printf_m13("raw data: not allocated\n");
	if (params->cps)
		printf_m13("cps: allocated\n");
	else
		printf_m13("cps: not allocated\n");
	if (params->fp)
		FILE_show_m13(params->fp);
	else
		printf_m13("fp: not allocated\n");
	printf_m13("memory map block bytes: %u\n", params->mmap_block_bytes);
	printf_m13("memory map blocks: %u\n", params->mmap_n_blocks);
	if (params->mmap_block_bitmap)
		printf_m13("memory map block bitmap: allocated\n");
	else
		printf_m13("memory map block bitmap: not allocated\n");
	printf_m13("----------------- FPS Parameters - END -----------------\n");

	return_m13(TRUE_m13);
}


tern	FPS_sort_m13(FPS_m13 **fps_array, si4 n_fps)
{
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// input must be 2D FPS array, such as allocated by calloc_2D_m13()
	// sorts the pointers by FPS file start time, does not move the FPSs
	
	qsort((void *) fps_array, (size_t) n_fps, sizeof(FPS_m13 *), FPS_compare_times_m13);

	return_m13(TRUE_m13);
}


tern	FPS_write_m13(FPS_m13 *fps, si8 offset, si8 n_bytes, si8 n_items, void *source, ...)  // varargs(offset == FPS_REL_*): si8 rel_bytes
{
	tern		write_uh, header_only, update_maximum_entry_size;
	void		*encrypted_data;
	si8		rel_bytes, nw, in_flen;
	PROC_GLOBS_m13	*proc_globs;
	UH_m13		*uh;
	va_list		v_arg;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// n_bytes does not include universal header bytes
	
	rel_bytes = 0;
	if (FPS_REL_OFFSET_m13(offset) == TRUE_m13) {
		va_start(v_arg, source);
		rel_bytes = va_arg(v_arg, si8);
		va_end(v_arg);
	}

	in_flen = fps->params.fp->len;
	write_uh = header_only = FALSE_m13;
	if (offset == FPS_APPEND_m13) {
		offset = in_flen;
	} else {
		if (n_bytes == FPS_UH_ONLY_m13) {
			offset = FPS_UH_OFFSET_m13;
			n_bytes = 0;
			header_only = write_uh = TRUE_m13;
		}
		offset = FPS_resolve_offset_m13(fps, offset, rel_bytes);
	}
	if (fps->direcs.flags & (FPS_DF_UPDATE_UH_m13 | FPS_DF_CLOSE_AFTER_OP_m13) || n_bytes == FPS_FULL_FILE_m13)  // always update universal header on close write
		write_uh = TRUE_m13;
	
	if (source == NULL)
		source = (void *) fps->data_ptrs;
			
	// update universal header, if requested
	if (write_uh == TRUE_m13) {
		uh = fps->uh;
		
		// update universal_header->body_CRC
		if (uh->body_CRC == CRC_NO_ENTRY_m13)  // otherwise this has been done with CRC_combine() in other functions
			if (n_bytes || n_items)  // this is first write: only calculate if writing some data
				uh->body_CRC = CRC_calculate_m13((ui1 *) fps->data_ptrs, n_bytes);
			
		// update universal_header->header_CRC
		uh->header_CRC = CRC_calculate_m13((ui1 *) uh + UH_HEADER_CRC_START_OFFSET_m13, FPS_UH_BYTES_m13 - UH_HEADER_CRC_START_OFFSET_m13);
		
		// write universal header
		FPS_seek_m13(fps, FPS_UH_OFFSET_m13);
		nw = fwrite_m13((void *) uh, sizeof(ui1), (size_t) FPS_UH_BYTES_m13, fps->params.fp);
		if (nw != (size_t) FPS_UH_BYTES_m13) {
			G_set_error_m13(E_WRITE_m13, "error writing universal header");
			return_m13((si8) FALSE_m13);
		}

		// write universal header only
		if (header_only == TRUE_m13) {
			if (fps->direcs.flags & FPS_DF_FLUSH_AFTER_WRITE_m13)
				fflush(fps->params.fp->fp);
			fps->n_items = 0;  // universal header does not count as an item
			if (fps->direcs.flags & FPS_DF_CLOSE_AFTER_OP_m13)
				FPS_close_m13(fps);
			
			return_m13(TRUE_m13);
		}
	}
	if (n_bytes == 0 && n_items == 0) {
		G_set_error_m13(E_WRITE_m13, "must specify either n_bytes or n_items");
		return_m13((si8) FALSE_m13);
	}

	if (n_bytes == FPS_FULL_FILE_m13) {
		n_bytes = fps->params.fp->len - FPS_UH_BYTES_m13;
		offset = UH_BYTES_m13;  // universal header written above
		fps->direcs.flags |= FPS_DF_CLOSE_AFTER_OP_m13;  // update universal header automatically done with close
	}
	
	update_maximum_entry_size = TRUE_m13;
	if (n_items == 0) {
		n_items = G_items_for_bytes_m13(fps, &n_bytes);
		update_maximum_entry_size = FALSE_m13;  // updated in G_items_for_bytes_m13()
	}
	fps->n_items = n_items;
	
	if (n_bytes == 0) {
		n_bytes = G_bytes_for_items_m13(fps, &n_items, 0);
		update_maximum_entry_size = FALSE_m13;  // updated in G_bytes_for_items_m13()
	}
	
	if (update_maximum_entry_size == TRUE_m13)
		G_update_maximum_entry_size_m13(fps, n_items, n_bytes, offset);
	
	if (offset == FPS_APPEND_m13 || offset == fps->params.fp->len)
		uh->n_entries += n_items;
	
	// leave decrypted directive
	encrypted_data = NULL;
	if (fps->direcs.flags & FPS_DF_LEAVE_DECRYPTED_m13) {
		switch (uh->type_code) {
			case TS_DATA_TYPE_CODE_m13:
			case TS_METADATA_TYPE_CODE_m13:
			case VID_DATA_TYPE_CODE_m13:
			case VID_METADATA_TYPE_CODE_m13:
			case REC_DATA_TYPE_CODE_m13:  // this mechanism assumes copying is faster than decrypting, but possible it's not
				encrypted_data = malloc_m13(n_bytes);
				memcpy(encrypted_data, source, (size_t) n_bytes);  // encrypted below
				source = encrypted_data;
				break;
		}
	}
	
	proc_globs = G_proc_globs_m13((LH_m13 *) fps);
	if (proc_globs->password_data.processed != TRUE_m13) {
		G_set_error_m13(E_ENC_m13, "password not processed");
		return_m13(FALSE_m13);
	}
	
	// encrypt
	switch (uh->type_code) {
		case TS_DATA_TYPE_CODE_m13:
			G_encrypt_time_series_data_m13(fps);
			break;
		case REC_DATA_TYPE_CODE_m13:
			G_encrypt_record_data_m13(fps);
			break;
		case TS_METADATA_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
			G_encrypt_metadata_m13(fps);
			break;
	}
	
	// Calculate CRCs
	// IMPORTANT: if the file is written non-sequentially (not FPS_APPEND_m13 or FPS_FULL_FILE_m13), the CRCs will be invalid
	if (globals_m13->CRC_mode & CRC_CALCULATE_m13) {
		switch (uh->type_code) {
			case TS_DATA_TYPE_CODE_m13:
				G_calculate_time_series_data_CRCs_m13(fps);
				break;
			case VID_DATA_TYPE_CODE_m13:
				G_calculate_video_data_CRCs_m13(fps);
				break;
			case REC_DATA_TYPE_CODE_m13:
				G_calculate_record_data_CRCs_m13(fps);
				break;
			case TS_INDS_TYPE_CODE_m13:
			case VID_INDS_TYPE_CODE_m13:
			case REC_INDS_TYPE_CODE_m13:
				G_calculate_indices_CRCs_m13(fps);
				break;
			case TS_METADATA_TYPE_CODE_m13:
			case VID_METADATA_TYPE_CODE_m13:
				G_calculate_metadata_CRC_m13(fps);
				break;
		}
	}
		
	FPS_seek_m13(fps, offset);
	nw = fwrite_m13(source, sizeof(ui1), (size_t) n_bytes, fps->params.fp);
	if (nw != n_bytes)
		G_warning_message_m13("%s(): write error\n", __FUNCTION__);
	
	// leave decrypted directive
	if (encrypted_data)
		free_m13(encrypted_data);

	// flush
	if (fps->direcs.flags & (FPS_DF_FLUSH_AFTER_WRITE_m13 | FPS_DF_UPDATE_UH_m13))
		fflush(fps->params.fp->fp);  // fflush() updates stat structure
		
	// close
	if (fps->direcs.flags & FPS_DF_CLOSE_AFTER_OP_m13)
		FPS_close_m13(fps);
	
	// update parity
	if (globals_m13->update_parity == TRUE_m13)
		PRTY_update_m13(fps->params.fp, offset, (ui1 *) source, n_bytes);
	
	if (globals_m13->access_times == TRUE_m13)
		G_update_access_time_m13((LH_m13 *) fps);
	
	return_m13(TRUE_m13);
}



//*******************************//
// MARK: HARDWARE FUNCTIONS  (HW)
//*******************************//

ui4	HW_get_block_size_m13(si1 *volume_path)
{
	si1			test_path[PATH_BYTES_m13], command[PATH_BYTES_m13 + 64];
	si1			tmp_path[PATH_BYTES_m13];
	ui4			mmap_block_bytes;
	si4			ret_val;
	FILE_m13		*test_fp;
	PROC_GLOBS_m13	*proc_globs;
#if defined MACOS_m13 || defined LINUX_m13
	struct stat		sb;
#endif
#ifdef WINDOWS_m13
	HANDLE			file_h;
	DISK_GEOMETRY		disk_geom = { 0 };
	ui4			dg_result;
#endif

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// pass name of a file or a directory on the volume you need block size for
	
	if (STR_empty_m13(volume_path) == TRUE_m13)
		return_m13(GLOBALS_MMAP_BLOCK_BYTES_DEFAULT_m13);
	if (G_exists_m13(volume_path) == FILE_EXISTS_m13) {
		G_path_parts_m13(volume_path, tmp_path, NULL, NULL);
		volume_path = tmp_path;
	}
	
	proc_globs = G_proc_globs_m13(NULL);
	mmap_block_bytes = 0;
	
	// create a file on the session volume
	sprintf_m13(test_path, "%s/test_file-remove_me", test_path);
	sprintf_m13(command, "echo x > \"%s\"", test_path);  // create non-empty file in case file system is cloud
	ret_val = system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
	if (ret_val == 0) {
		
		// get volume block size
		test_fp = fopen_m13(test_path, "r");
		#if defined MACOS_m13 || defined LINUX_m13
		fstat(test_fp->fd, &sb);
		mmap_block_bytes = (si8) sb.st_blksize;
		#endif
		#ifdef WINDOWS_m13
		if ((file_h = (HANDLE) _get_osfhandle(test_fp->fd)) != INVALID_HANDLE_VALUE) {
			dg_result = (ui4) DeviceIoControl(file_h, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &disk_geom, sizeof(DISK_GEOMETRY), &dg_result, (LPOVERLAPPED) NULL);
			if (dg_result == 1)
				mmap_block_bytes = (ui4) disk_geom.BytesPerSector;
		}
		#endif
		fclose_m13(test_fp);
		
		// clean up
		#if defined MACOS_m13 || defined LINUX_m13
		sprintf_m13(command, "rm \"%s\"", test_path);
		#endif
		#ifdef WINDOWS_m13
		sprintf_m13(command, "del \"%s\"", test_path);
		#endif
		ret_val = system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
	}
	
	if (mmap_block_bytes <= 0)
		mmap_block_bytes = GLOBALS_MMAP_BLOCK_BYTES_DEFAULT_m13;
	
	proc_globs->miscellaneous.mmap_block_bytes = mmap_block_bytes;

	return_m13(mmap_block_bytes);
}


tern	HW_get_core_info_m13()
{
	HW_PARAMS_m13	*hw_params;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	hw_params = &globals_m13->tables->HW_params;
	
	if (hw_params->logical_cores)
		return_m13(TRUE_m13);
	
	pthread_mutex_lock_m13(&globals_m13->tables->mutex);
	if (hw_params->logical_cores) {  // may have been set by another thread while waiting
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(TRUE_m13);
	}

#ifdef LINUX_m13
	si1	*buf = NULL, *c;;
	si8	buf_len;

	buf_len = system_pipe_m13(&buf, 0, "/usr/bin/lscpu", SP_DEFAULT_m13, CURRENT_BEHAVIOR_m13);
	if (buf_len < 0) {
		hw_params->logical_cores = (si4) get_nprocs_conf();
	} else {
		si4	threads_per_core, cores_per_socket, sockets;
		sf8	scaling, min_mhz, max_mhz;
		
		threads_per_core = cores_per_socket = sockets = 0;
		scaling = min_mhz = max_mhz = (sf8) 0.0;
		
		c = STR_match_end_m13("Vendor ID:", buf);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m13(c, "%[^\r\n]s", hw_params->cpu_manufacturer);
		}
		c = STR_match_end_m13("Model name:", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m13(c, "%[^\r\n]s", hw_params->cpu_model);
		}
		c = STR_match_end_m13("Thread(s) per core:", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m13(c, "%d", &threads_per_core);
		}
		c = STR_match_end_m13("Core(s) per socket:", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m13(c, "%d", &cores_per_socket);
		}
		c = STR_match_end_m13("Socket(s):", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m13(c, "%d", &sockets);
		}
		c = STR_match_end_m13("CPU(s) scaling MHz:", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m13(c, "%lf", &scaling);
		}
		c = STR_match_end_m13("CPU max MHz:", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m13(c, "%lf", &max_mhz);
		}
		c = STR_match_end_m13("CPU min MHz:", c);
		if (c == NULL) {
			c = buf;
		} else {
			while (*c == ' ')
				++c;
			sscanf_m13(c, "%lf", &min_mhz);
		}
		free((void *) buf);
		
		hw_params->physical_cores = sockets * cores_per_socket;
		hw_params->logical_cores = hw_params->physical_cores * threads_per_core;
		if (threads_per_core > 1)
			hw_params->hyperthreading = TRUE_m13;
		else
			hw_params->hyperthreading = FALSE_m13;
		
		hw_params->minimum_speed = min_mhz / (sf8) 1000.0;
		hw_params->maximum_speed = max_mhz / (sf8) 1000.0;
		hw_params->current_speed = hw_params->maximum_speed * (scaling / (sf8) 100.0);
	}
#endif  // LINUX_m13
	
#ifdef MACOS_m13
	size_t	len;
	si1	brand_string[128], *c;
	si8	max_speed;
	
	len = sizeof(si4);
	
	sysctlbyname("machdep.cpu.core_count", &hw_params->physical_cores, &len, NULL, 0);
	sysctlbyname("machdep.cpu.thread_count", &hw_params->logical_cores, &len, NULL, 0);
	if (hw_params->physical_cores < hw_params->logical_cores)
		hw_params->hyperthreading = TRUE_m13;
	else
		hw_params->hyperthreading = FALSE_m13;
	len = 128;
	sysctlbyname("machdep.cpu.brand_string", brand_string, &len, NULL, 0);
	c = STR_match_end_m13("(TM)", brand_string);
	if (c == NULL) {
		strncpy_m13(hw_params->cpu_manufacturer, brand_string, 64);
	} else {
		*c = 0;
		strcpy_m13(hw_params->cpu_manufacturer, brand_string);
		*c = ' ';
		while (*c == ' ')
			++c;
		strcpy_m13(hw_params->cpu_model, c);
	}
	len = sizeof(si8);
	sysctlbyname("hw.cpufrequency", &max_speed, &len, NULL, 0);
	hw_params->maximum_speed = (sf8) max_speed / (sf8) 1000000000.0;
#endif  // MACOS_m13
	
#ifdef WINDOWS_m13
	SYSTEM_INFO	sys_info;
	
	GetSystemInfo(&sys_info);  // returns logical cores
	hw_params->logical_cores = (si4) sys_info.dwNumberOfProcessors;
	hw_params->physical_cores = 0;  // unknown
	hw_params->hyperthreading = UNKNOWN_m13;

	switch((si4) sys_info.wProcessorArchitecture) {
		case PROCESSOR_ARCHITECTURE_AMD64:
			strcpy(hw_params->cpu_manufacturer, "Intel or AMD");
			strcpy(hw_params->cpu_model, "x64");
			break;
		case PROCESSOR_ARCHITECTURE_ARM:
			strcpy(hw_params->cpu_manufacturer, "ARM");
			*hw_params->cpu_model = 0;
			break;
		case PROCESSOR_ARCHITECTURE_ARM64:
			strcpy(hw_params->cpu_manufacturer, "ARM");
			strcpy(hw_params->cpu_model, "x64");
			break;
		case PROCESSOR_ARCHITECTURE_IA64:
			strcpy(hw_params->cpu_manufacturer, "Intel");
			strcpy(hw_params->cpu_model, "Itanium x64");
			break;
		case PROCESSOR_ARCHITECTURE_INTEL:
			strcpy(hw_params->cpu_manufacturer, "Intel");
			strcpy(hw_params->cpu_model, "x86");
			break;
		case PROCESSOR_ARCHITECTURE_UNKNOWN:
		default:
			*hw_params->cpu_manufacturer = *hw_params->cpu_model = 0;
			break;
	}
#endif  // WINDOWS_m13

	pthread_mutex_unlock_m13(&globals_m13->tables->mutex);

	return_m13(TRUE_m13);
}


tern	HW_get_endianness_m13(void)
{
	ui1		endianness;
	ui2		x;
	HW_PARAMS_m13	*hw_params;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	hw_params = &globals_m13->tables->HW_params;
	if (hw_params->endianness == LITTLE_ENDIAN_m13)
		return_m13(TRUE_m13);

	pthread_mutex_lock_m13(&globals_m13->tables->mutex);
	if (hw_params->endianness == LITTLE_ENDIAN_m13) {  // may have been set by another thread while waiting
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(TRUE_m13);
	}

	x = 1;
	endianness = *((ui1 *) &x);

	hw_params->endianness = endianness;

	pthread_mutex_unlock_m13(&globals_m13->tables->mutex);

	return_m13(TRUE_m13);
}


tern	HW_get_machine_code_m13(void)
{
	HW_PARAMS_m13	*hw_params;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	hw_params = &globals_m13->tables->HW_params;
	if (hw_params->machine_code)
		return_m13(TRUE_m13);

	// get machine serial number
	if (*hw_params->serial_number == 0)
		HW_get_machine_serial_m13();

	pthread_mutex_lock_m13(&globals_m13->tables->mutex);
	if (hw_params->machine_code) {  // may have been set by another thread while waiting
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(TRUE_m13);
	}

	// get CRC of machine serial number
	hw_params->machine_code = CRC_calculate_m13((ui1 *) hw_params->serial_number, strlen(hw_params->serial_number));
	
	pthread_mutex_unlock_m13(&globals_m13->tables->mutex);

	return_m13(TRUE_m13);
}


tern	HW_get_machine_serial_m13(void)
{
	HW_PARAMS_m13	*hw_params;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	hw_params = &globals_m13->tables->HW_params;
	if (*hw_params->serial_number)
		return_m13(TRUE_m13);

	pthread_mutex_lock_m13(&globals_m13->tables->mutex);
	if (*hw_params->serial_number) {  // may have been set by another thread while waiting
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(TRUE_m13);
	}
	
	// get machine serial number
#ifdef LINUX_m13
	// Linux makes it impossible to get product serial from within program, even with sudo password. Using default interface MAC.
	if (*globals_m13->tables->NET_params.MAC_address_string == 0)
		NET_get_mac_address_m13(NULL, &globals_m13->tables->NET_params);
	strcpy(hw_params->serial_number, globals_m13->tables->NET_params.MAC_address_string);
	STR_strip_character_m13(hw_params->serial_number, ':');
	pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	
	return_m13(TRUE_m13);
#endif
#if defined MACOS_m13 || defined WINDOWS_m13
	si1		*command, *buf, *machine_sn;
	si8		buf_len;

	#ifdef MACOS_m13
	// out example: "IOPlatformSerialNumber" = "C02XK4D2JGH6"  // quotes are part of output
	command = "ioreg -l | grep IOPlatformSerialNumber";
	#endif
	
	#ifdef WINDOWS_m13
	// out example: SerialNumber\nC02RP18FG8WM
	command = "wmic bios get serialnumber";
	#endif
	
	buf = NULL;
	buf_len = system_pipe_m13(&buf, 0, command, SP_DEFAULT_m13, CURRENT_BEHAVIOR_m13);
	if (buf_len < 0)
		return_m13(FALSE_m13);
	
#ifdef MACOS_m13
	machine_sn = STR_match_end_m13("IOPlatformSerialNumber\" = \"", buf);
	buf[buf_len - 3] = 0;  // <quote><lf>
#endif
	
#ifdef WINDOWS_m13
	buf[buf_len - 7] = buf[buf_len - 8] = 0;  // <cr><lf>
	STR_wchar2char_m13(buf, (wchar_t *) buf);
	machine_sn = STR_match_end_m13("SerialNumber  \r\n", buf);
#endif

	// copy machine serial number
	if (machine_sn)
		strcpy(hw_params->serial_number, machine_sn);

	free(buf);
	
	pthread_mutex_unlock_m13(&globals_m13->tables->mutex);

	return_m13(TRUE_m13);
#endif
}


tern	HW_get_memory_info_m13(void)
{
	si8		pages, page_size;
	HW_PARAMS_m13	*hw_params;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// gets system memory & page size in bytes

	hw_params = &globals_m13->tables->HW_params;
	if (hw_params->system_memory_size)
		return_m13(TRUE_m13);

	pthread_mutex_lock_m13(&globals_m13->tables->mutex);
	if (hw_params->system_memory_size) {  // may have been set by another thread while waiting
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(TRUE_m13);
	}

#if defined MACOS_m13 || defined LINUX_m13
	pages = sysconf(_SC_PHYS_PAGES);
	page_size = sysconf(_SC_PAGE_SIZE);
	
	if (pages == -1 || page_size == -1) {
		fprintf_m13(stderr_m13, "%s(): sysconf() error\n");
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(FALSE_m13);
	}

	hw_params->system_memory_size = (ui8) (pages * page_size);
	hw_params->system_page_size = (ui4) page_size;
#endif
	
#ifdef WINDOWS_m13
	MEMORYSTATUSEX	status;
	SYSTEM_INFO 	system_info;
	
	status.dwLength = sizeof(status);
	if (GlobalMemoryStatusEx(&status) == 0) {
		fprintf_m13(stderr_m13, "%s(): GlobalMemoryStatusEx() error\n", __FUNCTION__);
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(FALSE_m13);
	}
	hw_params->system_memory_size = (ui8) status.ullTotalPhys;
	
	GetNativeSystemInfo(&system_info);
	hw_params->system_page_size = (ui4) system_info.dwPageSize;
#endif
	
	hw_params->heap_base_address = (ui8) globals_m13;  // first thing allocated by init_medlib_m13()
	hw_params->heap_max_address = (hw_params->heap_base_address + hw_params->system_memory_size) - 1;
	
	pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	
	return_m13(TRUE_m13);
}


tern	HW_get_performance_specs_m13(tern get_current)
{
	si8				ROUNDS;
	clock_t				start_t, end_t, elapsed_time;
	si1				file[PATH_BYTES_m13];
	ui8				*p1, *p2, *p3;
	ui8				*test_arr1, *test_arr2, *test_arr3;
	si8				i;
	sf8				temp_sf8;
	FILE_m13			*fp;
	HW_PARAMS_m13			*hw_params;
	HW_PERFORMANCE_SPECS_m13	*perf_specs;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	hw_params = &globals_m13->tables->HW_params;
	perf_specs = &hw_params->performance_specs;

	if (perf_specs->integer_multiplications_per_sec != 0.0 && get_current != TRUE_m13)
		return_m13(TRUE_m13);

	// see if they've been written out previously
	if (get_current != TRUE_m13)
		if (HW_get_performance_specs_from_file_m13() == TRUE_m13)
			return_m13(TRUE_m13);

	pthread_mutex_lock_m13(&globals_m13->tables->mutex);
	// may have been done by another thread while waiting
	if (perf_specs->integer_multiplications_per_sec != 0.0)  {
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(TRUE_m13);
	}
	
	// setup
	if (get_current == TRUE_m13) {
		ROUNDS = 100000;
	} else {
		G_message_m13("Measuring performance specs ... ");
		ROUNDS = 100000000;
	}
	
	test_arr1 = (ui8 *) calloc((size_t) ROUNDS, sizeof(ui8));
	test_arr2 = (ui8 *) calloc((size_t) ROUNDS, sizeof(ui8));
	test_arr3 = (ui8 *) malloc((size_t) ROUNDS << 3);
	mlock_m13((void *) test_arr1, (size_t) (ROUNDS * sizeof(sf8)));
	mlock_m13((void *) test_arr2, (size_t) (ROUNDS * sizeof(sf8)));
	mlock_m13((void *) test_arr3, (size_t) (ROUNDS * sizeof(sf8)));

	p1 = test_arr1;
	p2 = test_arr2;
	for (i = ROUNDS; i--; ++p1, ++p2) {
#if defined MACOS_m13 || defined LINUX_m13
		*p1 = ((ui8) random()) << 16;
		*p1 ^= (ui8) random();  // 48 bit number
		*p2 = ((ui8) random() >> 16) + 1;  // 16 bit non-zero number
#endif
#ifdef WINDOWS_m13
		*p1 = ((ui8) rand()) << 16;
		*p1 ^= (ui8) rand();  // 48 bit number
		*p2 = ((ui8) rand() >> 16) + 1;  // 16 bit non-zero number
#endif
	}

	// multiplication
	p1 = test_arr1;
	p2 = test_arr2;
	p3 = test_arr3;
	start_t = clock();
	for (i = ROUNDS; i--;)
		*p3++ = *p1++ * *p2++;
	end_t = clock();
	elapsed_time = end_t - start_t;
	temp_sf8 = (sf8) (CLOCKS_PER_SEC * ROUNDS) / (sf8) elapsed_time;
	perf_specs->integer_multiplications_per_sec = (si8) (temp_sf8 + (sf8) 0.5);
	perf_specs->nsecs_per_integer_multiplication = (sf8) 1e9 / temp_sf8;

	// division
	p1 = test_arr1;
	p2 = test_arr2;
	p3 = test_arr3;
	start_t = clock();
	for (i = ROUNDS; i--;)
		*p3++ = *p1++ / *p2++;
	end_t = clock();
	elapsed_time = end_t - start_t;
	temp_sf8 = (sf8) (CLOCKS_PER_SEC * ROUNDS) / (sf8) elapsed_time;
	perf_specs->integer_divisions_per_sec = (si8) (temp_sf8 + (sf8) 0.5);
	perf_specs->nsecs_per_integer_division = (sf8) 1e9 / temp_sf8;

	// clean up
	munlock_m13((void *) test_arr1, (size_t) (ROUNDS * sizeof(sf8)));
	munlock_m13((void *) test_arr2, (size_t) (ROUNDS * sizeof(sf8)));
	munlock_m13((void *) test_arr3, (size_t) (ROUNDS * sizeof(sf8)));
	free((void *) test_arr1);
	free((void *) test_arr2);
	free((void *) test_arr3);
	
	pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	
	// write out (for future use)
	if (get_current != TRUE_m13) {
		G_message_m13("done\n");  // end of "Measuring performance specs" message;
		if (HW_get_performance_specs_file_m13(file) == NULL)
			return_m13(FALSE_m13);
		fp = fopen_m13(file, "w");
		fprintf_m13(fp, "machine code: 0x%08x\n", hw_params->machine_code);
		fprintf_m13(fp, "integer multiplications per sec: %ld\n", perf_specs->integer_multiplications_per_sec);
		fprintf_m13(fp, "integer divisions per sec: %ld\n", perf_specs->integer_divisions_per_sec);
		fprintf_m13(fp, "nsecs per integer multiplication: %0.6lf\n", perf_specs->nsecs_per_integer_multiplication);
		fprintf_m13(fp, "nsecs per integer division: %0.6lf\n", perf_specs->nsecs_per_integer_division);
		fclose_m13(fp);
	}
	
	return_m13(TRUE_m13);
}


si1	*HW_get_performance_specs_file_m13(si1 *file)
{
	tern	free_file;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	free_file = FALSE_m13;
	if (file == NULL) {  // caller responsible for freeing
		file = (si1 *) malloc_m13((size_t) PATH_BYTES_m13);
		free_file = TRUE_m13;
	}
	
#if defined MACOS_m13 || defined LINUX_m13
	si1		*env_var;

	env_var = getenv("HOME");
	if (env_var == NULL) {
		G_set_error_m13(E_UNKN_m13, "\"HOME\" is not defined in the environment");
		if (free_file == TRUE_m13)
			free_m13((void *) file);
		return_m13(NULL);
	}
	sprintf_m13(file, "%s/.hw_performance_specs", env_var);
#endif
#ifdef WINDOWS_m13
	si1	*home_drive, *home_path;
	
	home_drive = getenv("HOMEDRIVE");
	home_path = getenv("HOMEPATH");
	if (home_path == NULL || home_drive == NULL) {
		G_set_error_m13(E_UNKN_m13, "either \"HOMEDRIVE\" or \"HOMEPATH\" is not defined in the environment");
		if (free_file == TRUE_m13)
			free_m13((void *) file);
		return_m13(NULL);
	}
	sprintf_m13(file, "%s%s/.hw_performance_specs", home_drive, home_path);
#endif

	return_m13(file);
}


tern	HW_get_performance_specs_from_file_m13(void)
{
	si1				file[PATH_BYTES_m13], *buffer, *c;
	ui4				file_machine_code;
	si8				flen, items;
	FILE_m13			*fp;
	FILE_TIMES_m13			hw_specs_file_time;
	HW_PARAMS_m13			*hw_params;
	HW_PERFORMANCE_SPECS_m13	*perf_specs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (HW_get_performance_specs_file_m13(file) == NULL)
		return_m13(FALSE_m13);
		
	if (G_exists_m13(file) == DOES_NOT_EXIST_m13)
		return_m13(FALSE_m13);

	// read in file
	fp = fopen_m13(file, "r");
	G_file_times_m13(fp, NULL, &hw_specs_file_time, FALSE_m13); // app newer than specs => create new specs file
	if (globals_m13->app_info->file_times.modification > hw_specs_file_time.modification) {
		fclose_m13(fp);
		return_m13(FALSE_m13);
	}
	
	hw_params = &globals_m13->tables->HW_params;
	if (hw_params->machine_code == 0)
		HW_get_machine_code_m13();
	perf_specs = &hw_params->performance_specs;

	// get mutex
	pthread_mutex_lock_m13(&globals_m13->tables->mutex);  // delay getting mutex until machine code known
	if (perf_specs->integer_multiplications_per_sec != 0.0) {  // may have been done by another thread while waiting
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		fclose_m13(fp);
		return_m13(TRUE_m13);
	}

	flen = flen_m13(fp);
	buffer = (si1 *) malloc((size_t) (flen + 1));
	fread_m13((void *) buffer, sizeof(si1), (size_t) flen, fp);
	fclose_m13(fp);
	buffer[flen] = 0;
	
	// parse file
	c = buffer;
	c = STR_match_end_m13("machine code: ", c);
	if (c == NULL)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m13;
	items = sscanf_m13(c, "%x", &file_machine_code);
	if (file_machine_code != hw_params->machine_code || items == 0)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m13;

	c = STR_match_end_m13("integer multiplications per sec: ", c);
	if (c == NULL)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m13;
	items = sscanf_m13(c, "%ld", &perf_specs->integer_multiplications_per_sec);
	if (items == 0)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m13;

	c = STR_match_end_m13("integer divisions per sec: ", c);
	if (c == NULL)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m13;
	items = sscanf_m13(c, "%ld", &perf_specs->integer_divisions_per_sec);
	if (items == 0)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m13;

	c = STR_match_end_m13("nsecs per integer multiplication: ", c);
	if (c == NULL)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m13;
	items = sscanf_m13(c, "%lf", &perf_specs->nsecs_per_integer_multiplication);
	if (items == 0)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m13;

	c = STR_match_end_m13("nsecs per integer division: ", c);
	if (c == NULL)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m13;
	items = sscanf_m13(c, "%lf", &perf_specs->nsecs_per_integer_division);
	if (items == 0)
		goto HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m13;

	pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	free((void *) buffer);
	return_m13(TRUE_m13);

HW_GET_PERFORMANCE_SPECS_FROM_FILE_FAIL_m13:
	
	pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	free((void *) buffer);
	return_m13(FALSE_m13);
}


tern	HW_init_tables_m13(void)
{
	HW_PARAMS_m13		*hw_params;
	GLOBAL_TABLES_m13	*tables;
	

	// fill all unfilled fields in HW table
	tables = globals_m13->tables;
	hw_params = &tables->HW_params;

	if (hw_params->endianness != LITTLE_ENDIAN_m13)
		HW_get_endianness_m13();

	if (hw_params->system_memory_size == 0)  // do this before anything is allocated
		HW_get_memory_info_m13();

	if (hw_params->logical_cores == 0)
		HW_get_core_info_m13();

	if (*hw_params->serial_number == 0)  // do this before getting machine code
		HW_get_machine_serial_m13();

	if (hw_params->machine_code == 0)  // do this before getting performance specs
		HW_get_machine_code_m13();

	if (hw_params->performance_specs.integer_multiplications_per_sec == 0)
		HW_get_performance_specs_m13(FALSE_m13);
	
	return_m13(TRUE_m13);
}


tern	HW_show_info_m13(void)
{
	si1		size_str[SIZE_STRING_BYTES_m13];
	HW_PARAMS_m13	*hw_params;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	hw_params = &globals_m13->tables->HW_params;

	printf_m13("endianness = ");
	switch (hw_params->endianness) {
		case BIG_ENDIAN_m13:
			printf_m13("big endian\n");
			break;
		case LITTLE_ENDIAN_m13:
			printf_m13("little endian\n");
			break;
		default:
			printf_m13("invalid value (%hhu)\n", hw_params->endianness);
			break;
	}
	
	if (hw_params->logical_cores == 0)
		printf_m13("logical_cores = unknown\n");
	else
		printf_m13("logical_cores = %d\n", hw_params->logical_cores);

	if (hw_params->physical_cores == 0)
		printf_m13("physical_cores = unknown\n");
	else
		printf_m13("physical_cores = %d\n", hw_params->physical_cores);
	
	printf_m13("hyperthreading = %s\n", STR_tern_m13(hw_params->hyperthreading));
	
	if (hw_params->minimum_speed == 0.0)
		printf_m13("minimum_speed = unknown\n");
	else
		printf_m13("minimum_speed = %lf GHz\n", hw_params->minimum_speed);
	
	if (hw_params->maximum_speed == 0.0)
		printf_m13("maximum_speed = unknown\n");
	else
		printf_m13("maximum_speed = %lf GHz\n", hw_params->maximum_speed);
	
	if (hw_params->current_speed == 0.0)
		printf_m13("current_speed = unknown\n");
	else
		printf_m13("current_speed = %lf GHz  (average across logical cores)\n", hw_params->current_speed);
	
	if (hw_params->performance_specs.integer_multiplications_per_sec == 0.0)
		printf_m13("integer_multiplications_per_sec = unknown\n");
	else
		printf_m13("integer_multiplications_per_sec = %ld\n", hw_params->performance_specs.integer_multiplications_per_sec);
	if (hw_params->performance_specs.nsecs_per_integer_multiplication == 0.0)
		printf_m13("nsecs_per_integer_multiplication = unknown\n");
	else
		printf_m13("nsecs_per_integer_multiplication = %lf\n", hw_params->performance_specs.nsecs_per_integer_multiplication);
	if (hw_params->performance_specs.integer_divisions_per_sec == 0.0)
		printf_m13("integer_divisions_per_sec = unknown\n");
	else
		printf_m13("integer_divisions_per_sec = %ld\n", hw_params->performance_specs.integer_divisions_per_sec);
	if (hw_params->performance_specs.nsecs_per_integer_division == 0.0)
		printf_m13("nsecs_per_integer_division = unknown\n");
	else
		printf_m13("nsecs_per_integer_division = %lf\n", hw_params->performance_specs.nsecs_per_integer_division);

	if (hw_params->system_memory_size == 0) {
		printf_m13("system_memory_size = unknown\n");
	} else {
		STR_size_m13(size_str, hw_params->system_memory_size, TRUE_m13);
		printf_m13("system_memory_size = %s\n", size_str);
	}
	
	if (hw_params->system_page_size == 0) {
		printf_m13("system_page_size = unknown\n");
	} else {
		STR_size_m13(size_str, hw_params->system_page_size, TRUE_m13);
		printf_m13("system_page_size = %s\n", size_str);
	}

	if (hw_params->heap_base_address == 0)
		printf_m13("heap_base_address = unknown\n");
	else
		printf_m13("heap_base_address = %lu\n", hw_params->heap_base_address);
	
	if (hw_params->heap_max_address == 0)
		printf_m13("heap_max_address = unknown\n");
	else
		printf_m13("heap_max_address = %lu\n", hw_params->heap_max_address);
	
	if (*hw_params->cpu_manufacturer == 0)
		printf_m13("cpu_manufacturer = unknown\n");
	else
		printf_m13("cpu_manufacturer = \"%s\"\n", hw_params->cpu_manufacturer);
	
	if (*hw_params->cpu_model == 0)
		printf_m13("cpu_model = unknown\n");
	else
		printf_m13("cpu_model = \"%s\"\n", hw_params->cpu_model);
	
	if (*hw_params->serial_number == 0)
		printf_m13("serial_number = unknown\n");
	else
		printf_m13("serial_number = %s\n", hw_params->serial_number);
	
	if (hw_params->machine_code == 0)
		printf_m13("machine_code = unknown\n");
	else
		printf_m13("machine_code = 0x%08x\n", hw_params->machine_code);

	return_m13(TRUE_m13);
}



//*******************************//
// MARK: NETWORK FUNCTIONS  (NET)
//*******************************//

tern	NET_check_internet_connection_m13(void)
{
	NET_PARAMS_m13	*np;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// if want to know if machine can reach internet, check == TRUE_m13
	// if want to know if network connected locally != FALSE_m13

	np = &globals_m13->tables->NET_params;
	
	pthread_mutex_lock_m13(&globals_m13->tables->mutex);
	*np->interface_name = 0;
	pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	G_push_behavior_m13(SUPPRESS_OUTPUT_m13);
	np = NET_get_default_interface_m13(np);
	G_pop_behavior_m13();
	if (np == NULL)
		return_m13(FALSE_m13);
	
	// LAN can be up but WAN still down, so check wan IP
	pthread_mutex_lock_m13(&globals_m13->tables->mutex);
	*np->WAN_IPv4_address_string = 0;
	pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	G_push_behavior_m13(SUPPRESS_OUTPUT_m13);
	np = NET_get_wan_ipv4_address_m13(np);
	G_pop_behavior_m13();
	if (np == NULL)
		return_m13(UNKNOWN_m13);  // UNKNOWN == LAN up, WAN down

	return_m13(TRUE_m13);  // TRUE == LAN + WAN up (if machine has static ip, WAN == LAN)
}


tern	NET_domain_to_ip_m13(si1 *domain_name, si1 *ip)
{
	si4			rv;
	struct addrinfo		hints, *servinfo;
	struct sockaddr_in	*h;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	memset(&hints, 0, sizeof(struct addrinfo));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;

	if ((rv = getaddrinfo(domain_name, NULL, &hints , &servinfo)) != 0) {
		G_set_error_m13(E_UNKN_m13, "getaddrinfo: %s (%d)\n", __FUNCTION__, gai_strerror(rv), rv);
		return_m13(FALSE_m13);
	}
	
	// just use the first addrinfo
	if ((h = (struct sockaddr_in *) servinfo->ai_addr) == NULL) {
		*ip = 0;
		freeaddrinfo(servinfo);
		return_m13(FALSE_m13);
	}

	strcpy(ip, inet_ntoa(h->sin_addr));
	freeaddrinfo(servinfo);  // done with this structure
	
	return_m13(TRUE_m13);
}


NET_PARAMS_m13	*NET_get_active_m13(si1 *iface, NET_PARAMS_m13 *np)
{
	tern	copy_global, free_np;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	copy_global = NET_resolve_arguments_m13(iface, &np, &free_np);
	if (copy_global == UNKNOWN_m13)
		return_m13(NULL);

	if (copy_global == TRUE_m13) {
		if (globals_m13->tables->NET_params.active != UNKNOWN_m13)
			np->active = globals_m13->tables->NET_params.active;
	}
	if (np->active != UNKNOWN_m13)
		return_m13(np);
	
#if defined MACOS_m13 || defined LINUX_m13
	if (NET_get_config_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
#endif
#ifdef WINDOWS_m13
	if (NET_get_adapter_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
#endif
	
	return_m13(np);
}


tern	NET_get_adapter_m13(NET_PARAMS_m13 *np, tern copy_global)
{
#ifndef WINDOWS_m13
	return_m13(UNKNOWN_m13);
#else
	tern		global_np;
	si1 	tmp_str[256], *buffer, *iface_start, *c, *c2, *pattern;
	si4 	i, ret_val, attempts;
	DWORD 			dwSize, dwRetVal;
	ULONG			flags, family, outBufLen;
	LPVOID 			lpMsgBuf;
	PIP_ADAPTER_ADDRESSES	pAddresses, pCurrAddress;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// (get all info present in same buffers regardless of which was requested)
	//
	// called for mtu, duplex, link_speed, & active status in Windows

	global_np = FALSE_m13;
	if (copy_global == FALSE_m13)
		if (np == &globals_m13->tables->NET_params)
			global_np = TRUE_m13;

	if (global_np == TRUE_m13) {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		if (*np->link_speed)  {  // may have been done by another thread while waiting
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
			return_m13(TRUE_m13);
		}
	}
		
	// need MAC address
	if (NET_get_mac_address_m13(NULL, np) == NULL) {
		G_warning_message_m13("%s(): cannot get MAC address\n", __FUNCTION__);
		if (global_np == TRUE_m13)
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(FALSE_m13);
	}

	// read GetAdapterAddresses() output
	flags = 0;
	family = AF_INET;  //IPv4
	lpMsgBuf = NULL;
	dwSize = 0;
	dwRetVal = 0;
	pAddresses = NULL;
	outBufLen = 0;
	pCurrAddress = NULL;
	outBufLen = 16384;

	attempts = 0; do {
		pAddresses = (IP_ADAPTER_ADDRESSES *) malloc_m13(outBufLen);
		dwRetVal = GetAdaptersAddresses(family, flags, NULL, pAddresses, &outBufLen);
		if (dwRetVal == ERROR_BUFFER_OVERFLOW) {
			free((void *) pAddresses);
			pAddresses = NULL;
		} else {
			break;
		}
		++attempts;
	} while ((dwRetVal == ERROR_BUFFER_OVERFLOW) && (attempts < 3));
	
	if (dwRetVal == NO_ERROR) {
		pCurrAddress = pAddresses;
		while (pCurrAddress) {
			// match MAC address to interface
			if (pCurrAddress->PhysicalAddressLength != 0) {
				for (i = 0; i < pCurrAddress->PhysicalAddressLength; ++i)
					if (pCurrAddress->PhysicalAddress[i] != np->MAC_address_bytes[i])
						break;
				if (i != pCurrAddress->PhysicalAddressLength) {
					pCurrAddress = pCurrAddress->Next;
					continue;
				}
			}
			np->MTU = (si4) pCurrAddress->Mtu;
			if (pCurrAddress->Flags & IP_ADAPTER_RECEIVE_ONLY)
				strcpy_m13(np->duplex, "false");
			else
				strcpy_m13(np->duplex, "true");
			if (pCurrAddress->ReceiveLinkSpeed >= 1000000000)
				sprintf_m13(np->link_speed, "1 Gbps");
			else if (pCurrAddress->ReceiveLinkSpeed >= 100000000)
				sprintf_m13(np->link_speed, "100 Mbps");
			else if (pCurrAddress->ReceiveLinkSpeed >= 10000000)
				sprintf_m13(np->link_speed, "10 Mbps");
			else
				strcpy(np->link_speed, "unknown");
			if (pCurrAddress->OperStatus == 1)
				np->active = TRUE_m13;
			else if
				(pCurrAddress->OperStatus == 2)
				np->active = TRUE_m13;
			else
				np->active = UNKNOWN_m13;
			break;  // found correct entry - exit loop
		}
	}

	// clean up
	if (pAddresses)
		free((void *) pAddresses);

	// called for mtu, duplex, link_speed, & active status in Windows
	if (copy_global == TRUE_m13) {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		globals_m13->tables->NET_params.MTU = np->MTU;
		globals_m13->tables->NET_params.active = np->active;
		strcpy(globals_m13->tables->NET_params.link_speed, np->link_speed);
		strcpy(globals_m13->tables->NET_params.duplex, np->duplex);
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	} else if (global_np == TRUE_m13) {
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	}

	return_m13(TRUE_m13);
#endif
}


#ifdef LINUX_m13
tern	NET_get_config_m13(NET_PARAMS_m13 *np, tern copy_global)
{
	tern	global_np;
	si1		tmp_str[256], *buffer, *c, *pattern;
	si4		ret_val;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// (get all info present in same buffers regardless of which was requested)
	//
	// called for mtu, MAC_address, LAN_IPv4, plugged_in, & active in Linux

	if (*np->interface_name == 0) {
		G_warning_message_m13("%s(): no interface name\n", __FUNCTION__);
		return_m13(FALSE_m13);
	}

	global_np = FALSE_m13;
	if (copy_global == FALSE_m13)
		if (np == &globals_m13->tables->NET_params)
			global_np = TRUE_m13;

	if (global_np == TRUE_m13) {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		if (*np->MAC_address_string)  {  // may have been done by another thread while waiting
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
			return_m13(TRUE_m13);
		}
	}
	
	// get ifconfig() output
	sprintf_m13(tmp_str, "/usr/sbin/ifconfig %s", np->interface_name);
	buffer = NULL;
	G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_ERROR_OUTPUT_m13);
	ret_val = system_pipe_m13(&buffer, 0, tmp_str, SP_DEFAULT_m13);
	G_pop_behavior_m13();
	if (ret_val) {
		if (global_np == TRUE_m13)
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(FALSE_m13);
	}

	// mtu
	pattern = "mtu ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL) {
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->MTU = 0;
	} else {
		sscanf(c, "%d", &np->MTU);
	}
	
	// MAC address
	pattern = "ether ";
	np->MAC_address_num = 0;
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL) {
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		strcpy(np->MAC_address_string, "unknown");
	} else {
		sscanf(c, "%s", np->MAC_address_string);
		STR_to_upper_m13(np->MAC_address_string);
		sscanf(np->MAC_address_string, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", np->MAC_address_bytes, np->MAC_address_bytes + 1, np->MAC_address_bytes + 2, np->MAC_address_bytes + 3, np->MAC_address_bytes + 4, np->MAC_address_bytes + 5);  // network byte order
	}

	// LAN_IPv4
	if (*np->LAN_IPv4_address_string == 0) {
		pattern = "inet ";
		if ((c = STR_match_end_m13(pattern, buffer)) == NULL) {
			G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
			np->LAN_IPv4_address_num = 0;
			strcpy(np->LAN_IPv4_address_string, "unknown");
		} else {
			sscanf(c, "%s", np->LAN_IPv4_address_string);
			sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_address_bytes, np->LAN_IPv4_address_bytes + 1, np->LAN_IPv4_address_bytes + 2, np->LAN_IPv4_address_bytes + 3);  // network byte order
		}
	}

	pattern = "netmask ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL) {
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->LAN_IPv4_subnet_mask_num = 0;
		strcpy(np->LAN_IPv4_subnet_mask_string, "unknown");
	} else {
		sscanf(c, "%s", np->LAN_IPv4_subnet_mask_string);
		sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_subnet_mask_bytes, np->LAN_IPv4_subnet_mask_bytes + 1, np->LAN_IPv4_subnet_mask_bytes + 2, np->LAN_IPv4_subnet_mask_bytes + 3);
	}

	// status
	pattern = "UP";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL)
		np->active = FALSE_m13;
	else
		np->active = TRUE_m13;
 
	pattern = "RUNNING";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL)
		np->plugged_in = FALSE_m13;
	else
		np->plugged_in = TRUE_m13;

	// clean up
	free(buffer);

	if (copy_global == TRUE_m13) {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		globals_m13->tables->NET_params.MTU = np->MTU;
		strcpy(globals_m13->tables->NET_params.MAC_address_string, np->MAC_address_string);
		globals_m13->tables->NET_params.MAC_address_num = np->MAC_address_num;
		strcpy(globals_m13->tables->NET_params.LAN_IPv4_address_string, np->LAN_IPv4_address_string);
		globals_m13->tables->NET_params.LAN_IPv4_address_num = np->LAN_IPv4_address_num;
		strcpy(globals_m13->tables->NET_params.LAN_IPv4_subnet_mask_string, np->LAN_IPv4_subnet_mask_string);
		globals_m13->tables->NET_params.LAN_IPv4_subnet_mask_num = np->LAN_IPv4_subnet_mask_num;
		globals_m13->tables->NET_params.plugged_in = np->plugged_in;
		globals_m13->tables->NET_params.active = np->active;
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	} else if (global_np == TRUE_m13) {
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	}

	return_m13(TRUE_m13);
}
#endif  // LINUX_m13


#ifdef MACOS_m13
tern	NET_get_config_m13(NET_PARAMS_m13 *np, tern copy_global)
{
	tern	global_np;
	si1		tmp_str[256], *buffer, *c, *pattern;
	si4		ret_val;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// (get all info present in same buffer regardless of which was requested)
	//
	// called for mtu, MAC_address, LAN_IPv4, plugged_in, active, link_speed, & duplex fields in MacOS

	if (*np->interface_name == 0) {
		G_warning_message_m13("%s(): no interface name\n", __FUNCTION__);
		return_m13(FALSE_m13);
	}

	global_np = FALSE_m13;
	if (copy_global == FALSE_m13)
		if (np == &globals_m13->tables->NET_params)
			global_np = TRUE_m13;

	if (global_np == TRUE_m13) {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		if (*np->MAC_address_string)  {  // may have been done by another thread while waiting
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
			return_m13(TRUE_m13);
		}
	}
	
	// get ifconfig() output
	sprintf_m13(tmp_str, "/sbin/ifconfig %s", np->interface_name);
	buffer = NULL;
	G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_ERROR_OUTPUT_m13);
	ret_val = system_pipe_m13(&buffer, 0, tmp_str, SP_DEFAULT_m13);
	G_pop_behavior_m13();
	if (ret_val) {
		if (global_np == TRUE_m13)
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(FALSE_m13);
	}

	// parse ifconfig() output
	pattern = "mtu ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL) {
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->MTU = 0;
	} else {
		sscanf(c, "%d", &np->MTU);
	}
	
	pattern = "ether ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL) {
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", pattern, np->interface_name);
		np->MAC_address_num = 0;
		strcpy(np->MAC_address_string, "unknown");
	} else {
		sscanf(c, "%s", np->MAC_address_string);
		STR_to_upper_m13(np->MAC_address_string);
		sscanf(np->MAC_address_string, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", np->MAC_address_bytes, np->MAC_address_bytes + 1, np->MAC_address_bytes + 2, np->MAC_address_bytes + 3, np->MAC_address_bytes + 4, np->MAC_address_bytes + 5);  // network byte order
	}

	if (*np->LAN_IPv4_address_string == 0) {  // may have been filled in by NET_get_lan_ipv4_address_m13()
		pattern = "inet ";
		if ((c = STR_match_end_m13(pattern, buffer)) == NULL) {
			G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\".\nCheck that cable is plugged in\n", __FUNCTION__, pattern, np->interface_name);
			np->LAN_IPv4_address_num = 0;
			strcpy(np->LAN_IPv4_address_string, "unknown");
		} else {
			sscanf(c, "%s", np->LAN_IPv4_address_string);
			sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_address_bytes, np->LAN_IPv4_address_bytes + 1, np->LAN_IPv4_address_bytes + 2, np->LAN_IPv4_address_bytes + 3);  // network byte order
		}
	}

	pattern = "netmask 0x";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL) {
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->LAN_IPv4_subnet_mask_num = 0;
		strcpy(np->LAN_IPv4_subnet_mask_string, "unknown");
	} else {
		sscanf(c, "%02hhx%02hhx%02hhx%02hhx", np->LAN_IPv4_subnet_mask_bytes, np->LAN_IPv4_subnet_mask_bytes + 1, np->LAN_IPv4_subnet_mask_bytes + 2, np->LAN_IPv4_subnet_mask_bytes + 3);  // network byte order
		sprintf_m13(np->LAN_IPv4_subnet_mask_string, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_subnet_mask_bytes[0], np->LAN_IPv4_subnet_mask_bytes[1], np->LAN_IPv4_subnet_mask_bytes[2], np->LAN_IPv4_subnet_mask_bytes[3]);
	}

	pattern = "media: ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL) {
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		strcpy(np->link_speed, "unknown");
		strcpy(np->duplex, "unknown");
	} else {
		sscanf(c, "%s %s", np->link_speed, np->duplex);
	}

	pattern = "status: ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL) {
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->active = UNKNOWN_m13;
	} else {
		sscanf(c, "%s", tmp_str);
		if (strcmp_m13(tmp_str, "active") == 0)
			np->active = TRUE_m13;
		else if (strcmp_m13(tmp_str, "inactive") == 0)
			np->active = FALSE_m13;
		else {
			G_warning_message_m13("%s(): Unrecognized value (\"%s\") for field \"%s\" in output of ifconfig() for interface \"%s\"\n", __FUNCTION__, tmp_str, pattern, np->interface_name);
			np->active = UNKNOWN_m13;
		}
	}
	
	// clean up
	free(buffer);

	if (copy_global == TRUE_m13) {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		globals_m13->tables->NET_params.MTU = np->MTU;
		strcpy(globals_m13->tables->NET_params.MAC_address_string, np->MAC_address_string);
		globals_m13->tables->NET_params.MAC_address_num = np->MAC_address_num;
		strcpy(globals_m13->tables->NET_params.LAN_IPv4_address_string, np->LAN_IPv4_address_string);
		globals_m13->tables->NET_params.LAN_IPv4_address_num = np->LAN_IPv4_address_num;
		strcpy(globals_m13->tables->NET_params.LAN_IPv4_subnet_mask_string, np->LAN_IPv4_subnet_mask_string);
		globals_m13->tables->NET_params.LAN_IPv4_subnet_mask_num = np->LAN_IPv4_subnet_mask_num;
		globals_m13->tables->NET_params.plugged_in = np->plugged_in;
		globals_m13->tables->NET_params.active = np->active;
		strcpy(globals_m13->tables->NET_params.link_speed, np->link_speed);
		strcpy(globals_m13->tables->NET_params.duplex, np->duplex);
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	} else if (global_np == TRUE_m13) {
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	}

	return_m13(TRUE_m13);
}
#endif  // MACOS_m13


#ifdef WINDOWS_m13
tern	NET_get_config_m13(NET_PARAMS_m13 *np, tern copy_global)
{
	tern		global_np;
	si1 	tmp_str[256], *buffer, *iface_start, *c, *c2, *pattern;
	si4 	i, ret_val, attempts;
	DWORD 			dwSize, dwRetVal;
	ULONG			flags, family, outBufLen;
	LPVOID 			lpMsgBuf;
	PIP_ADAPTER_ADDRESSES	pAddresses, pCurrAddress;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// (get all info present in same buffers regardless of which was requested)
	//
	// called for host_name, MAC_address, LAN_IPv4, & plugged_in fields in Windows

	if (*np->interface_name == 0) {
		G_warning_message_m13("%s(): no interface name\n", __FUNCTION__);
		return_m13(FALSE_m13);
	}

	global_np = FALSE_m13;
	if (copy_global == FALSE_m13)
		if (np == &globals_m13->tables->NET_params)
			global_np = TRUE_m13;

	if (global_np == TRUE_m13) {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		if (*np->MAC_address_string)  {  // may have been done by another thread while waiting
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
			return_m13(TRUE_m13);
		}
	}
		
	// get ipconfig() output
	buffer = NULL;
	G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_ERROR_OUTPUT_m13);
	ret_val = system_pipe_m13(&buffer, 0, "ipconfig /all", SP_DEFAULT_m13);
	G_pop_behavior_m13();
	if (ret_val) {
		if (global_np == TRUE_m13)
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(FALSE_m13);
	}

	// parse ipconfig() output
	if (*np->host_name == 0) {
		pattern = "Host Name";
		if ((c = STR_match_end_m13(pattern, buffer)) == NULL) {
			if (gethostname(np->host_name, sizeof(np->host_name)) == -1) {
				G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ipconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
				strcpy(np->host_name, "unknown");
			}
		} else {
			while (*c++ != ':');
			++c;
			c2 = np->host_name;
			while (*c != '\r' && *c != '\n')
				*c2++ = *c++;
			*c2 = 0;
		}
	}
	
	// search for interface entry
	sprintf_m13(tmp_str, "LAN adapter %s:", np->interface_name);  // pattern
	if ((c = STR_match_end_m13(tmp_str, buffer)) == NULL) {
		G_warning_message_m13("%s(): Could not find interface \"%s\" in output of ipconfig()\n", __FUNCTION__, np->interface_name);
		if (global_np == TRUE_m13)
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(FALSE_m13);
	}
	iface_start = c;  // start all subsequent searches fro this point

	// find next network adapter
	pattern = "adapter";
	if ((c = STR_match_start_m13(pattern, iface_start)))
		*c = 0;  // terminate all subsequent searches here

	np->plugged_in = TRUE_m13;
	pattern = "Media disconnected";
	if ((c = STR_match_end_m13(pattern, iface_start)))
		np->plugged_in = FALSE_m13;

	pattern = "Physical Address";
	if ((c = STR_match_end_m13(pattern, iface_start)) == NULL) {
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ipconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->MAC_address_num = 0;
		strcpy(np->MAC_address_string, "unknown");
	} else {
		while (*c++ != ':');
		++c;
		c2 = np->MAC_address_string;
		while (*c != '\r' && *c != '\n')
			*c2++ = *c++;
		*c2 = 0;
		STR_replace_char_m13('-', ':', np->MAC_address_string);
		STR_to_upper_m13(np->MAC_address_string);
		sscanf(np->MAC_address_string, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", np->MAC_address_bytes, np->MAC_address_bytes + 1, np->MAC_address_bytes + 2, np->MAC_address_bytes + 3, np->MAC_address_bytes + 4, np->MAC_address_bytes + 5);  // network byte order
	}

	if (*np->LAN_IPv4_address_string == 0) {  // may have been filled in above
		pattern = "IPv4 Address";
		if ((c = STR_match_end_m13(pattern, iface_start)) == NULL) {
			G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ipconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
			np->LAN_IPv4_address_num = 0;
			strcpy(np->LAN_IPv4_address_string, "unknown");
		} else {
			while (*c++ != ':');
			++c;
			c2 = np->LAN_IPv4_address_string;
			while (*c != '\r' && *c != '\n' && *c != '(')  // MS attaches "(Preferred)" with no space to default interface
				*c2++ = *c++;
			*c2 = 0;
			sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_address_bytes, np->LAN_IPv4_address_bytes + 1, np->LAN_IPv4_address_bytes + 2, np->LAN_IPv4_address_bytes + 3);  // network byte order
		}
	}

	pattern = "Subnet Mask";
	if ((c = STR_match_end_m13(pattern, iface_start)) == NULL) {
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of ipconfig() for interface \"%s\"\n", __FUNCTION__, pattern, np->interface_name);
		np->LAN_IPv4_subnet_mask_num = 0;
		strcpy(np->LAN_IPv4_subnet_mask_string, "unknown");
	} else {
		while (*c++ != ':');
		++c;
		c2 = np->LAN_IPv4_subnet_mask_string;
		while (*c != '\r' && *c != '\n')
			*c2++ = *c++;
		*c2 = 0;
		sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_subnet_mask_bytes, np->LAN_IPv4_subnet_mask_bytes + 1, np->LAN_IPv4_subnet_mask_bytes + 2, np->LAN_IPv4_subnet_mask_bytes + 3);
	}
	free((void *) buffer);

	if (copy_global == TRUE_m13) {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		strcpy(globals_m13->tables->NET_params.host_name, np->host_name);
		strcpy(globals_m13->tables->NET_params.MAC_address_string, np->MAC_address_string);
		globals_m13->tables->NET_params.MAC_address_num = np->MAC_address_num;
		strcpy(globals_m13->tables->NET_params.LAN_IPv4_address_string, np->LAN_IPv4_address_string);
		globals_m13->tables->NET_params.LAN_IPv4_address_num = np->LAN_IPv4_address_num;
		strcpy(globals_m13->tables->NET_params.LAN_IPv4_subnet_mask_string, np->LAN_IPv4_subnet_mask_string);
		globals_m13->tables->NET_params.LAN_IPv4_subnet_mask_num = np->LAN_IPv4_subnet_mask_num;
		globals_m13->tables->NET_params.plugged_in = np->plugged_in;
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	} else if (global_np == TRUE_m13) {
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	}

	return_m13(TRUE_m13);
}
#endif  // WINDOWS_m13


NET_PARAMS_m13	*NET_get_default_interface_m13(NET_PARAMS_m13 *np)
{
	tern	global_np, free_np;
	si1		*command, *buffer, *c;
	si4		ret_val;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	free_np = global_np = FALSE_m13;
	if (np == &globals_m13->tables->NET_params) {
		global_np = TRUE_m13;
	} else if (np == NULL) {
		np = (NET_PARAMS_m13 *) calloc_m13((size_t) 1, sizeof(NET_PARAMS_m13));
		free_np = TRUE_m13;
	}

	if (*globals_m13->tables->NET_params.interface_name) {
		if (global_np == FALSE_m13)
			strcpy(np->interface_name, globals_m13->tables->NET_params.interface_name);
		return_m13(np);
	}

	if (global_np == TRUE_m13)
		if (*np->interface_name)  // may have been done by another thread while waiting
			return_m13(np);
			
	#ifdef MACOS_m13
	command = "/sbin/route -n get default";
	#endif
	#ifdef LINUX_m13
	command = "/usr/sbin/ip route get 8.8.8.8";
	#endif
	#ifdef WINDOWS_m13
	command = "route PRINT -4 0.0.0.0";
	#endif
	buffer = NULL;
	G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_ERROR_OUTPUT_m13);
	ret_val = system_pipe_m13(&buffer, 0, command, SP_DEFAULT_m13, RETURN_ON_FAIL_m13);
	G_pop_behavior_m13();
	if (ret_val) {  // probably no internet connection, otherwise route() error
		if (global_np == TRUE_m13)
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		if (free_np == TRUE_m13)
			free((void *) np);
		return_m13(NULL);
	}

	#ifdef MACOS_m13
	// parse route() output to get internet interface name
	if ((c = STR_match_end_m13("interface: ", buffer)))
		sscanf(c, "%s", np->interface_name);
	#endif  // MACOS_m13
	
	#ifdef LINUX_m13
	// parse route() output to get internet interface name
	if ((c = STR_match_end_m13("dev ", buffer)))
		sscanf(c, "%s", np->interface_name);
	// parse route() output to get internet ip address
	if ((c = STR_match_end_m13("src ", buffer))) {
		sscanf(c, "%s", np->LAN_IPv4_address_string);
		sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_address_bytes, np->LAN_IPv4_address_bytes + 1, np->LAN_IPv4_address_bytes + 2, np->LAN_IPv4_address_bytes + 3);
	}
	#endif  // LINUX_m13

	#ifdef WINDOWS_m13
	si1	tmp_str[128];

	// parse route() output to get default ip address
	if ((c = STR_match_end_m13("0.0.0.0", buffer))) {
		sscanf(c, "%s%s%s", tmp_str, tmp_str, np->LAN_IPv4_address_string);
		sscanf(np->LAN_IPv4_address_string, "%hhu.%hhu.%hhu.%hhu", np->LAN_IPv4_address_bytes, np->LAN_IPv4_address_bytes + 1, np->LAN_IPv4_address_bytes + 2, np->LAN_IPv4_address_bytes + 3);
		NET_iface_name_for_addr_m13(np->interface_name, np->LAN_IPv4_address_string);
	}
	#endif
	
	free((void *) buffer);
	
	if (*np->interface_name) {
		if (global_np == FALSE_m13) {
			strcpy(globals_m13->tables->NET_params.interface_name, np->interface_name);
			#if defined LINUX_m13 || defined WINDOWS_m13
			strcpy(globals_m13->tables->NET_params.LAN_IPv4_address_string, np->LAN_IPv4_address_string);
			globals_m13->tables->NET_params.LAN_IPv4_address_num = np->LAN_IPv4_address_num;
			#endif
		}
	} else {
		G_warning_message_m13("%s(): no default interface (error %d)\n", __FUNCTION__, ret_val);
		*np->LAN_IPv4_address_string = 0;
		np->LAN_IPv4_address_num = 0;
		if (free_np == TRUE_m13)
			free((void *) np);
		np = NULL;
	}
	
	if (global_np == TRUE_m13)
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);

	return_m13(np);
}


NET_PARAMS_m13	*NET_get_duplex_m13(si1 *iface, NET_PARAMS_m13 *np)
{
	tern	copy_global, free_np;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	copy_global = NET_resolve_arguments_m13(iface, &np, &free_np);
	if (copy_global == UNKNOWN_m13)
		return_m13(NULL);

	if (copy_global == TRUE_m13) {
		if (*globals_m13->tables->NET_params.duplex)
			strcpy(np->duplex, globals_m13->tables->NET_params.duplex);
	}
	if (*np->duplex)
		return_m13(np);
	
#ifdef LINUX_m13
	if (NET_get_ethtool_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
#endif
#ifdef MACOS_m13
	if (NET_get_config_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
#endif
#ifdef WINDOWS_m13
	if (NET_get_adapter_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
#endif
	
	return_m13(np);
}


tern	NET_get_ethtool_m13(NET_PARAMS_m13 *np, tern copy_global)
{
#ifndef LINUX_m13
	return_m13(UNKNOWN_m13);
#else

	tern	global_np;
	si1		tmp_str[256], *buffer, *c, *pattern;
	si4		ret_val;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// (get all info present in same buffers regardless of which was requested)
	//
	// called for link speed & duplex in Linux

	global_np = FALSE_m13;
	if (copy_global == FALSE_m13)
		if (np == &globals_m13->tables->NET_params)
			global_np = TRUE_m13;

	if (global_np == TRUE_m13) {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		if (*np->link_speed)  {  // may have been done by another thread while waiting
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
			return_m13(TRUE_m13);
		}
	}
	
	// Note: ethtool() doesn't seem to work on WiFi networks
	buffer = NULL;
	sprintf_m13(tmp_str, "/usr/sbin/ethtool %s", np->interface_name);
	ret_val = system_pipe_m13(&buffer, 0, tmp_str, SP_DEFAULT_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
	if (ret_val < 0) {  // don't return false => this is typically superfluous info
		G_warning_message_m13("%s(): ethtool is not installed.\nCannot get link speed or duplex settings.\nInstall with \"sudo apt install ethtool\"\n", __FUNCTION__);
	} else {
		pattern = "Speed: ";
		if ((c = STR_match_end_m13(pattern, buffer)))  // not present for wireless connections
			sscanf(c, "%s", np->link_speed);
		pattern = "Duplex: ";
		if ((c = STR_match_end_m13(pattern, buffer)))  // not present for wireless connections
			sscanf(c, "%s", np->duplex);
		free(buffer);
	}
	if (*np->link_speed == 0)
		strcpy(np->link_speed, "unknown");
	if (*np->duplex == 0)
		strcpy(np->duplex, "unknown");

	if (copy_global == TRUE_m13) {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		strcpy(globals_m13->tables->NET_params.link_speed, np->link_speed);
		strcpy(globals_m13->tables->NET_params.duplex, np->duplex);
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	} else if (global_np == TRUE_m13) {
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	}

	return_m13(TRUE_m13);
#endif
}


NET_PARAMS_m13	*NET_get_host_name_m13(NET_PARAMS_m13 *np)
{
	tern	global_np, free_np;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	free_np = FALSE_m13;
	if (np == NULL) {
		np = (NET_PARAMS_m13 *) calloc_m13((size_t) 1, sizeof(NET_PARAMS_m13));
		free_np = TRUE_m13;
	} else if (*np->host_name) {
		return_m13(np);
	}
	
	global_np = FALSE_m13;
	if (np == &globals_m13->tables->NET_params)
		global_np = TRUE_m13;

	if (*globals_m13->tables->NET_params.host_name) {
		if (global_np == FALSE_m13)
			strcpy(np->host_name, globals_m13->tables->NET_params.host_name);
		return_m13(np);
	}
	
	if (global_np == TRUE_m13) {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		if (*np->host_name)  {  // may have been done by another thread while waiting
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
			return_m13(np);
		}
	}
	
	if (gethostname(np->host_name, sizeof(np->host_name)) == -1) {
		G_warning_message_m13("%s(): cannot get host_name\n", __FUNCTION__);
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		else
			strcpy(np->host_name, "unknown");
		return_m13(NULL);
	}
	
	if (global_np == TRUE_m13) {
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	} else {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		strcpy(globals_m13->tables->NET_params.host_name, np->host_name);
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	}

	return_m13(np);
}


void	*NET_get_in_addr_m13(struct sockaddr *sa)	// get sockaddr, IPv4 or IPv6
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (sa->sa_family == AF_INET)
		return_m13(&(((struct sockaddr_in *) sa)->sin_addr));

	return_m13(&(((struct sockaddr_in6 *) sa)->sin6_addr));
}


NET_PARAMS_m13	*NET_get_lan_ipv4_address_m13(si1 *iface, NET_PARAMS_m13 *np)
{
	tern	copy_global, free_np;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	copy_global = NET_resolve_arguments_m13(iface, &np, &free_np);
	if (copy_global == UNKNOWN_m13)
		return_m13(NULL);

	if (copy_global == TRUE_m13) {
		if (*globals_m13->tables->NET_params.LAN_IPv4_address_string) {
			strcpy(np->LAN_IPv4_address_string, globals_m13->tables->NET_params.LAN_IPv4_address_string);
			np->LAN_IPv4_address_num = globals_m13->tables->NET_params.LAN_IPv4_address_num;
		}
	}
	if (*np->LAN_IPv4_address_string)
		return_m13(np);
		
	if (NET_get_config_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
	
	return_m13(np);
}


NET_PARAMS_m13	*NET_get_link_speed_m13(si1 *iface, NET_PARAMS_m13 *np)
{
	tern	copy_global, free_np;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	copy_global = NET_resolve_arguments_m13(iface, &np, &free_np);
	if (copy_global == UNKNOWN_m13)
		return_m13(NULL);

	if (copy_global == TRUE_m13) {
		if (*globals_m13->tables->NET_params.link_speed)
			strcpy(np->link_speed, globals_m13->tables->NET_params.link_speed);
	}
	if (*np->link_speed)
		return_m13(np);
	
#ifdef LINUX_m13
	if (NET_get_ethtool_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
#endif
#ifdef MACOS_m13
	if (NET_get_config_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
#endif
#ifdef WINDOWS_m13
	if (NET_get_adapter_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
#endif
	
	return_m13(np);
}


NET_PARAMS_m13	*NET_get_mac_address_m13(si1 *iface, NET_PARAMS_m13 *np)
{
	tern	copy_global, free_np;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	copy_global = NET_resolve_arguments_m13(iface, &np, &free_np);
	if (copy_global == UNKNOWN_m13)
		return_m13(NULL);

	if (copy_global == TRUE_m13) {
		if (*globals_m13->tables->NET_params.MAC_address_string) {
			strcpy(np->MAC_address_string, globals_m13->tables->NET_params.MAC_address_string);
			np->MAC_address_num = globals_m13->tables->NET_params.MAC_address_num;
		}
	}
	if (*np->MAC_address_string)
		return_m13(np);
	
	if (NET_get_config_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
	
	return_m13(np);
}


NET_PARAMS_m13	*NET_get_mtu_m13(si1 *iface, NET_PARAMS_m13 *np)
{
	tern	copy_global, free_np;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	copy_global = NET_resolve_arguments_m13(iface, &np, &free_np);
	if (copy_global == UNKNOWN_m13)
		return_m13(NULL);

	if (copy_global == TRUE_m13) {
		if (globals_m13->tables->NET_params.MTU > 0)
			np->MTU = globals_m13->tables->NET_params.MTU;
	}
	if (np->MTU > 0)
		return_m13(np);

#if defined MACOS_m13 || defined LINUX_m13
	if (NET_get_config_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
#endif
#ifdef WINDOWS_m13
	if (NET_get_adapter_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
#endif
	
	return_m13(np);
}


NET_PARAMS_m13	*NET_get_parameters_m13(si1 *iface, NET_PARAMS_m13 *np)
{
	tern	copy_global, free_np;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// fill all fields of NET_PARAMS_m13 structure

	copy_global = NET_resolve_arguments_m13(iface, &np, &free_np);
	if (copy_global == UNKNOWN_m13)
		return_m13(NULL);

	if (copy_global == TRUE_m13) {
		if (globals_m13->tables->NET_params.plugged_in != UNKNOWN_m13)
			np->plugged_in = globals_m13->tables->NET_params.plugged_in;
	}
	
	if (NET_get_config_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}

#ifdef LINUX_m13
	if (NET_get_host_name_m13(np) == NULL) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}

	if (NET_get_ethtool_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
#endif
#ifdef MACOS_m13
	if (NET_get_host_name_m13(np) == NULL) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
#endif
#ifdef WINDOWS_m13
	if (NET_get_adapter_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
#endif

	return_m13(np);
}


NET_PARAMS_m13	*NET_get_plugged_in_m13(si1 *iface, NET_PARAMS_m13 *np)
{
	tern	copy_global, free_np;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	copy_global = NET_resolve_arguments_m13(iface, &np, &free_np);
	if (copy_global == UNKNOWN_m13)
		return_m13(NULL);

	if (copy_global == TRUE_m13) {
		if (globals_m13->tables->NET_params.plugged_in != UNKNOWN_m13)
			np->plugged_in = globals_m13->tables->NET_params.plugged_in;
	}
	if (np->plugged_in != UNKNOWN_m13)
		return_m13(np);
	
	if (NET_get_config_m13(np, copy_global) == FALSE_m13) {
		if (free_np == TRUE_m13)
			free_m13((void *) np);
		return_m13(NULL);
	}
	
	return_m13(np);
}


NET_PARAMS_m13 *NET_get_wan_ipv4_address_m13(NET_PARAMS_m13 *np)
{
	tern	global_np;
	si1		*command, *buffer, *pattern, *c;
	si4		ret_val;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (np == NULL)
		np = (NET_PARAMS_m13 *) calloc_m13((size_t) 1, sizeof(NET_PARAMS_m13));
	else if (*np->WAN_IPv4_address_string)
		return_m13(np);
	
	global_np = FALSE_m13;
	if (np == &globals_m13->tables->NET_params)
		global_np = TRUE_m13;
	
	if (*globals_m13->tables->NET_params.WAN_IPv4_address_string) {
		if (global_np == FALSE_m13) {
			strcpy(np->WAN_IPv4_address_string, globals_m13->tables->NET_params.WAN_IPv4_address_string);
			np->WAN_IPv4_address_num = globals_m13->tables->NET_params.WAN_IPv4_address_num;
		}
		return_m13(np);
	}
	
	if (global_np == TRUE_m13) {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		if (*np->WAN_IPv4_address_string)  {  // may have been done by another thread while waiting
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
			return_m13(np);
		}
	}


	// get WAN IPV4 address (this server can take some time)
#if defined MACOS_m13 || defined LINUX_m13
	command = "/usr/bin/curl --connect-timeout 7.0 -s checkip.dyndns.org";
#endif
#ifdef WINDOWS_m13
	command = "curl.exe --connect-timeout 7.0 -s checkip.dyndns.org";
#endif
	
	buffer = NULL;
	G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_ERROR_OUTPUT_m13 | RETRY_ONCE_m13);
	ret_val = system_pipe_m13(&buffer, 0, command, SP_DEFAULT_m13);
	G_pop_behavior_m13();
	if (ret_val || buffer == NULL) {  // curl can fail without output, in which case buffer is NULL
		if (NET_get_lan_ipv4_address_m13(NULL, np) == NULL)
			G_warning_message_m13("%s(): no internet connection\n", __FUNCTION__);
		else
			G_warning_message_m13("%s(): cannot connect to checkip.dyndns.org\n", __FUNCTION__);
		if (global_np == TRUE_m13)
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		return_m13(NULL);
	}

	// parse output
	pattern = "Current IP Address: ";
	if ((c = STR_match_end_m13(pattern, buffer)) == NULL) {
		G_warning_message_m13("%s(): Could not match pattern \"%s\" in output of \"%s\"\n", __FUNCTION__, pattern, command);
		if (global_np == TRUE_m13)
			pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
		free((void *) buffer);
		return_m13(NULL);
	}
	sscanf(c, "%[^< ]s", np->WAN_IPv4_address_string);
	sscanf(c, "%hhu.%hhu.%hhu.%hhu", np->WAN_IPv4_address_bytes, np->WAN_IPv4_address_bytes + 1, np->WAN_IPv4_address_bytes + 2, np->WAN_IPv4_address_bytes + 3);
	
	free((void *) buffer);

	if (global_np == TRUE_m13) {
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	} else {
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
		strcpy(globals_m13->tables->NET_params.WAN_IPv4_address_string, np->WAN_IPv4_address_string);
		globals_m13->tables->NET_params.WAN_IPv4_address_num = np->WAN_IPv4_address_num;
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);
	}

	return_m13(np);
}


#if defined MACOS_m13 || defined LINUX_m13
si1	*NET_iface_name_for_addr_m13(si1 *iface_name, si1 *iface_addr)
{
	si1 			local_iface_name[NI_MAXHOST], tmp_addr[INET6_ADDRSTRLEN];
	si4 			fam;
	struct ifaddrs		*if_addr_list, *ifa;
	socklen_t		si_len;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (getifaddrs(&if_addr_list)) {
		G_warning_message_m13("%s(): getifaddrs() error\n", __FUNCTION__);
		return_m13(NULL);
	}
	
	if (iface_name == NULL)
		iface_name = local_iface_name;  // not thread safe

	for (ifa = if_addr_list; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr == NULL)
			continue;
		
		fam = ifa->ifa_addr->sa_family;
		if (fam == AF_INET)
			si_len = sizeof(struct sockaddr_in);
		else if (fam == AF_INET6)
			si_len = sizeof(struct sockaddr_in6);
		else
			continue;
		
		// get ip address of interface
		if (getnameinfo(ifa->ifa_addr, si_len, tmp_addr, NI_MAXHOST, NULL, 0, NI_NUMERICHOST)) {
			G_warning_message_m13("%s(): getnameinfo() error\n", __FUNCTION__);
			freeifaddrs(if_addr_list);
			return_m13(NULL);
		}
		
		// compare to target address
		if (strcmp_m13(tmp_addr, iface_addr) == 0)
			break;
	}
	if (ifa == NULL) {
		G_warning_message_m13("%s(): could not match ip address to interface\n", __FUNCTION__);
		freeifaddrs(if_addr_list);
		return_m13(NULL);
	}
	
	strcpy(iface_name, ifa->ifa_name);
	freeifaddrs(if_addr_list);
	
	return_m13(iface_name);
}
#endif


#ifdef WINDOWS_m13
si1	*NET_iface_name_for_addr_m13(si1 *iface_name, si1 *iface_addr)
{
	si1			local_iface_name[64], *buffer, *c, *c2;
	si4			ret_val;
	si8			sz;
	FILE			*fp;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (iface_name == NULL)
		iface_name = local_iface_name;  // not thread safe

	// get interface name (aka connection name in Windows)
	buffer = NULL;
	ret_val = system_pipe_m13(&buffer, 0, "ipconfig", SP_DEFAULT_m13, RETURN_ON_FAIL_m13);
	*iface_name = 0;
	if (ret_val > 0) {  // parse ipconfig() output to find internet ip address
		if ((c = STR_match_start_m13(iface_addr, buffer))) {
			// find "LAN adapter" backwards fromm here
			while (c >= buffer) {
				if (*c == 'L')
					if (strncmp_m13(c, "LAN adapter ", 12) == 0)
						break;
				--c;
			}
			if (c >= buffer) {
				c += 12;
				c2 = iface_name;
				while (*c != ':')
					*c2++ = *c++;
				*c2 = 0;
			}
		}
		free((void *) buffer);
	}

	return_m13(iface_name);
}
#endif


tern	NET_init_tables_m13(void)
{
	tern	copy_global;
	NET_PARAMS_m13	*np;
	

	np = &globals_m13->tables->NET_params;
	NET_reset_parameters_m13(np);
	NET_get_default_interface_m13(np);
	copy_global = FALSE_m13;
	
	if (NET_get_config_m13(np, copy_global) == FALSE_m13)
		return(FALSE_m13);
	
	// this can be problematic and is rarely needed
//	if (NET_get_wan_ipv4_address_m13(np) == NULL)
//		return(FALSE_m13);

#ifdef LINUX_m13
	if (NET_get_host_name_m13(np) == NULL)
		return(FALSE_m13);

	if (NET_get_ethtool_m13(np, copy_global) == FALSE_m13)
		return(FALSE_m13);
#endif
#ifdef MACOS_m13
	if (NET_get_host_name_m13(np) == NULL)
		return(FALSE_m13);
#endif
#ifdef WINDOWS_m13
	if (NET_get_adapter_m13(np, copy_global) == FALSE_m13)
		return(FALSE_m13);
#endif

	return(TRUE_m13);
}


tern	NET_reset_parameters_m13(NET_PARAMS_m13 *np)
{
	tern	global_np;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// call to clear NET_PARAMS_m13 structure (e.g. to obtain current values)
	// can call with NULL to reset global parameters)
	
	if (np == NULL)
		np = &globals_m13->tables->NET_params;
	
	global_np = FALSE_m13;
	if (np == &globals_m13->tables->NET_params)
		global_np = TRUE_m13;

	if (global_np == TRUE_m13)
		pthread_mutex_lock_m13(&globals_m13->tables->mutex);
	
	memset((void *) np, 0, sizeof(NET_PARAMS_m13));
	
	if (global_np == TRUE_m13)
		pthread_mutex_unlock_m13(&globals_m13->tables->mutex);

	return_m13(TRUE_m13);
}


tern	NET_resolve_arguments_m13(si1 *iface, NET_PARAMS_m13 **params_ptr, tern *free_params)
{
	tern	interface_is_global, params_are_global;
	si1		tmp_str[64];
	NET_PARAMS_m13	*params;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns "copy global" (if global value known, just copy to np, else get & copy to global)
	// UNKNOWN_m13 indicates failure

	
	if (iface) {
		if (*iface == 0)
			iface = NULL;
	}
	if (params_ptr == NULL)
		params = NULL;
	else
		params = *params_ptr;
	
	*free_params = FALSE_m13;
	
	params_are_global = FALSE_m13;
	if (params) {
		if (params == &globals_m13->tables->NET_params)
			params_are_global = TRUE_m13;
		if (iface == NULL)
			if (*params->interface_name)
				iface = params->interface_name;
	}
	
	if (*globals_m13->tables->NET_params.interface_name == 0)
		if (NET_get_default_interface_m13(&globals_m13->tables->NET_params) == NULL)
			return_m13(UNKNOWN_m13);

	interface_is_global = FALSE_m13;
	if (iface) {
		if (*iface >= '0' && *iface <= '9') {  // caller passed interface ip for interface name
			strcpy_m13(tmp_str, iface);
			NET_iface_name_for_addr_m13(iface, tmp_str);
		}
		if (strcmp_m13(globals_m13->tables->NET_params.interface_name, iface) == 0)
			interface_is_global = TRUE_m13;
	}
	
	if (iface) {
		// case: +iface, +params
		if (params) {
			if (iface != params->interface_name) {
				if (strcmp_m13(iface, params->interface_name)) {  // interface changed, zero other params
					memset((void *) params, 0, sizeof(NET_PARAMS_m13));
					strcpy(params->interface_name, iface);
				}
			}
		}
		// case: +iface, -params
		else {
			params = (NET_PARAMS_m13 *) calloc_m13((size_t) 1, sizeof(NET_PARAMS_m13));
			*free_params = TRUE_m13;
			strcpy(params->interface_name, iface);
		}
	} else { // iface == NULL
		interface_is_global = TRUE_m13;  // true for both cases because if params->interface_name exists, iface
		iface = globals_m13->tables->NET_params.interface_name;
		 // case: -iface, +params
		if (params) {
			if (params_are_global == FALSE_m13)
				strcpy(iface, params->interface_name);
		}
		// case: -iface, -params
		else {
			params = (NET_PARAMS_m13 *) calloc_m13((size_t) 1, sizeof(NET_PARAMS_m13));
			*free_params = TRUE_m13;
			strcpy(iface, params->interface_name);
		}
	}

	*params_ptr = params;

	if (interface_is_global == TRUE_m13 && params_are_global == FALSE_m13)
		return_m13(TRUE_m13);

	return_m13(FALSE_m13);
}


tern  NET_show_parameters_m13(NET_PARAMS_m13 *np)
{
	si1  hex_str[HEX_STR_BYTES_m13(NET_MAC_ADDRESS_BYTES_m13, 1)];
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (np == NULL)
		np = &globals_m13->tables->NET_params;

	printf_m13("interface_name: ");
	if (*np->interface_name)
		printf_m13("%s\n", np->interface_name);
	else
		printf_m13("unknown\n");
	printf_m13("host_name: ", np->host_name);
	if (*np->host_name)
		printf_m13("%s\n", np->host_name);
	else
		printf_m13("unknown\n");
	if (np->MAC_address_num) {
		STR_hex_m13(hex_str, np->MAC_address_bytes, NET_MAC_ADDRESS_BYTES_m13, ":", FALSE_m13);
		printf_m13("MAC_address_bytes: %s\n", hex_str);
		printf_m13("MAC_address_string: %s\n", np->MAC_address_string);
	} else {
		printf_m13("MAC_address_bytes: unknown\n");
		printf_m13("MAC_address_string: unknown\n");
	}
	if (np->LAN_IPv4_address_num) {
		STR_hex_m13(hex_str, np->LAN_IPv4_address_bytes, NET_IPV4_ADDRESS_BYTES_m13, ":", TRUE_m13);
		printf_m13("LAN_IPv4_address_bytes: %s\n", hex_str);
		printf_m13("LAN_IPv4_address_string: %s\n", np->LAN_IPv4_address_string);
	} else {
		printf_m13("LAN_IPv4_address_bytes: unknown\n");
		printf_m13("LAN_IPv4_address_string: unknown\n");
	}
	if (np->LAN_IPv4_subnet_mask_num) {
		STR_hex_m13(hex_str, np->LAN_IPv4_subnet_mask_bytes, NET_IPV4_ADDRESS_BYTES_m13, ":", TRUE_m13);
		printf_m13("LAN_IPv4_subnet_mask_bytes: %s\n", hex_str);
		printf_m13("LAN_IPv4_subnet_mask_string: %s\n", np->LAN_IPv4_subnet_mask_string);
	} else {
		printf_m13("LAN_IPv4_subnet_mask_bytes: unknown\n");
		printf_m13("LAN_IPv4_subnet_mask_string: unknown\n");
	}
	if (np->WAN_IPv4_address_num) {
		STR_hex_m13(hex_str, np->WAN_IPv4_address_bytes, NET_IPV4_ADDRESS_BYTES_m13, ":", TRUE_m13);
		printf_m13("WAN_IPv4_address_bytes: %s\n", hex_str);
		printf_m13("WAN_IPv4_address_string: %s\n", np->WAN_IPv4_address_string);
	} else {
		printf_m13("WAN_IPv4_address_bytes: unknown\n");
		printf_m13("WAN_IPv4_address_string: unknown\n");
	}
	if (np->MTU)
		printf_m13("MTU: %d\n", np->MTU);
	else
		printf_m13("MTU: unknown\n");
	if (*np->link_speed)
		printf_m13("link speed: %s\n", np->link_speed);
	else
		printf_m13("link speed: unknown\n");
	if (np->active == TRUE_m13)
		printf_m13("active: true\n");
	else if (np->active == FALSE_m13)
		printf_m13("active: false\n");
	else
		printf_m13("active: unknown\n");
#ifdef LINUX_m13
	if (*np->duplex)
		printf_m13("duplex: %s\n", np->duplex);
	else
		printf_m13("duplex: unknown\n");
	if (np->plugged_in == TRUE_m13)
		printf_m13("plugged_in: true\n");
	else if (np->plugged_in == FALSE_m13)
		printf_m13("plugged_in: false\n");
	else
		printf_m13("plugged_in: unknown\n");
#endif

	return_m13(TRUE_m13);
}


tern	NET_trim_address_m13(si1 *address)
{
	size_t	len;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// trim ipv6 version of ipv4 address to standard ipv4 address
	
	if (strncmp_m13(address, "::ffff:", 7) == 0) {
		len = strlen(address);
		memmove(address, address + 7, len - 6);
	}
	
	return_m13(TRUE_m13);
}



//********************************//
// MARK: PARALLEL FUNCTIONS  (PAR)
//********************************//

tern	PAR_free_m13(PAR_INFO_m13 **par_info_ptr)  // frees thread globals & par itself - sets par pointer to NULL
{
	extern GLOBALS_m13		**globals_list_m13;
	extern volatile si4		globals_list_len_m13;
	extern pthread_mutex_t_m13	globals_list_mutex_m13;
	PAR_INFO_m13			*par_info;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	par_info = *par_info_ptr;
	if (par_info->status == PAR_RUNNING_m13) {
		G_warning_message_m13("%s(): process is running => returning\n", __FUNCTION__);
		return_m13(FALSE_m13);
	}
	if (par_info->tid == 0) {
		G_warning_message_m13("%s(): process has no thread ID => returning\n", __FUNCTION__);
		return_m13(FALSE_m13);
	}

	// free par & set to NULL
	free((void *) par_info);  // caller responsible for disposing of anything in par_info->ret_val, if neceessary
	*par_info_ptr = NULL;

	return_m13(TRUE_m13);;
}


PAR_INFO_m13	*PAR_init_m13(PAR_INFO_m13 *par_info, si1 *function, si1 *label, ...) // varargs(label != "PAR_DEFAULTS_m13" or NULL): si4 priority, si1 *affinity, si4 detached
{
	tern	defaults;
	si1 		*affinity;
	si4 		priority, detached;
	va_list		v_args;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (STR_empty_m13(function) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "no function passed");
		return_m13(NULL);
	}

	if (par_info == NULL)
		par_info = (PAR_INFO_m13 *) calloc_m13((size_t) 1, sizeof(PAR_INFO_m13));

	strcpy(par_info->function, function);

	defaults = FALSE_m13;
	if (label)
		if (strcmp_m13(label, PAR_DEFAULTS_m13) == 0)
			defaults = TRUE_m13;
	
	if (defaults == TRUE_m13) {
		label = affinity = NULL;
		priority = detached = 0;
	} else {
		va_start(v_args, label);
		priority = va_arg(v_args, si4);
		affinity = va_arg(v_args, si1 *);
		detached = va_arg(v_args, si4);
		va_end(v_args);
	}

	if (STR_empty_m13(label) == TRUE_m13)
		strcpy(par_info->label, "unlabeled thread");
	else
		strcpy(par_info->label, label);
	
	if (priority == 0)
		priority = PROC_DEFAULT_PRIORITY_m13;
	par_info->priority = priority;
	
	if (affinity == NULL)
		affinity = "~0";
	strcpy(par_info->affinity, affinity);

	if (detached == 0)
		detached = TRUE_m13;
	par_info->detached = detached;
	
	return_m13(par_info);
}


PAR_INFO_m13	*PAR_launch_m13(PAR_INFO_m13 *par_info, ...)  // varargs (par_info == NULL): si1 *function, si1 *label, si4 priority, si1 *affinity, si4 detached, <function arguments>
							  // varargs (par_info): <function arguments>
{
	tern			unthreaded;
	PAR_THREAD_INFO_m13	par_t_info;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// function() must return a pointer
	
	// get varags
	va_start(par_t_info.args, par_info);
	
	// initialize par_info
	if (par_info == NULL) {
		si1			*function, *label, *affinity;
		si4			priority, detached;
 
		par_info = (PAR_INFO_m13 *) calloc_m13((size_t) 1, sizeof(PAR_INFO_m13));
		function = va_arg(par_t_info.args, si1 *);
		label = va_arg(par_t_info.args, si1 *);
		if (strcmp_m13(label, PAR_DEFAULTS_m13) == 0) {
			PAR_init_m13(par_info, function, label);
		} else {
			priority = va_arg(par_t_info.args, si4);
			affinity = va_arg(par_t_info.args, si1 *);
			detached = va_arg(par_t_info.args, si4);
			PAR_init_m13(par_info, function, label, priority, affinity, detached);
		}
	}
		
	// "unthreaded" mechanism => just want seperate globals
	if (par_info->detached == PAR_UNTHREADED_m13) {
		unthreaded = TRUE_m13;
		par_info->detached = FALSE_m13;  // launch as attached thread
	} else {
		unthreaded = FALSE_m13;
	}
	
	// set up thread info
	par_t_info.par_info = par_info;
	
	// launch thread
	par_info->status = PAR_LAUNCHING_m13;
	PROC_launch_thread_m13(&par_info->thread_id, PAR_thread_m13, (void *) &par_t_info, par_info->priority, par_info->affinity, NULL, par_info->detached, par_info->label);

	// wait for argument capture
	while (par_info->status == PAR_LAUNCHING_m13)
		nap_m13("10 us");
	va_end(par_t_info.args);
	
	if (unthreaded == TRUE_m13) {
		PAR_wait_m13(par_info, NULL);
		par_info->detached = PAR_UNTHREADED_m13;  // restore for next call
	}
	
	return_m13(par_info);
}


tern	PAR_show_info_m13(PAR_INFO_m13 *par_info)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	printf_m13("\nlabel: \"%s\"\n", par_info->label);
	printf_m13("function: \"%s\"\n", par_info->function);
	if (par_info->ret_val == NULL)
		printf_m13("ret_val: not set\n");
	else
		printf_m13("ret_val: set\n");
	printf_m13("tid: %d\n", par_info->tid);
	printf_m13("priority: 0x%08x\n", par_info->priority);
	printf_m13("affinity: \"%s\"\n", par_info->affinity);
	printf_m13("detached: %d\n", par_info->detached);
	printf_m13("status: %d\n\n", par_info->status);

	return_m13(TRUE_m13);
}


pthread_rval_m13	PAR_thread_m13(void *arg)
{
	si1				*function, *path, *password, *index_channel_name;
	si4				i, fn, list_len, varargs, entries;
	ui8				flags;
	si8 				sample_count;
	sf8 				sampling_frequency, scale, fc1, fc2;
	void				*file_list;
	pid_t_m13			_id;
	PROC_GLOBS_LIST_m13		*list;
	PROC_GLOBS_m13		*proc_globs, **proc_globs_ptr;
	PAR_THREAD_INFO_m13		*par_t_info;
	PAR_INFO_m13 			*par_info;
	SESS_m13			*sess;
	CHAN_m13			*chan;
	SEG_m13			*seg;
	SLICE_m13			*slice;
	DATA_MATRIX_m13 		*mat;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	par_t_info = (PAR_THREAD_INFO_m13 *) arg;
	par_info = par_t_info->par_info;
	function = par_info->function;
	
	// find proc_globs by previous thread id
	_id = par_info->tid;
	list = globals_m13->proc_globs_list;
	pthread_mutex_lock_m13(&list->mutex);  // get mutex
	entries = list->top_idx + 1;
	proc_globs_ptr = list->proc_globs_ptrs;
	proc_globs = NULL;
	for (i = entries; i--; ++proc_globs_ptr) {
		if (*proc_globs_ptr) {
			proc_globs = *proc_globs_ptr;
			if (proc_globs->_id == _id)
				break;
		}
	}
	pthread_mutex_unlock_m13(&list->mutex);  // relase mutex

	if (i == -1)  // proc_globs not found, create new
		proc_globs = G_proc_globs_m13(NULL);
	else
		proc_globs->_id = gettid_m13();  // set to current thread id
	par_info->tid = proc_globs->_id;

	// get function
	if (strcmp_m13(function, "G_open_session_m13") == 0)
		fn = PAR_OPEN_SESSION_M13;
	else if (strcmp_m13(function, "G_read_session_m13") == 0)
		fn = PAR_READ_SESSION_M13;
	else if (strcmp_m13(function, "G_open_channel_m13") == 0)
		fn = PAR_OPEN_CHANNEL_M13;
	else if (strcmp_m13(function, "G_read_channel_m13") == 0)
		fn = PAR_READ_CHANNEL_M13;
	else if (strcmp_m13(function, "G_open_segment_m13") == 0)
		fn = PAR_OPEN_SEGMENT_M13;
	else if (strcmp_m13(function, "G_read_segment_m13") == 0)
		fn = PAR_READ_SEGMENT_M13;
	else if (strcmp_m13(function, "DM_get_matrix_m13") == 0)
		fn = PAR_DM_GET_MATRIX_M13;
	else {
		G_warning_message_m13("%s(): can't match function => returning\n", __FUNCTION__);
		par_info->status = PAR_FINISHED_m13;
		thread_return_null_m13;
	}

	// launch function
	par_info->status = PAR_RUNNING_m13;
	switch (fn) {
		case PAR_OPEN_SESSION_M13:
		case PAR_READ_SESSION_M13:
			sess = va_arg(par_t_info->args, SESS_m13 *);
			slice = va_arg(par_t_info->args, SLICE_m13 *);
			if (fn == PAR_READ_SESSION_M13 && sess) {
				par_info->ret_val = (void *) G_read_session_m13(sess, slice);
			} else {
				file_list = va_arg(par_t_info->args, void *);
				list_len = va_arg(par_t_info->args, si4);
				flags = va_arg(par_t_info->args, ui8);
				password = va_arg(par_t_info->args, si1 *);
				index_channel_name = va_arg(par_t_info->args, si1 *);
				switch (fn) {
					case PAR_OPEN_SESSION_M13:
						par_info->ret_val = (void *) G_open_session_m13(sess, slice, file_list, list_len, flags, password, index_channel_name);
						break;
					case PAR_READ_SESSION_M13:
						par_info->ret_val = (void *) G_read_session_m13(sess, slice, file_list, list_len, flags, password, index_channel_name);
						break;
				}
			}
			break;
		case PAR_OPEN_CHANNEL_M13:
		case PAR_READ_CHANNEL_M13:
		case PAR_OPEN_SEGMENT_M13:
		case PAR_READ_SEGMENT_M13:
			if (fn == PAR_OPEN_SEGMENT_M13 || fn == PAR_READ_SEGMENT_M13)
				seg = va_arg(par_t_info->args, SEG_m13 *);
			else
				chan = va_arg(par_t_info->args, CHAN_m13 *);
			slice = va_arg(par_t_info->args, SLICE_m13 *);
			if (fn == PAR_READ_CHANNEL_M13 && chan) {
				par_info->ret_val = (void *) G_read_channel_m13(chan, slice);
			} else if (fn == PAR_READ_SEGMENT_M13 && seg) {
				par_info->ret_val = (void *) G_read_segment_m13(seg, slice);
			} else {
				path = va_arg(par_t_info->args, void *);
				flags = va_arg(par_t_info->args, ui8);
				password = va_arg(par_t_info->args, si1 *);
				switch (fn) {
					case PAR_OPEN_CHANNEL_M13:
						par_info->ret_val = (void *) G_open_channel_m13(chan, slice, path, NULL, flags, password);
						break;
					case PAR_READ_CHANNEL_M13:
						par_info->ret_val = (void *) G_read_channel_m13(chan, slice, path, NULL, flags, password);
						break;
					case PAR_OPEN_SEGMENT_M13:
						par_info->ret_val = (void *) G_open_segment_m13(seg, slice, path, NULL, flags, password);
						break;
					case PAR_READ_SEGMENT_M13:
						par_info->ret_val = (void *) G_read_segment_m13(seg, slice, path, NULL, flags, password);
						break;
				}
			}
			break;
		case PAR_DM_GET_MATRIX_M13:
			mat = va_arg(par_t_info->args, DATA_MATRIX_m13 *);
			sess = va_arg(par_t_info->args, SESS_m13 *);
			slice = va_arg(par_t_info->args, SLICE_m13 *);
			varargs = va_arg(par_t_info->args, si4);
			if (varargs == FALSE_m13) {
				par_info->ret_val = (void *) DM_get_matrix_m13(mat, sess, slice, varargs);
			} else {
				sample_count = va_arg(par_t_info->args, si8);
				sampling_frequency = va_arg(par_t_info->args, sf8);
				flags = va_arg(par_t_info->args, ui8);
				scale = va_arg(par_t_info->args, sf8);
				fc1 = va_arg(par_t_info->args, sf8);
				fc2 = va_arg(par_t_info->args, sf8);
				par_info->ret_val = (void *) DM_get_matrix_m13(mat, sess, slice, varargs, sample_count, sampling_frequency, flags, scale, fc1, fc2);
			}
			break;
	}

	par_info->status = PAR_FINISHED_m13;
	
	thread_return_null_m13;
}


tern	PAR_wait_m13(PAR_INFO_m13 *par_info, si1 *interval)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (par_info->detached == FALSE_m13) {
		pthread_join_m13(par_info->thread_id, NULL);
		return_m13(TRUE_m13);
	}
	
	if (STR_empty_m13(interval) == TRUE_m13)
		interval = "1 ms";

	// poll detached thread at interval
	while (par_info->status == PAR_RUNNING_m13)
		nap_m13(interval);
	
	return_m13(TRUE_m13);
}



//********************************//
// MARK: PROCESS FUNCTIONS  (PROC)
//********************************//

tern	PROC_adjust_open_file_limit_m13(si4 new_limit, tern verbose_flag)
{
	tern	ret_val = TRUE_m13;
#if defined MACOS_m13 || defined LINUX_m13
	struct rlimit	resource_limit;
#endif

	// verbose_flag passed because this function is usually called before the MED libraries are initialized
	
	#if defined MACOS_m13 || defined LINUX_m13
	// change resource limits (note: must change before calling any functions that use system resources)
	getrlimit(RLIMIT_NOFILE, &resource_limit);  // get existing limit set
	resource_limit.rlim_cur = (rlim_t) new_limit;  // change open file limit
	if (setrlimit(RLIMIT_NOFILE, &resource_limit) == -1)  // set limit set
		ret_val = FALSE_m13;
	#endif

	#ifdef WINDOWS_m13
	if (_setmaxstdio((int) new_limit) == -1)  // change open file limit
		ret_val = FALSE_m13;
	#endif

	if (ret_val == FALSE_m13) {
		if (verbose_flag == TRUE_m13) {
			#ifdef MATLAB_m13
			mexPrintf("%s(): could not adjust process open file limit\n", __FUNCTION__);
			#else
			fprintf(stderr, "%s(): could not adjust process open file limit\n", __FUNCTION__);
			#endif
		}
	}

	return(ret_val);
}


tern	PROC_distribute_jobs_m13(PROC_THREAD_INFO_m13 *jobs, si4 n_jobs, si4 n_reserved_cores, tern wait_jobs, tern thread_jobs)
{
	si4			i, n_logical_cores, n_concurrent_jobs, new_job_idx;
	cpu_set_t_m13		cpu_set;
	HW_PARAMS_m13		*hw_params;
	PROC_THREAD_INFO_m13	*job, *new_job;
	PROC_GLOBS_m13		*proc_globs;
	#if defined LINUX_m13 || defined WINDOWS_m13
	si1			affinity[8];
	si4			start_core, end_core;
	#endif
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// calling function sets up thread_info structures
	// n_reserved_cores = number of cores to leave unassigned (typically zero). When needed this will be adjusted for the task & OS
	// if reserving cores for system n_reserved_cores typically == 1-2
	// if wait_jobs == TRUE_m13 wait for jobs in this function
	// returns FALSE_m13 on error, UNKNOWN_m13 if jobs still running, TRUE_m13 if all jobs finished
	
	// get logical cores
	hw_params = &globals_m13->tables->HW_params;
	if (hw_params->logical_cores == 0)
		HW_get_core_info_m13();
	n_logical_cores = hw_params->logical_cores;
	
	// set reserved cores & concurrent jobs
	#ifdef WINDOWS_m13
	// Windows performs better with at least 1 reserved core (if possible)
	if (n_logical_cores <= 3)
		n_reserved_cores = n_logical_cores - 1;
	else if (n_reserved_cores < 3)
		n_reserved_cores = 3;
	#endif
	
	if (n_reserved_cores >= n_logical_cores)
		n_reserved_cores = n_logical_cores - 1;
	n_concurrent_jobs = n_logical_cores - n_reserved_cores;
	if (n_concurrent_jobs > n_jobs)
		n_concurrent_jobs = n_jobs;
	
	// check threading
	if (thread_jobs == NOT_SET_m13) {
		proc_globs = G_proc_globs_m13(NULL);
		thread_jobs = proc_globs->miscellaneous.threading;  // current process specific
		if (thread_jobs == NOT_SET_m13)
			thread_jobs = globals_m13->threading;  // global
	}

	// build cpu set
#if defined LINUX_m13 || defined WINDOWS_m13  // MacOS does not allow affinity assignment
	#ifdef LINUX_m13
	start_core = n_reserved_cores;
	#endif
	#ifdef WINDOWS_m13  // Windows prefers first and terminal cores
	start_core = 1;
	#endif
	end_core = start_core + (n_concurrent_jobs - 1);
	
	sprintf(affinity, "%d-%d", start_core, end_core);
	PROC_generate_cpu_set_m13(affinity, &cpu_set);
#endif  // LINUX_m13 || WINDOWS_m13
#ifdef MACOS_m13
	cpu_set = ~((cpu_set_t_m13) 0);  // not used at current time
#endif
	
	// set all jobs to waiting state
	for (i = 0; i < n_jobs; ++i)
		jobs[i].status = PROC_THREAD_WAITING_m13;

	#ifdef MATLAB_m13
	G_push_behavior_m13(SUPPRESS_OUTPUT_m13);  // can't have output from threads in mex functions
	#endif

	// launch initial job set (all jobs detached)
	for (i = 0, job = jobs; i < n_concurrent_jobs; ++i, ++job)
		PROC_launch_thread_m13(&job->thread_id, job->thread_f, (void *) job, job->priority, NULL, &cpu_set, TRUE_m13, job->thread_label);

	// make sure status set in threads (volatile)
	for (i = 0, job = jobs; i < n_concurrent_jobs; ++i, ++job)
		while (job->status == PROC_THREAD_WAITING_m13);
	
	// launch rest of jobs as others finish
	new_job_idx = n_concurrent_jobs;
	while (1) {
		for (i = 0, job = jobs; i < n_jobs; ++i, ++job) {
			if (job->status & PROC_THREAD_FINISHED_m13) {
				
				new_job = jobs + new_job_idx;

				// launch new job
				if (thread_jobs == TRUE_m13)
					PROC_launch_thread_m13(&new_job->thread_id, new_job->thread_f, (void *) new_job, new_job->priority, NULL, &cpu_set, TRUE_m13, new_job->thread_label);
				else  // UNKNOWN_m13 or FALSE_m13
					new_job->thread_f((void *) new_job);  // launch in current thread; complete before return

				// check if done
				if (++new_job_idx == n_jobs)
					break;
				
				// make sure status set in thread (volatile)
				while (new_job->status == PROC_THREAD_WAITING_m13);
			}
		}
		if (new_job_idx < n_jobs)
			nap_m13("100 us"); // don't peg this cpu
		else
			break;
	}
	
	if (wait_jobs == TRUE_m13)
		return_m13(PROC_wait_jobs_m13(jobs, n_jobs));
	else
		return_m13(UNKNOWN_m13);
}


cpu_set_t_m13	*PROC_generate_cpu_set_m13(si1 *affinity_str, cpu_set_t_m13 *passed_cpu_set_p)
{
	tern  	not_flag, lessthan_flag, greaterthan_flag;
	si1 	*aff_str;
	si4 	i, n_cpus, start_num, end_num, cpus_set;
	cpu_set_t_m13 		*cpu_set_p;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	/* affinity string examples
	"a" or "all" set to all logical cpus  // same as not specifying a cpu set on most OS's
	"0" set to cpu 0  (read: "0")
	"~0" set to any cpu except 0  (read: "not 0")  // this is the default setting if no cpus are specified
	"<2" set to any cpu less than 2  (read: "less than 2")
	"~<2" set to any cpu greater than or equal to 2  (read: "not less than 2")
	">2" set to any cpu greater than 2  (read: "greater than 2")
	"~>2" set to any cpu less than or equal to 2  (read: "not greater than 2")
	"2-5" set to cpus 2 through 5  (read: "2 through 5")
	"~2-5" set to any cpu except 2 through 5  (read: "not 2 through 5")
	*/
	
	// set default
	if (affinity_str == NULL)
		affinity_str = "~0";
	else if (*affinity_str == 0)
		affinity_str = "~0";

	if (passed_cpu_set_p == NULL)  // up to caller to receive & free
		cpu_set_p = (cpu_set_t_m13 *) malloc(sizeof(cpu_set_t_m13));
	else
		cpu_set_p = passed_cpu_set_p;

	// get logical cpus
	if (globals_m13->tables->HW_params.logical_cores == 0)
		HW_get_core_info_m13();
	n_cpus = globals_m13->tables->HW_params.logical_cores;
	if (n_cpus == 1) {
	#ifdef LINUX_m13
		CPU_ZERO(cpu_set_p);
		CPU_SET(0, cpu_set_p);
	#endif
	#if defined MACOS_m13 || defined WINDOWS_m13
		*cpu_set_p = 1;
	#endif
		return_m13(cpu_set_p);
	}
	
	// parse affinity string
	aff_str = affinity_str;
	not_flag = FALSE_m13;
	if (*aff_str == '~') {
		not_flag = TRUE_m13;
		++aff_str;
	}
	if (*aff_str == 'a')
		end_num = n_cpus - 1;
	lessthan_flag = greaterthan_flag = FALSE_m13;
	if (*aff_str == '<') {
		lessthan_flag = TRUE_m13;
		++aff_str;
	} else if (*aff_str == '>') {
		greaterthan_flag = TRUE_m13;
		++aff_str;
	}
	start_num = 0;
	while (*aff_str >= '0' && *aff_str <= '9') {
		start_num *= 10;
		start_num += *aff_str - '0';
		++aff_str;
	}
	if (*aff_str == '-') {
		++aff_str;
		end_num = 0;
		while (*aff_str >= '0' && *aff_str <= '9') {
			end_num *= 10;
			end_num += *aff_str - '0';
			++aff_str;
		}
	} else {
		if (lessthan_flag == TRUE_m13) {
			end_num = start_num;
			start_num = 0;
		} else if (greaterthan_flag == TRUE_m13) {
			++start_num;
			end_num = n_cpus - 1;
		} else {
			end_num = start_num;
		}
	}
	if (start_num >= n_cpus)
		start_num = end_num = n_cpus - 1;
	else if (end_num >= n_cpus)
		end_num = n_cpus - 1;

	// build affinity set
#ifdef LINUX_m13
	if (not_flag == TRUE_m13) {
		for (i = 0; i < n_cpus; ++i)  // set all bits
			CPU_SET(i, cpu_set_p);
		for (cpus_set = n_cpus, i = start_num; i <= end_num; ++i, --cpus_set)
			CPU_CLR(i, cpu_set_p);
	} else {
		CPU_ZERO(cpu_set_p);
		for (cpus_set = 0, i = start_num; i <= end_num; ++i, ++cpus_set)
			CPU_SET(i, cpu_set_p);
	}
#endif

#if defined MACOS_m13 || defined WINDOWS_m13
	cpu_set_t_m13	mask;

	mask = 1 << start_num;
	*cpu_set_p = 0;
	for (cpus_set = 0, i = start_num; i <= end_num; ++i, mask <<= 1, ++cpus_set)
		*cpu_set_p |= mask;
	if (not_flag == TRUE_m13) {
		*cpu_set_p = ~*cpu_set_p;
		cpus_set = n_cpus - cpus_set;
	}
#endif
	
	if (cpus_set == 0) {
		G_warning_message_m13("%s(): no cpus specified => setting to ~0\n", __FUNCTION__);
#ifdef LINUX_m13
		CPU_CLR(0, cpu_set_p);
		for (i = 1; i < n_cpus; ++i)  // set all remaining bits
			CPU_SET(i, cpu_set_p);
#endif
#if defined MACOS_m13 || defined WINDOWS_m13
		*cpu_set_p = ~((cpu_set_t_m13) 1);
#endif
	}

	return_m13(cpu_set_p);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
pid_t_m13	PROC_id_for_thread_m13(pthread_t_m13 *thread)
{
	pid_t_m13	id;


	// pass NULL for thread for current process id
	
	if (thread == NULL)
		return_m13(gettid_m13());

#if defined MACOS_m13 || defined LINUX_m13
	#ifdef MACOS_m13
	pthread_threadid_np(*thread, &id);
	#endif
	
	#ifdef LINUX_m13
	id = (pid_t_m13) *thread;
	#endif
#endif
	
#ifdef WINDOWS_m13
	id = (pid_t_m13) GetThreadId(*thread);
#endif
	
	return(id);
}


tern	PROC_increase_process_priority_m13(tern verbose_flag, si4 sudo_prompt_flag, ...)  // varargs (sudo_prompt_flag == TRUE_m13): si1 *exec_name, sf8 timeout_secs;
{
	tern	ret_val;
	si4	sys_ret_val;
	

	// verbose_flag passed because this function is usually called before the MED libraries are initialized
	// no printf_m13() calls for the same reason
	
	#if (defined MACOS_m13 || defined LINUX_m13) && !defined MATLAB_m13
	if (sudo_prompt_flag == TRUE_m13) {
		
		uid_t	effective_user = geteuid();
		
		if (effective_user == 0) {  // just reset sudo timeout if necessary (root UID == 0 so this should not prompt)
			system("sudo -l > /dev/null");
		} else {
			si1			pw[MAX_ASCII_PASSWORD_STRING_BYTES_m13], command[1024];
			si1			*exec_name, full_exec_name[PATH_BYTES_m13];
			sf8			timeout_secs;
			va_list			arg_p;
			pid_t			pid;
			
			// check that medlib initialized (required for G_enter_ascii_password_m13)
			if (globals_m13 == NULL) {
				#ifdef MATLAB_m13
				sprintf((char *) command, "\n%s(): initialize medlib before calling with sudo_prompt_flag\n\n", __FUNCTION__);
				mexErrMsgTxt(command);
				#else
				fprintf(stderr, "\n%s(): initialize medlib before calling with sudo_prompt_flag => exiting\n\n", __FUNCTION__);
				exit(-1);
				#endif
			}

			// get varargs
			va_start(arg_p, sudo_prompt_flag);
			exec_name = va_arg(arg_p, si1 *);
			timeout_secs = va_arg(arg_p, sf8);
			va_end(arg_p);
			G_full_path_m13(exec_name, full_exec_name);

			if (G_enter_ascii_password_m13(pw, "Enter sudo password", FALSE_m13, (sf8) timeout_secs, FALSE_m13) == TRUE_m13) {
				if (*pw) {
					// change executable's permissions (for subsequent runs)
					// (changing permissions may fail silently if executable is on a network file system, or NOSUID bit set on volume)
					sprintf_m13(command, "echo %s | sudo -S chown root %s", pw, full_exec_name);  // in case owner wasn't root
					sys_ret_val = system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
					if (sys_ret_val) {  // just check for password failure once
						G_warning_message_m13("%s(): Invalid sudo password\n", __FUNCTION__);
						return(FALSE_m13);
					}
					sprintf_m13(command, "echo %s | sudo -S chmod g+x %s", pw, full_exec_name);  // in case group didn't have execute permissions
					system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
					sprintf_m13(command, "echo %s | sudo -S chmod ug+s %s", pw, full_exec_name);  // set the "set-user" bits (must do owner and group)
					system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
					// renice in shell with sudo password (can't change current process priority from within process unless UID is root, or change kernel CAP_SETUID to true)
					pid = getpid();
					sprintf_m13(command, "echo %s | sudo -S renice %d -p %d", pw, PRIO_MIN, pid);
					sys_ret_val = system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
					if (sys_ret_val)
						return(FALSE_m13);
					return(TRUE_m13);
				} else {
					return(FALSE_m13);  // no password entered
				}
			} else {
				return(FALSE_m13);
			}
		}
	}
	#endif

	ret_val = TRUE_m13;
	#if defined MACOS_m13 || defined LINUX_m13
	if (setpriority(PRIO_PROCESS, 0, PRIO_MIN))
		ret_val = FALSE_m13;
	#endif

	#ifdef WINDOWS_m13
	if ((ret_val = SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS)) == 0)  // zero indicates failure in Windows
		ret_val = FALSE_m13;
	#endif
	
	if (ret_val == FALSE_m13 && verbose_flag == TRUE_m13) {
	#if defined MACOS_m13 || defined LINUX_m13
		#ifdef MATLAB_m13
		mexPrintf("%s(): could not increase priority\nTo run with high priority, in a terminal type: \"sudo chown root <mex file>; sudo chmod ug+s <mex file>\"\n", __FUNCTION__);
		#else
		fprintf(stderr, "%s(): could not increase priority\nTo run with high priority, run with sudo or as root.\nOr: \"sudo chown root <program name>; sudo chmod ug+s <program name>\"\n", __FUNCTION__);
		#endif
	#endif
		
	#ifdef WINDOWS_m13
		#ifdef MATLAB_m13
		mexPrintf("%s(): could not increase priority\n", __FUNCTION__);
		#else
		fprintf(stderr, "%s(): could not increase priority\n", __FUNCTION__);
		#endif
	#endif
	}
	
	return(ret_val);
}


#if defined MACOS_m13 || defined LINUX_m13
pid_t_m13	PROC_launch_thread_m13(pthread_t_m13 *thread, pthread_fn_m13 thread_f, void *arg, si4 priority, si1 *affinity_str, cpu_set_t_m13 *cpu_set_p, tern detached, si1 *thread_name)
{
	sf8			f_min_priority, f_max_priority;
	pid_t_m13		_id = 0;
	pthread_t		local_thread;
	pthread_attr_t		thread_attributes;
	struct sched_param	scheduling_parameters;
	static si4		min_priority = PROC_UNDEFINED_PRIORITY_m13, low_priority, medium_priority, high_priority, max_priority;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// returns new thread's id, or zero for failure

	if (thread == NULL)  // caller doesn't need thread_id - detached thread
		thread = &local_thread;
	
	pthread_attr_init(&thread_attributes);
	
	if (priority != PROC_DEFAULT_PRIORITY_m13) {
		pthread_attr_getschedparam(&thread_attributes, &scheduling_parameters);
		if (min_priority == PROC_UNDEFINED_PRIORITY_m13) {  // only do this once
			f_max_priority = (sf8) sched_get_priority_max(SCHED_OTHER);
			f_min_priority = (sf8) sched_get_priority_min(SCHED_OTHER);
			low_priority = (si4) round((0.75 * f_min_priority) + (0.25 * f_max_priority));
			medium_priority = (si4) round(0.5 * (f_min_priority + f_max_priority));
			high_priority = (si4) round((0.25 * f_min_priority) + (0.75 * f_max_priority));
			max_priority = (si4) f_max_priority;
			min_priority = (si4) f_min_priority;
		}
		switch (priority) {
			case PROC_MIN_PRIORITY_m13:
				scheduling_parameters.sched_priority = min_priority;
				break;
			case PROC_LOW_PRIORITY_m13:
				scheduling_parameters.sched_priority = low_priority;
				break;
			case PROC_MEDIUM_PRIORITY_m13:
				scheduling_parameters.sched_priority = medium_priority;
				break;
			case PROC_HIGH_PRIORITY_m13:
				scheduling_parameters.sched_priority = high_priority;
				break;
			case PROC_MAX_PRIORITY_m13:
				scheduling_parameters.sched_priority = max_priority;
				break;
			default: // caller passed priority value
				scheduling_parameters.sched_priority = priority;
				break;
		}
		pthread_attr_setschedparam(&thread_attributes, &scheduling_parameters);
	}

	if (detached == TRUE_m13)
		pthread_attr_setdetachstate(&thread_attributes, PTHREAD_CREATE_DETACHED);

# ifdef LINUX_m13
	tern	free_cpu_set = FALSE_m13;
	
	// generate affinity
	if (affinity_str) {
		if (*affinity_str) {
			if (cpu_set_p == NULL)  // PROC_generate_cpu_set_m13() will allocate
				free_cpu_set = TRUE_m13;
			cpu_set_p = PROC_generate_cpu_set_m13(affinity_str, cpu_set_p);
		}
	}
	// set affinity
	if (cpu_set_p) {
		PROC_set_thread_affinity_m13(NULL, &thread_attributes, cpu_set_p, TRUE_m13);
		if (free_cpu_set == TRUE_m13)
			free((void *) cpu_set_p);
	}
# endif  // LINUX_m13

# ifdef MACOS_m13
	// in MacOS pthread_setname_np must be run from within the thread itself, so launch thread to name & then run code from within that thread
	if (STR_empty_m13(thread_name) == FALSE_m13) {
		PROC_MACOS_NAMED_THREAD_INFO_m13	*named_thread_info;
		
		named_thread_info = (PROC_MACOS_NAMED_THREAD_INFO_m13 *) malloc(sizeof(PROC_MACOS_NAMED_THREAD_INFO_m13));
		named_thread_info->thread_name = thread_name;
		named_thread_info->thread_f = thread_f;
		named_thread_info->thread_arg = arg;
		arg = (void *) named_thread_info;
		thread_f = PROC_macos_named_thread_m13;
	}
# endif  // MACOS_m13

	// start thread
	if (pthread_create(thread, &thread_attributes, thread_f, arg)) {
		G_set_error_m13(E_UNKN_m13, "beginthreadex() error");
		return_m13(_id);
	}

	// finished with attributes (destroy, or get memory leak)
	pthread_attr_destroy(&thread_attributes);

# ifdef LINUX_m13
	// set thread name (after thread created)
	if (STR_empty_m13(thread_name) == FALSE_m13)
		pthread_setname_np(*thread, thread_name);  // suffix _np is for "not posix" or "not portable"
# endif  // LINUX_m13
	
	_id = PROC_id_for_thread_m13(thread);  // new thread's tid

#ifdef FT_DEBUG_m13
	pid_t_m13	_pid;

	_pid = gettid_m13();  // new thread's parent id
	G_function_stack_set_pid_m13(_id, _pid);
#endif
	
	return_m13(_id);  // zero indicates failure (for compatibility with Windows version, which returns thread id)
}
#endif  // MACOS_m13 || LINUX_m13


#ifdef WINDOWS_m13
pid_t_m13	PROC_launch_thread_m13(pthread_t_m13 *thread, pthread_fn_m13 thread_f, void *arg, si4 priority, si1 *affinity_str, cpu_set_t_m13 *cpu_set_p, tern detached, si1 *thread_name)
{
	tern			free_cpu_set;
	pthread_t_m13		local_thread;
	ui4			win_id;
	pid_t_m13		_id = 0;
	wchar_t			w_thread_name[THREAD_NAME_BYTES_m13];
	cpu_set_t_m13 		local_cpu_set_p;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns new thread's id, or zero for failure

	if (thread == NULL)  // caller doesn't need thread_id - detached thread
		thread = &local_thread;

	// Create thread in suspended state so can set attributes
	*thread = (HANDLE) _beginthreadex(NULL, 0, (LPTHREAD_START_ROUTINE) thread_f, arg, CREATE_SUSPENDED, &win_id);
	if (*thread == NULL || win_id == 0) {
		G_set_error_m13(E_UNKN_m13, "beginthreadex() error");
		return_m13(_id);
	}
	_id = (pid_t_m13) win_id;

	// Set Priority
	if (priority != PROC_DEFAULT_PRIORITY_m13) {
		switch (priority) {
			case PROC_MIN_PRIORITY_m13:
				priority = THREAD_PRIORITY_LOWEST;
				break;
			case PROC_LOW_PRIORITY_m13:
				priority = THREAD_PRIORITY_BELOW_NORMAL;
				break;
			case PROC_MEDIUM_PRIORITY_m13:
				priority = THREAD_PRIORITY_NORMAL;
				break;
			case PROC_HIGH_PRIORITY_m13:
				priority = THREAD_PRIORITY_ABOVE_NORMAL;
				break;
			case PROC_MAX_PRIORITY_m13:
				priority = THREAD_PRIORITY_HIGHEST;
				break;
			default: // caller passed priority value
				break;
		}
		SetThreadPriority(*thread, priority);
	}
	
	// Set Affinity
	free_cpu_set = FALSE_m13;
	if (affinity_str) {
		if (*affinity_str) {
			if (cpu_set_p == NULL)
				free_cpu_set = TRUE_m13;  // PROC_generate_cpu_set_m13() will allocate
			cpu_set_p = PROC_generate_cpu_set_m13(affinity_str, cpu_set_p);
		}
	}
	if (cpu_set_p) {
		PROC_set_thread_affinity_m13(thread, NULL, cpu_set_p, TRUE_m13);
		if (free_cpu_set == TRUE_m13)
			free((void *) cpu_set_p);
	}
	
	// set thread name
	if (STR_empty_m13(thread_name) == FALSE_m13) {
		STR_char2wchar_m13(w_thread_name, thread_name);
		SetThreadDescription(*thread, w_thread_name);
	}
	
	// start thread
	ResumeThread(*thread);

	// detach thread
	if (detached == TRUE_m13)
		CloseHandle(*thread);
	
#ifdef FT_DEBUG_m13
	pid_t_m13	_pid;

	_pid = gettid_m13();  // new thread's parent id
	G_function_stack_set_pid_m13(_id, _pid);
#endif

	return_m13(_id);  // zero indicates failure
}
#endif  // WINDOWS_m13


pthread_rval_m13	PROC_macos_named_thread_m13(void *arg)
{
#ifdef MACOS_m13
	
	PROC_MACOS_NAMED_THREAD_INFO_m13	*named_thread_info;
	si1					*thread_name;
	pthread_fn_m13				thread_f;
	void					*thread_arg;
	pthread_rval_m13			rval;

	// in MacOS a thread can only be named from within itself
	// this thread is substituted for the desired thread, names itself, & then calls desired thread as function

	// break out (for readability)
	named_thread_info = (PROC_MACOS_NAMED_THREAD_INFO_m13 *) arg;
	thread_name = named_thread_info->thread_name;
	thread_f = named_thread_info->thread_f;
	thread_arg = named_thread_info->thread_arg;

	// name thread
	pthread_setname_np(thread_name);  // suffix _np is for "not posix" or "not portable"

	// start thread function
	rval = thread_f(thread_arg);
	
	// release named_thread_info structure
	free(arg);
	
	thread_return_m13(rval);
#else
	return((pthread_rval_m13) 0);
#endif
}


#ifdef LINUX_m13
tern	PROC_set_thread_affinity_m13(pthread_t_m13 *thread, pthread_attr_t_m13 *attributes, cpu_set_t_m13 *cpu_set_p, tern wait_for_lauch)
{
	const si4	MAX_ATTEMPTS = 10;
	tern		use_attributes;
	si1		thread_name[THREAD_NAME_BYTES_m13];
	si4		err, attempts;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// if thread_id_p is passed, it is used
	// if thread_id_p is null & attributes is passed, it is used
	// attributes allow affinity to be set before thread is launched
	// thread_id can be used to change affinity while thread is running
	
	if (thread) {
		err = pthread_setaffinity_np(*thread, sizeof(cpu_set_t), cpu_set_p);  // _np is for "not portable"
		use_attributes = FALSE_m13;
	} else {
		if (attributes == NULL)
			return_m13(FALSE_m13);
		err = pthread_attr_setaffinity_np((pthread_attr_t *) attributes, sizeof(cpu_set_t), cpu_set_p);  // _np is for "not portable"
		use_attributes = TRUE_m13;
	}
	
	if (wait_for_lauch == TRUE_m13) {
		for (attempts = MAX_ATTEMPTS; err == ESRCH && attempts--;) {  // ESRCH == "thread not found" => threads can take a beat to launch
			nap_m13("1 ms");
			if (use_attributes == TRUE_m13)
				err = pthread_attr_setaffinity_np((pthread_attr_t *) attributes, sizeof(cpu_set_t), cpu_set_p);  // _np is for "not portable"
			else
				err = pthread_setaffinity_np(*thread, sizeof(cpu_set_t), cpu_set_p);  // _np is for "not portable"
		}
	}
	
	if (err) {
		*thread_name = 0;
		if (thread)
			pthread_getname_np(*thread, thread_name, (size_t) THREAD_NAME_BYTES_m13);  // _np is for "not posix" or "not portable"
		if (*thread_name)
			G_warning_message_m13("%s(): error setting affinity for thread \"%s\" => not set\n", __FUNCTION__, thread_name);
		else
			G_warning_message_m13("%s(): error setting thread affinity => not set\n", __FUNCTION__);
		return_m13(FALSE_m13);
	}
	
	return_m13(TRUE_m13);
}
#endif  // LINUX_m13


#ifdef WINDOWS_m13
tern	PROC_set_thread_affinity_m13(pthread_t_m13 *thread, pthread_attr_t_m13 *attributes, cpu_set_t_m13 *cpu_set_p, tern wait_for_lauch)
{
	const si4	MAX_ATTEMPTS = 100;
	si1		thread_name[THREAD_NAME_BYTES_m13];
	wchar_t		*w_thread_name;
	si4		err, attempts;
	HRESULT		hr;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// no correlate of attributes in Windows (argument ignored)
	
	err = SetThreadAffinityMask(*thread, (DWORD_PTR) *cpu_set_p);  // Note Windows uses DWORD_PTR to ensure a ui8 - it is not used as pointer to ui4
	
	if (wait_for_lauch == TRUE_m13) {
		for (attempts = MAX_ATTEMPTS; err == 0 && attempts--;) {  // zero == unspecified error => can take a beat to launch
			nap_m13("1 ms");
			err = SetThreadAffinityMask(thread_h, (DWORD_PTR) *cpu_set_p);  // Note Windows uses DWORD_PTR to ensure a ui8 - not used as pointer to ui4
		}
	}
  
	if (err == 0) {
		*thread_name = 0;
		hr = GetThreadDescription(*thread, (PWSTR *) &w_thread_name);
		if (SUCCEEDED(hr)) {
			STR_wchar2char_m13(thread_name, w_thread_name);
			free((void *) w_thread_name);
		}
		if (*thread_name)
			G_warning_message_m13("%s(): error setting affinity for thread \"%s\" => not set\n", __FUNCTION__, thread_name);
		else
			G_warning_message_m13("%s(): error setting thread affinity => not set\n", __FUNCTION__);
		return_m13(FALSE_m13);
	}

	return_m13(TRUE_m13);
}
#endif  // WINDOWS_m13


#ifdef MACOS_m13
tern	PROC_set_thread_affinity_m13(pthread_t_m13 *thread, pthread_attr_t_m13 *attributes, cpu_set_t_m13 *cpu_set_p, tern wait_for_lauch)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// setting processor affinities can be done in MacOS but takes some work (see http://www.hybridkernel.com/2015/01/18/binding_threads_to_cores_osx.html)
	// this site suggests that it must be one core to one thread, not a range, which could be ok, but probably better to do some more reading
	
	*cpu_set_p = 0xFFFFFFFE;
	
	return_m13(TRUE_m13);
}
#endif


#ifdef MACOS_m13
tern	PROC_show_thread_affinity_m13(pthread_t_m13 *thread)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	return_m13(FALSE_m13);  // thread affinity can be done in MacOS, but it takes some work
}
#endif  // MACOS_m13


#ifdef LINUX_m13
tern	PROC_show_thread_affinity_m13(pthread_t_m13 *thread)
{
	si1		thread_name[THREAD_NAME_BYTES_m13];
	si4 		i, n_cpus;
	cpu_set_t	cpu_set;
  
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	*thread_name = 0;
	pthread_getname_np(*thread, thread_name, (size_t) THREAD_NAME_BYTES_m13);  // _np is for "not portable"
	if (*thread_name)
		printf_m13("thread \"%s()\": ", thread_name);
	
	pthread_getaffinity_np(*thread, sizeof(cpu_set_t), &cpu_set);  // _np is for "not portable"
	
	if (globals_m13->tables->HW_params.logical_cores == 0)
		HW_get_core_info_m13();
	n_cpus = globals_m13->tables->HW_params.logical_cores;
	for (i = 0; i < n_cpus; ++i) {
		if (CPU_ISSET(i, &cpu_set))
			printf_m13("1 ");
		else
			printf_m13("0 ");
	}
	printf_m13("\n\n");

	return_m13(TRUE_m13);
}
#endif  // LINUX_m13


#ifdef WINDOWS_m13
tern	PROC_show_thread_affinity_m13(pthread_t_m13 *thread)
{
	si1		thread_name[THREAD_NAME_BYTES_m13];
	wchar_t		*w_thread_name;
	si4		i, n_cpus;
	cpu_set_t_m13	cpu_set, tmp_cpu_set, mask;
	HRESULT		hr;
  
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	SuspendThread(*thread);  // suspend thread to get current cpu set
	tmp_cpu_set = ~((cpu_set_t_m13) 0);
	cpu_set = (cpu_set_t_m13) SetThreadAffinityMask(*thread, (DWORD_PTR) tmp_cpu_set);  // use SetThreadAffinityMask() to return existing cpu set
	tmp_cpu_set = (cpu_set_t_m13) SetThreadAffinityMask(*thread, (DWORD_PTR) cpu_set);  // reset to existing cpu set
	ResumeThread(thread_h);

	if (tmp_cpu_set == 0) {
		G_warning_message_m13("%s(): error %d from SetThreadAffinityMask()\n", __FUNCTION__, GetLastError());
		return_m13(FALSE_m13);
	}

	*thread_name = 0;
	hr = GetThreadDescription(*thread, (PWSTR *) &w_thread_name);
	if (SUCCEEDED(hr)) {
		STR_wchar2char_m13(thread_name, w_thread_name);
		free((void *) w_thread_name);
	}
	if (*thread_name)
		printf_m13("thread \"%s()\": ", thread_name);
	else
		printf_m13("thread: ");
	
	if (globals_m13->tables->HW_params.logical_cores == 0)
		HW_get_core_info_m13();
	n_cpus = globals_m13->tables->HW_params.logical_cores;
	
	for (mask = 1, i = 0; i < n_cpus; ++i, mask <<= 1) {
		if (cpu_set & mask)
			printf_m13("1 ");
		else
			printf_m13("0 ");
	}
	printf_m13("\n\n");

	return_m13(TRUE_m13);
}
#endif  // WINDOWS


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
pthread_t_m13	PROC_thread_for_id_m13(pid_t_m13 id)
{
	pthread_t_m13 thread;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// pass 0 for id for current process thread

	if (id == 0)
		return_m13(pthread_self_m13());

#ifdef MACOS_m13
	// haven't found a away to do this
	G_warning_message_m13("%s(): not implemented on MacOS => returning NULL thread\n");
	thread = (pthread_t_m13) 0;
#endif

#ifdef LINUX_m13
	thread = (pthread_t_m13) id;
#endif
	
#ifdef WINDOWS_m13
	thread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, id);
	CloseHandle(thread);
#endif
	
	return_m13(thread);
}


tern	PROC_wait_jobs_m13(PROC_THREAD_INFO_m13 *jobs, si4 n_jobs)
{
	tern	ret_val;
	si4	i, finished_jobs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// returns FALSE_m13 if any of the jobs failed

	ret_val = TRUE_m13;
	while (1) {
		for (i = finished_jobs = 0; i < n_jobs; ++i) {
			if (jobs[i].status & PROC_THREAD_FINISHED_m13) {
				++finished_jobs;
				if (jobs[i].status == PROC_THREAD_FAILED_m13)
					ret_val = FALSE_m13;
			}
		}
		if (finished_jobs == n_jobs)
			break;
		
		// don't peg this cpu
		nap_m13("100 us");
	}
	
	#ifdef MATLAB_m13
	G_pop_behavior_m13();  // set in PROC_distribute_jobs_m13()
	#endif
	
	return_m13(ret_val);
}



//********************************************//
// MARK: PARITY FUNCTIONS  (PRTY)
//********************************************//


tern	PRTY_build_m13(PRTY_m13 *parity_ps)
{
	ui1			*parity, *data;
	si1			*parity_path;
	ui4			type_code;
	si4			i, j, n_files;
	ui8			*target_ptr, *source_ptr;
	si8			nr, nw, mem_block_bytes, bytes_read, bytes_written, bytes_remaining, bytes_to_read, bytes_to_write, basis_len;
	si8			source_bytes_to_read, source_bytes_remaining;
	PRTY_FILE_m13		*files, *basis_file, *source_file;
	FILE_m13		*parity_fp;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// break out ps
	files = parity_ps->files;
	n_files = parity_ps->n_files;
	parity = parity_ps->parity;
	data = parity_ps->data;
	mem_block_bytes = parity_ps->mem_block_bytes;
	parity_path = parity_ps->path;
	
	// copy single files (they're their own parity)
	if (n_files == 1) {
		if (G_exists_m13(files[0].path) == TRUE_m13) {
			cp_m13(files[0].path, parity_path);
			return_m13(TRUE_m13);
		}
		return_m13(FALSE_m13);
	}

	// open files
	for (i = 0; i < n_files; ++i) {
		if (G_exists_m13(files[i].path) == FILE_EXISTS_m13) {
			files[i].fp = fopen_m13(files[i].path, "r");
			files[i].len = PRTY_pcrc_offset_m13(files[i].fp, NULL, NULL);  // check if file has parity data
		} else {
			G_set_error_m13(E_UNKN_m13, "file \"%s\" does not exist", files[i].path);
			return_m13(FALSE_m13);
		}
		files[i].finished = FALSE_m13;
	}

	// sort by length
	qsort((void *) files, (size_t) n_files, sizeof(PRTY_FILE_m13), PRTY_file_compare_m13);
		
	// open parity file
	parity_fp = fopen_m13(parity_path, "w");
	
	// build parity
	bytes_read = bytes_written = 0;
	--n_files;  // longest (last) file is will be read into parity array as basis file
	basis_file = files + n_files;
	basis_len = basis_file->len;
	while (bytes_read < basis_len) {
		// read basis file (longest)
		bytes_remaining = basis_len - bytes_read;
		bytes_to_read = mem_block_bytes;
		if (bytes_remaining < mem_block_bytes)
			bytes_to_read = bytes_remaining;
		bytes_to_write = bytes_to_read;
		nr = fread_m13((void *) parity, sizeof(ui1), (size_t) bytes_to_read, basis_file->fp);
		if (nr != bytes_to_read)
			return_m13(FALSE_m13);
		bytes_read += nr;
		
		// read source files
		for (i = 0; i < n_files; ++i) {
			source_file = files + i;
			if (source_file->finished == TRUE_m13)
				continue;
			source_bytes_to_read = bytes_to_read;
			source_bytes_remaining = source_file->len - bytes_written;
			if (source_bytes_remaining & 7)
				G_warning_message_m13("%s(): source_bytes_remaining not multiple of 8 in \"%s\"\n", __FUNCTION__, source_file->path);
			if (source_bytes_to_read >= source_bytes_remaining) {
				source_bytes_to_read = source_bytes_remaining;
				source_file->finished = TRUE_m13;
			}
			nr = fread_m13((void *) data, sizeof(ui1), (size_t) source_bytes_to_read, source_file->fp);
			if (nr != source_bytes_to_read)
				return_m13(FALSE_m13);

			// add to parity array
			target_ptr = (ui8 *) parity;
			source_ptr = (ui8 *) data;
			
			for (j = source_bytes_to_read >> 3; j--;)
				*target_ptr++ ^= *source_ptr++;
		}

		// write out new parity
		nw = fwrite_m13((void *) parity, sizeof(ui1), (size_t) bytes_to_write, parity_fp);
		if (nw != bytes_to_write)
			return_m13(FALSE_m13);
		bytes_written += nw;
	}
	
	// close files
	++n_files;  // (n_files decremented above)
	for (i = 0; i < n_files; ++i)
		fclose_m13(files[i].fp);
	fclose_m13(parity_fp);

	// add parity crc data for video data
	type_code = G_MED_type_code_from_string_m13(files[0].path);
	if (type_code == VID_DATA_TYPE_CODE_m13) {
		for (i = 0; i < n_files; ++i) {
			if (PRTY_write_pcrc_m13(files[i].path, 0) != TRUE_m13)
				return_m13(FALSE_m13);
		}
	}
	
	// add parity crc data for parity file
	if (PRTY_write_pcrc_m13(parity_path, 0) != TRUE_m13)
		return_m13(FALSE_m13);

	return_m13(TRUE_m13);
}


si4	PRTY_file_compare_m13(const void *a, const void *b)
{
	PRTY_FILE_m13	*as, *bs;
	
	
	as = (PRTY_FILE_m13 *) a;
	bs = (PRTY_FILE_m13 *) b;
	
	if (as->len < bs->len)
		return((si4) -1);
	if (as->len > bs->len)
		return((si4) 1);
	
	return((si4) 0);
}


si1	**PRTY_file_list_m13(si1 *MED_path, si4 *n_files)  // MED_path is MED file or directory
{
	tern	sess_files, ssr_files, chan_files, all_segs;
	si1	sess_path[PATH_BYTES_m13] = { 0 };
	si1	sess_name[NAME_BYTES_m13] = { 0 };
	si1	ssr_path[PATH_BYTES_m13] = { 0 };
	si1	chan_path[PATH_BYTES_m13] = { 0 };
	si1	seg_path[PATH_BYTES_m13] = { 0 };
	si1	tmp_path[PATH_BYTES_m13] = { 0 };
	si1	tmp_str[SEG_NAME_BYTES_m13] = { 0 };
	si1	**file_list, **tmp_list, **ssr_list, **chan_list, **seg_list, **vid_list;
	ui4	type_code;
	si4	i, j, k, tmp_files;
	si4	n_ssrs, n_chans, n_segs, n_vids;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns a list of file paths that exist at or below the passed path level
	
	G_full_path_m13(MED_path, tmp_path);
	
	file_list = NULL;
	*n_files = 0;

	n_chans = n_segs = 0;
	sess_files = ssr_files = chan_files = all_segs = FALSE_m13;
	type_code = G_MED_type_code_from_string_m13(tmp_path);
	ssr_list = chan_list = NULL;
	switch (type_code) {
		case SESS_TYPE_CODE_m13:
			strcpy(sess_path, tmp_path);
			G_path_parts_m13(sess_path, NULL, sess_name, NULL);
			sprintf_m13(ssr_path, "%s/%s.%s", sess_path, sess_name, SSR_TYPE_STR_m13);
			chan_list = G_file_list_m13(NULL, &n_chans, sess_path, NULL, "?icd", GFL_FULL_PATH_m13);
			sess_files = ssr_files = chan_files = all_segs = TRUE_m13;
			break;
		case SSR_TYPE_CODE_m13:
			strcpy(ssr_path, tmp_path);
			G_path_parts_m13(ssr_path, sess_path, sess_name, NULL);
			ssr_files = TRUE_m13;
			break;
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
			strcpy(chan_path, tmp_path);
			G_path_parts_m13(chan_path, sess_path, NULL, NULL);
			sess_files = ssr_files = FALSE_m13;
			chan_list = (si1 **) calloc_2D_m13((size_t) 1, (size_t) PATH_BYTES_m13, sizeof(si1));
			strcpy(chan_list[0], chan_path);
			chan_files = all_segs = TRUE_m13;
			n_chans = 1;
			break;
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
			strcpy(seg_path, tmp_path);
			G_path_parts_m13(seg_path, chan_path, NULL, NULL);
			G_path_parts_m13(chan_path, sess_path, NULL, NULL);
			n_chans = 1;
			chan_list = (si1 **) calloc_2D_m13((size_t) n_chans, (size_t) PATH_BYTES_m13, sizeof(si1));
			strcpy(chan_list[0], chan_path);
			n_segs = 1;
			seg_list = (si1 **) calloc_2D_m13((size_t) n_segs, (size_t) PATH_BYTES_m13, sizeof(si1));
			strcpy(seg_list[0], seg_path);
			all_segs = FALSE_m13;
			break;
		case REC_DATA_TYPE_CODE_m13:
		case REC_INDS_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
		case VID_DATA_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
		case TS_METADATA_TYPE_CODE_m13:
		case TS_DATA_TYPE_CODE_m13:
		case TS_INDS_TYPE_CODE_m13:
			if (G_exists_m13(tmp_path) == FILE_EXISTS_m13) {
				file_list = (si1 **) calloc_2D_m13((size_t) 1, (size_t) PATH_BYTES_m13, sizeof(si1));
				strcpy(file_list[0], tmp_path);
				*n_files = 1;
			}
			return_m13(file_list);
		case NO_TYPE_CODE_m13:
			return_m13(NULL);
	}
		
	tmp_files = MAX_OPEN_FILES_m13(2048, 1);  // max channels 2048
	tmp_list = (si1 **) calloc_2D_m13((size_t) tmp_files, (size_t) PATH_BYTES_m13, sizeof(si1));
	tmp_files = 0;
	
	// session records
	if (sess_files == TRUE_m13) {
		sprintf_m13(tmp_path, "%s/%s.%s", sess_path, sess_name, REC_DATA_TYPE_STR_m13);
		if (G_exists_m13(tmp_path) == FILE_EXISTS_m13)
			strcpy(tmp_list[tmp_files++], tmp_path);
		sprintf_m13(tmp_path, "%s/%s.%s", sess_path, sess_name, REC_INDS_TYPE_STR_m13);
		if (G_exists_m13(tmp_path) == FILE_EXISTS_m13)
			strcpy(tmp_list[tmp_files++], tmp_path);
	}

	if (ssr_files == TRUE_m13) {
		if (G_exists_m13(ssr_path) == DIR_EXISTS_m13) {
			ssr_list = G_file_list_m13(NULL, &n_ssrs, ssr_path, NULL, "r*", GFL_FULL_PATH_m13);
			for (i = 0; i < n_ssrs; ++i) {
				if (G_exists_m13(ssr_list[i]) == FILE_EXISTS_m13)
					strcpy(tmp_list[tmp_files++], ssr_list[i]);
			}
			free_m13((void *) ssr_list);
		}
	}
	
	for (i = 0; i < n_chans; ++i) {
		if (chan_files == TRUE_m13) {
			G_path_parts_m13(chan_list[i], NULL, tmp_str, NULL);
			sprintf_m13(tmp_path, "%s/%s.%s", chan_list[i], tmp_str, REC_DATA_TYPE_STR_m13);
			if (G_exists_m13(tmp_path) == FILE_EXISTS_m13)
				strcpy(tmp_list[tmp_files++], tmp_path);
			sprintf_m13(tmp_path, "%s/%s.%s", chan_list[i], tmp_str, REC_INDS_TYPE_STR_m13);
			if (G_exists_m13(tmp_path) == FILE_EXISTS_m13)
				strcpy(tmp_list[tmp_files++], tmp_path);
		}
		if (all_segs == TRUE_m13)
			seg_list = G_file_list_m13(NULL, &n_segs, chan_list[i], NULL, "?isd", GFL_FULL_PATH_m13);
		
		type_code = G_MED_type_code_from_string_m13(chan_list[i]);
		for (j = 0; j < n_segs; ++j) {
			G_path_parts_m13(seg_list[j], NULL, tmp_str, NULL);

			if (type_code == TS_CHAN_TYPE_CODE_m13) {
				sprintf_m13(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, TS_DATA_TYPE_STR_m13);
				if (G_exists_m13(tmp_path) == FILE_EXISTS_m13)
					strcpy(tmp_list[tmp_files++], tmp_path);
				sprintf_m13(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, TS_INDS_TYPE_STR_m13);
				if (G_exists_m13(tmp_path) == FILE_EXISTS_m13)
					strcpy(tmp_list[tmp_files++], tmp_path);
				sprintf_m13(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, TS_METADATA_TYPE_STR_m13);
				if (G_exists_m13(tmp_path) == FILE_EXISTS_m13)
					strcpy(tmp_list[tmp_files++], tmp_path);
			} else if (type_code == VID_CHAN_TYPE_CODE_m13) {
				vid_list = G_file_list_m13(NULL, &n_vids, chan_list[i], "*_s????_n????", NULL, GFL_FULL_PATH_m13);
				for (k = 0; k < n_vids; ++k)
					strcpy(tmp_list[tmp_files++], vid_list[k]);
				free_m13((void *) vid_list);
				sprintf_m13(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, VID_INDS_TYPE_STR_m13);
				if (G_exists_m13(tmp_path) == FILE_EXISTS_m13)
					strcpy(tmp_list[tmp_files++], tmp_path);
				sprintf_m13(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, VID_METADATA_TYPE_STR_m13);
				if (G_exists_m13(tmp_path) == FILE_EXISTS_m13)
					strcpy(tmp_list[tmp_files++], tmp_path);
			}
			sprintf_m13(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, REC_DATA_TYPE_STR_m13);
			if (G_exists_m13(tmp_path) == FILE_EXISTS_m13)
				strcpy(tmp_list[tmp_files], tmp_path);
			sprintf_m13(tmp_path, "%s/%s.%s", seg_list[j], tmp_str, REC_INDS_TYPE_STR_m13);
			if (G_exists_m13(tmp_path) == FILE_EXISTS_m13)
				strcpy(tmp_list[tmp_files++], tmp_path);
		}
		free_m13((void *) seg_list);  // free for next channel
	}
	free_m13((void *) chan_list);

	file_list = (si1 **) calloc_2D_m13((size_t) tmp_files, (size_t) PATH_BYTES_m13, sizeof(si1));
	for (i = 0; i < tmp_files; ++i)
		strcpy(file_list[i], tmp_list[i]);
	free_m13((void *) tmp_list);

	*n_files = tmp_files;
	
	return_m13(file_list);
}


ui4	PRTY_flag_for_path_m13(si1 *path)
{
	ui4	type_code, level_code, flag;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	level_code = G_level_m13(path, &type_code);
	switch (type_code) {
		case REC_DATA_TYPE_CODE_m13:
			switch (level_code) {
				case SESS_TYPE_CODE_m13:
					flag = PRTY_GLB_SESS_REC_DATA_m13;
					break;
				case SSR_TYPE_CODE_m13:
					flag = PRTY_SEG_SESS_REC_DATA_m13;
					break;
				case TS_CHAN_TYPE_CODE_m13:
					flag = PRTY_TS_CHAN_REC_DATA_m13;
					break;
				case VID_CHAN_TYPE_CODE_m13:
					flag = PRTY_VID_CHAN_REC_DATA_m13;
					break;
				case TS_SEG_TYPE_CODE_m13:
					flag = PRTY_TS_SEG_REC_DATA_m13;
					break;
				case VID_SEG_TYPE_CODE_m13:
					flag = PRTY_VID_SEG_REC_DATA_m13;
					break;
			}
			break;
		case REC_INDS_TYPE_CODE_m13:
			switch (level_code) {
				case SESS_TYPE_CODE_m13:
					flag = PRTY_GLB_SESS_REC_IDX_m13;
					break;
				case SSR_TYPE_CODE_m13:
					flag = PRTY_SEG_SESS_REC_IDX_m13;
					break;
				case TS_CHAN_TYPE_CODE_m13:
					flag = PRTY_TS_CHAN_REC_IDX_m13;
					break;
				case VID_CHAN_TYPE_CODE_m13:
					flag = PRTY_VID_CHAN_REC_IDX_m13;
					break;
				case TS_SEG_TYPE_CODE_m13:
					flag = PRTY_TS_SEG_REC_IDX_m13;
					break;
				case VID_SEG_TYPE_CODE_m13:
					flag = PRTY_VID_SEG_REC_IDX_m13;
					break;
			}
			break;
		case TS_METADATA_TYPE_CODE_m13:
			flag = PRTY_TS_SEG_META_m13;
			break;
		case TS_DATA_TYPE_CODE_m13:
			flag = PRTY_TS_SEG_DAT_DATA_m13;
			break;
		case TS_INDS_TYPE_CODE_m13:
			flag = PRTY_TS_SEG_DAT_IDX_m13;
			break;
		case VID_METADATA_TYPE_CODE_m13:
			flag = PRTY_VID_SEG_META_m13;
			break;
		case VID_DATA_TYPE_CODE_m13:
			flag = PRTY_VID_SEG_DAT_DATA_m13;
			break;
		case VID_INDS_TYPE_CODE_m13:
			flag = PRTY_VID_SEG_DAT_IDX_m13;
			break;
	}

	return_m13(flag);
}


si8	PRTY_pcrc_offset_m13(FILE_m13 *fp, si1 *file_path, si8 *pcrc_len)
{
	tern			vid_data;
	si8			nr, in_offset, pcrc_offset;
	PRTY_CRC_DATA_m13	pcrc;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// returns offset of pcrc structure, file length (+/- pcrc_len == 0) indicates no pcrc data
	// if fp passed: assumes file is open with read priveleges, returns fp to where it was when called
	// if path passed: file is opened & closed
	// pass address of pcrc_len to return pcrc length (struct + crcs), NULL if not needed
	
	in_offset = -1;
	if (fp == NULL) {
		vid_data = G_video_data_m13(file_path);
		fp = fopen_m13(file_path, "r");
		if (fp == NULL)
			return_m13(0);
	} else {
		vid_data = G_video_data_m13(fp->path);
		in_offset = ftell_m13(fp);
	}
	
	pcrc_offset = flen_m13(fp) - sizeof(PRTY_CRC_DATA_m13);
	if (vid_data == TRUE_m13)
		pcrc_offset -= UH_BYTES_m13;
	
	fseek_m13(fp, (size_t) pcrc_offset, SEEK_SET);
	nr = fread_m13((void *) &pcrc, sizeof(PRTY_CRC_DATA_m13), (size_t) 1, fp);
	if (nr != 1) {
		if (in_offset > 0)
			fseek_m13(fp, in_offset, SEEK_SET);
		else
			fclose_m13(fp);
		return_m13(0);
	}
		
	if (pcrc.pcrc_tag == PRTY_PCRC_TAG_m13) {
		if (pcrc_len)
			*pcrc_len = (pcrc.n_blocks * sizeof(ui4)) + sizeof(PRTY_CRC_DATA_m13);
	} else {
		pcrc_offset = flen_m13(fp);  // return file length
		if (pcrc_len)
			*pcrc_len = 0;
	}

	if (in_offset > 0)
		fseek_m13(fp, in_offset, SEEK_SET);
	else
		fclose_m13(fp);

	return_m13(pcrc_offset);
}


tern	PRTY_repair_file_m13(PRTY_m13 *parity_ps)
{
	tern			result, repaired, rebuild_parity, block_included;
	ui1			*parity, *data, diffs, mask;
	si1			*parity_path, sess_path[PATH_BYTES_m13], response[8];
	ui4			flag;
	si4			i, j, k, m, n_files, n_bad_blocks, p_n_bad_blocks, seg_num;
	ui8			*target_ptr, *source_ptr;
	si8			nr, nw, bytes_read, bytes_written, mem_block_bytes, offset;
	si8			len, bytes_to_read, bytes_to_write, bytes_remaining, parity_modification;
	si8			parity_damage_start, parity_damage_end, file_damage_start, file_damage_end;
	si8			source_bytes_to_read, source_bytes_remaining;
	PRTY_FILE_m13		*files, *source_file;
	PRTY_BLOCK_m13		*bad_blocks, *p_bad_blocks;
	FILE_TIMES_m13		ft;
	FILE_m13		*parity_fp;

	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// internal function called from PRTY_restore_m13()
	
	// unpack ps
	files = parity_ps->files;
	n_files = parity_ps->n_files;
	parity = parity_ps->parity;
	data = parity_ps->data;
	mem_block_bytes = parity_ps->mem_block_bytes;
	parity_path = parity_ps->path;
	n_bad_blocks = parity_ps->n_bad_blocks;
	bad_blocks = parity_ps->bad_blocks;

	// set up for exit
	parity_fp = NULL;
	for (i = 0; i < n_files; ++i) {
		files[i].fp = NULL;
		files[i].finished = FALSE_m13;
	}
	
	// check parity pcrc data (if exists)
	rebuild_parity = FALSE_m13;
	p_bad_blocks = NULL;
	p_n_bad_blocks = 0;
	result = PRTY_validate_pcrc_m13(NULL, parity_path, &p_bad_blocks, &p_n_bad_blocks, NULL);
	if (result == FALSE_m13) {
		// see if damage is in same region
		for (i = 0; i < n_bad_blocks; ++i) {
			parity_damage_start = bad_blocks[i].offset;
			parity_damage_end = parity_damage_start + bad_blocks[i].length - 1;
			for (j = 0; j < p_n_bad_blocks; ++i) {
				file_damage_start = p_bad_blocks[j].offset;
				file_damage_end = file_damage_start + p_bad_blocks[j].length - 1;
				block_included = FALSE_m13;
				if (file_damage_start >= parity_damage_start && file_damage_start <= parity_damage_end)
					block_included = TRUE_m13;
				if (file_damage_end >= parity_damage_start && file_damage_end <= parity_damage_end)
					block_included = TRUE_m13;
				if (block_included == TRUE_m13) {
					G_warning_message_m13("%s(): parity data is damaged in the same region as the damaged file; cannot repair => returning", __FUNCTION__);
					return_m13(FALSE_m13);
				}
			}
			rebuild_parity = TRUE_m13;
		}
		free_m13((void *) p_bad_blocks);
	} else if (result == UNKNOWN_m13) {
		G_warning_message_m13("%s(): validity of parity data cannot be confirmed\n", __FUNCTION__);
		G_terminal_entry_m13("Would you like to proceed & rebuild parity (y/n) ?", RC_STRING_TYPE_m13, (void *) response, "n", FALSE_m13, FALSE_m13);
		if (*response == 'y' || *response == 'Y')
			rebuild_parity = TRUE_m13;
		else
			return_m13(FALSE_m13);
	}
	
	// check validity of other parity component files
	for (i = PRTY_FILE_DAMAGED_IDX_m13 + 1; i < n_files; ++i) {
		p_bad_blocks = NULL;
		p_n_bad_blocks = 0;
		G_push_behavior_m13(SUPPRESS_MESSAGE_OUTPUT_m13);
		result = PRTY_validate_m13(NULL, files[i].path, &p_bad_blocks, &p_n_bad_blocks, NULL);
		G_pop_behavior_m13();
		if (result == FALSE_m13) {
			parity_damage_start = bad_blocks[i].offset;
			parity_damage_end = parity_damage_start + bad_blocks[i].length - 1;
			for (j = 0; j < p_n_bad_blocks; ++i) {
				file_damage_start = p_bad_blocks[j].offset;
				file_damage_end = file_damage_start + p_bad_blocks[j].length - 1;
				block_included = FALSE_m13;
				if (file_damage_start >= parity_damage_start && file_damage_start <= parity_damage_end)
					block_included = TRUE_m13;
				if (file_damage_end >= parity_damage_start && file_damage_end <= parity_damage_end)
					block_included = TRUE_m13;
				if (block_included == TRUE_m13) {
					G_warning_message_m13("%s(): parity component file \"%s\" is damaged in the same region as the damaged file; cannot repair => returning", __FUNCTION__, files[i].path);
					return_m13(FALSE_m13);
				}
			}
			free_m13((void *) p_bad_blocks);
		} else if (result == UNKNOWN_m13) {
			G_warning_message_m13("%s(): validity of parity component data cannot be confirmed\n", __FUNCTION__);
			G_terminal_entry_m13("Would you like to proceed (y/n) ?", RC_STRING_TYPE_m13, (void *) response, "n", FALSE_m13, FALSE_m13);
			if (*response != 'y' && *response != 'Y')
				return_m13(FALSE_m13);
		}
	}
	
	// open parity file
	parity_fp = fopen_m13(parity_path, "r");
	if (parity_fp == NULL) {
		G_warning_message_m13("Error opening parity data file \"%s\" => returning\n", parity_path);
		return_m13(FALSE_m13);
	}

	for (i = PRTY_FILE_DAMAGED_IDX_m13 + 1; i < n_files; ++i) {
		files[i].fp = fopen_m13(files[i].path, "r");
		if (files[i].fp == NULL)
			goto PRTY_REPAIR_EXIT_m13;
		files[i].len = PRTY_pcrc_offset_m13(files[i].fp, NULL, NULL);
	}

	// check that parity is at least as recent as rest of files
	G_file_times_m13(parity_fp, NULL, &ft, FALSE_m13);  // get parity modification time
	parity_modification = ft.modification;
	for (i = PRTY_FILE_DAMAGED_IDX_m13 + 1; i < n_files; ++i) {  // skip damaged file
		G_file_times_m13(files[i].fp, NULL, &ft, FALSE_m13);  // get parity modification time
		if (ft.modification > parity_modification && i != PRTY_FILE_DAMAGED_IDX_m13) {
			G_warning_message_m13("File \"%s\" was modified after the parity file => returning\n", files[i].path);
			goto PRTY_REPAIR_EXIT_m13;
		}
	}

	// open damaged file
	i = PRTY_FILE_DAMAGED_IDX_m13;
	files[i].fp = fopen_m13(files[i].path, "r+");
	if (files[i].fp == NULL)
		goto PRTY_REPAIR_EXIT_m13;
	files[i].len = flen_m13(files[i].fp);

	// repair
	repaired = FALSE_m13;
	for (i = 0; i < n_bad_blocks; ++i) {
		offset = bad_blocks[i].offset;
		fseek_m13(parity_fp, offset, SEEK_SET);
		for (j = 0; j < n_files; ++j) {
			if (offset >= files[j].len)
				files[j].finished = TRUE_m13;
			else
				fseek_m13(files[j].fp, offset, SEEK_SET);
		}
		
		// read parity file
		len = bad_blocks[i].length;
		bytes_read = bytes_written = 0;
		while (bytes_read < len) {
			// read parity file
			bytes_remaining = len - bytes_read;
			bytes_to_read = mem_block_bytes;
			if (bytes_remaining < mem_block_bytes)
				bytes_to_read = bytes_remaining;
			bytes_to_write = bytes_to_read;
			nr = fread_m13((void *) parity, sizeof(ui1), (size_t) bytes_to_read, parity_fp);
			if (nr != bytes_to_read)
				return_m13(FALSE_m13);
			bytes_read += nr;
			
			// read undamaged files
			for (j = PRTY_FILE_DAMAGED_IDX_m13 + 1; j < n_files; ++j) {
				source_file = files + j;
				if (source_file->finished == TRUE_m13)
					continue;
				source_bytes_to_read = bytes_to_read;
				source_bytes_remaining = source_file->len - (offset + bytes_written);
				if (source_bytes_to_read >= source_bytes_remaining) {
					source_bytes_to_read = source_bytes_remaining;
					source_file->finished = TRUE_m13;
				}
				nr = fread_m13((void *) data, sizeof(ui1), (size_t) source_bytes_to_read, source_file->fp);
				if (nr != source_bytes_to_read)
					return_m13(FALSE_m13);
				
				// add to parity array
				target_ptr = (ui8 *) parity;
				source_ptr = (ui8 *) data;
				for (k = source_bytes_to_read >> 3; k--;)
					*target_ptr++ ^= *source_ptr++;
			}
			
			// show modifications
			j = PRTY_FILE_DAMAGED_IDX_m13;
			nr = fread_m13((void *) data, sizeof(ui1), (size_t) bytes_to_read, files[j].fp);
			if (nr == bytes_to_read) {
				for (k = 0; k < bytes_to_read; ++k) {
					if (data[k] != parity[k]) {
						G_message_m13("\t%sByte %ld: 0x%02hhx (damaged) => 0x%02hhx (repaired) [flip position(s):", TC_BLUE_m13, offset + k, data[k], parity[k]);
						diffs = data[k] ^ parity[k];
						for (mask = 1, m = 0; m < 8; ++m, mask <<= 1) {
							if (diffs & mask)
								G_message_m13(" %d", m);
						}
						G_message_m13("]\n%s", TC_RESET_m13);
					}
				}
			}
			fseek_m13(files[j].fp, offset, SEEK_SET);

			// write out repaired data
			nw = fwrite_m13((void *) parity, sizeof(ui1), (size_t) bytes_to_write, files[j].fp);
			if (nw != bytes_to_write)
				goto PRTY_REPAIR_EXIT_m13;
			bytes_written += nw;
		}
	}
	repaired = TRUE_m13;

PRTY_REPAIR_EXIT_m13:

	if (parity_fp)
		fclose_m13(parity_fp);
	for (i = 0; i < n_files; ++i) {
		if (files[i].fp)
			fclose_m13(files[i].fp);
	}
	
	if (rebuild_parity == TRUE_m13) {
		flag = PRTY_flag_for_path_m13(parity_path);
		if (flag & PRTY_SEG_m13)
			seg_num = G_segment_for_path_m13(parity_path);
		else
			seg_num = 0;
		G_session_path_for_path_m13(parity_path, sess_path);
		PRTY_write_m13(sess_path, flag, seg_num);
	}
	
	return_m13(repaired);
}


tern	PRTY_restore_m13(si1 *MED_path)
{
	tern			success, valid, video_data, unlock_parity, unlock_data;
	si1			sess_path[PATH_BYTES_m13], sess_name[NAME_BYTES_m13], base_name[SEG_NAME_BYTES_m13];
	si1			tmp_path[PATH_BYTES_m13], **input_file_list, **ts_chan_names, **vid_chan_names, **ssr_names, **list;
	si1			*parity_path, response[8];
	ui4			level_code;
	si4			i, j, k, n_ts_chans, n_vid_chans, n_segs, n_input_files, n_parity_files, n_bad_blocks;
	si4			allocated_parity_files, n_repaired, n_attempted, n_skipped;
	si8			len, mmap_block_bytes, mem_block_bytes, mem_blocks;
	PRTY_FILE_m13		*parity_files;
	PRTY_BLOCK_m13		*bad_blocks;
	PRTY_m13		parity_ps;
	EXT_CODE_m13 		type;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// get file list
	input_file_list = PRTY_file_list_m13(MED_path, &n_input_files);
	if (n_input_files == 0) {
		G_warning_message_m13("\nNo MED files found at or below \"%s\"\n", MED_path);
		return_m13(FALSE_m13);
	}
	
	// get session path & name
	G_session_path_for_path_m13(input_file_list[0], sess_path);
	G_path_parts_m13(sess_path, NULL, sess_name, NULL);

	// get volume block size
	mmap_block_bytes = HW_get_block_size_m13(MED_path);
	
	// get parity & data arrays
	mem_block_bytes = (si8) (1 << 29);  // 500 MiB
	mem_blocks = mem_block_bytes / mmap_block_bytes;
	parity_ps.mem_block_bytes = mem_blocks * mmap_block_bytes;
	parity_ps.parity = (ui1 *) calloc_m13((size_t) mem_block_bytes, sizeof(ui1));
	parity_ps.data = (ui1 *) calloc_m13((size_t) mem_block_bytes, sizeof(ui1));
	G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_ERROR_OUTPUT_m13);
	unlock_parity = mlock_m13((void *) parity_ps.parity, (size_t) mem_block_bytes);
	unlock_data = mlock_m13((void *) parity_ps.data, (size_t) mem_block_bytes);
	G_pop_behavior_m13();
	n_parity_files = allocated_parity_files = 0;
	parity_path = parity_ps.path;
	parity_files = NULL;

	// validate & restore files
	n_repaired = n_attempted = n_skipped = 0;
	ts_chan_names = vid_chan_names = ssr_names = NULL;
	n_ts_chans = n_vid_chans = n_segs = 0;
	for (i = 0; i < n_input_files; ++i) {
		valid = PRTY_validate_m13(NULL, input_file_list[i], &bad_blocks, &n_bad_blocks, NULL);
		if (valid == TRUE_m13)
			continue;
		if (valid == UNKNOWN_m13) {
			++n_skipped;
			G_warning_message_m13("Unspecified error processing file \"%s\" => skipping\n", input_file_list[i]);
			continue;
		}
		++n_attempted;

		// get channel names, channel count, & segment count, if needed
		level_code = G_level_m13(input_file_list[i], &type.code);
		switch (level_code) {
			case SESS_TYPE_CODE_m13:
				n_parity_files = 1;
				break;
			case SSR_TYPE_CODE_m13:
				if (ssr_names == NULL) {
					sprintf_m13(tmp_path, "%s/%s.%s", sess_path, sess_name, SSR_TYPE_STR_m13);
					ssr_names = G_file_list_m13(NULL, &n_segs, tmp_path, NULL, REC_DATA_TYPE_STR_m13, GFL_NAME_m13);
				}
				n_parity_files = n_segs;
				list = ssr_names;
				break;
			case TS_CHAN_TYPE_CODE_m13:
			case TS_SEG_TYPE_CODE_m13:
				if (ts_chan_names == NULL)
					ts_chan_names = G_file_list_m13(NULL, &n_ts_chans, sess_path, NULL, TS_CHAN_TYPE_STR_m13, GFL_NAME_m13);
				n_parity_files = n_ts_chans;
				list = ts_chan_names;
				break;
			case VID_CHAN_TYPE_CODE_m13:
			case VID_SEG_TYPE_CODE_m13:
				if (vid_chan_names == NULL)
					vid_chan_names = G_file_list_m13(NULL, &n_vid_chans, sess_path, NULL, VID_CHAN_TYPE_STR_m13, GFL_NAME_m13);
				n_parity_files = n_vid_chans;
				list = vid_chan_names;
				break;
		}
		
		// realloc, if needed
		if (n_parity_files > allocated_parity_files) {
			parity_files = (PRTY_FILE_m13 *) realloc_m13((void *) parity_files, (size_t) n_parity_files * sizeof(PRTY_FILE_m13));
			allocated_parity_files = n_parity_files;
		}
				
		// build parity path
		video_data = FALSE_m13;
		G_path_parts_m13(input_file_list[i], NULL, base_name, type.ext);
		switch (type.code) {
			case REC_DATA_TYPE_CODE_m13:
			case REC_INDS_TYPE_CODE_m13:
				switch (level_code) {
					case SESS_TYPE_CODE_m13:
						sprintf_m13(parity_path, "%s/parity.%s", sess_path, type.ext);
						break;
					case SSR_TYPE_CODE_m13:
						sprintf_m13(parity_path, "%s/%s.%s/parity_s0000.%s", sess_path, sess_name, SSR_TYPE_STR_m13, type.ext);
						break;
					case TS_SEG_TYPE_CODE_m13:
					case VID_SEG_TYPE_CODE_m13:
						len = strlen(base_name);
						base_name[len - 6] = 0;
					case TS_CHAN_TYPE_CODE_m13:
					case VID_CHAN_TYPE_CODE_m13:
						STR_replace_pattern_m13(base_name, "parity", input_file_list[i], parity_path);
						break;
				}
				break;
			case VID_DATA_TYPE_CODE_m13:
				video_data = TRUE_m13;
			case TS_METADATA_TYPE_CODE_m13:
			case TS_DATA_TYPE_CODE_m13:
			case TS_INDS_TYPE_CODE_m13:
			case VID_METADATA_TYPE_CODE_m13:
			case VID_INDS_TYPE_CODE_m13:
				len = strlen(base_name);
				if (video_data == TRUE_m13)
					base_name[len - 12] = 0;
				else
					base_name[len - 6] = 0;
				STR_replace_pattern_m13(base_name, "parity", input_file_list[i], parity_path);
				break;
		}
		if (G_exists_m13(parity_path) == DOES_NOT_EXIST_m13) {
			++n_skipped;
			G_warning_message_m13("No parity data for file \"%s\" => skipping\n", input_file_list[i]);
			continue;
		}

		// build file list
		strcpy(parity_files[PRTY_FILE_DAMAGED_IDX_m13].path, input_file_list[i]);
		for (j = 1, k = 0; j < n_parity_files; ++k) {
			if (strcmp_m13(list[k], base_name)) {
				STR_replace_pattern_m13("parity", list[k], parity_path, tmp_path);
				strcpy(parity_files[j++].path, tmp_path);
			}
		}

		// repair
		G_warning_message_m13("Repairing \"%s\" ...\n", input_file_list[i]);
		parity_ps.files = parity_files;
		parity_ps.n_files = n_parity_files;
		parity_ps.n_bad_blocks = n_bad_blocks;
		parity_ps.bad_blocks = bad_blocks;

		// make a copy (just in case)
		sprintf_m13(tmp_path, "%s.damaged_original", input_file_list[i]);
		cp_m13(input_file_list[i], tmp_path);
		
		success = PRTY_repair_file_m13(&parity_ps);
		if (success == TRUE_m13) {
			++n_repaired;
			G_terminal_entry_m13("Repair successful. Would you like to remove the damaged file (y/n) ?", RC_STRING_TYPE_m13, (void *) response, "y", FALSE_m13, FALSE_m13);
			if (*response == 'y' || *response == 'Y')
				rm_m13(tmp_path);
		} else {
			G_warning_message_m13("Error restoring file \"%s\".  Reverting to input state.\n", input_file_list[i]);
			mv_m13(tmp_path, input_file_list[i]);
		}
		if (n_bad_blocks) {
			n_bad_blocks = 0;
			free_m13((void *) bad_blocks);
		}
	}
	
	if (unlock_parity == TRUE_m13)
		munlock_m13((void *) parity_ps.parity, (size_t) parity_ps.mem_block_bytes);
	free_m13((void *) parity_ps.parity);
	if (unlock_data == TRUE_m13)
		munlock_m13((void *) parity_ps.data, (size_t) parity_ps.mem_block_bytes);
	free_m13((void *) parity_ps.data);
	munlock_m13((void *) parity_ps.files, (size_t) allocated_parity_files * sizeof(PRTY_FILE_m13));
	free_m13((void *) parity_ps.files);

	free_m13((void *) ts_chan_names);
	free_m13((void *) vid_chan_names);
	free_m13((void *) ssr_names);

	if (n_attempted == 0) {
		if (n_skipped) {
			G_message_m13("No damaged files detected  (%d files skipped)\n\n", n_skipped);
			success = UNKNOWN_m13;
		} else {
			G_message_m13("No damaged files detected\n\n");
			success = TRUE_m13;
		}
	} else {
		if (n_attempted == n_repaired) {
			if (n_skipped) {
				G_message_m13("All damaged files restored  (%d files skipped)\n\n", n_skipped);
				success = UNKNOWN_m13;
			} else {
				G_message_m13("All damaged files restored\n\n");
				success = TRUE_m13;
			}
		} else {
			if (n_skipped) {
				G_message_m13("%d of %d damaged files restored  (%d files skipped)\n\n", n_repaired, n_attempted, n_skipped);
				success = UNKNOWN_m13;
			} else {
				G_message_m13("%d of %d damaged files restored\n\n", n_repaired, n_attempted);
				success = FALSE_m13;
			}
		}
	}

	return_m13(success);
}


tern	PRTY_show_pcrc_m13(si1 *file_path)
{
	si8			pcrc_offset;
	FILE_m13		*fp;
	PRTY_CRC_DATA_m13	pcrc;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
		
	if (G_exists_m13(file_path) == DOES_NOT_EXIST_m13) {
		G_warning_message_m13("%s(): file \"%s\" does not exist\n", __FUNCTION__, file_path);
		return_m13(FALSE_m13);
	}
	
	fp = fopen_m13(file_path, "r");
	pcrc_offset = flen_m13(fp) - sizeof(PRTY_CRC_DATA_m13);
	if (G_video_data_m13(fp->path) == TRUE_m13)
		pcrc_offset -= UH_BYTES_m13;

	fseek_m13(fp, pcrc_offset, SEEK_SET);
	fread_m13((void *) &pcrc, sizeof(PRTY_CRC_DATA_m13), (size_t) 1, fp);
	fclose_m13(fp);

	printf_m13("parity_tag: 0x%08x\n", pcrc.pcrc_tag);
	printf_m13("session_UID: 0x%08x\n", pcrc.session_UID);
	printf_m13("segment_UID: 0x%08x\n", pcrc.segment_UID);
	printf_m13("n_blocks: %u\n", pcrc.n_blocks);
	printf_m13("block_bytes: %u\n", pcrc.block_bytes);

	return_m13(TRUE_m13);
}


tern	PRTY_update_m13(FILE_m13 *fp, si8 offset, ui1 *new_data, si8 n_bytes)
{
	tern			was_open, extending;
	ui1			*od, *nd, *pd, *td, *old_data, *par_data, *tmp_data;
	si1			*path, par_path[PATH_BYTES_m13], base_name[MAX_NAME_BYTES_m13], ext[TYPE_BYTES_m13];
	ui4			level_code, *crcs;
	si8			i, j, pcrc_len, pcrc_offset, nrw, crc_bytes;
	si8			start_block, start_byte, end_block, end_byte, bytes_to_read;
	PRTY_CRC_DATA_m13	pcrc;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// returns FALSE_m13 on true failure
	// returns TRUE_m13 on success or no parity data exists
	
	if (FILE_stream_m13(fp) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "fp must be a FILE_m13 *");
		return_m13(FALSE_m13);
	}
	
	// get parity path
	path = fp->path;
	level_code = G_level_m13(path, NULL);
	if (level_code == SESS_TYPE_CODE_m13 || level_code == SSR_TYPE_CODE_m13) {
		G_path_parts_m13(path, par_path, NULL, ext);
		if (level_code == SESS_TYPE_CODE_m13)
			sprintf_m13(par_path, "%s/parity.%s", par_path, ext);
		else  // level_code == SSR_TYPE_CODE_m13
			sprintf_m13(par_path, "%s/parity_s0000.%s", par_path, ext);
	} else {
		G_base_name_m13(NULL, path, base_name);
		STR_replace_pattern_m13(base_name, "parity", path, par_path);
	}
	
	if (G_exists_m13(par_path) == FALSE_m13)
		return_m13(TRUE_m13);

	// open data file
	was_open = fisopen_m13(fp);
	if (was_open == FALSE_m13) {
		fp = (void *) fopen_m13(path, "r+");
		if (fp == NULL)
			return_m13(FALSE_m13);
	}
	
	// allocate
	old_data = (ui1 *) calloc((size_t) (n_bytes << 1), sizeof(ui1));  // calloc because need zeros if appending to file
	if (old_data == NULL) {
		fclose_m13(fp);
		return_m13(FALSE_m13);
	}
	par_data = old_data + n_bytes;
	
	// read data file
	fseek_m13(fp, offset, SEEK_SET);
	bytes_to_read = flen_m13(fp) - offset;
	if (bytes_to_read >= n_bytes) {
		extending = FALSE_m13;
		bytes_to_read = n_bytes;
	} else {
		extending = TRUE_m13;  // extending => don't read past end of file
	}
	if (bytes_to_read) {
		nrw = (si8) fread_m13((void *) old_data, sizeof(ui1), (size_t) bytes_to_read, fp);
		if (nrw != bytes_to_read) {
			fclose_m13(fp);
			free((void *) old_data);
			return_m13(FALSE_m13);
		}
	}
	
	// update pcrc data, if exists
	pcrc_offset = PRTY_pcrc_offset_m13(fp, NULL, &pcrc_len);
	if (extending == FALSE_m13) {
		if (pcrc_len) {
			// read in pcrc
			fseek_m13(fp, pcrc_offset, SEEK_SET);
			nrw = fread_m13((void *) &pcrc, sizeof(PRTY_CRC_DATA_m13), (size_t) 1, fp);
			if (nrw != 1) {
				fclose_m13(fp);
				free((void *) old_data);
				return_m13(FALSE_m13);
			}
			crc_bytes = pcrc.n_blocks * sizeof(ui4);
			crcs = (ui4 *) malloc((size_t) crc_bytes);
			if (crcs == NULL) {
				fclose_m13(fp);
				free((void *) old_data);
				return_m13(FALSE_m13);
			}
			fseek_m13(fp, pcrc_offset - crc_bytes, SEEK_SET);
			nrw = fread_m13((void *) crcs, sizeof(ui1), (size_t) crc_bytes, fp);
			if (nrw != crc_bytes) {
				fclose_m13(fp);
				free((void *) crcs);
				free((void *) old_data);
				return_m13(FALSE_m13);
			}

			// find where offset falls in pcrc blocks
			start_block = offset / pcrc.block_bytes;
			end_block = (offset + n_bytes) / pcrc.block_bytes;
			
			// read in data
			start_byte = start_block * pcrc.block_bytes;
			end_byte = (end_block + 1) * pcrc.block_bytes;
			bytes_to_read = end_byte - start_byte;
			tmp_data = (ui1 *) malloc((size_t) bytes_to_read);
			if (tmp_data == NULL) {
				fclose_m13(fp);
				free((void *) crcs);
				free((void *) old_data);
				return_m13(FALSE_m13);
			}
			fseek_m13(fp, start_byte, SEEK_SET);
			nrw = fread_m13((void *) tmp_data, sizeof(ui1), (size_t) bytes_to_read, fp);
			if (nrw != bytes_to_read) {
				fclose_m13(fp);
				free((void *) crcs);
				free((void *) tmp_data);
				free((void *) old_data);
				return_m13(FALSE_m13);
			}
			
			// replace with old with new data
			start_byte -= offset;
			for (i = start_byte, j = 0; j < bytes_to_read; ++i, ++j)
				tmp_data[i] = new_data[j];

			// update those values in pcrc crc array
			for (i = start_block, td = tmp_data; i <= end_block; ++i, td += pcrc.block_bytes)
				crcs[i] = CRC_calculate_m13(td, pcrc.block_bytes);
			
			// write out update values
			fseek_m13(fp, pcrc_offset - crc_bytes, SEEK_SET);
			nrw = fwrite_m13((void *) crcs, sizeof(ui1), (size_t) crc_bytes, fp);
			if (nrw != crc_bytes) {
				fclose_m13(fp);
				free((void *) old_data);
				free((void *) crcs);
				free((void *) tmp_data);
				return_m13(FALSE_m13);
			}
			
			// clean up
			free((void *) crcs);
			free((void *) tmp_data);
		}
	} else if (pcrc_len) {
		G_warning_message_m13("%s(): pcrc data not updated for file \"%s\" because write extends file\n", __FUNCTION__, path);
	}
	
	// close data file
	fclose_m13(fp);
	
	// open parity file
	fp = fopen_m13(par_path, "r+");
	if (fp == NULL) {
		fclose_m13(fp);
		free((void *) old_data);
		return_m13(FALSE_m13);
	}
	fp->flags |= FILE_FLAGS_LOCK_m13;  // the parity file has to be locked - multiple threads may be trying to read & write
	
	// update parity
	fseek_m13(fp, offset, SEEK_SET);
	bytes_to_read = flen_m13(fp) - offset;
	if (bytes_to_read >= n_bytes)
		bytes_to_read = n_bytes;  // don't read past end of parity file
	nrw = (si8) fread_m13((void *) par_data, sizeof(ui1), (size_t) bytes_to_read, fp);
	if (nrw != bytes_to_read) {
		fclose_m13(fp);
		free((void *) old_data);
		return_m13(FALSE_m13);
	}
	
	// remove old & add new contributions
	// (OK if extending => old data past end of file is zeros)
	od = old_data;
	nd = new_data;
	pd = par_data;
	for (i = n_bytes; i--;) {
		*pd ^= *od++;
		*pd++ ^= *nd++;
	}
	
	// update parity file
	fseek_m13(fp, offset, SEEK_SET);
	nrw = (si8) fwrite_m13((void *) par_data, sizeof(ui1), (size_t) n_bytes, fp);
	if (nrw != n_bytes) {
		fclose_m13(fp);
		free((void *) old_data);
		return_m13(FALSE_m13);
	}
	
	// close parity file
	if (was_open == FALSE_m13)
		fclose_m13(fp);
	
	// clean up
	free((void *) old_data);
	
	return_m13(TRUE_m13);
}


tern  PRTY_validate_m13(si1 *file_path, ...)  // varargs(file_path == NULL): si1 *file_path, PRTY_BLOCK_m13 **bad_blocks, si4 *n_bad_blocks, ui4 *n_blocks)
{
	tern			ret_val, valid, header_valid, body_valid, return_bb, localizing_crcs;
	ui1			*bytes, *idx_bytes;
	si1			idx_path[PATH_BYTES_m13];
	ui4			n_b, *n_blocks, type_code;
	si4			n_bb, bb_size, *n_bad_blocks, BAD_BLOCK_INCREMENT;
	si8			i, len, pcrc_len, idx_len, nr, offset, record_bytes, block_bytes;
	va_list			v_args;
	FILE_m13		*fp, *idx_fp;
	UH_m13			*uh;
	GEN_IDX_m13		*idx;
	REC_HDR_m13		*rh;
	CMP_FIXED_BH_m13	*bh;
	PRTY_BLOCK_m13		*bb, **bad_blocks;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// validates MED file CRCs
	// if bad_blocks or n_bad_blocks are NULL, they will not be returned
	// n_blocks can be NULL
	// returns TRUE_m13 if valid, FALSE_m13 if invaliid, UNKNOWN_m13 for errors

	// get varargs
	return_bb = FALSE_m13;
	if (file_path == NULL) {
		bad_blocks = NULL;
		n_bad_blocks = NULL;
		if (file_path == NULL) {
			va_start(v_args, file_path);
			file_path = va_arg(v_args, si1 *);
			bad_blocks = va_arg(v_args, PRTY_BLOCK_m13 **);
			n_bad_blocks = va_arg(v_args, si4 *);
			n_blocks = va_arg(v_args, ui4 *);
			va_end(v_args);
			
			if (bad_blocks && n_bad_blocks) {
				return_bb = TRUE_m13;
				*bad_blocks = NULL;
				*n_bad_blocks = 0;
				if (n_blocks)
					*n_blocks = 0;
				BAD_BLOCK_INCREMENT = 5;
			}
		}
	}
	bb = NULL;
	n_b = n_bb = bb_size = 0;

	G_message_m13("Validating \"%s\" ... ", file_path);

	if (G_exists_m13(file_path) == DOES_NOT_EXIST_m13) {
		G_warning_message_m13("\n%s(): file \"%s\" does not exist\n", __FUNCTION__, file_path);
		return_m13(UNKNOWN_m13);
	}

	type_code = G_MED_type_code_from_string_m13(file_path);
	switch (type_code) {
		case SESS_TYPE_CODE_m13:
		case SSR_TYPE_CODE_m13:
		case TS_CHAN_TYPE_CODE_m13:
		case VID_CHAN_TYPE_CODE_m13:
		case TS_SEG_TYPE_CODE_m13:
		case VID_SEG_TYPE_CODE_m13:
			G_warning_message_m13("\n%s(): \"%s\" is a MED directory, not file\n", __FUNCTION__, file_path);
			return_m13(UNKNOWN_m13);
		case REC_DATA_TYPE_CODE_m13:
		case REC_INDS_TYPE_CODE_m13:
		case TS_METADATA_TYPE_CODE_m13:
		case TS_DATA_TYPE_CODE_m13:
		case TS_INDS_TYPE_CODE_m13:
		case VID_METADATA_TYPE_CODE_m13:
		case VID_DATA_TYPE_CODE_m13:
		case VID_INDS_TYPE_CODE_m13:
			break;
		case NO_TYPE_CODE_m13:
		default:
			G_warning_message_m13("\n%s(): file \"%s\" is not a MED type\n", __FUNCTION__, file_path);
			return_m13(UNKNOWN_m13);
	}
	
	fp = fopen_m13(file_path, "r");
	if (fp == NULL)
		return_m13(UNKNOWN_m13);
	len = PRTY_pcrc_offset_m13(fp, NULL, &pcrc_len);
	bytes = (ui1 *) malloc((size_t) len);
	if (bytes == NULL) {
		G_warning_message_m13("\n%s(): allocation error\n", __FUNCTION__);
		return_m13(UNKNOWN_m13);
	}
	nr = fread_m13((void *) bytes, sizeof(ui1), (size_t) len, fp);
	fclose_m13(fp);
	if (nr != len) {
		free((void *) bytes);
		return_m13(UNKNOWN_m13);
	}

	// check universal header CRCs
	header_valid = body_valid = valid = UNKNOWN_m13;
	if (type_code != VID_DATA_TYPE_CODE_m13) {
		// header CRC
		uh = (UH_m13 *) bytes;
		header_valid = CRC_validate_m13(bytes + UH_HEADER_CRC_START_OFFSET_m13, UH_BYTES_m13 - UH_HEADER_CRC_START_OFFSET_m13, uh->header_CRC);
		if (header_valid == FALSE_m13) {
			if (return_bb == TRUE_m13) {
				if (n_bb == bb_size) {
					bb_size += BAD_BLOCK_INCREMENT;
					bb = (PRTY_BLOCK_m13 *) realloc_m13((void *) bb, (size_t) bb_size * sizeof(PRTY_BLOCK_m13));
				}
				bb[n_bb].length = (si8) UH_BYTES_m13;
				bb[n_bb].offset = 0;
				++n_bb;
			}
		}
		// body CRC
		body_valid = CRC_validate_m13(bytes + UH_BODY_CRC_START_OFFSET_m13, len - UH_BODY_CRC_START_OFFSET_m13, uh->body_CRC);
		if (body_valid == FALSE_m13) {
			if (return_bb == TRUE_m13) {
				if (n_bb == bb_size) {
					bb_size += BAD_BLOCK_INCREMENT;
					bb = (PRTY_BLOCK_m13 *) realloc_m13((void *) bb, (size_t) bb_size * sizeof(PRTY_BLOCK_m13));
				}
				bb[n_bb].length = len - (si8) UH_BODY_CRC_START_OFFSET_m13;
				bb[n_bb].offset = (si8) UH_BODY_CRC_START_OFFSET_m13;
				++n_bb;
			}
		}
		if (header_valid == TRUE_m13 && body_valid == TRUE_m13)
			valid = TRUE_m13;
		else if (header_valid == FALSE_m13 || body_valid == FALSE_m13)
			valid = FALSE_m13;
	}

	localizing_crcs = FALSE_m13;
	if (body_valid != TRUE_m13 && return_bb == TRUE_m13)
		if (type_code == REC_DATA_TYPE_CODE_m13 || type_code == TS_DATA_TYPE_CODE_m13 || pcrc_len)
			localizing_crcs = TRUE_m13;

	// check body CRCs (localize within in data files)
	if (localizing_crcs == TRUE_m13) {
		if (body_valid == FALSE_m13) {
			if (bb[0].offset == 0)  // keep universal header entry, if present, overwrite body entry
				n_bb = 1;
			else
				n_bb = 0;  // overwrite body entry
		}
		if (type_code == REC_DATA_TYPE_CODE_m13) {
			idx_len = strcpy_m13(idx_path, file_path);
			strcpy(idx_path + (idx_len - 4), REC_INDS_TYPE_STR_m13);
			idx_fp = fopen_m13(idx_path, "r");
			if (idx_fp == NULL)
				goto PRTY_VALIDATE_EXIT_m13;
			idx_len = flen_m13(idx_fp);
			idx_bytes = (ui1 *) malloc((size_t) idx_len);
			if (idx_bytes == NULL) {
				G_warning_message_m13("\n%s(): allocation error\n", __FUNCTION__);
				fclose_m13(idx_fp);
				goto PRTY_VALIDATE_EXIT_m13;
			}
			nr = fread_m13((void *) idx_bytes, sizeof(ui1), (size_t) idx_len, idx_fp);
			fclose_m13(idx_fp);
			if (nr != idx_len) {
				free((void *) idx_bytes);
				G_warning_message_m13("\n%s(): index file read error\n", __FUNCTION__);
				goto PRTY_VALIDATE_EXIT_m13;
			}
			idx = (GEN_IDX_m13 *) (idx_bytes + UH_BYTES_m13);
			for (i = uh->n_entries - 1; i--; ++idx) {
				offset = idx->file_offset;
				rh = (REC_HDR_m13 *) (bytes + offset);
				record_bytes = (idx + 1)->file_offset - offset;  // no discontinuities in record indices
				ret_val = CRC_validate_m13((ui1 *) rh + REC_HDR_CRC_START_OFFSET_m13, record_bytes - REC_HDR_CRC_START_OFFSET_m13, rh->record_CRC);
				if (ret_val == FALSE_m13) {
					if (return_bb == TRUE_m13) {
						if (n_bb == bb_size) {
							bb_size += BAD_BLOCK_INCREMENT;
							bb = (PRTY_BLOCK_m13 *) realloc_m13((void *) bb, (size_t) bb_size * sizeof(PRTY_BLOCK_m13));
						}
						bb[n_bb].length = (si8) rh->total_record_bytes;
						bb[n_bb].offset = offset;
						++n_bb;
					}
				}
			}
		} else if (type_code == TS_DATA_TYPE_CODE_m13) {
			idx_len = strcpy_m13(idx_path, file_path);
			strcpy(idx_path + (idx_len - 4), TS_INDS_TYPE_STR_m13);
			idx_fp = fopen_m13(idx_path, "r");
			if (idx_fp == NULL)
				goto PRTY_VALIDATE_EXIT_m13;
			idx_len = flen_m13(idx_fp);
			idx_bytes = (ui1 *) malloc((size_t) idx_len);
			if (idx_bytes == NULL) {
				G_warning_message_m13("\n%s(): allocation error\n", __FUNCTION__);
				fclose_m13(idx_fp);
				goto PRTY_VALIDATE_EXIT_m13;
			}
			nr = fread_m13((void *) idx_bytes, sizeof(ui1), (size_t) idx_len, idx_fp);
			fclose_m13(idx_fp);
			if (nr != idx_len) {
				free((void *) idx_bytes);
				G_warning_message_m13("\n%s(): index file read error\n", __FUNCTION__);
				goto PRTY_VALIDATE_EXIT_m13;
			}
			idx = (GEN_IDX_m13 *) (idx_bytes + UH_BYTES_m13);
			for (i = uh->n_entries - 1; i--; ++idx) {
				offset = REMOVE_DISCONT_m13(idx->file_offset);  // discontinuities possible in time series indices
				bh = (CMP_FIXED_BH_m13 *) (bytes + offset);
				block_bytes = REMOVE_DISCONT_m13((idx + 1)->file_offset) - offset;
				ret_val = CRC_validate_m13((ui1 *) bh + CMP_BLOCK_CRC_START_OFFSET_m13, block_bytes - CMP_BLOCK_CRC_START_OFFSET_m13, bh->block_CRC);
				if (ret_val == FALSE_m13) {
					if (return_bb == TRUE_m13) {
						if (n_bb == bb_size) {
							bb_size += BAD_BLOCK_INCREMENT;
							bb = (PRTY_BLOCK_m13 *) realloc_m13((void *) bb, (size_t) bb_size * sizeof(PRTY_BLOCK_m13));
						}
						bb[n_bb].length = (si8) bh->total_block_bytes;
						bb[n_bb].offset = offset;
						++n_bb;
					}
				}
			}
		} else {  // pcrc data present (covers video data also)
			valid = PRTY_validate_pcrc_m13(NULL, file_path, &bb, &n_bb, &n_b);
		}
	}
	
PRTY_VALIDATE_EXIT_m13:
	
	free((void *) bytes);
	
	if (return_bb == TRUE_m13 && n_bb) {
		*bad_blocks = bb;
		*n_bad_blocks = n_bb;
		if (n_blocks)
			*n_blocks = n_b;
	} else if (bb) {
		free_m13((void *) bb);
	}
	
	switch (valid) {
		case FALSE_m13:
			G_message_m13("%sinvalid%s\n", TC_RED_m13, TC_RESET_m13);
			break;
		case UNKNOWN_m13:
			G_message_m13("%sprocessing error%s\n", TC_BLUE_m13, TC_RESET_m13);
			break;
		case TRUE_m13:
			G_message_m13("%svalid%s\n", TC_GREEN_m13, TC_RESET_m13);
			break;
	}

	return_m13(valid);
}


tern	PRTY_validate_pcrc_m13(si1 *file_path, ...)  // varargs(file_path == NULL): si1 *file_path, PRTY_BLOCK_m13 **bad_blocks, si4 *n_bad_blocks, ui4 *n_blocks
{
	tern			return_bb;
	ui1			*block;
	ui4			*n_blocks, n_b, *crcs, block_bytes;
	si4			i, *n_bad_blocks, n_bb, bb_size, BAD_BLOCK_INCREMENT;
	si8			len, offset, crc_bytes;
	PRTY_CRC_DATA_m13	pcrc;
	PRTY_BLOCK_m13		**bad_blocks, *bb;
	FILE_m13		*fp;
	va_list			v_args;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// if bad_blocks or n_bad_blocks are NULL, they will not be returned
	// n_blocks can be NULL
	// returns TRUE_m13 if valid, FALSE_m13 if invaliid, UNKNOWN_m13 for errors
		
	// get varargs
	return_bb = FALSE_m13;
	if (file_path == NULL) {
		bad_blocks = NULL;
		n_bad_blocks = NULL;
		if (file_path == NULL) {
			va_start(v_args, file_path);
			file_path = va_arg(v_args, si1 *);
			bad_blocks = va_arg(v_args, PRTY_BLOCK_m13 **);
			n_bad_blocks = va_arg(v_args, si4 *);
			n_blocks = va_arg(v_args, ui4 *);
			va_end(v_args);
			
			if (bad_blocks && n_bad_blocks) {
				return_bb = TRUE_m13;
				*bad_blocks = NULL;
				*n_bad_blocks = 0;
				if (n_blocks)
					*n_blocks = 0;

				BAD_BLOCK_INCREMENT = 5;
			}
		}
	}
	bb = NULL;
	n_b = bb_size = 0;

	if (G_exists_m13(file_path) != FILE_EXISTS_m13) {
		G_warning_message_m13("%s(): file \"%s\" does not exist => returning\n", __FUNCTION__, file_path);
		return_m13(UNKNOWN_m13);
	}
		
	// check if in pcrc data exists
	fp = fopen_m13(file_path, "r");
	len = flen_m13(fp);
	len -= sizeof(PRTY_CRC_DATA_m13);
	if (G_video_data_m13(file_path) == TRUE_m13)
		len -= UH_BYTES_m13;
	fseek_m13(fp, len, SEEK_SET);
	fread_m13((void *) &pcrc, sizeof(PRTY_CRC_DATA_m13), (size_t) 1, fp);
	if (pcrc.pcrc_tag != PRTY_PCRC_TAG_m13) {
		G_warning_message_m13("%s(): file \"%s\" does not contain parity crc data\n", __FUNCTION__, file_path);
		fclose_m13(fp);
		return_m13(UNKNOWN_m13);
	}
	
	// read in crcs
	n_b = pcrc.n_blocks;
	if (n_blocks)
		*n_blocks = n_b;
	block_bytes = pcrc.block_bytes;
	crc_bytes = (si8) n_b * sizeof(ui4);
	crcs = (ui4 *) malloc((size_t) crc_bytes);
	len -= crc_bytes;
	fseek_m13(fp, len, SEEK_SET);
	fread_m13((void *) crcs, sizeof(ui4), (size_t) n_b, fp);

	// check crcs
	block = (ui1 *) malloc((size_t) block_bytes);
	fseek_m13(fp, 0, SEEK_SET);
	offset = 0;
	n_bb = 0;
	for (i = 0; i < n_b; ++i) {
		if (len < block_bytes)
			block_bytes = len;
		fread_m13((void *) block, sizeof(ui1), (size_t) block_bytes, fp);
		if (crcs[i] != CRC_calculate_m13(block, block_bytes)) {
			if (return_bb == TRUE_m13) {
				if (n_bb == bb_size) {
					bb_size += BAD_BLOCK_INCREMENT;
					bb = (PRTY_BLOCK_m13 *) realloc_m13((void *) bb, (size_t) bb_size * sizeof(PRTY_BLOCK_m13));
				}
				bb[n_bb].length = (si8) block_bytes;
				bb[n_bb].offset = offset;
				offset += block_bytes;
				++n_bb;
			} else {
				fclose_m13(fp);
				free((void *) block);
				free((void *) crcs);
				return_m13(FALSE_m13);
			}
		}
		len -= block_bytes;
	}

	// clean up
	fclose_m13(fp);
	free((void *) block);
	free((void *) crcs);

	if (n_bb) {
		*bad_blocks = bb;
		*n_bad_blocks = n_bb;
		if (n_blocks)
			*n_blocks = n_b;
		return_m13(FALSE_m13);
	}
	
	return_m13(TRUE_m13);
}


tern	PRTY_write_m13(si1 *session_path, ui4 flags, si4 segment_number)
{
	tern			unlock_parity, unlock_data, unlock_files;
	si1			sess_path[PATH_BYTES_m13];
	si1			sess_name[NAME_BYTES_m13], tmp_str[PATH_BYTES_m13 + 64];
	si1			num_str[FILE_NUMBERING_DIGITS_m13 + 1], type_string[TYPE_BYTES_m13];
	si1			**chan_names, **vid_paths, **seg_names, **base_paths, **ssr_list;
	si4			i, j, k, start_seg, end_seg, n_chans, n_vids, n_segs, n_ssrs, n_files, new_files;
	si8			mmap_block_bytes, mem_block_bytes, mem_blocks;
	PRTY_FILE_m13		*files;
	PRTY_m13		parity_ps;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	G_message_m13("Creating parity data ...\n");

	n_files = n_chans = n_vids = n_segs = n_ssrs = 0;
	base_paths = NULL; files = NULL;

	// get full path & name
	G_full_path_m13(session_path, sess_path);
	G_path_parts_m13(sess_path, NULL, sess_name, NULL);

	// get volume block size
	mmap_block_bytes = HW_get_block_size_m13(session_path);
	
	// get time series channel names
	chan_names = NULL;
	if (flags & PRTY_TS_MASK_m13) {
		chan_names = G_file_list_m13(NULL, &n_chans, sess_path, NULL, TS_CHAN_TYPE_STR_m13, GFL_NAME_m13);
		if (n_chans) {
			// get segment count
			if (segment_number == PRTY_ALL_SEGS_m13) {
				sprintf_m13(tmp_str, "%s/%s.%s", sess_path, chan_names[0], TS_CHAN_TYPE_STR_m13);
				seg_names = G_file_list_m13(NULL, &n_segs, tmp_str, NULL, TS_SEG_TYPE_STR_m13, GFL_NAME_m13);
				free_m13((void *) seg_names);
				start_seg = 1;
				end_seg = n_segs;
			} else {
				start_seg = end_seg = segment_number;
				n_segs = 1;
			}
		}
	}

	// fill parity ps
	mem_block_bytes = (si8) (1 << 29);  // 500 MiB
	mem_blocks = mem_block_bytes / mmap_block_bytes;
	parity_ps.mem_block_bytes = mem_block_bytes = mem_blocks * mmap_block_bytes;
	
	parity_ps.parity = (ui1 *) calloc_m13((size_t) mem_block_bytes, sizeof(ui1));
	parity_ps.data = (ui1 *) calloc_m13((size_t) mem_block_bytes, sizeof(ui1));
	G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_ERROR_OUTPUT_m13);
	unlock_parity = mlock_m13((void *) parity_ps.parity, (size_t) mem_block_bytes);
	unlock_data = mlock_m13((void *) parity_ps.data, (size_t) mem_block_bytes);
	G_pop_behavior_m13();
	
	n_files = (n_chans > n_segs) ? n_chans : n_segs;
	unlock_files = FALSE_m13;
	if (n_files) {
		parity_ps.files = files = (PRTY_FILE_m13 *) malloc_m13((size_t) n_files * sizeof(PRTY_FILE_m13));
		G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_ERROR_OUTPUT_m13);
		unlock_files = mlock_m13((void *) files, (size_t) n_files * sizeof(PRTY_FILE_m13));
		G_pop_behavior_m13();
		base_paths = (si1 **) calloc_2D_m13(n_files, PATH_BYTES_m13, sizeof(si1));
	}
	
	// build time series segment parity
	if (n_chans) {
		for (i = start_seg; i <= end_seg; ++i) {
			// build segment base paths
			STR_fixed_width_int_m13(num_str, FILE_NUMBERING_DIGITS_m13, i);
			for (j = 0; j < n_chans; ++j) {
				sprintf_m13(tmp_str, "%s_s%s", chan_names[j], num_str);
				sprintf_m13(base_paths[j], "%s/%s.%s/%s.%s/%s", sess_path, chan_names[j], TS_CHAN_TYPE_STR_m13, tmp_str, TS_SEG_TYPE_STR_m13, tmp_str);
			}
			
			// time series data
			if (flags & PRTY_TS_SEG_DAT_DATA_m13) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m13(files[k].path, "%s.%s", base_paths[j], TS_DATA_TYPE_STR_m13);
					if (G_exists_m13(files[k].path) == FILE_EXISTS_m13)
						++k;
				}
				if (k) {
					sprintf_m13(tmp_str, "parity_s%s", num_str);
					sprintf_m13(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, TS_CHAN_TYPE_STR_m13, tmp_str, TS_SEG_TYPE_STR_m13, tmp_str, TS_DATA_TYPE_STR_m13);
					parity_ps.n_files = k;
					G_message_m13("Building segment %d time series data parity ...\n", i);
					PRTY_build_m13(&parity_ps);
				}
			}
			
			// time series indices
			if (flags & PRTY_TS_SEG_DAT_IDX_m13) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m13(files[k].path, "%s.%s", base_paths[j], TS_INDS_TYPE_STR_m13);
					if (G_exists_m13(files[k].path) == FILE_EXISTS_m13)
						++k;
				}
				if (k) {
					sprintf_m13(tmp_str, "parity_s%s", num_str);
					sprintf_m13(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, TS_CHAN_TYPE_STR_m13, tmp_str, TS_SEG_TYPE_STR_m13, tmp_str, TS_INDS_TYPE_STR_m13);
					parity_ps.n_files = k;
					G_message_m13("Building segment %d time series indices parity ...\n", i);
					PRTY_build_m13(&parity_ps);
				}
			}
			
			// time series metadata
			if (flags & PRTY_TS_SEG_META_m13) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m13(files[k].path, "%s.%s", base_paths[j], TS_METADATA_TYPE_STR_m13);
					if (G_exists_m13(files[k].path) == FILE_EXISTS_m13)
						++k;
				}
				if (k) {
					sprintf_m13(tmp_str, "parity_s%s", num_str);
					sprintf_m13(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, TS_CHAN_TYPE_STR_m13, tmp_str, TS_SEG_TYPE_STR_m13, tmp_str, TS_METADATA_TYPE_STR_m13);
					parity_ps.n_files = k;
					G_message_m13("Building segment %d time series metadata parity ...\n", i);
					PRTY_build_m13(&parity_ps);
				}
			}
			
			// time series segment record data
			if (flags & PRTY_TS_SEG_REC_DATA_m13) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m13(files[k].path, "%s.%s", base_paths[j], REC_DATA_TYPE_STR_m13);
					if (G_exists_m13(files[k].path) == FILE_EXISTS_m13)
						++k;
				}
				if (k) {
					sprintf_m13(tmp_str, "parity_s%s", num_str);
					sprintf_m13(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, TS_CHAN_TYPE_STR_m13, tmp_str, TS_SEG_TYPE_STR_m13, tmp_str, REC_DATA_TYPE_STR_m13);
					parity_ps.n_files = k;
					G_message_m13("Building time series segment record data parity ...\n");
					PRTY_build_m13(&parity_ps);
				}
			}
			
			// time series segment record indices
			if (flags & PRTY_TS_SEG_REC_IDX_m13) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m13(files[k].path, "%s.%s", base_paths[j], REC_INDS_TYPE_STR_m13);
					if (G_exists_m13(files[k].path) == FILE_EXISTS_m13)
						++k;
				}
				if (k) {
					sprintf_m13(tmp_str, "parity_s%s", num_str);
					sprintf_m13(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, TS_CHAN_TYPE_STR_m13, tmp_str, TS_SEG_TYPE_STR_m13, tmp_str, REC_INDS_TYPE_STR_m13);
					parity_ps.n_files = k;
					G_message_m13("Building time series segment record indices parity ...\n");
					PRTY_build_m13(&parity_ps);
				}
			}
		}
		
		// build time series channel record base paths
		if (flags & PRTY_TS_CHAN_RECS_m13) {
			for (i = 0; i < n_chans; ++i)
				sprintf_m13(base_paths[i], "%s/%s.%s/%s", sess_path, chan_names[i], TS_CHAN_TYPE_STR_m13, chan_names[i]);
			
			// time series channel record data
			if (flags & PRTY_TS_CHAN_REC_DATA_m13) {
				for (i = j = 0; i < n_chans; ++i) {
					sprintf_m13(files[j].path, "%s.%s", base_paths[i], REC_DATA_TYPE_STR_m13);
					if (G_exists_m13(files[j].path) == FILE_EXISTS_m13)
						++j;
				}
				if (j) {
					sprintf_m13(parity_ps.path, "%s/parity.%s/parity.%s", sess_path, TS_CHAN_TYPE_STR_m13, REC_DATA_TYPE_STR_m13);
					parity_ps.n_files = j;
					G_message_m13("Building channel record data parity ...\n");
					PRTY_build_m13(&parity_ps);
				}
			}
			
			// time series channel record indices
			if (flags & PRTY_TS_CHAN_REC_IDX_m13) {
				for (i = j = 0; i < n_chans; ++i) {
					sprintf_m13(files[j].path, "%s.%s", base_paths[i], REC_INDS_TYPE_STR_m13);
					if (G_exists_m13(files[j].path) == FILE_EXISTS_m13)
						++j;
				}
				if (j) {
					sprintf_m13(parity_ps.path, "%s/parity.%s/parity.%s", sess_path, TS_CHAN_TYPE_STR_m13, REC_INDS_TYPE_STR_m13);
					parity_ps.n_files = j;
					G_message_m13("Building channel record indices parity ...\n");
					PRTY_build_m13(&parity_ps);
				}
			}
		}
	}  // end time series channels
	free_m13((void *) chan_names);
	
	// get video channel names
	n_chans = 0;
	chan_names = NULL;
	if (flags & PRTY_VID_MASK_m13) {
		chan_names = G_file_list_m13(NULL, &n_chans, sess_path, NULL, VID_CHAN_TYPE_STR_m13, GFL_NAME_m13);
		if (n_chans && n_segs == 0) {  // segment count should be same for time series & video channels
			// get segment count
			if (segment_number == PRTY_ALL_SEGS_m13) {
				sprintf_m13(tmp_str, "%s/%s.%s", sess_path, chan_names[0], VID_CHAN_TYPE_STR_m13);
				seg_names = G_file_list_m13(NULL, &n_segs, tmp_str, NULL, VID_SEG_TYPE_STR_m13, GFL_NAME_m13);
				free_m13((void *) seg_names);
				start_seg = 1;
				end_seg = n_segs;
			} else {
				start_seg = end_seg = segment_number;
				n_segs = 1;
			}
		}
	}
	
	new_files = (n_chans > n_segs) ? n_chans : n_segs;
	if (new_files > n_files) {
		if (n_files) {
			if (unlock_files == TRUE_m13)
				munlock_m13((void *) files, (size_t) n_files * sizeof(PRTY_FILE_m13));
			free_m13((void *) base_paths);
		}

		n_files = new_files;
		parity_ps.files = files = (PRTY_FILE_m13 *) realloc_m13((void *) files, (size_t) n_files * sizeof(PRTY_FILE_m13));
		G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_ERROR_OUTPUT_m13);
		unlock_files = mlock_m13((void *) files, (size_t) n_files * sizeof(PRTY_FILE_m13));
		G_pop_behavior_m13();
		base_paths = (si1 **) calloc_2D_m13(n_files, PATH_BYTES_m13, sizeof(si1));
	}
	
	if (n_chans) {
		
		// build video segment parity
		for (i = start_seg; i <= end_seg; ++i) {
			
			STR_fixed_width_int_m13(num_str, FILE_NUMBERING_DIGITS_m13, i);
			
			// video segment data (these are done across video data files within a segment)
			if (flags & PRTY_VID_SEG_DAT_DATA_m13) {
				sprintf_m13(base_paths[0], "%s/%s.%s/%s.%s", sess_path, chan_names[j], VID_CHAN_TYPE_STR_m13, tmp_str, VID_SEG_TYPE_STR_m13);
				strcat(tmp_str, "_n0000");
				vid_paths = G_file_list_m13(NULL, &n_vids, base_paths[0], tmp_str, NULL, GFL_FULL_PATH_m13);
				if (n_vids) {
					G_path_parts_m13(vid_paths[0], NULL, NULL, type_string);  // get video extension
					sprintf_m13(tmp_str, "parity_s%s", num_str);
					sprintf_m13(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, VID_CHAN_TYPE_STR_m13, tmp_str, VID_SEG_TYPE_STR_m13, tmp_str, type_string);
					G_message_m13("Building segment %d video data parity ...\n", i);
					for (j = 0; j < n_vids; ++j)
						strcpy_m13(files[j].path, vid_paths[j]);
					free_m13((void *) vid_paths);
					parity_ps.n_files = n_vids;
					PRTY_build_m13(&parity_ps);
					for (j = 0; j < n_vids; ++j)  // create parity crc files for video data files
						PRTY_write_pcrc_m13(files[j].path, 0);
				}
			}
			
			// build segment base paths
			for (j = 0; j < n_chans; ++j) {
				sprintf_m13(tmp_str, "%s_s%s", chan_names[j], num_str);
				sprintf_m13(base_paths[j], "%s/%s.%s/%s.%s/%s", sess_path, chan_names[j], VID_CHAN_TYPE_STR_m13, tmp_str, VID_SEG_TYPE_STR_m13, tmp_str);
			}
			
			// video indices
			if (flags & PRTY_VID_SEG_DAT_IDX_m13) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m13(files[k].path, "%s.%s", base_paths[j], VID_INDS_TYPE_STR_m13);
					if (G_exists_m13(files[k].path) == FILE_EXISTS_m13)
						++k;
				}
				if (k) {
					sprintf_m13(tmp_str, "parity_s%s", num_str);
					sprintf_m13(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, VID_CHAN_TYPE_STR_m13, tmp_str, VID_SEG_TYPE_STR_m13, tmp_str, VID_INDS_TYPE_STR_m13);
					G_message_m13("Building segment %d video indices parity ...\n", i);
					parity_ps.n_files = k;
					PRTY_build_m13(&parity_ps);
				}
			}
			
			// video metadata
			if (flags & PRTY_VID_SEG_META_m13) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m13(files[k].path, "%s.%s", base_paths[j], VID_METADATA_TYPE_STR_m13);
					if (G_exists_m13(files[k].path) == FILE_EXISTS_m13)
						++k;
				}
				if (k) {
					sprintf_m13(tmp_str, "parity_s%s", num_str);
					sprintf_m13(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, VID_CHAN_TYPE_STR_m13, tmp_str, VID_SEG_TYPE_STR_m13, tmp_str, VID_METADATA_TYPE_STR_m13);
					parity_ps.n_files = k;
					G_message_m13("Building segment %d video metadata parity ...\n", i);
					PRTY_build_m13(&parity_ps);
				}
			}
			
			// video segment record data
			if (flags & PRTY_VID_SEG_REC_DATA_m13) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m13(files[k].path, "%s.%s", base_paths[j], REC_DATA_TYPE_STR_m13);
					if (G_exists_m13(files[k].path) == FILE_EXISTS_m13)
						++k;
				}
				if (k) {
					sprintf_m13(tmp_str, "parity_s%s", num_str);
					sprintf_m13(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, VID_CHAN_TYPE_STR_m13, tmp_str, VID_SEG_TYPE_STR_m13, tmp_str, REC_DATA_TYPE_STR_m13);
					parity_ps.n_files = k;
					G_message_m13("Building segment %d record data parity ...\n", i);
					PRTY_build_m13(&parity_ps);
				}
			}
			
			// video segment record indices
			if (flags & PRTY_VID_SEG_REC_IDX_m13) {
				for (j = k = 0; j < n_chans; ++j) {
					sprintf_m13(files[k].path, "%s.%s", base_paths[j], REC_INDS_TYPE_STR_m13);
					if (G_exists_m13(files[k].path) == FILE_EXISTS_m13)
						++k;
				}
				if (k) {
					sprintf_m13(tmp_str, "parity_s%s", num_str);
					sprintf_m13(parity_ps.path, "%s/parity.%s/%s.%s/%s.%s", sess_path, VID_CHAN_TYPE_STR_m13, tmp_str, VID_SEG_TYPE_STR_m13, tmp_str, REC_INDS_TYPE_STR_m13);
					parity_ps.n_files = k;
					G_message_m13("Building segment %d record indices parity ...\n", i);
					PRTY_build_m13(&parity_ps);
				}
			}
		}
		
		// build video channel record base paths
		if (flags & PRTY_VID_CHAN_RECS_m13) {
			for (i = 0; i < n_chans; ++i)
				sprintf_m13(base_paths[i], "%s/%s.%s/%s", sess_path, chan_names[i], VID_CHAN_TYPE_STR_m13, chan_names[i]);
			
			// video record data
			if (flags & PRTY_VID_CHAN_REC_DATA_m13) {
				for (i = j = 0; i < n_chans; ++i) {
					sprintf_m13(files[j].path, "%s.%s", base_paths[i], REC_DATA_TYPE_STR_m13);
					if (G_exists_m13(files[j].path) == FILE_EXISTS_m13)
						++j;
				}
				if (j) {
					sprintf_m13(parity_ps.path, "%s/parity.%s/parity.%s", sess_path, VID_CHAN_TYPE_STR_m13, REC_DATA_TYPE_STR_m13);
					parity_ps.n_files = j;
					G_message_m13("Building channel record data parity ...\n");
					PRTY_build_m13(&parity_ps);
				}
			}
			
			// video channel record indices
			if (flags & PRTY_VID_CHAN_REC_IDX_m13) {
				for (i = j = 0; i < n_chans; ++i) {
					sprintf_m13(files[j].path, "%s.%s", base_paths[i], REC_INDS_TYPE_STR_m13);
					if (G_exists_m13(files[j].path) == FILE_EXISTS_m13)
						++j;
				}
				if (j) {
					sprintf_m13(parity_ps.path, "%s/parity.%s/parity.%s", sess_path, VID_CHAN_TYPE_STR_m13, REC_INDS_TYPE_STR_m13);
					parity_ps.n_files = j;
					G_message_m13("Building channel record indices parity ...\n");
					PRTY_build_m13(&parity_ps);
				}
			}
		}
		
	}  // end video channels
	free_m13((void *) chan_names);
	
	// segmented session records
	if (flags & PRTY_SSR_m13) {
		// get ssr list (all segments for segmented session records)
		// n_ssrs not necessarily == n_segs (not written if no records)
		sprintf_m13(tmp_str, "%s/%s.%s", sess_path, sess_name, SSR_TYPE_STR_m13);
		ssr_list = G_file_list_m13(NULL, &n_ssrs, tmp_str, NULL, REC_DATA_TYPE_STR_m13, GFL_PATH_m13 | GFL_NAME_m13);
		if (n_ssrs > n_files) {
			if (unlock_files == TRUE_m13)
				munlock_m13((void *) files, (size_t) n_files * sizeof(PRTY_FILE_m13));
			n_files = n_ssrs;
			parity_ps.files = files = (PRTY_FILE_m13 *) realloc_m13((void *) files, (size_t) n_files * sizeof(PRTY_FILE_m13));
			G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_ERROR_OUTPUT_m13);
			unlock_files = mlock_m13((void *) files, (size_t) n_files * sizeof(PRTY_FILE_m13));
			G_pop_behavior_m13();
		}

		// segmented session record data
		if (flags & PRTY_SEG_SESS_REC_DATA_m13) {
			for (i = 0; i < n_ssrs; ++i)
				sprintf_m13(files[i].path, "%s.%s", ssr_list[i], REC_DATA_TYPE_STR_m13);
			if (n_ssrs) {
				sprintf_m13(parity_ps.path, "%s/%s.%s/parity_s0000.%s", sess_path, sess_name, SSR_TYPE_STR_m13, REC_DATA_TYPE_STR_m13);
				parity_ps.n_files = n_ssrs;
				G_message_m13("Building segmented session record data parity ...\n");
				PRTY_build_m13(&parity_ps);
			}
		}
		
		// segmented session record indices
		if (flags & PRTY_SEG_SESS_REC_IDX_m13) {
			for (i = 0; i < n_ssrs; ++i)
				sprintf_m13(files[i].path, "%s.%s", ssr_list[i], REC_INDS_TYPE_STR_m13);
			if (n_ssrs) {
				sprintf_m13(parity_ps.path, "%s/%s.%s/parity_s0000.%s", sess_path, sess_name, SSR_TYPE_STR_m13, REC_INDS_TYPE_STR_m13);
				parity_ps.n_files = n_ssrs;
				G_message_m13("Building segmented session record indices parity ...\n");
				PRTY_build_m13(&parity_ps);
			}
		}
		free_m13((void *) ssr_list);
	}

	// session records
	if (flags & PRTY_SESS_RECS_m13) {
		// session records data
		if (flags & PRTY_GLB_SESS_REC_DATA_m13) {
			sprintf_m13(files[0].path, "%s/%s.%s", sess_path, sess_name, REC_DATA_TYPE_STR_m13);
			if (G_exists_m13(files[0].path) == FILE_EXISTS_m13) {
				sprintf_m13(parity_ps.path, "%s/parity.%s", sess_path, REC_DATA_TYPE_STR_m13);
				parity_ps.n_files = 1;
				G_message_m13("Building session record data parity ...\n");
				PRTY_build_m13(&parity_ps);
			}
		}
		
		// session records indices
		if (flags & PRTY_GLB_SESS_REC_IDX_m13) {
			sprintf_m13(files[0].path, "%s/%s.%s", sess_path, sess_name, REC_INDS_TYPE_STR_m13);
			if (G_exists_m13(files[0].path) == FILE_EXISTS_m13) {
				sprintf_m13(parity_ps.path, "%s/parity.%s", sess_path, REC_INDS_TYPE_STR_m13);
				parity_ps.n_files = 1;
				G_message_m13("Building session record indices parity ...\n");
				PRTY_build_m13(&parity_ps);
			}
		}
	}

	if (unlock_parity == TRUE_m13)
		munlock_m13((void *) parity_ps.parity, (size_t) mem_block_bytes);
	free_m13((void *) parity_ps.parity);
	if (unlock_data == TRUE_m13)
		munlock_m13((void *) parity_ps.data, (size_t) mem_block_bytes);
	free_m13((void *) parity_ps.data);
	if (files) {
		if (unlock_files == TRUE_m13)
			munlock_m13((void *) files, (size_t) n_files * sizeof(PRTY_FILE_m13));
		free_m13((void *) files);
	}
	if (base_paths)
		free_m13((void *) base_paths);

	G_message_m13("Parity data created\n\n");

	return_m13(0);
}


tern	PRTY_write_pcrc_m13(si1 *file_path, ui4 block_bytes)
{
	tern			vid_data;
	ui1			*bytes;
	ui4			*crcs, n_blocks;
	si4			i;
	si8			len;
	PRTY_CRC_DATA_m13	pcrc;
	FILE_m13		*fp;
	UH_m13			*uh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// function expects file to be closed
	// pass zero for blocks_bytes to use default
	// if file_path can be any file, typically used for files that have no CRCs such as parity data and video data
	// can be used to enhance localization in any file that has only one crc for the entire body, such as record or time series index files
	
	if (G_exists_m13(file_path) != FILE_EXISTS_m13) {
		G_warning_message_m13("%s(): parity file \"%s\" does not exist\n", __FUNCTION__, file_path);
		return_m13(FALSE_m13);
	}

	// open file
	fp = fopen_m13(file_path, "r+");
	len = PRTY_pcrc_offset_m13(fp, NULL, NULL);
	
	vid_data = G_video_data_m13(fp->path);  // preserve video universal header
	if (vid_data == TRUE_m13) {
		len -= UH_BYTES_m13;  // universal header is after pcrc in video files (so not included in pcrcs)
		uh = (UH_m13 *) malloc((size_t) UH_BYTES_m13);
		fseek_m13(fp, -UH_BYTES_m13, SEEK_END);
		fread_m13((void *) uh, sizeof(ui1), UH_BYTES_m13, fp);
		fseek_m13(fp, 0, SEEK_SET);
	}
	if (block_bytes == 0)
		block_bytes = PRTY_BLOCK_BYTES_DEFAULT_m13;
	pcrc.pcrc_tag = PRTY_PCRC_TAG_m13;
	pcrc.block_bytes = block_bytes;
	
	// allocate
	bytes = (ui1 *) malloc((size_t) block_bytes);
	n_blocks = pcrc.n_blocks = (ui4) ceil((sf8) len / (sf8) block_bytes);
	crcs = (ui4 *) malloc((size_t) n_blocks * sizeof(ui4));

	// calculate crcs
	for (i = 0; i < n_blocks; ++i) {
		if (len < block_bytes)
			block_bytes = len;
		fread_m13((void *) bytes, sizeof(ui1), block_bytes, fp);
		crcs[i] = CRC_calculate_m13(bytes, block_bytes);
		len -= block_bytes;
	}
	
	// write crcs
	fwrite_m13((void *) crcs, sizeof(ui4), (size_t) n_blocks, fp);
	
	// write pcrc data
	fwrite_m13((void *) &pcrc, sizeof(PRTY_CRC_DATA_m13), (size_t) 1, fp);
	
	// write video universal header
	if (vid_data == TRUE_m13) {
		fwrite_m13((void *) &uh, sizeof(ui1), UH_BYTES_m13, fp);
		free((void *) uh);
	}
	
	// clean up
	fclose_m13(fp);
	free((void *) bytes);
	free((void *) crcs);

	return_m13(TRUE_m13);
}


//********************************************//
// MARK: RUNTIME CONFIGURATION FUNCTIONS  (RC)
//********************************************//

si4 RC_read_field_m13(si1 *field_name, si1 **buffer, tern update_buffer_ptr, si1 *field_value_str, sf8 *float_val, si8 *int_val, tern *TERN_val)
{
	tern  option_selected, free_field_value_str, local_TERN_val, options_only;
	si1 *c, tmp_str[256], *temp_si1_ptr, *field_title_ptr;
	si1 *type_ptr, type_str[256];
	si1 *options_ptr, options_str[256];
	si1 *default_value_ptr, default_value_str[256];
	si1 *field_value_ptr;
	si4 type, option_number;
	si8 item, default_item, local_int_val;
	sf8 local_float_val;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// If update_buffer_ptr == TRUE_m13, caller can use it to progress serially through the RC file instead of starting at beginning each time.
	// Requires that caller knows that order of entries will stay the same. It is more efficient, but less flexible.
	// IMPORTANT: Caller responsible for saving a copy of *buffer for freeing, if it will be modified.
	
	// setup
	free_field_value_str = FALSE_m13;
	if (field_value_str == NULL) {  // need this string regardless of types
		field_value_str = (si1 *) malloc((size_t) 256);
		free_field_value_str = TRUE_m13;
	}
	// prevent error if user passes NULL to expected type (value will still be in field_value_str)
	if (float_val == NULL)
		float_val = &local_float_val;
	if (int_val == NULL)
		int_val = &local_int_val;
	if (TERN_val == NULL)
		TERN_val = &local_TERN_val;
	// zero strings
	*type_str = *options_str = *default_value_str = *field_value_str = 0;
	
	// find requested field entry
	c = *buffer;
	sprintf_m13(tmp_str, "%%%% FIELD: %s", field_name);
	if ((field_title_ptr = STR_match_end_m13(tmp_str, c)) == NULL) {
		G_set_error_m13(E_UNKN_m13, "could not match field label \"%s\" in rc file", tmp_str);
		return_m13(RC_ERR_m13);
	}
	
	// get type
	c = field_title_ptr;
	if ((type_ptr = STR_match_end_m13("%% TYPE:", c)) == NULL) {
		G_set_error_m13(E_UNKN_m13, "could not match TYPE subfield in field \"%s\" of rc file", field_name);
		return_m13(RC_ERR_m13);
	}
	while (*type_ptr == (si1) 32)  // space
		++type_ptr;
	item = sscanf(type_ptr, "%[^\r\n]", type_str);
	if (item) {
		temp_si1_ptr = type_str + strlen(type_str);
		while (*--temp_si1_ptr == (si1) 32);
		*++temp_si1_ptr = 0;
	} else {
		G_set_error_m13(E_UNKN_m13, "No TYPE subfield specified in field \"%s\" of rc file", field_name);
		return_m13(RC_ERR_m13);
	}

	type = 0;
	if (strcmp_m13(type_str, "string") == 0) {
		type = RC_STRING_TYPE_m13;
	} else if (strcmp_m13(type_str, "float") == 0) {
		type = RC_FLOAT_TYPE_m13;
	} else if (strcmp_m13(type_str, "integer") == 0) {
		type = RC_INTEGER_TYPE_m13;
	} else if (strcmp_m13(type_str, "ternary") == 0) {
		type = RC_TERNARY_TYPE_m13;
	} else {
		G_set_error_m13(E_UNKN_m13, "could not match TYPE subfield in field \"%s\" of rc file", field_name);
		return_m13(RC_ERR_m13);
	}

	// get options pointer
	c = type_ptr;
	options_only = FALSE_m13;
	if ((options_ptr = STR_match_end_m13("%% OPTIONS", c)) == NULL) {
		G_set_error_m13(E_UNKN_m13, "could not match OPTIONS subfield in field \"%s\" of rc file", field_name);
		return_m13(RC_ERR_m13);
	}
	if (*options_ptr == ':') {
		++options_ptr;
	} else if (strncmp_m13(options_ptr, " ONLY:", 6) == 0) {
		options_ptr += 6;
		options_only = TRUE_m13;
	} else {
		G_set_error_m13(E_UNKN_m13, "could not match OPTIONS subfield in field \"%s\" of rc file", field_name);
		return_m13(RC_ERR_m13);
	}
	while (*options_ptr == (si1) 32)  // space
		++options_ptr;
	item = sscanf(options_ptr, "%[^\r\n]", options_str);
	if (item) {
		temp_si1_ptr = options_str + strlen(options_str);
		while (*--temp_si1_ptr == (si1) 32);
		*++temp_si1_ptr = 0;
	}

	// get default value pointer
	c = options_ptr;
	if ((default_value_ptr = STR_match_end_m13("%% DEFAULT:", c)) == NULL) {
		G_set_error_m13(E_UNKN_m13, "could not match DEFAULT subfield in field \"%s\" of rc file", field_name);
		return_m13(RC_ERR_m13);
	}
	while (*default_value_ptr == (si1) 32)  // space
		++default_value_ptr;
	
	default_item = sscanf(default_value_ptr, "%[^\r\n]", default_value_str);
	if (default_item) {
		temp_si1_ptr = default_value_str + strlen(default_value_str);
		while (*--temp_si1_ptr == (si1) 32);  // space
		*++temp_si1_ptr = 0;
	}

	// get field value as string
	c = default_value_ptr;
	if ((field_value_ptr = STR_match_end_m13("%% VALUE:", c)) == NULL) {
		G_set_error_m13(E_UNKN_m13, "could not match VALUE field label \"%s\" in rc file", tmp_str);
		return_m13(RC_ERR_m13);
	}
	while (*field_value_ptr == (si1) 32)  // space
		++field_value_ptr;
	item = sscanf(field_value_ptr, "%[^\r\n]", field_value_str);
	temp_si1_ptr = field_value_str + strlen(field_value_str);
	if (update_buffer_ptr == TRUE_m13)
		*buffer = temp_si1_ptr;
	if (item) {
		while (*--temp_si1_ptr == (si1) 32);  // space
		*++temp_si1_ptr = 0;
	} else {
		strcpy(field_value_str, "DEFAULT");
	}
	
READ_RC_HANDLE_DEFAULT_m13:
	
	// VALUE field is "DEFAULT", and default may be "PROMPT"
	if (strcmp_m13(field_value_str, "DEFAULT") == 0) {
		if (default_item) {
			strcpy(field_value_str, default_value_str);
		} else {
			G_set_error_m13(E_UNKN_m13, "no DEFAULT value to enter in field \"%s\" of rc file", field_name);
		 	return_m13(RC_ERR_m13);
	 	}
	}

	// PROMPT (Note: user can enter "DEFAULT", "NO ENTRY", or any of the recognized OPTIONS here if desired)
	if (strcmp_m13(field_value_str, "PROMPT") == 0) {
		if (options_only == TRUE_m13)
			printf_m13("RC FIELD: \033[31m%s\033[0m\nOPTIONS: \033[31m%s\033[0m\nDEFAULT: \033[31m%s\033[0m\nEnter an option: ", field_name, options_str, default_value_str);
		else
			printf_m13("RC FIELD: \033[31m%s\033[0m\nOPTIONS: \033[31m%s\033[0m\nDEFAULT: \033[31m%s\033[0m\nEnter a value: ", field_name, options_str, default_value_str);
		item = scanf("%[^\r\n]", field_value_str); fgetc(stdin); putchar_m13('\n');
		if (item) {
			temp_si1_ptr = field_value_str + strlen(field_value_str);
			while (*--temp_si1_ptr == (si1) 32);  // space
			*++temp_si1_ptr = 0;
		}
	}

	// no entry
	option_selected = RC_NO_OPTION_m13;
	if ((strcmp_m13(field_value_str, "NO ENTRY") == 0)) {
		if (options_only == TRUE_m13) {
			G_warning_message_m13("%s(): \"NO ENTRY\" is not an option in field \"%s\" of rc file => using default\n", __FUNCTION__, field_name);
			strcpy(field_value_str, "DEFAULT");
			goto READ_RC_HANDLE_DEFAULT_m13;
		} else
			option_selected = RC_NO_ENTRY_m13;
	}

	// options
	if (option_selected == RC_NO_OPTION_m13) {
		option_number = 0;
		options_ptr = options_str;
		while (1) {
			while (*options_ptr == 32 || *options_ptr == ',')  // space or comma
				++options_ptr;
			if (*options_ptr == 0)
				break;
			++option_number;
			item = sscanf(options_ptr, "%[^,\r\n]", tmp_str);
			if (item) {
				if (strcmp_m13(tmp_str, field_value_str) == 0) {
					option_selected = option_number;
					strcpy(field_value_str, tmp_str);
					break;
				}
				options_ptr += strlen(tmp_str);
			} else {
				break;
			}
		}
		if (option_selected == RC_NO_OPTION_m13) {
			if (options_only == TRUE_m13) {
				G_warning_message_m13("%s(): String \"%s\" is not an option in field \"%s\" of rc file => using default\n", __FUNCTION__, field_value_str, field_name);
				strcpy(field_value_str, "DEFAULT");
				goto READ_RC_HANDLE_DEFAULT_m13;
			}
		}
	}
			
	// user entered value
	switch (type) {
		case RC_STRING_TYPE_m13:
			if (option_selected == RC_NO_ENTRY_m13)
				field_value_str[0] = 0;  // function default
			break;
		case RC_FLOAT_TYPE_m13:
			if (option_selected == RC_NO_ENTRY_m13) {
				*float_val = 0.0;  // function default
			} else {
				item = sscanf(field_value_str, "%lf", float_val);
				if (item != 1 && option_selected == RC_NO_OPTION_m13) {
					G_set_error_m13(E_UNKN_m13, "could not convert string \"%s\" to type \"%s\" in field \"%s\" of rc file", field_value_str, type_str, field_name);
			  		return_m13(RC_ERR_m13);
		  		}
			}
			break;
		case RC_INTEGER_TYPE_m13:
			if (option_selected == RC_NO_ENTRY_m13) {
				*int_val = 0;  // function default
			} else {
				item = sscanf_m13(field_value_str, "%ld", int_val);
				if (item != 1 && option_selected == RC_NO_OPTION_m13) {
					G_set_error_m13(E_UNKN_m13, "could not convert string \"%s\" to type \"%s\" in field \"%s\" of rc file", field_value_str, type_str, field_name);
					return_m13(RC_ERR_m13);
				}
			}
			break;
		case RC_TERNARY_TYPE_m13:
			if (option_selected == RC_NO_ENTRY_m13) {
				*TERN_val = UNKNOWN_m13;  // function default
				break;
			}
			if (option_selected == RC_NO_OPTION_m13) {  // user entered value
				item = sscanf(field_value_str, "%hhd", TERN_val);
				if (item != 1) {
					G_set_error_m13(E_UNKN_m13, "could not convert string \"%s\" to type \"%s\" in field \"%s\" of rc file", field_value_str, type_str, field_name);
					return_m13(RC_ERR_m13);
				}
				if (*TERN_val < FALSE_m13 || *TERN_val > TRUE_m13) {
					G_set_error_m13(E_UNKN_m13, "invalid value for type \"%s\" in field \"%s\" of rc file", type_str, field_name);
					return_m13(RC_ERR_m13);
				}
			} else {  // user entered option
				if (strcmp_m13(field_value_str, "YES") == 0 || strcmp_m13(field_value_str, "TRUE") == 0) {
					*TERN_val = TRUE_m13;
				} else if (strcmp_m13(field_value_str, "NO") == 0 || strcmp_m13(field_value_str, "FALSE") == 0) {
					*TERN_val = FALSE_m13;
				} else if (strcmp_m13(field_value_str, "UNKNOWN") == 0) {
					*TERN_val = UNKNOWN_m13;
				}
			}
			break;
		default:
			break;
	}

	if (free_field_value_str == TRUE_m13)
		free((void *) field_value_str);
	
	return_m13(option_selected);
}


si4 RC_read_field_2_m13(si1 *field_name, si1 **buffer, tern update_buffer_ptr, void *val, si4 val_type, ...)  // vararg (val_type == RC_UNKNOWN_m13): *returned_val_type
{
	tern	*tern_val, option_selected, options_only;
	si1	*str_val, *c, tmp_str[RC_STRING_BYTES_m13], *temp_si1_ptr, *field_title_ptr, local_str_val[RC_STRING_BYTES_m13];
	si1	*type_ptr, type_str[RC_STRING_BYTES_m13];
	si1	*options_ptr, options_str[RC_STRING_BYTES_m13];
	si1	*default_value_ptr, default_value_str[RC_STRING_BYTES_m13];
	si1	*field_value_ptr;
	si4	type, option_number, *returned_val_type;
	si8	*int_val, item, default_item;
	sf8	*float_val;
	va_list	arg_p;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// If update_buffer_ptr == TRUE_m13, caller can use it to progress serially through the RC file instead of starting at beginning each time.
	// Requires that caller knows that order of entries will stay the same. It is more efficient, but less flexible.
	// IMPORTANT: Caller responsible for saving a copy of *buffer for freeing, if it will be modified.
	// if type unknown, caller should pass RC_STRING_BYTES_m13 byte block of memory in val, and pass the address of an si4 in returned_val_type vararg
	// Version 2 has fewer arguments, but does not return field value as a string unless the field type was a string
	// All strings are presumed to be < RC_STRING_BYTES_m13 bytes

	if (val == NULL) {
		G_set_error_m13(E_UNKN_m13, "NULL value pointer passed");
		return_m13(RC_ERR_m13);
	}

	// setup
	if (val_type != RC_STRING_TYPE_m13)  // need str_val regardless of type
		str_val = local_str_val;
	returned_val_type = NULL;
	switch (val_type) {
		case RC_STRING_TYPE_m13:
			str_val = (si1 *) val;
			break;
		case RC_FLOAT_TYPE_m13:
			float_val = (sf8 *) val;
			break;
		case RC_INTEGER_TYPE_m13:
			int_val = (si8 *) val;
			break;
		case RC_TERNARY_TYPE_m13:
			tern_val = (tern *) val;
			break;
		case RC_UNKNOWN_TYPE_m13:
			va_start(arg_p, val_type);
			returned_val_type = va_arg(arg_p, si4 *);
			va_end(arg_p);
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "unrecognized type (%d) passed", val_type);
			return_m13(RC_ERR_m13);
	}
	// zero strings
	*str_val = *type_str = *options_str = *default_value_str = 0;
	
	// find requested field entry
	c = *buffer;
	sprintf_m13(tmp_str, "%%%% FIELD: %s", field_name);
	if ((field_title_ptr = STR_match_end_m13(tmp_str, c)) == NULL) {
		G_set_error_m13(E_UNKN_m13, "could not match field label \"%s\" in rc file", tmp_str);
		return_m13(RC_ERR_m13);
	}
	
	// get type
	c = field_title_ptr;
	if ((type_ptr = STR_match_end_m13("%% TYPE:", c)) == NULL) {
		G_set_error_m13(E_UNKN_m13, "could not match TYPE subfield in field \"%s\" of rc file", field_name);
		return_m13(RC_ERR_m13);
	}
	while (*type_ptr == (si1) 32)  // space
		++type_ptr;
	item = sscanf(type_ptr, "%[^\r\n]", type_str);
	if (item) {
		temp_si1_ptr = type_str + strlen(type_str);
		while (*--temp_si1_ptr == (si1) 32);
		*++temp_si1_ptr = 0;
	} else {
		G_set_error_m13(E_UNKN_m13, "no TYPE subfield specified in field \"%s\" of rc file", field_name);
		return_m13(RC_ERR_m13);
	}

	type = 0;
	if (strcmp_m13(type_str, "string") == 0) {
		type = RC_STRING_TYPE_m13;
	} else if (strcmp_m13(type_str, "float") == 0) {
		type = RC_FLOAT_TYPE_m13;
	} else if (strcmp_m13(type_str, "integer") == 0) {
		type = RC_INTEGER_TYPE_m13;
	} else if (strcmp_m13(type_str, "ternary") == 0) {
		type = RC_TERNARY_TYPE_m13;
	} else {
		G_set_error_m13(E_UNKN_m13, "could not match TYPE subfield in field \"%s\" of rc file", field_name);
		return_m13(RC_ERR_m13);
	}
	
	if (type != val_type) {
		if (val_type == RC_UNKNOWN_TYPE_m13) {
			*returned_val_type = type;
			switch (type) {
				case RC_STRING_TYPE_m13:
					str_val = (si1 *) val;
					break;
				case RC_FLOAT_TYPE_m13:
					float_val = (sf8 *) val;
					break;
				case RC_INTEGER_TYPE_m13:
					int_val = (si8 *) val;
					break;
				case RC_TERNARY_TYPE_m13:
					tern_val = (tern *) val;
					break;
			}
		} else {
			G_set_error_m13(E_UNKN_m13, "field type (%d) != passed type (%d) in field \"%s\" of rc file", type, val_type, field_name);
			return_m13(RC_ERR_m13);
		}
	}

	// get options pointer
	c = type_ptr;
	options_only = FALSE_m13;
	if ((options_ptr = STR_match_end_m13("%% OPTIONS", c)) == NULL) {
		G_set_error_m13(E_UNKN_m13, "could not match OPTIONS subfield in field \"%s\" of rc file", field_name);
		return_m13(RC_ERR_m13);
	}
	if (*options_ptr == ':') {
		++options_ptr;
	} else if (strncmp_m13(options_ptr, " ONLY:", 6) == 0) {
		options_ptr += 6;
		options_only = TRUE_m13;
	} else {
		G_set_error_m13(E_UNKN_m13, "could not match OPTIONS subfield in field \"%s\" of rc file", field_name);
		return_m13(RC_ERR_m13);
	}
	while (*options_ptr == (si1) 32)  // space
		++options_ptr;
	item = sscanf(options_ptr, "%[^\r\n]", options_str);
	if (item) {
		temp_si1_ptr = options_str + strlen(options_str);
		while (*--temp_si1_ptr == (si1) 32);
		*++temp_si1_ptr = 0;
	}

	// get default value pointer
	c = options_ptr;
	if ((default_value_ptr = STR_match_end_m13("%% DEFAULT:", c)) == NULL) {
		G_set_error_m13(E_UNKN_m13, "could not match DEFAULT subfield in field \"%s\" of rc file", field_name);
		return_m13(RC_ERR_m13);
	}
	while (*default_value_ptr == (si1) 32)  // space
		++default_value_ptr;
	
	default_item = sscanf(default_value_ptr, "%[^\r\n]", default_value_str);
	if (default_item) {
		temp_si1_ptr = default_value_str + strlen(default_value_str);
		while (*--temp_si1_ptr == (si1) 32);  // space
		*++temp_si1_ptr = 0;
	}

	// get field value as string
	c = default_value_ptr;
	if ((field_value_ptr = STR_match_end_m13("%% VALUE:", c)) == NULL) {
		G_set_error_m13(E_UNKN_m13, "could not match value field label \"%s\" in rc file", tmp_str);
		return_m13(RC_ERR_m13);
	}
	while (*field_value_ptr == (si1) 32)  // space
		++field_value_ptr;
	item = sscanf(field_value_ptr, "%[^\r\n]", str_val);
	temp_si1_ptr = str_val + strlen(str_val);
	if (update_buffer_ptr == TRUE_m13)
		*buffer = temp_si1_ptr;
	if (item) {
		while (*--temp_si1_ptr == (si1) 32);  // space
		*++temp_si1_ptr = 0;
	} else {
		strcpy(str_val, "DEFAULT");
	}
	
READ_RC_HANDLE_DEFAULT_m13:
	
	// VALUE field is "DEFAULT", and default may be "PROMPT"
	if (strcmp_m13(str_val, "DEFAULT") == 0) {
		if (default_item) {
			strcpy(str_val, default_value_str);
		} else {
			G_set_error_m13(E_UNKN_m13, "no DEFAULT value to enter in field \"%s\" of rc file", field_name);
			return_m13(RC_ERR_m13);
		}
	}

	// PROMPT (Note: user can enter "DEFAULT", "NO ENTRY", or any of the recognized OPTIONS here if desired)
	if (strcmp_m13(str_val, "PROMPT") == 0) {
		if (options_only == TRUE_m13)
			printf_m13("RC FIELD: \033[31m%s\033[0m\nOPTIONS: \033[31m%s\033[0m\nDEFAULT: \033[31m%s\033[0m\nEnter an option: ", field_name, options_str, default_value_str);
		else
			printf_m13("RC FIELD: \033[31m%s\033[0m\nOPTIONS: \033[31m%s\033[0m\nDEFAULT: \033[31m%s\033[0m\nEnter a value: ", field_name, options_str, default_value_str);
		item = scanf("%[^\r\n]", str_val); fgetc(stdin); putchar_m13('\n');
		if (item) {
			temp_si1_ptr = str_val + strlen(str_val);
			while (*--temp_si1_ptr == (si1) 32);  // space
			*++temp_si1_ptr = 0;
		}
	}

	// no entry
	option_selected = RC_NO_OPTION_m13;
	if ((strcmp_m13(str_val, "NO ENTRY") == 0)) {
		if (options_only == TRUE_m13) {
			G_warning_message_m13("%s(): \"NO ENTRY\" is not an option in field \"%s\" of rc file => using default\n", __FUNCTION__, field_name);
			strcpy(str_val, "DEFAULT");
			goto READ_RC_HANDLE_DEFAULT_m13;
		} else
			option_selected = RC_NO_ENTRY_m13;
	}

	// options
	if (option_selected == RC_NO_OPTION_m13) {
		option_number = 0;
		options_ptr = options_str;
		while (1) {
			while (*options_ptr == 32 || *options_ptr == ',')  // space or comma
				++options_ptr;
			if (*options_ptr == 0)
				break;
			++option_number;
			item = sscanf(options_ptr, "%[^,\r\n]", tmp_str);
			if (item) {
				if (strcmp_m13(tmp_str, str_val) == 0) {
					option_selected = option_number;
					strcpy(str_val, tmp_str);
					break;
				}
				options_ptr += strlen(tmp_str);
			} else {
				break;
			}
		}
		if (option_selected == RC_NO_OPTION_m13) {
			if (options_only == TRUE_m13) {
				G_warning_message_m13("%s(): string \"%s\" is not an option in field \"%s\" of rc file => using default\n", __FUNCTION__, str_val, field_name);
				strcpy(str_val, "DEFAULT");
				goto READ_RC_HANDLE_DEFAULT_m13;
			}
		}
	}
			
	// user entered value
	switch (type) {
		case RC_STRING_TYPE_m13:
			if (option_selected == RC_NO_ENTRY_m13)
				str_val[0] = 0;  // function default
			break;
		case RC_FLOAT_TYPE_m13:
			if (option_selected == RC_NO_ENTRY_m13) {
				*float_val = 0.0;  // function default
			} else {
				item = sscanf(str_val, "%lf", float_val);
				if (item != 1 && option_selected == RC_NO_OPTION_m13) {
					G_set_error_m13(E_UNKN_m13, "could not convert string \"%s\" to type \"%s\" in field \"%s\" of rc file", str_val, type_str, field_name);
					return_m13(RC_ERR_m13);
				}
			}
			break;
		case RC_INTEGER_TYPE_m13:
			if (option_selected == RC_NO_ENTRY_m13) {
				*int_val = 0;  // function default
			} else {
				item = sscanf_m13(str_val, "%ld", int_val);
				if (item != 1 && option_selected == RC_NO_OPTION_m13) {
					G_set_error_m13(E_UNKN_m13, "could not convert string \"%s\" to type \"%s\" in field \"%s\" of rc file", str_val, type_str, field_name);
					return_m13(RC_ERR_m13);
				}
			}
			break;
		case RC_TERNARY_TYPE_m13:
			if (option_selected == RC_NO_ENTRY_m13) {
				*tern_val = UNKNOWN_m13;  // function default
				break;
			}
			if (option_selected == RC_NO_OPTION_m13) {  // user entered value
				item = sscanf(str_val, "%hhd", tern_val);
				if (item != 1) {
					G_set_error_m13(E_UNKN_m13, "could not convert string \"%s\" to type \"%s\" in field \"%s\" of rc file", str_val, type_str, field_name);
					return_m13(RC_ERR_m13);
				}
				if (*tern_val < FALSE_m13 || *tern_val > TRUE_m13) {
					G_set_error_m13(E_UNKN_m13, "invalid value for type \"%s\" in field \"%s\" of rc file", type_str, field_name);
					return_m13(RC_ERR_m13);
				}
			} else {  // user entered option
				if (strcmp_m13(str_val, "YES") == 0 || strcmp_m13(str_val, "TRUE") == 0) {
					*tern_val = TRUE_m13;
				} else if (strcmp_m13(str_val, "NO") == 0 || strcmp_m13(str_val, "FALSE") == 0) {
					*tern_val = FALSE_m13;
				} else if (strcmp_m13(str_val, "UNKNOWN") == 0) {
					*tern_val = UNKNOWN_m13;
				}
			}
			break;
		default:
			break;
	}
	
	return_m13(option_selected);
}


//****************************//
// MARK: HASH FUNCTIONS  (SHA)
//****************************//

// ATTRIBUTION:
//
// Author:	Brad Conte (brad@bradconte.com)
// Disclaimer:	This code is presented "as is" without any guarantees.
// Details:	Implementation of the SHA-256 hashing algorithm.
//		Algorithm specification can be found here:
//	  	http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf
//		This implementation uses little endian byte order.
//
// Code:	https://github.com/B-Con/crypto-algorithms/blob/master/sha256.c
//
// Only SHA-256 functions are included in the MED library
// The version below contains minor modifications for compatibility with the MED Library.


void	SHA_finalize_m13(SHA_CTX_m13 *ctx, ui1 *hash)
{
	ui4	i;
	

	i = ctx->datalen;

	// pad whatever data is left in the buffer
	if (ctx->datalen < 56) {
		ctx->data[i++] = 0x80;
		while (i < 56)
			ctx->data[i++] = 0x00;
	}
	else {
		ctx->data[i++] = 0x80;
		while (i < 64)
			ctx->data[i++] = 0x00;
		SHA_transform_m13(ctx, ctx->data);
		memset(ctx->data, 0, 56);
	}

	// Append to the padding the total message's length in bits and transform.
	ctx->bitlen += ctx->datalen * 8;
	ctx->data[63] = ctx->bitlen;
	ctx->data[62] = ctx->bitlen >> 8;
	ctx->data[61] = ctx->bitlen >> 16;
	ctx->data[60] = ctx->bitlen >> 24;
	ctx->data[59] = ctx->bitlen >> 32;
	ctx->data[58] = ctx->bitlen >> 40;
	ctx->data[57] = ctx->bitlen >> 48;
	ctx->data[56] = ctx->bitlen >> 56;
	SHA_transform_m13(ctx, ctx->data);

	// Since this implementation uses little endian byte ordering and SHA uses big endian,
	// reverse all the bytes when copying the final state to the output hash.
	for (i = 0; i < 4; ++i) {
		hash[i]  = (ctx->state[0] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m13;
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m13;
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m13;
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m13;
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m13;
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m13;
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m13;
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & SHA_LOW_BYTE_MASK_m13;
	}
	
	return;
}


ui1  *SHA_hash_m13(const ui1 *data, si8 len, ui1 *hash)
{
	SHA_CTX_m13 ctx;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (globals_m13->tables->SHA_h0_table == NULL)  // all tables initialized together
		SHA_init_tables_m13();

	// if hash not passed, up to caller to free it
	if (hash == NULL)
		hash = (ui1 *) calloc_m13((size_t) SHA_HASH_BYTES_m13, sizeof(ui1));
	
	SHA_init_m13(&ctx);
	SHA_update_m13(&ctx, data, len);
	SHA_finalize_m13(&ctx, hash);
	
	return_m13(hash);
}


void	SHA_init_m13(SHA_CTX_m13 *ctx)
{
	ui4	*SHA_h0;
	

	ctx->datalen = 0;
	ctx->bitlen = 0;
	
	SHA_h0 = globals_m13->tables->SHA_h0_table;
	ctx->state[0] = SHA_h0[0];
	ctx->state[1] = SHA_h0[1];
	ctx->state[2] = SHA_h0[2];
	ctx->state[3] = SHA_h0[3];
	ctx->state[4] = SHA_h0[4];
	ctx->state[5] = SHA_h0[5];
	ctx->state[6] = SHA_h0[6];
	ctx->state[7] = SHA_h0[7];
	
	return;
}


tern	SHA_init_tables_m13(void)
{
	size_t			len;
	GLOBAL_TABLES_m13	*tables;

	
	tables = globals_m13->tables;
	if (tables->SHA_h0_table)
		return_m13(TRUE_m13);

	pthread_mutex_lock_m13(&tables->mutex);
	if (tables->SHA_h0_table) {  // may have been done by another thread while waiting
		pthread_mutex_unlock_m13(&tables->mutex);
		return(TRUE_m13);
	}

	// h0 table
	tables->SHA_h0_table = (ui4 *) calloc((size_t) SHA_H0_ENTRIES_m13, sizeof(ui4));
	if (tables->SHA_h0_table == NULL) {
		pthread_mutex_unlock_m13(&tables->mutex);
		return(FALSE_m13);
	}
	{
		ui4	temp[SHA_H0_ENTRIES_m13] = SHA_H0_m13;
		
		len = (size_t) SHA_H0_ENTRIES_m13 * sizeof(ui4);
		memcpy((void *) tables->SHA_h0_table, (void *) temp, len);
	}

	// k table
	tables->SHA_k_table = (ui4 *) calloc((size_t) SHA_K_ENTRIES_m13, sizeof(ui4));
	if (tables->SHA_k_table == NULL) {
		pthread_mutex_unlock_m13(&tables->mutex);
		return(FALSE_m13);
	}
	{
		ui4 temp[SHA_K_ENTRIES_m13] = SHA_K_m13;
		
		len = (size_t) SHA_K_ENTRIES_m13 * sizeof(ui4);
		memcpy((void *) tables->SHA_k_table, (void *) temp, len);
	}

	pthread_mutex_unlock_m13(&tables->mutex);

	return(TRUE_m13);
}


void	SHA_transform_m13(SHA_CTX_m13 *ctx, const ui1 *data)
{
	ui4	a, b, c, d, e, f, g, h, i, j, t1, t2, m[64], *sha_k;


	for (i = 0, j = 0; i < 16; ++i, j += 4)
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
	for ( ; i < 64; ++i)
		m[i] = SHA_SIG1_m13(m[i - 2]) + m[i - 7] + SHA_SIG0_m13(m[i - 15]) + m[i - 16];

	a = ctx->state[0];
	b = ctx->state[1];
	c = ctx->state[2];
	d = ctx->state[3];
	e = ctx->state[4];
	f = ctx->state[5];
	g = ctx->state[6];
	h = ctx->state[7];
	
	sha_k = globals_m13->tables->SHA_k_table;
	for (i = 0; i < 64; ++i) {
		t1 = h + SHA_EP1_m13(e) + SHA_CH_m13(e,f,g) + sha_k[i] + m[i];
		t2 = SHA_EP0_m13(a) + SHA_MAJ_m13(a,b,c);
		h = g;
		g = f;
		f = e;
		e = d + t1;
		d = c;
		c = b;
		b = a;
		a = t1 + t2;
	}

	ctx->state[0] += a;
	ctx->state[1] += b;
	ctx->state[2] += c;
	ctx->state[3] += d;
	ctx->state[4] += e;
	ctx->state[5] += f;
	ctx->state[6] += g;
	ctx->state[7] += h;
	
	return;
}


void	SHA_update_m13(SHA_CTX_m13 *ctx, const ui1 *data, si8 len)
{
	si8	i;
	

	for (i = 0; i < len; ++i) {
		ctx->data[ctx->datalen] = data[i];
		ctx->datalen++;
		if (ctx->datalen == 64) {
			SHA_transform_m13(ctx, ctx->data);
			ctx->bitlen += 512;
			ctx->datalen = 0;
		}
	}
	
	return;
}



//******************************//
// MARK: STRING FUNCTIONS  (STR)
//******************************//

si1	*STR_bin_m13(si1 *str, void *num_ptr, size_t num_bytes, si1 *byte_separator, tern numeric_order)
{
	ui1	*num, mask;
	si1	*c, *c2;
	si4	str_len, sep_len, byte_bits;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// returns a binary string for num
	// input presumed to be little endian
	// displayed high bit => low bit, left to right
	// pass NULL or "" for byte_separator for no separation between bytes
	// if numeric_order is TRUE_m13, bytes & bits will be displayed high->low from left->right
	// otherwise they will be displayed as they appear in memory (from low->high addresses & bit positions)

	if (STR_empty_m13(byte_separator) == FALSE_m13) {
		for (c = byte_separator - 1; *++c;);
		sep_len = (c - byte_separator);
	} else {
		sep_len = 0;
	}

	if (str == NULL) {  // caller responsible for freeing
		str_len = (num_bytes << 3) + 1;  // account for terminal zero
		if (sep_len)
			str_len += (num_bytes - 1) * sep_len;
		str = malloc_m13((size_t) str_len);
	}
	
	if (numeric_order == TRUE_m13) {
		num = (ui1 *) num_ptr + (num_bytes - 1);
		c = str;
		for (; num_bytes--; --num) {
			for (mask = 1 << 7, byte_bits = 8; byte_bits--; mask >>= 1) {
				if (*num & mask)
					*c++ = '1';
				else
					*c++ = '0';
			}
			if (sep_len && num_bytes)
				for (c2 = byte_separator; *c2; *c++ = *c2++);
		}
	} else {
		num = (ui1 *) num_ptr;
		c = str;
		for (; num_bytes--; --num) {
			for (mask = 1, byte_bits = 8; byte_bits--; mask <<= 1) {
				if (*num & mask)
					*c++ = '1';
				else
					*c++ = '0';
			}
			if (sep_len && num_bytes)
				for (c2 = byte_separator; *c2; *c++ = *c2++);
		}
	}
	*c = 0;

	return_m13(str);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
const si1	*STR_bool_m13(ui8 val)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	if (val)
		return_m13("true");
	
	return_m13("false");
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
wchar_t	*STR_char2wchar_m13(wchar_t *target, si1 *source)
{
	si1	*c, *c2, *tmp_source = NULL;
	si8	len, wsz;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// if source == target, done in place
	// if not actually ascii, results may be weird
	// assumes target is big enough
	
	wsz = sizeof(wchar_t);  // 2 or 4 => varies by OS & compiler
	c = (si1 *) target - wsz;
	len = strlen(source);
	if ((void *) source == (void *) target) {
		tmp_source = (si1 *) malloc((size_t) len + 1);
		memcpy((void *) tmp_source, (void *)  source, (size_t)len + 1);
		c2 = tmp_source;
	} else {
		c2 = source;
	}
	memset((void *) target, 0, wsz * (len + 1));
	
	while (len--)
		*(c += wsz) = *c2++;  // little endian version
	
	if (tmp_source)
		free((void *) tmp_source);
	
	return_m13(target);
}


ui4 STR_check_spaces_m13(si1 *string)
{
	ui4 spaces;
	si1 *c;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (string == NULL)
		return_m13(NO_SPACES_m13);
	if (*string == 0)
		return_m13(NO_SPACES_m13);
	
	c = string;
	spaces = NO_SPACES_m13;
	while (*++c) {
		if (*c == 0x20) {  // space
			if (*(c - 1) == 0x5c)  // backslash
				spaces |= ESCAPED_SPACES_m13;
			else
				spaces |= UNESCAPED_SPACES_m13;
		}
	}
			  
	return_m13(spaces);
}


si4	STR_compare_m13(const void *a, const void *b)
{
	si1		*ap, *bp, ac, bc;
	
	
	// Sorting Rules:
	// ascii only
	// case insensitive, but in case of equivalence lower case precedes upper case (e.g. "abc.txt" before "Abc.txt"
	//  "." before <space> (e.g. "RawData.nrd" before "RawData 0001.nrd"
	
	ac = *(ap = *((si1 **) a));
	bc = *(bp = *((si1 **) b));

	while (ac && bc) {
		
		// letters
		if (ac >= 'A' && ac <= 'Z') {
			ac += ('a' - 'A');  // "promote" to lower case, so "_" precedes letters
		}
		if (bc >= 'A' && bc <= 'Z')
			bc += ('a' - 'A');  // "promote" to lower case, so "_" precedes letters
		
		// equal - go to next character
		if (ac == bc) {
			ac = *++ap;
			bc = *++bp;
			continue;
		}
		
		// change ascii <space> before "." to "." before <space>
		if (ac == 0x20 || bc == 0x20) {  // a or b is a space, not both (caught above) (0x20 == <space>)
			if (bc == '.')
				return_m13(1);
			if (ac == '.')
				return_m13(-1);
		}
		
		return((si4) ac - (si4) bc);
	}
	
	if (ac)  // b longer than a
		return(1);
	if (bc)  // a longer than b
		return(-1);
	
	// case-insensitive equal strings - sort by case
	--ap; --bp;
	while (*++ap && *++bp) {
		if (*ap != *bp)  // first case difference
			return((si4) *bp - (si4) *ap);  // lower before upper case
	}
	
	// identical strings
	return(0);
}


tern  STR_contains_formatting_m13(const si1 *string, si1 *plain_string)
{
	tern	format_seq;
	const si1	*c1, *c3;
	si1		*c2;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// if plain_string == NULL : return T/F on string, do not modify string
	// if plain_string == string : return T/F on string, do modify string (done in place)
	// if plain_string != string && plain_string : return T/F on path, return plain_string with formatting removed, leave string intact
	// assumes plain_string has adequate space for deformatted string if passed (length plain_string will always be <= length of string)
		
	c1 = string;
	format_seq = FALSE_m13;
	while (*c1) {
		if (*c1 == 27) {  // escape
			if (*(c1 + 1) == 91) {  // '['
				c2 = (si1 *) c1 + 3;
				if (*c2++ == 109)  // 'm'
					format_seq = TRUE_m13;
				else if (*c2++ == 109)  // 'm'
					format_seq = TRUE_m13;
				else if (*c2++ == 109)  // 'm'
					format_seq = TRUE_m13;
				else if (*c2++ == 109)  // 'm'
					format_seq = TRUE_m13;
				if (format_seq == TRUE_m13)
					break;
			}
		}
		++c1;
	}
	
	if (plain_string == NULL)
		return_m13(format_seq);
	
	if (format_seq == TRUE_m13) {
		if (plain_string != string) {
			c2 = plain_string;
			c3 = string;
			while (c3 != c1)  // copy string up to c1 into plain_string
				*c2++ = *c3++;
		} else {
			c2 = (si1 *) c1;  // same string - no copying needed
		}
	} else {
		if (plain_string != string)
			strcpy(plain_string, string);
		return_m13(FALSE_m13);
	}
	
	// remove formatting
	while (*c1) {
		if (*c1 == 27) {  // escape
			if (*(c1 + 1) == 91) {  // '['
				c3 = c1 + 3;
				format_seq = FALSE_m13;
				if (*c3++ == 109)  // 'm'
					format_seq = TRUE_m13;
				else if (*c3++ == 109)  // 'm'
					format_seq = TRUE_m13;
				else if (*c3++ == 109)  // 'm'
					format_seq = TRUE_m13;
				else if (*c3++ == 109)  // 'm'
					format_seq = TRUE_m13;
				if (format_seq == TRUE_m13) {
					c1 = c3;
					if (*c1 == 0) // end of string
						break;
					if (*c1 == 27)  // possibly another escape sequence
						continue;
				}
			}
		}
		*c2++ = *c1++;
	}
	*c2 = 0;
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	STR_contains_regex_m13(const si1 *string)
{
	si1	c;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// NOT an exhaustive list of potential regex characters, just enough to know if regex is present
	
	if (string == NULL)
		return_m13(FALSE_m13);
	
	while ((c = *string++)) {
		switch (c) {
			case '*':
			case '?':
			case '|':
			case '^':
			case '$':
			case '[':
			case '{':
				return_m13(TRUE_m13);
		}
	}
	
	return_m13(FALSE_m13);
}


si1 *STR_duration_m13(si1 *dur_str, si8 int_usecs, tern abbreviated, tern two_level)
{
	const si1	*full[9] = {"year", "month", "week", "day", "hour", "minute", "second", "millisecond", "microsecond"};
	const si1	*abbr[9] = {"yr", "mo", "wk", "day", "hr", "min", "sec", "ms", "us"};
	si1		*offset_dur_str;
	si4		level_idx, int_level_1, int_level_2;
	const sf8	divisors[9] = {31556926000000.0, 2629744000000.0, 604800000000.0, 86400000000.0, 3600000000.0, 60000000.0, 1000000.0, 1000.0, 1.0};
	sf8 usecs, level_1, level_2;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// Note: if dur_str == NULL, it will be allocated & calling function is responsible for freeing
	if (dur_str == NULL)
		dur_str = malloc_m13((size_t) TIME_STRING_BYTES_m13);
		
	if (int_usecs <= 0) {
		if (int_usecs == 0) {
			if (two_level == TRUE_m13)
				strcpy(dur_str, "0 ");
			else
				strcpy(dur_str, "0.00 ");
			if (abbreviated == TRUE_m13)
				strcat(dur_str, "us");
			else
				strcat(dur_str, "microseconds");
			return_m13(dur_str);
		}
		if (abbreviated == TRUE_m13) {
			strcpy(dur_str, "neg ");
			offset_dur_str = dur_str + 4;
		} else {
			strcpy(dur_str, "negative ");
			offset_dur_str = dur_str + 9;
		}
		int_usecs = -int_usecs;
	} else {
		offset_dur_str = dur_str;
	}

	level_1 = usecs = (sf8) int_usecs;
	for (level_idx = 0; usecs >= divisors[level_idx]; ++level_idx);

	if (level_idx == 8)  // usecs
		two_level = FALSE_m13;
	else
		level_1 /= divisors[level_idx];

	if (two_level == TRUE_m13) {
		int_level_1 = (si4) level_1;  // rounnd down
		usecs = (level_1 - (sf8) int_level_1) * divisors[level_idx];
		level_2 = usecs / divisors[level_idx + 1];
		int_level_2 = (si4) level_2;  // rounnd down
		if (abbreviated == TRUE_m13) {
			sprintf_m13(offset_dur_str, "%d %s, %d %s", int_level_1, abbr[level_idx], int_level_2, abbr[level_idx + 1]);
		} else {
			if (level_idx == 2 && int_level_1 == 2 && int_level_2 == 0)  // :)
				sprintf_m13(offset_dur_str, "a fortnight");
			else
				sprintf_m13(offset_dur_str, "%d %s%s, %d %s%s", int_level_1, full[level_idx], PLURAL_m13(int_level_1), int_level_2, full[level_idx + 1], PLURAL_m13(int_level_2));
		}
	} else {
		if (abbreviated == TRUE_m13)
			sprintf_m13(offset_dur_str, "%0.2lf %s", level_1, abbr[level_idx]);
		else
			sprintf_m13(offset_dur_str, "%0.2lf %ss", level_1, full[level_idx]);
	}

	return_m13(dur_str);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	STR_empty_m13(const si1 *string)
{
	if (string == NULL)
		return(TRUE_m13);
	
	if (*string)
		return(FALSE_m13);
	
	return(TRUE_m13);
}


tern  STR_escape_chars_m13(si1 *string, si1 target_char, si8 buffer_len)
{
	si1	*c1, *c2, *tmp_str, backslash;
	si8 n_target_chars, len;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	backslash = (si1) 0x5c;
	
	// count
	for (n_target_chars = 0, c1 = string; *c1++;)
		if (*c1 == target_char)
			if (*(c1 - 1) != backslash)
				++n_target_chars;
	len = (c1 - string) + n_target_chars;
	if (buffer_len != 0) {  // if zero, proceed at caller's peril
		if (buffer_len < len) {
			G_set_error_m13(E_UNKN_m13, "string buffer too small");
			return_m13(FALSE_m13);
		}
	}
	
	tmp_str = (si1 *) malloc(len);
	
	c1 = string;
	c2 = tmp_str;
	while (*c1) {
		if (*c1 == target_char) {
			if (*(c1 - 1) != backslash)
				*c2++ = backslash;
		}
		*c2++ = *c1++;
	}
	*c2 = 0;
	strcpy(string, tmp_str);
	
	free((void *) tmp_str);
	
	return_m13(TRUE_m13);
}


si1	*STR_fixed_width_int_m13(si1 *string, si4 string_bytes, si8 number)
{
	si4	native_numerical_length, temp;
	si1	*c;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// string bytes does not include terminal zero
	
	if (string == NULL)
		string = (si1 *) calloc_m13((size_t)(string_bytes + 1), sizeof(si1));
	
	native_numerical_length = 0;
	temp = number;
	while (temp) {
		temp /= 10;
		++native_numerical_length;
	}
	if (number <= 0)
		++native_numerical_length;
	
	c = string;
	temp = string_bytes - native_numerical_length;
	if (temp < 0) {
		G_set_error_m13(E_UNKN_m13, "required digits exceed string length");
		return_m13(NULL);
	}
	while (temp--)
		*c++ = '0';
	
	sprintf_m13(c, "%d", number);
	
	return_m13(string);
}


si1	*STR_hex_m13(si1 *str, void *num_ptr, si8 num_bytes, si1 *byte_separator, tern numeric_order)
{
	tern	caps;
	ui1	*byte;
	si4	sep_len, str_len;
	si1	*c, *c2;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns a hexadecimal string for num
	// input presumed to be little endian
	// displayed high byte => low byte, left to right
	// pass NULL or "" for byte_separator for no separation between bytes
	// pass negative num_bytes for capital letters
	// if numeric_order is TRUE_m13, bytes will be displayed high->low from left->right
	// otherwise bytes will be displayed as they appear in memory (from low->high addresses)

	if (STR_empty_m13(byte_separator) == FALSE_m13) {
		for (c = byte_separator - 1; *++c;);
		sep_len = (c - byte_separator);
	} else {
		sep_len = 0;
	}
	
	if (num_bytes < 0) {
		num_bytes = -num_bytes;
		caps = TRUE_m13;
	} else {
		caps = FALSE_m13;
	}

	if (str == NULL) {  // caller takes ownership
		str_len = (num_bytes << 1) + 1;  // 2 bytes per byte + terminal zero
		if (sep_len)
			str_len += (num_bytes - 1) * sep_len;
		str = malloc_m13((size_t) str_len);
	}
	
	c = str;
	if (numeric_order == TRUE_m13) {
		byte = ((ui1 *) num_ptr) + (num_bytes - 1);  // little endian - last byte is highest order
		for (; num_bytes--; --byte) {
			if (caps == TRUE_m13)
				sprintf(c, "%02hhX", *byte);
			else
				sprintf(c, "%02hhx", *byte);
			c += 2;
			if (sep_len && num_bytes)
				for (c2 = byte_separator; *c2; *c++ = *c2++);
		}
	} else {
		byte = (ui1 *) num_ptr;
		for (; num_bytes--; ++byte) {
			if (caps == TRUE_m13)
				sprintf(c, "%02hhX", *byte);
			else
				sprintf(c, "%02hhx", *byte);
			c += 2;
			if (sep_len && num_bytes)
				for (c2 = byte_separator; *c2; *c++ = *c2++);
		}
	}
	*c = 0;
	
	return_m13(str);
}


si1	*STR_match_end_m13(si1 *pattern, si1 *buffer)
{
	si1	*pat_p, *buf_p;
	si4	pat_len, buf_len;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns pointer to the character after the first match in the buffer, NULL if no match (assumes both pattern & buffer are zero-terminated)
	
	pat_len = strlen(pattern);
	buf_len = strlen(buffer);
	if (pat_len > buf_len)
		return_m13(NULL);
	
	do {
		pat_p = pattern;
		buf_p = buffer++;
		while (*buf_p++ == *pat_p++)
			if (!*pat_p)
				return_m13(buf_p);
	} while (*buf_p);
	
	return_m13(NULL);
}


si1	*STR_match_end_bin_m13(si1 *pattern, si1 *buffer, si8 buf_len)
{
	si1	*pat_p, *buf_p, *buf_end;
	si8	pat_len;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns pointer to the character after the first match in the buffer, NULL if no match (assumes pattern is zero-terminated)
	// "bin" version allows for binary data in buffer (zeros in buffer)
	// NOTE: if updating buffer pointer in sequential calls, adjust buf_len accordingly

	pat_len = (si8) strlen(pattern);
	if (pat_len >= buf_len)
		return_m13(NULL);
	
	buf_end = (buffer + buf_len) - pat_len;
	do {
		pat_p = pattern;
		buf_p = buffer++;
		while (*buf_p++ == *pat_p++)
			if (!*pat_p)
				return_m13(buf_p);
		if (!*pat_p) {
			if (buf_p <= buf_end)
				return_m13(buf_p);
			return_m13(NULL);
		}
	} while (buffer < buf_end);
	
	return_m13(NULL);
}


si1	*STR_match_line_end_m13(si1 *pattern, si1 *buffer)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns pointer to beginning of the line following the line with first match, NULL if no match (assumes both pattern & buffer are zero-terminated)
	
	buffer = STR_match_end_m13(pattern, buffer);
	if (buffer == NULL)
		return_m13(NULL);
	
	while (*buffer != '\n' && *buffer != '\r' && *buffer != 0)
		++buffer;
	if (*buffer == 0)
		return_m13(NULL);
	
	while (*buffer == '\n' || *buffer != '\r')
		++buffer;
	
	if (*buffer == 0)
		return_m13(NULL);
	
	return_m13(buffer);
}


si1	*STR_match_line_start_m13(si1 *pattern, si1 *buffer)
{
	si1	*buf_p;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns pointer to beginning of the line containing the first match, NULL if no match (assumes both pattern & buffer are zero-terminated)

	buf_p = STR_match_start_m13(pattern, buffer);
	if (buf_p == NULL)
		return_m13(NULL);
	
	while (*buf_p != '\n' && buf_p != buffer)
		--buf_p;
	
	if (buf_p == buffer)
		return_m13(buffer);
	
	return_m13(++buf_p);
}


si1	*STR_match_start_m13(si1 *pattern, si1 *buffer)
{
	si1	*pat_p, *buf_p;
	si4	pat_len, buf_len;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns pointer to beginning of the first match in the buffer, NULL if no match (assumes both pattern & buffer are zero-terminated)

	pat_len = strlen(pattern);
	buf_len = strlen(buffer);
	if (pat_len > buf_len)
		return_m13(NULL);
	
	do {
		pat_p = pattern;
		buf_p = buffer++;
		while (*buf_p++ == *pat_p++)
		if (!*pat_p)
			return_m13(--buffer);
	} while (*buf_p);
	
	return_m13(NULL);
}


si1	*STR_match_start_bin_m13(si1 *pattern, si1 *buffer, si8 buf_len)
{
	si1	*pat_p, *buf_p, *buf_end;
	si8	pat_len;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns pointer to beginning of the first match in the buffer, NULL if no match (assumes pattern is zero-terminated)
	// "bin" version allows for binary data in buffer (zeros in buffer)
	// NOTE: if updating buffer pointer in sequential calls, adjust buf_len accordingly

	pat_len = (si8) strlen(pattern);
	if (pat_len >= buf_len)
		return_m13(NULL);
	
	buf_end = (buffer + buf_len) - pat_len;
	do {
		pat_p = pattern;
		buf_p = buffer++;
		while (*buf_p++ == *pat_p++) {
			if (!*pat_p)
				return_m13(--buffer);
			if (buf_p == buf_end)
				return_m13(NULL);
		}
		if (!*pat_p) {
			if (buf_p <= buf_end)
				return_m13(--buffer);
			return_m13(NULL);
		}
	} while (buffer < buf_end);
	
	return_m13(NULL);
}


si1 *STR_re_escape_m13(si1 *str, si1 *esc_str)
{
	si8 len;
	si1 *c1, *c2;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	c1 = str;
	while (*c1++);
	len = c1 - str;
	if (esc_str == NULL)  // up to caller to free
		esc_str = (si1 *) calloc((size_t) (len * 2), sizeof(si1));
	strcpy(esc_str, str);
	c1 = esc_str;
	c2 = str - 1;
	while (*++c2) {
		switch (*c2) {
			case '\n':
				*c1++ = '\\'; *c1++ = 'n'; break;
			case '\r':
				*c1++ = '\\'; *c1++ = 'r'; break;
			case '\t':
				*c1++ = '\\'; *c1++ = 't'; break;
			case '\7':
				*c1++ = '\\'; *c1++ = '7'; break;
			case '\\':
				*c1++ = '\\'; *c1++ = '\\'; break;
			default:
				*c1++ = *c2; break;
		}
	}
	*c1 = 0;
	
	return_m13(esc_str);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern  STR_replace_char_m13(si1 c, si1 new_c, si1 *buffer)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Note: does not handle UTF8 chars
	// Done in place
	
	if (buffer == NULL || c == 0)
		return_m13(TRUE_m13);
	
	do {
		if (*buffer == c)
			*buffer = new_c;
	} while (*buffer++);
	
	return_m13(TRUE_m13);
}


si1	*STR_replace_pattern_m13(si1 *pattern, si1 *new_pattern, si1 *buffer, si1 *new_buffer)
{
	tern	in_place = FALSE_m13;
	si1	*c, *last_c, *new_c, *c2;
	si4	char_diff, extra_chars, matches;
	si8	len, pat_len, new_pat_len;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// if buffer buffer == new_buffer, done in place (adequate space assumed)
	// if buffer new_buffer == NULL, it is allocated

	if (pattern == NULL || new_pattern == NULL || buffer == NULL)
		return_m13(NULL);
	if (*pattern == 0 || *buffer == 0)
		return_m13(NULL);
	
	pat_len = strlen(pattern);
	new_pat_len = strlen(new_pattern);
	char_diff = new_pat_len - pat_len;
	
	matches = 0;
	c = buffer;
	while (1) {
		c = STR_match_end_m13(pattern, c);
		if (c == NULL)
			break;
		++matches;
	}
	if (!matches)
		return_m13(buffer);
	
	extra_chars = matches * char_diff;
	len = strlen(buffer) + extra_chars + 1;  // extra byte for terminal zero
	if (new_buffer == buffer) {
		in_place = TRUE_m13;
		new_buffer = NULL;
	}
	if (new_buffer == NULL)
		new_buffer = (si1 *) calloc_m13((size_t)len, sizeof(ui1));
	strcpy(new_buffer, buffer);
	
	last_c = c = buffer;
	new_c = new_buffer;
	extra_chars = 0;
	while (1) {
		c = STR_match_start_m13(pattern, c);
		if (c == NULL)
			break;
		while (last_c < c)
			*new_c++ = *last_c++;
		c2 = new_pattern;
		while (*c2)
			*new_c++ = *c2++;
		last_c = (c += pat_len);
	}
	while (*last_c)
		*new_c++ = *last_c++;
	*new_c = 0;
	
	if (in_place == TRUE_m13) {
		memcpy((void *) buffer, (void *) new_buffer, (size_t) len);
		free_m13((void *) new_buffer);
		new_buffer = buffer;
	}

	return_m13(new_buffer);
}


si1 *STR_size_m13(si1 *size_str, si8 n_bytes, tern base_two)
{
	static const si1  units[6][8] = {"Bytes", "KB", "MB", "GB", "TB", "PB"};
	static const si1  i_units[6][8] = {"Bytes", "KiB", "MiB", "GiB", "TiB", "PiB"};
	ui8 i, j, t;
	sf8 size;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Note: if size_str == NULL, it will be allocated & calling function is responsible for freeing
	if (size_str == NULL)
		size_str = (si1 *) malloc_m13((size_t) SIZE_STRING_BYTES_m13);
	
	if (base_two == TRUE_m13) {
		for (i = 0, j = 1, t = n_bytes; t >>= 10; ++i, j <<= 10);
		size = (sf8) n_bytes / (sf8) j;
		sprintf_m13(size_str, "%0.2lf %s", size, i_units[i]);
	} else {
		for (i = 0, j = 1, t = n_bytes; t /= 1000; ++i, j *= 1000);
		size = (sf8) n_bytes / (sf8) j;
		sprintf_m13(size_str, "%0.2lf %s", size, units[i]);
	}

	return_m13(size_str);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	STR_sort_m13(si1 **string_array, si8 n_strings)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// input must be 2D string array, such as allocated by calloc_2D_m13()
	// sorts the pointers, does not move the strings
	
	qsort((void *) string_array, (size_t) n_strings, sizeof(si1 *), STR_compare_m13);
	
	return_m13(TRUE_m13);
}


tern  STR_strip_character_m13(si1 *s, si1 character)
{
	si1	*c1, *c2;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	c1 = c2 = s;
	while (*c2) {
		if (*c2 == character) {
			++c2;
			continue;
		}
		*c1++ = *c2++;
	}
	*c1 = 0;
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
const si1	*STR_tern_m13(tern val)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	switch(val) {
		case 1:
			return_m13("true");
		case -1:
			return_m13("false");
		case 0:
			return_m13("not set or unknown");
		default:
			return_m13("invalid");
	}
}


si1	*STR_time_m13(LH_m13 *lh, si8 uutc, si1 *time_str, tern fixed_width, tern relative_days, si4 colored_text, ...)  // time_str buffer sould be of length TIME_STRING_BYTES_m13
{
	si1			*standard_timezone_acronym, *standard_timezone_string, *date_color, *time_color, *color_reset, *meridian;
	const si1  		*mos[12] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
	const si1		*months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
	const si1		*wdays[7] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
	const si1		*mday_num_sufs[32] = { "", "st", "nd", "rd", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", \
						       "th", "th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th", "th", "st" };
	const si1		*weekdays[7] = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };
	tern			offset;
	si4 			microseconds, DST_offset, day_num;
	time_t 			local_time, test_time;
	sf8 			UTC_offset_hours;
	va_list 		arg_p;
	struct tm 		ti;
	LOCATION_INFO_m13	loc_info = {0};
	PROC_GLOBS_m13		*proc_globs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// PASS NULL for level header to use thread-local globals
	
	// if time_str is null, caller is responsible for freeing
	if (time_str == NULL) {
		time_str = (si1 *) malloc_m13((size_t) TIME_STRING_BYTES_m13);
		if (time_str == NULL)
			return_m13(NULL);
	}
	
	proc_globs = G_proc_globs_m13(lh);
	switch (uutc) {
		case UUTC_NO_ENTRY_m13:
			strcpy(time_str, "no entry");
			return_m13(time_str);
		case BEGINNING_OF_TIME_m13:
			strcpy(time_str, "beginning of time");
			return_m13(time_str);
		case END_OF_TIME_m13:
			strcpy(time_str, "end of time");
			return_m13(time_str);
		case CURRENT_TIME_m13:
			uutc = G_current_uutc_m13();
			if (proc_globs->time_constants.set == FALSE_m13)  // set global time constants to location of machine
				if (G_location_info_m13(&loc_info, NULL, NULL, TRUE_m13, FALSE_m13) == FALSE_m13)
					G_warning_message_m13("%s(): daylight change data not available\n", __FUNCTION__);
			break;
	}
	
	if (proc_globs->time_constants.RTO_known == FALSE_m13) {  // FALSE_m13 used to mean unknown and relevant.
		relative_days = offset = TRUE_m13;  // force relative days if using oUTC - nobody needs to know the 1970 date
	} else {  // use UNKNOWN_m13 (0) for cases in which recording time offset is irrelevant (e.g. times not associated with MED files)
		test_time = uutc - proc_globs->time_constants.recording_time_offset;
		if (test_time < 0)  // time is offset
			uutc += proc_globs->time_constants.recording_time_offset;
		offset = FALSE_m13;
	}
	DST_offset = G_DST_offset_m13(uutc);
	
	standard_timezone_acronym = proc_globs->time_constants.standard_timezone_acronym;
	standard_timezone_string = proc_globs->time_constants.standard_timezone_string;
	if (offset == FALSE_m13) {
		if (strncmp_m13(standard_timezone_string, "offset", 6) == 0) {
			standard_timezone_acronym = "UTC";
			standard_timezone_string = "Coordinated Universal Time";
		}
	}
	local_time = (si8) (uutc / (si8) 1000000) + (si8) (proc_globs->time_constants.standard_UTC_offset + DST_offset);
	microseconds = (si4) (uutc % (si8) 1000000);
#if defined MACOS_m13 || defined LINUX_m13
	gmtime_r(&local_time, &ti);
#endif
#ifdef WINDOWS_m13
	ti = *(gmtime(&local_time));
#endif
	ti.tm_year += 1900;
	
	if (colored_text == TRUE_m13) {
		va_start(arg_p, colored_text);
		date_color = va_arg(arg_p, si1 *);
		time_color = va_arg(arg_p, si1 *);
		va_end(arg_p);
		color_reset = TC_RESET_m13;
	} else {
		date_color = time_color = color_reset = "";
	}
	if (relative_days == TRUE_m13) {
		uutc -= proc_globs->time_constants.recording_time_offset;
		day_num = (si4)(uutc / TWENTY_FOURS_HOURS_m13) + 1;
	}
	
	if (fixed_width == TRUE_m13) {
		UTC_offset_hours = (sf8)(DST_offset + proc_globs->time_constants.standard_UTC_offset) / (sf8)3600.0;
		if (relative_days == TRUE_m13)
			sprintf_m13(time_str, "%sDay %04d  %s%02d:%02d:%02d.%06d", date_color, day_num, time_color, ti.tm_hour, ti.tm_min, ti.tm_sec, microseconds);
		else
			sprintf_m13(time_str, "%s%s %02d %s %d  %s%02d:%02d:%02d.%06d", date_color, wdays[ti.tm_wday], ti.tm_mday, mos[ti.tm_mon], ti.tm_year, time_color, ti.tm_hour, ti.tm_min, ti.tm_sec, microseconds);
		if (DST_offset) {
			if (UTC_offset_hours >= 0.0)
				sprintf_m13(time_str, "%s %s (UTC +%0.2lf)%s", time_str, proc_globs->time_constants.daylight_timezone_acronym, UTC_offset_hours, color_reset);
			else
				sprintf_m13(time_str, "%s %s (UTC %0.2lf)%s", time_str, proc_globs->time_constants.daylight_timezone_acronym, UTC_offset_hours, color_reset);
		} else {
			if (offset == TRUE_m13)  // no UTC offset displayed
				sprintf_m13(time_str, "%s %s%s", time_str, standard_timezone_acronym, color_reset);
			else if (UTC_offset_hours >= 0.0)
				sprintf_m13(time_str, "%s %s (UTC +%0.2lf)%s", time_str, standard_timezone_acronym, UTC_offset_hours, color_reset);
			else
				sprintf_m13(time_str, "%s %s (UTC %0.2lf)%s", time_str, standard_timezone_acronym, UTC_offset_hours, color_reset);
		}
	} else {
		ti.tm_sec += ((microseconds + 5e5) / 1e6);  // round to nearest second
		if (ti.tm_hour < 12) {
			meridian = "AM";
			if (ti.tm_hour == 0)
				ti.tm_hour = 12;
		}
		else {
			meridian = "PM";
			if (ti.tm_hour > 12)
				ti.tm_hour -= 12;
		}
		if (relative_days == TRUE_m13)
			sprintf_m13(time_str, "%sDay %04d  %s%d:%02d:%02d %s,", date_color, day_num, time_color, ti.tm_hour, ti.tm_min, ti.tm_sec, meridian);
		else
			sprintf_m13(time_str, "%s%s, %s %d%s, %d  %s%d:%02d:%02d %s,", date_color, weekdays[ti.tm_wday], months[ti.tm_mon], ti.tm_mday, mday_num_sufs[ti.tm_mday], ti.tm_year, time_color, ti.tm_hour, ti.tm_min, ti.tm_sec, meridian);
		if (DST_offset)
			sprintf_m13(time_str, "%s %s%s", time_str, proc_globs->time_constants.daylight_timezone_string, color_reset);
		else
				sprintf_m13(time_str, "%s %s%s", time_str, standard_timezone_string, color_reset);
	}
	
	return_m13(time_str);
}


tern	STR_to_lower_m13(si1 *s)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	--s;
	while (*++s) {
		if (*s > 64 && *s < 91)
			*s += 32;
	}
	
	return_m13(TRUE_m13);
}


tern	STR_to_title_m13(si1 *s)
{
	tern	cap_mode;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// make all lower case
	STR_to_lower_m13(s);
	
	// capitalize first letter regardless of word
	if (*s > 96 && *s < 123)
		*s -= 32;
	
	cap_mode = FALSE_m13;
	while (*++s) {
		if (*s < 97 || *s > 122) {  // not a lower case letter
			if (*s == 32)  // space
				cap_mode = TRUE_m13;
			continue;
		}
		if (cap_mode == TRUE_m13) {
			switch (*s) {  // not exhaustive, but covers most cases
				case 'a':
					if (strncmp_m13(s, "a ", 2) == 0) {
						++s;
						continue;
					}
					if (strncmp_m13(s, "an ", 3) == 0) {
						s += 2;
						continue;
					}
					if (strncmp_m13(s, "and ", 4) == 0) {
						s += 3;
						continue;
					}
					break;
				case 'b':
					if (strncmp_m13(s, "but ", 4) == 0) {
						s += 3;
						continue;
					}
					if (strncmp_m13(s, "by ", 3) == 0) {
						s += 2;
						continue;
					}
					break;
				case 'f':
					if (strncmp_m13(s, "for ", 4) == 0) {
						s += 3;
						continue;
					}
					if (strncmp_m13(s, "from ", 5) == 0) {
						s += 4;
						continue;
					}
					break;
				case 'i':
					if (strncmp_m13(s, "if ", 3) == 0) {
						s += 2;
						continue;
					}
					break;
				case 'o':
					if (strncmp_m13(s, "of ", 3) == 0) {
						s += 2;
						continue;
					}
					break;
				case 't':
					if (strncmp_m13(s, "the ", 4) == 0) {
						s += 3;
						continue;
					}
					if (strncmp_m13(s, "to ", 3) == 0) {
						s += 2;
						continue;
					}
					break;
				case 'w':
					if (strncmp_m13(s, "with ", 5) == 0) {
						s += 4;
						continue;
					}
					if (strncmp_m13(s, "within ", 7) == 0) {
						s += 6;
						continue;
					}
					if (strncmp_m13(s, "without ", 8) == 0) {
						s += 7;
						continue;
					}
					break;
			}
			*s -= 32;
			cap_mode = FALSE_m13;
		}
	}
	
	return_m13(TRUE_m13);
}


tern	STR_to_upper_m13(si1 *s)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	--s;
	while (*++s) {
		if (*s > 96 && *s < 123)
			*s -= 32;
	}
	
	return_m13(TRUE_m13);
}


tern  STR_unescape_chars_m13(si1 *string, si1 target_char)
{
	si1	*c1, *c2, backslash;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	backslash = (si1) 0x5c;
	c1 = c2 = string;
	while (*c1) {
		if (*c1 == backslash) {
			if (*(c1 + 1) == target_char) {
				++c1;
				continue;
			}
		}
		*c2++ = *c1++;
	}
	*c2 = 0;
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si1	*STR_wchar2char_m13(si1 *target, wchar_t *source)
{
	si1	*c, *c2;
	si8	len, wsz;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// if source == target, done in place
	// if not actually ascii, results may be weird
	
	wsz = sizeof(wchar_t);  // 2 or 4 => varies by OS & compiler
	c = target;
	c2 = (si1 *) source - wsz;
	len = wcslen(source);
	
	while (len--)
		*c++ = *(c2 += wsz);  // little endian version
	*c = 0;
	
	return_m13(target);
}



//***********************************//
// MARK: TRANSMISSION FUNCTIONS  (TR)
//***********************************//

TR_INFO_m13	*TR_alloc_trans_info_m13(si8 buffer_bytes, ui4 ID_code, ui1 header_flags, sf4 timeout, si1 *password)
{
	TR_INFO_m13	*trans_info;
	TR_HDR_m13	*header;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// allocate
	trans_info = (TR_INFO_m13 *) calloc_m13((size_t) 1, sizeof(TR_INFO_m13));
	trans_info->buffer_bytes = buffer_bytes;  // bytes available for data
	trans_info->buffer = (ui1 *) calloc_m13((size_t) (buffer_bytes + TR_HDR_BYTES_m13), sizeof(ui1));  // add room for header
	trans_info->data = trans_info->buffer + TR_HDR_BYTES_m13;
	trans_info->mss = TR_INET_MSS_BYTES_m13;  // change to TR_LO_MSS_BYTES_m13 for backplane
	trans_info->sock_fd = -1;
	trans_info->timeout = timeout;
	trans_info->mode = TR_MODE_NONE_m13;
	header = trans_info->header;
	header->flags = header_flags;
	header->ID_code = ID_code;

	// set header defaults
	header->type = TR_TYPE_DEFAULT_m13;
	header->version = TR_VERSION_DEFAULT_m13;
	
	// password / expanded key only required for encrypted transissions
	trans_info->expanded_key_allocated = FALSE_m13;
	if (password) {
		if (*password) {
			trans_info->expanded_key = (ui1 *) malloc_m13((size_t) AES_EXPANDED_KEY_BYTES_m13);
			AES_key_expansion_m13(trans_info->expanded_key, password);
			trans_info->expanded_key_allocated = TRUE_m13;
		}
	}
	
	// create socket (this function also sets timeout)
	TR_create_socket_m13(trans_info);

	return_m13(trans_info);
}


tern	TR_bind_m13(TR_INFO_m13 *trans_info, si1 *iface_addr, ui2 iface_port)
{
	tern		sys_asgn_iface_addr, sys_asgn_iface_port;
	si4			sock_fd;
	si2			sock_fam = AF_INET;  // change to AF_UNSPEC to support IPv4 or IPv6
	NET_PARAMS_m13		np;
	struct sockaddr_in	sock_addr = { 0 };
	socklen_t		si_len;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	sys_asgn_iface_addr = sys_asgn_iface_port = FALSE_m13;
	
	if (iface_addr == TR_IFACE_ANY_m13) {
		*trans_info->iface_addr = 0;
		sys_asgn_iface_addr = TRUE_m13;
	} else if (*iface_addr == 0) {  // TR_IFACE_DFLT_m13
		if (*globals_m13->tables->NET_params.LAN_IPv4_address_string == 0)
			NET_get_lan_ipv4_address_m13(NULL, &globals_m13->tables->NET_params);
		strcpy(trans_info->iface_addr, globals_m13->tables->NET_params.LAN_IPv4_address_string);
	} else if (*iface_addr >= 'A' && *iface_addr <= 'z') {  // user passed interface name, get ip
		NET_get_lan_ipv4_address_m13(NULL, &globals_m13->tables->NET_params);
		if (NET_get_parameters_m13(iface_addr, &np) == NULL) {
			G_warning_message_m13("%s(): cannot get IP address for interface name \"%s\"\n", __FUNCTION__, iface_addr);
			return_m13(FALSE_m13);
		} else {
			strcpy(trans_info->iface_addr, np.LAN_IPv4_address_string);
		}
	} else if (*iface_addr >= '0' && *iface_addr <= '9') {  // user passed ip
		if (trans_info->iface_addr != iface_addr)
			strcpy(trans_info->iface_addr, iface_addr);
	} else {
		G_warning_message_m13("%s(): improper IP address or interface name: \"%s\"\n", __FUNCTION__, iface_addr);
		return_m13(FALSE_m13);
	}
	
	if (iface_port == TR_PORT_ANY_m13)
		sys_asgn_iface_port = TRUE_m13;
	trans_info->iface_port = iface_port;

	if (trans_info->sock_fd <= 0)
		TR_create_socket_m13(trans_info);
	sock_fd = trans_info->sock_fd;

	// set socket to reuse address
	if (TR_set_socket_reuse_address_m13(trans_info, TRUE_m13) == FALSE_m13)
		return_m13(FALSE_m13);

	// set socket info
	si_len = sizeof(struct sockaddr_in);
	sock_addr.sin_family = sock_fam;
	sock_addr.sin_port = htons(trans_info->iface_port);  // set local port (in internet byte order)
	if (sys_asgn_iface_addr == TRUE_m13)
		sock_addr.sin_addr.s_addr = 0;  // htonl(INADDR_ANY)
	else
		inet_pton(sock_fam, trans_info->iface_addr, &sock_addr.sin_addr);  // set local address for bind()

	// bind socket to local interface
	if (bind(sock_fd, (struct sockaddr *) &sock_addr, sizeof(struct sockaddr_in))) {
		G_warning_message_m13("%s(): socket binding error\n", __FUNCTION__);
		#if defined MACOS_m13 || defined LINUX_m13
		close(sock_fd);
		#endif
		#ifdef WINDOWS_m13
		closesocket(sock_fd);
		#endif
		return_m13(FALSE_m13);
	}

	// get system assigned interface values
	if (sys_asgn_iface_addr == TRUE_m13 || sys_asgn_iface_port == TRUE_m13) {
		getsockname(sock_fd, (struct sockaddr *) &sock_addr, &si_len);
		if (sys_asgn_iface_addr == TRUE_m13)
			inet_ntop(sock_fam, &sock_addr.sin_addr, trans_info->iface_addr, si_len);  // usually 0.0.0.0
		if (sys_asgn_iface_port == TRUE_m13)
			trans_info->iface_port = ntohs(sock_addr.sin_port);
	}

	return_m13(TRUE_m13);
}


tern	TR_build_message_m13(TR_MESSAGE_HDR_m13 *msg, si1 *message_text)
{
	si4	encrpyption_blocks;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	msg->time = G_current_uutc_m13();
	encrpyption_blocks = (strlen(message_text) + ENCRYPTION_BLOCK_BYTES_m13) / ENCRYPTION_BLOCK_BYTES_m13;  // include room for terminal zero
	msg->message_bytes = encrpyption_blocks * ENCRYPTION_BLOCK_BYTES_m13;
	strncpy_m13((si1 *) (msg + 1), message_text, msg->message_bytes);  // zero unused bytes
	
	return_m13(TRUE_m13);
}


tern	TR_check_transmission_header_alignment_m13(ui1 *bytes)
{
	TR_HDR_m13	*th;
	tern		free_flag = FALSE_m13;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// check overall size
	if (sizeof(TR_HDR_m13) != TR_HDR_BYTES_m13)
		goto TR_HDR_NOT_ALIGNED_m13;
	
	// check fields
	if (bytes == NULL) {
		bytes = (ui1 *) malloc_m13(TR_HDR_BYTES_m13);
		free_flag = TRUE_m13;
	}
	th = (TR_HDR_m13 *) bytes;
	if (&th->crc != (ui4 *) (bytes + TR_CRC_OFFSET_m13))
		goto TR_HDR_NOT_ALIGNED_m13;
	if (&th->packet_bytes != (ui2 *) (bytes + TR_PACKET_BYTES_OFFSET_m13))
		goto TR_HDR_NOT_ALIGNED_m13;
	if (&th->flags != (ui2 *) (bytes + TR_FLAGS_OFFSET_m13))
		goto TR_HDR_NOT_ALIGNED_m13;
	if (th->ID_string != (si1 *) (bytes + TR_ID_STRING_OFFSET_m13))
		goto TR_HDR_NOT_ALIGNED_m13;
	if (&th->ID_string_terminal_zero != (si1 *) (bytes + TR_ID_STRING_TERMINAL_ZERO_OFFSET_m13))
		goto TR_HDR_NOT_ALIGNED_m13;
	if (&th->ID_code != (ui4 *) (bytes + TR_ID_CODE_OFFSET_m13))
		goto TR_HDR_NOT_ALIGNED_m13;
	if (&th->type != (ui1 *) (bytes + TR_TYPE_OFFSET_m13))
		goto TR_HDR_NOT_ALIGNED_m13;
	if (&th->subtype != (ui1 *) (bytes + TR_SUBTYPE_OFFSET_m13))
		goto TR_HDR_NOT_ALIGNED_m13;
	if (&th->version != (ui1 *) (bytes + TR_VERSION_OFFSET_m13))
		goto TR_HDR_NOT_ALIGNED_m13;
	if (&th->transmission_bytes != (si8 *) (bytes + TR_TRANSMISSION_BYTES_OFFSET_m13))
		goto TR_HDR_NOT_ALIGNED_m13;
	if (&th->offset != (si8 *) (bytes + TR_OFFSET_OFFSET_m13))
		goto TR_HDR_NOT_ALIGNED_m13;

	// aligned
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(TRUE_m13);
	
	// not aligned
TR_HDR_NOT_ALIGNED_m13:
	
	if (free_flag == TRUE_m13)
		free((void *) bytes);
	
	return_m13(FALSE_m13);
}


tern	TR_close_transmission_m13(TR_INFO_m13 *trans_info)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	trans_info->mode = TR_MODE_NONE_m13;  // reset mode
	trans_info->header->flags &= ~TR_FLAGS_CLOSE_m13;  // reset close flag if set
	if (trans_info->sock_fd == -1)
		return_m13(TRUE_m13);

#if defined MACOS_m13 || defined LINUX_m13
	if (trans_info->mode == TR_MODE_FORCE_CLOSE_m13)
		shutdown(trans_info->sock_fd, SHUT_RDWR);
	close(trans_info->sock_fd);
#endif
#ifdef WINDOWS_m13
	if (trans_info->mode == TR_MODE_FORCE_CLOSE_m13)
		shutdown(trans_info->sock_fd, SD_BOTH);
	closesocket(trans_info->sock_fd);
#endif
	
	trans_info->sock_fd = -1;
	
	return_m13(TRUE_m13);
}


tern	TR_connect_m13(TR_INFO_m13 *trans_info, si1 *dest_addr, ui2 dest_port)
{
	tern		blocking, connected;
	si2			sock_fam = AF_INET;  // change to AF_UNSPEC to support IPv4 or IPv6
	si4			sock_fd, err, ret_val, timeout_ms;
	struct sockaddr_in	sock_addr = { 0 };
#if defined MACOS_m13 || defined LINUX_m13
	struct pollfd		fds;
#endif
#ifdef WINDOWS_m13
	WSAPOLLFD		fds;
#endif

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// connect() does not use the socket timeout value
	// this function uses poll() to accomplish that
	// the timeout value is read from the TR_INFO_m13 structure
	
	if (trans_info->sock_fd <= 0)
		TR_create_socket_m13(trans_info);
	sock_fd = trans_info->sock_fd;

	if (*dest_addr >= 'A' && *dest_addr <= 'z') {  // user passed domain, get ip
		if (NET_domain_to_ip_m13(dest_addr, trans_info->dest_addr) == FALSE_m13) {
			G_warning_message_m13("%s(): cannot get IP address for domain \"%s\"\n", __FUNCTION__, dest_addr);
			return_m13(FALSE_m13);
		}
	} else if (*dest_addr >= '0' && *dest_addr <= '9') {  // user passed ip
		if (trans_info->dest_addr != dest_addr)
			strcpy(trans_info->dest_addr, dest_addr);
	} else if (*dest_addr == 0) {  // user passed no destination
		G_warning_message_m13("%s(): no destination address\n", __FUNCTION__);
		return_m13(FALSE_m13);
	} else {
		G_warning_message_m13("%s(): improper IP address or domain: \"%s\"\n", __FUNCTION__, dest_addr);
		return_m13(FALSE_m13);
	}
	trans_info->dest_port = dest_port;
	
	// connect socket to remote interface
	inet_pton(sock_fam, trans_info->dest_addr, &sock_addr.sin_addr); // set remote address for connect()
	sock_addr.sin_port = htons(trans_info->dest_port);  // set local port (in internet byte order)
	sock_addr.sin_family = sock_fam;  // set socket family
	
	// set socket to non-blocking (if not already)
	blocking = TR_set_socket_blocking_m13(trans_info, UNKNOWN_m13);
	if (blocking == TRUE_m13)
		TR_set_socket_blocking_m13(trans_info, FALSE_m13);

	// try to connect
	connected = TRUE_m13;
	errno_reset_m13();
	ret_val = connect(sock_fd, (struct sockaddr *) &sock_addr, sizeof(struct sockaddr_in));
	if (ret_val == -1) {
		err = errno_m13();
		// see if just not connected yet
		if (errno == EINPROGRESS) {
			// wait for socket to be writable, or return after socket timeout
			if (trans_info->timeout > (sf4) 0.0)
				timeout_ms = (si4) (((sf8) trans_info->timeout * (sf8) 1000.0) + (sf8) 0.5);  // timeout in ms
			else
				timeout_ms = 5;  // default to 5 second timeout

			// use poll() because socket fd's often exceed set size limit (1024) of select()
#if defined MACOS_m13 || defined LINUX_m13
			memset((void *) &fds, 0, sizeof(struct pollfd));
#endif
#ifdef WINDOWS_m13
			memset((void *) &fds, 0, sizeof(WSAPOLLFD));
#endif
			fds.fd = sock_fd;
			fds.events = POLLOUT;
			errno_reset_m13();
#if defined MACOS_m13 || defined LINUX_m13
			ret_val = poll(&fds, (nfds_t) 1, timeout_ms);
#endif
#ifdef WINDOWS_m13
			ret_val = WSAPoll(&fds, (ULONG) 1, timeout_ms);
#endif
			if (ret_val == -1) {
				err = errno_m13();
			} else if (ret_val == 0) {
				err = ETIMEDOUT;  // timed out
				ret_val = -1;
			} else if (fds.revents != POLLOUT) {
				err = EACCES;  // socket not writable
				ret_val = -1;
			}
		}
		if (ret_val == -1) {
			connected = FALSE_m13;
			G_warning_message_m13("%s(): socket connect error: #%d: %s\n", __FUNCTION__, err, strerror(err));
			TR_close_transmission_m13(trans_info);
		}
	}

	// reset socket to blocking if necessary
	if (blocking == TRUE_m13)
		TR_set_socket_blocking_m13(trans_info, TRUE_m13);

	return_m13(connected);
}


tern	TR_connect_to_server_m13(TR_INFO_m13 *trans_info, si1 *dest_addr, ui2 dest_port)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// binds to default route interface & then connects

	if (trans_info->sock_fd <= 0)
		TR_create_socket_m13(trans_info);
	
	// bind to default interface, any port
	if (TR_bind_m13(trans_info, TR_IFACE_DFLT_m13, TR_PORT_ANY_m13) == FALSE_m13)
		return_m13(FALSE_m13);

	return_m13(TR_connect_m13(trans_info, dest_addr, dest_port));
}


tern	TR_create_socket_m13(TR_INFO_m13 *trans_info)
{
	si2		sock_fam = AF_INET;
	si4		sock_type, sock_protocol;
	TR_HDR_m13	*header;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (trans_info->sock_fd > 0)
		TR_close_transmission_m13(trans_info);  // don't leave existing socket open
	
	// create socket
	header = trans_info->header;
	if (header->flags & TR_FLAGS_UDP_m13) {
		sock_type = SOCK_DGRAM;
		sock_protocol = IPPROTO_UDP;
	} else {  // TCP
		sock_type = SOCK_STREAM;
		sock_protocol = IPPROTO_TCP;
	}
	if ((trans_info->sock_fd = socket(sock_fam, sock_type, sock_protocol)) == -1) {
		G_warning_message_m13("%s(): socket creation error\n", __FUNCTION__);
		return_m13(FALSE_m13);
	}

	// set socket timeout
	if (trans_info->timeout > (sf4) 0.0)
		TR_set_socket_timeout_m13(trans_info);
			
	return_m13(TRUE_m13);
}


tern	TR_free_transmission_info_m13(TR_INFO_m13 **trans_info_ptr)
{
	TR_INFO_m13 	*trans_info;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns FALSE_m13 if trans_info not freed
	
	if (trans_info_ptr == NULL)
		return_m13(FALSE_m13);
	trans_info = *trans_info_ptr;
	if (trans_info == NULL)
		return_m13(FALSE_m13);
	
	if (trans_info->sock_fd != -1)
		TR_close_transmission_m13(trans_info);

	if (trans_info->buffer)
		free_m13((void *) trans_info->buffer);
	
	if (trans_info->expanded_key_allocated == TRUE_m13)  // don't free password itself - passed by caller
		free_m13((void *) trans_info->expanded_key);
		
	if (freeable_m13((void *) trans_info) == TRUE_m13)
		free_m13((void *) trans_info);
	
	if (freeable_m13((void *) trans_info) == TRUE_m13)
		free_m13((void *) trans_info);
	
	*trans_info_ptr = NULL;
	
	return_m13(TRUE_m13);
}


tern	TR_realloc_trans_info_m13(TR_INFO_m13 *trans_info, si8 buffer_bytes, TR_HDR_m13 **caller_header)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (buffer_bytes > trans_info->buffer_bytes) {
		trans_info->buffer = (ui1 *) realloc_m13((void *) trans_info->buffer, (size_t) (buffer_bytes + TR_HDR_BYTES_m13));
		trans_info->buffer_bytes = buffer_bytes;
		trans_info->data = trans_info->buffer + TR_HDR_BYTES_m13;
		if (caller_header)
			*caller_header = trans_info->header;
	}

	return_m13(TRUE_m13);
}


si8	TR_recv_transmission_m13(TR_INFO_m13 *trans_info, TR_HDR_m13 **caller_header)
{
	tern		password_passed, acknowledge;
	ui1		*buffer, *partial_pkt;
	si1		pw_bytes[PASSWORD_BYTES_m13];
	ui2		max_pkt_bytes;
	ui4		ID_code;
	si4		sock_fd, attempts, err;
	sf4		curr_timeout;
	si8		data_bytes, data_bytes_received, ret_val, packet_bytes_remaining;
	TR_HDR_m13	*header, *pkt_header, *ack_header, saved_data;
	TR_INFO_m13	*ack_trans_info;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (trans_info == NULL) {
		G_warning_message_m13("%s(): transmission info is NULL\n", __FUNCTION__);
		return_m13((si8) FALSE_m13);
	}
	trans_info->mode = TR_MODE_NONE_m13;
	if (trans_info->sock_fd == -1) {  // try to reopen socket
		if (TR_create_socket_m13(trans_info) == FALSE_m13)
			return_m13((si8) FALSE_m13);
		if (TR_bind_m13(trans_info, trans_info->iface_addr, TR_PORT_ANY_m13) == FALSE_m13)
			return_m13((si8) FALSE_m13);
		if (TR_connect_m13(trans_info, trans_info->dest_addr, trans_info->dest_port) == FALSE_m13)
			return_m13((si8) FALSE_m13);
	}
	buffer = trans_info->buffer;
	header = trans_info->header;
	sock_fd = trans_info->sock_fd;
	ID_code = header->ID_code;
	max_pkt_bytes = trans_info->mss + TR_HDR_BYTES_m13;
	
	// receive
	attempts = 0;
	data_bytes_received = 0;
	acknowledge = UNKNOWN_m13;
	do {
		pkt_header = (TR_HDR_m13 *) (buffer + data_bytes_received);
		if (data_bytes_received)
			saved_data = *pkt_header;
			
		// recv
		errno_reset_m13();
		ret_val = recv(sock_fd, (void *) pkt_header, max_pkt_bytes, 0);
				
		// receive checks
		if (ret_val < TR_HDR_BYTES_m13 && data_bytes_received == 0) {
			if (ret_val == 0) {
				data_bytes_received = TR_E_SOCK_CLOSED_m13;
				G_warning_message_m13("%s(%s:%hu <- %s:%hu): %s\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, TR_strerror_m13(data_bytes_received));
			} else if (ret_val < 0) {
				err = errno_m13();
				if (TR_set_socket_blocking_m13(trans_info, UNKNOWN_m13) == FALSE_m13)
					if (err == EAGAIN || err == EWOULDBLOCK)  // no data available on non-blocking socket (on most OS implementations these are the same number)
						return_m13(TR_E_DATA_m13);
				if (err == ETIMEDOUT) {  // timeout
					data_bytes_received = TR_E_SOCK_TIMED_OUT_m13;
					G_warning_message_m13("%s(%s:%hu <- %s:%hu): %s\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, TR_strerror_m13(data_bytes_received));
				} else {
					data_bytes_received = TR_E_SOCK_FAILED_m13;
					G_warning_message_m13("%s(%s:%hu <- %s:%hu): %s (sock errno %d)\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, TR_strerror_m13(data_bytes_received), err);
				}
			} else {
				data_bytes_received = TR_E_UNKN_m13;
				G_warning_message_m13("%s(%s:%hu <- %s:%hu): receive too small for header (%ld bytes)\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, ret_val);
			}
			goto TR_RECV_FAIL_m13;
		}

		// check ID code
		if (pkt_header->ID_code != ID_code) {
			data_bytes_received = TR_E_ID_m13;
			goto TR_RECV_FAIL_m13;
		}
				
		// keep alive
		if (pkt_header->packet_bytes == TR_HDR_BYTES_m13)
			if (pkt_header->type == TR_TYPE_KEEP_ALIVE_m13)
				break;

		// sender requested acknowledgment
		if (acknowledge == UNKNOWN_m13) {
			acknowledge = FALSE_m13;
			if (header->flags & TR_FLAGS_UDP_m13) {  // TCP has built in acknowledgment
				if (header->flags & TR_FLAGS_ACKNOWLEDGE_m13) {
					acknowledge = TRUE_m13;
					ack_trans_info = (TR_INFO_m13 *) calloc((size_t) 1, sizeof(TR_INFO_m13));
					ack_header = ack_trans_info->header;
					ack_header->ID_code = ID_code;
					ack_header->type = TR_TYPE_ACK_OK_m13;
					ack_trans_info->sock_fd = sock_fd;
				}
			}
		}

		if (ret_val < (si8) pkt_header->packet_bytes) {
			// first try to receive rest of packet (shouldn't happen often: inet mss chosen to avoid this)
			partial_pkt = (ui1 *) pkt_header;
			packet_bytes_remaining = (si8) pkt_header->packet_bytes - ret_val;
			curr_timeout = trans_info->timeout;
			trans_info->timeout = (sf4) 2.0;  // wait no more than 2 seconds for subsequent sends
			TR_set_socket_timeout_m13(trans_info);
			attempts = 0; do {
				partial_pkt += ret_val;
				ret_val = recv(sock_fd, (void *) partial_pkt, max_pkt_bytes, 0);
				if (ret_val <= 0)
					break;
				packet_bytes_remaining -= ret_val;
			} while (packet_bytes_remaining > 0 && attempts++ < 3);
			trans_info->timeout = curr_timeout;  // reset timeout
			TR_set_socket_timeout_m13(trans_info);

			// couldn't get full packet
			if (packet_bytes_remaining > 0) {
				if (acknowledge == TRUE_m13) {
					if (attempts++ < TR_RETRANSMIT_ATTEMPTS_m13) {
						ack_header->flags = TR_TYPE_ACK_RETRANSMIT_m13;
						TR_send_transmission_m13(ack_trans_info);
						data_bytes_received = 0;
						continue;
					}
				}
				data_bytes_received = TR_E_TRANS_FAILED_m13;
				G_warning_message_m13("%s(%s:%hu <- %s:%hu): packet size error\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port);
				goto TR_RECV_FAIL_m13;
			}
		}
		
		// CRC
		if (pkt_header->flags & TR_FLAGS_CRC_m13) {
			if (CRC_validate_m13((ui1 *) pkt_header + CRC_BYTES_m13, pkt_header->packet_bytes - CRC_BYTES_m13, pkt_header->crc) == FALSE_m13) {
				if (acknowledge == TRUE_m13) {
					if (attempts++ < TR_RETRANSMIT_ATTEMPTS_m13) {
						ack_header->type = TR_TYPE_ACK_RETRANSMIT_m13;
						TR_send_transmission_m13(ack_trans_info);
						continue;
					}
				}
				data_bytes_received = TR_E_CRC_m13;
				G_warning_message_m13("%s(%s:%hu <- %s:%hu): %s\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, TR_strerror_m13(data_bytes_received));
				goto TR_RECV_FAIL_m13;
			}
		}
		
		if (acknowledge == TRUE_m13)
			TR_send_transmission_m13(ack_trans_info);
		
		// realloc
		if (pkt_header->transmission_bytes > trans_info->buffer_bytes)
			TR_realloc_trans_info_m13(trans_info, pkt_header->transmission_bytes, &header);
		
		// move data into place
		data_bytes = (si8) (pkt_header->packet_bytes - (ui2) TR_HDR_BYTES_m13);
		if (data_bytes_received)
			*pkt_header = saved_data;

		// update
		data_bytes_received += data_bytes;
		attempts = 0;  // reset counter
		
	} while (data_bytes_received < pkt_header->transmission_bytes);
	
	// get key
	if (pkt_header->flags & TR_FLAGS_INCLUDE_KEY_m13) {
		if (trans_info->expanded_key == NULL) {
			trans_info->expanded_key = malloc_m13(ENCRYPTION_KEY_BYTES_m13);
			trans_info->expanded_key_allocated = TRUE_m13;
		}
		pkt_header->transmission_bytes -= ENCRYPTION_KEY_BYTES_m13;
		data_bytes_received -= ENCRYPTION_KEY_BYTES_m13;
		memcpy((void *) trans_info->expanded_key, (void *) (trans_info->data + pkt_header->transmission_bytes), (size_t) ENCRYPTION_KEY_BYTES_m13);
		AES_partial_decrypt_m13(ENCRYPTION_KEY_BYTES_m13, trans_info->expanded_key, NULL);
	}

	// decrypt
	if (pkt_header->flags & TR_FLAGS_ENCRYPT_m13) {
		if (trans_info->expanded_key == NULL) {
			G_push_behavior_m13(SUPPRESS_OUTPUT_m13);
			password_passed = G_condition_password_m13(trans_info->password, pw_bytes, TRUE_m13);  // use expanded password
			G_pop_behavior_m13();
			if (password_passed == FALSE_m13) {
				G_warning_message_m13("%s(): no password or expanded key => cannot decrypt transmission\n", __FUNCTION__);
				return_m13(TR_E_UNKN_m13);
			}
			trans_info->expanded_key = (ui1 *) malloc_m13((size_t) ENCRYPTION_KEY_BYTES_m13);
			trans_info->expanded_key_allocated = TRUE_m13;
			AES_key_expansion_m13(trans_info->expanded_key, pw_bytes);
		}
		AES_decrypt_m13(trans_info->data, data_bytes_received, NULL, trans_info->expanded_key, 1);
	}
	
	trans_info->mode = TR_MODE_RECV_m13;

TR_RECV_FAIL_m13:
	
	// update & clean header
	*header = *pkt_header;
	header->crc = 0;
	header->packet_bytes = 0;
	header->offset = 0;

	// reset encryption flags
	header->flags &= ~(TR_FLAGS_ENCRYPT_m13 | TR_FLAGS_INCLUDE_KEY_m13);
	
	// close on request or error
	if (data_bytes_received < 0 || header->flags & TR_FLAGS_CLOSE_m13)
		TR_close_transmission_m13(trans_info);
	
	// clean up
	if (acknowledge == TRUE_m13)
		free((void *) ack_trans_info);
	
	return_m13(data_bytes_received);
}


tern	TR_send_message_m13(TR_INFO_m13 *trans_info, ui1 type, tern encrypt, si1 *fmt, ...)
{
	si1			*message_text;
	si8			bytes_sent;
	va_list 		v_args;
	TR_HDR_m13		*header;
	TR_MESSAGE_HDR_m13	*msg;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	switch (type) {
		case TR_ERROR_TYPE_m13:
		case TR_WARNING_TYPE_m13:
		case TR_SUCCESS_TYPE_m13:
		case TR_MESSAGE_TYPE_m13:
			break;
		default:
			G_warning_message_m13("%s(): unrecognized message type\n", __FUNCTION__);
			return_m13(FALSE_m13);
	}

	header = trans_info->header;
	msg = (TR_MESSAGE_HDR_m13 *) (header + 1);
	message_text = (si1 *) (msg + 1);
	va_start(v_args, fmt);
	vsprintf_m13(message_text, fmt, v_args);
	va_end(v_args);
	TR_build_message_m13(msg, message_text);

	header->type = type;
	if (type == TR_ERROR_TYPE_m13)
		header->flags |= TR_FLAGS_CLOSE_m13;
	if (encrypt == TRUE_m13)
		header->flags |= TR_FLAGS_ENCRYPT_m13;
	header->transmission_bytes = TR_MESSAGE_HDR_BYTES_m13 + msg->message_bytes;
	
	bytes_sent = TR_send_transmission_m13(trans_info);
	header = trans_info->header;
	if (bytes_sent != header->transmission_bytes)
		return_m13(FALSE_m13);

	return_m13(TRUE_m13);
}


si8	TR_send_transmission_m13(TR_INFO_m13 *trans_info)  // expanded_key can be NULL if not encypting
{
	tern	password_passed, acknowledge, no_destruct_flag;
	ui1		*buffer, *data;
	si1		pw_bytes[PASSWORD_BYTES_m13];
	ui2		data_bytes, packet_bytes;
	ui4		ID_code;
	si4		sock_fd, attempts, err;
	si8		ret_val, data_bytes_sent, data_bytes_remaining, bytes_received, actual_data_bytes;
	TR_HDR_m13	*header, *pkt_header, *ack_header, saved_data;
	TR_INFO_m13	*ack_trans_info;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (trans_info == NULL) {
		G_warning_message_m13("%s(): transmission info is NULL\n", __FUNCTION__);
		return_m13((si8) FALSE_m13);
	}
	trans_info->mode = TR_MODE_NONE_m13;
	if (trans_info->sock_fd == -1) {  // try to reopen socket
		if (TR_create_socket_m13(trans_info) == FALSE_m13)
			return_m13((si8) FALSE_m13);
		if (TR_bind_m13(trans_info, trans_info->iface_addr, TR_PORT_ANY_m13) == FALSE_m13)
			return_m13((si8) FALSE_m13);
		if (TR_connect_m13(trans_info, trans_info->dest_addr, trans_info->dest_port) == FALSE_m13)
			return_m13((si8) FALSE_m13);
	}
	header = trans_info->header;
	ID_code = header->ID_code;
	buffer = trans_info->buffer;
	data = trans_info->data;
	sock_fd = trans_info->sock_fd;
	
	if (header->transmission_bytes > trans_info->buffer_bytes) {
		G_warning_message_m13("%s(): buffer too small for transmission\n", __FUNCTION__);
		return_m13(TR_E_UNKN_m13);
	}
	
	// encryption
	if (header->flags & TR_FLAGS_ENCRYPT_m13) {
		if (trans_info->expanded_key == NULL) {
			G_push_behavior_m13(SUPPRESS_OUTPUT_m13);
			password_passed = G_condition_password_m13(trans_info->password, pw_bytes, TRUE_m13);  // expand password
			G_pop_behavior_m13();
			if (password_passed == FALSE_m13) {
				G_warning_message_m13("%s(): no password or expanded key => cannot encrypt transmission\n", __FUNCTION__);
				return_m13(TR_E_UNKN_m13);
			}
			trans_info->expanded_key = (ui1 *) malloc_m13((size_t) ENCRYPTION_KEY_BYTES_m13);
			trans_info->expanded_key_allocated = TRUE_m13;
			AES_key_expansion_m13(trans_info->expanded_key, pw_bytes);
		}
	}
	
	// no destruct flag - send side only
	no_destruct_flag = FALSE_m13;
	if (header->flags & TR_FLAGS_NO_DESTRUCT_m13) {
		no_destruct_flag = TRUE_m13;
		header->flags &= ~TR_FLAGS_NO_DESTRUCT_m13; // reset before transmission so receiver doesn't use it on subsequent send
	}
	
	// include key
	actual_data_bytes = header->transmission_bytes;  // save this value for encryption
	if (header->flags & TR_FLAGS_INCLUDE_KEY_m13) {
		TR_realloc_trans_info_m13(trans_info, header->transmission_bytes + ENCRYPTION_KEY_BYTES_m13, &header);
		memcpy((void *) (trans_info->data + header->transmission_bytes), (void *) trans_info->expanded_key, (size_t) ENCRYPTION_KEY_BYTES_m13);
		AES_partial_encrypt_m13(ENCRYPTION_KEY_BYTES_m13, trans_info->data + header->transmission_bytes, NULL);
		header->transmission_bytes += ENCRYPTION_KEY_BYTES_m13;
	}
	
	// encrypt
	if (header->flags & TR_FLAGS_ENCRYPT_m13)
		AES_encrypt_m13(data, actual_data_bytes, NULL, trans_info->expanded_key, 1);
	
	// acknowledge
	acknowledge = FALSE_m13;
	if (header->flags & TR_FLAGS_UDP_m13)  // TCP has built in acknowledgment
		if (header->flags & TR_FLAGS_ACKNOWLEDGE_m13)
			acknowledge = TRUE_m13;
	if (acknowledge == TRUE_m13) {
		ack_trans_info = (TR_INFO_m13 *) calloc((size_t) 1, sizeof(TR_INFO_m13));
		ack_header = ack_trans_info->header;
		ack_header->ID_code = header->ID_code;
		ack_trans_info->sock_fd = sock_fd;
		ack_trans_info->timeout = (sf4) 2.0;  // wait 2 seconds for acknowledgment
	}
		
	// transmit
	data_bytes_sent = 0;
	data_bytes_remaining = header->transmission_bytes;
	do {
		if (data_bytes_remaining > trans_info->mss)  // this is set so 8 byte alignment will be maintained
			data_bytes = trans_info->mss;
		else
			data_bytes = (ui2) data_bytes_remaining;
		packet_bytes = data_bytes + (ui2) TR_HDR_BYTES_m13;

		// set packet header
		pkt_header = (TR_HDR_m13 *) (buffer + data_bytes_sent);
		if (data_bytes_sent) {
			if (no_destruct_flag == TRUE_m13)  // preserve data in header region
				saved_data = *pkt_header;
			*pkt_header = *header;
		}
		pkt_header->packet_bytes = packet_bytes;
		pkt_header->offset = data_bytes_sent;
		
		// calculate CRC (does not include crc field of header)
		if (pkt_header->flags & TR_FLAGS_CRC_m13)
			header->crc = CRC_calculate_m13(buffer + CRC_BYTES_m13, packet_bytes - CRC_BYTES_m13);
		
		// send
	TR_SEND_RETRANSMIT_m13:
		errno_reset_m13();
		ret_val = send(sock_fd, (void *) pkt_header, packet_bytes, 0);
		if (ret_val <= 0) {
			if (ret_val == 0) {
				data_bytes_sent = TR_E_SOCK_CLOSED_m13;
				G_warning_message_m13("%s(%s:%hu -> %s:%hu): %s\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, TR_strerror_m13(data_bytes_sent));
			} else {
				data_bytes_sent = TR_E_SOCK_FAILED_m13;
				err = errno_m13();
				G_warning_message_m13("%s(%s:%hu -> %s:%hu): %s (sock errno %d)\n", __FUNCTION__, trans_info->iface_addr, trans_info->iface_port, trans_info->dest_addr, trans_info->dest_port, TR_strerror_m13(data_bytes_sent), err);
			}
			header->flags |= TR_FLAGS_CLOSE_m13;
			goto TR_SEND_FAIL_m13;
		}
		if (ret_val != (si8) packet_bytes) {
			G_warning_message_m13("%s(): packet size error\n", __FUNCTION__);
			header->flags |= TR_FLAGS_CLOSE_m13;
			data_bytes_sent = TR_E_TRANS_FAILED_m13;
			goto TR_SEND_FAIL_m13;
		}

		// acknowledge
		if (acknowledge == TRUE_m13) {
			TR_set_socket_timeout_m13(ack_trans_info);
			attempts = 0; do {
				bytes_received = TR_recv_transmission_m13(ack_trans_info, NULL);
				if (bytes_received != 0)
					continue;
				if (pkt_header->ID_code != ID_code)  // check ID code
					continue;
				if (ack_header->type == TR_TYPE_ACK_RETRANSMIT_m13)
					goto TR_SEND_RETRANSMIT_m13;
			} while (header->type != TR_TYPE_ACK_OK_m13 && attempts++ < TR_RETRANSMIT_ATTEMPTS_m13);
			TR_set_socket_timeout_m13(trans_info);  // reset timeout

			if (ack_header->type != TR_TYPE_ACK_OK_m13) {
				data_bytes_sent = TR_E_ACK_m13;
				G_warning_message_m13("%s(): %s\n", __FUNCTION__, TR_strerror_m13(data_bytes_sent));
				header->flags |= TR_FLAGS_CLOSE_m13;
				goto TR_SEND_FAIL_m13;
			}
		}
		
		// restore data in header region
		if (no_destruct_flag == TRUE_m13)
			if (data_bytes_sent)
				*pkt_header = saved_data;
				
		data_bytes_sent += (si8) data_bytes;
		data_bytes_remaining -= (si8) data_bytes;
		
	} while (data_bytes_remaining);
	
	trans_info->mode = TR_MODE_SEND_m13;
	
TR_SEND_FAIL_m13:
	
	// clean up header
	header->crc = 0;
	header->packet_bytes = 0;
	header->offset = 0;

	// decrypt for non destructive mode
	// note: faster to copy & substitute buffer than decrypt after transmitting, but may cause memory issue for large transmissions & this mode is rarely necessary)
	if (header->flags & TR_FLAGS_ENCRYPT_m13) {
		if (no_destruct_flag == TRUE_m13)
			AES_decrypt_m13(data, actual_data_bytes, NULL, trans_info->expanded_key, 1);
		// reset encryption flags
		header->flags &= ~(TR_FLAGS_ENCRYPT_m13 | TR_FLAGS_INCLUDE_KEY_m13);
	}
	
	// close
	if (header->flags & TR_FLAGS_CLOSE_m13)
		TR_close_transmission_m13(trans_info);
	
	// clean up
	if (acknowledge == TRUE_m13)
		free((void *) ack_trans_info);
	
	return_m13(data_bytes_sent);
}


tern	TR_set_socket_blocking_m13(TR_INFO_m13 *trans_info, tern set)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

#if defined MACOS_m13 || defined LINUX_m13
	tern	current_state;
	si4	socket_flags;

	socket_flags = fcntl(trans_info->sock_fd, F_GETFL, 0);  // get existing flags
	if (socket_flags == -1)
		return_m13(UNKNOWN_m13);
	
	current_state = (socket_flags & O_NONBLOCK) ? FALSE_m13 : TRUE_m13;
	if (current_state == set || set == UNKNOWN_m13)
		return_m13(current_state);

	// set socket to blocking
	if (set == TRUE_m13) {
		socket_flags &= ~O_NONBLOCK;
		if (fcntl(trans_info->sock_fd, F_SETFL, socket_flags) == -1) {
			G_warning_message_m13("%s(): could not set socket to blocking\n", __FUNCTION__);
			set = UNKNOWN_m13;
		}
	}

	// set socket to non-blocking
	else {
		socket_flags |= O_NONBLOCK;
		if (fcntl(trans_info->sock_fd, F_SETFL, socket_flags) == -1) {
			G_warning_message_m13("%s(): could not set socket to non-blocking\n", __FUNCTION__);
			set = UNKNOWN_m13;
		}
	}
#endif
	
#ifdef WINDOWS_m13
	ui4	enable;
	si4	err;
	
	
	// set socket to blocking
	if (set == TRUE_m13) {
		enable = 1;
		err = ioctlsocket(trans_info->sock_fd, FIONBIO, &enable);
		if (err != NO_ERROR) {
			G_warning_message_m13("%s(): could not set socket to blocking\n", __FUNCTION__);
			set = UNKNOWN_m13;
		}
	}

	// set socket to non-blocking
	else if (set == FALSE_m13) {
		enable = 0;
		err = ioctlsocket(trans_info->sock_fd, FIONBIO, &enable);
		if (err != NO_ERROR) {
			G_warning_message_m13("%s(): could not set socket to non-blocking\n", __FUNCTION__);
			set = UNKNOWN_m13;
		}
	}
	
	// blocking == UNKNOWN_m13 => just return current state
	else {
		enable = 1;  // set to blocking
		err = ioctlsocket(trans_info->sock_fd, FIONBIO, &enable);  // apparently this will fail if already set to blocking, with error code WSAEOPNOTSUPP
		
		if (err == NO_ERROR) {  // reset to non-blocking
			enable = 0;
			ioctlsocket(trans_info->sock_fd, FIONBIO, &enable);
			set = FALSE_m13;
		} else if (WSAGetLastError() == WSAEOPNOTSUPP) {
			set = TRUE_m13;
		}
	}
#endif

	return_m13(set);
}


tern	TR_set_socket_broadcast_m13(TR_INFO_m13 *trans_info, tern set)
{
#if defined MACOS_m13 || defined LINUX_m13
	si4	flags;
#endif
#ifdef WINDOWS_m13
	si1	flags;
#endif
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// set socket reuse address option
	// pass TRUE_m13 to set, FALSE_m13 to unset
	
	if (set == TRUE_m13)
		flags = 1;
	else
		flags = 0;
	if (setsockopt(trans_info->sock_fd, SOL_SOCKET, SO_BROADCAST, &flags, sizeof(flags)) == -1) {
		G_warning_message_m13("%s(): socket option error\n", __FUNCTION__);
		return_m13(FALSE_m13);
	}
	
	return_m13(TRUE_m13);
}


tern	TR_set_socket_reuse_address_m13(TR_INFO_m13 *trans_info, tern set)
{
#if defined MACOS_m13 || defined LINUX_m13
	si4	flags;
#endif
#ifdef WINDOWS_m13
	si1	flags;
#endif
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// set socket reuse address option
	// pass TRUE_m13 to set, FALSE_m13 to unset
	
	if (set == TRUE_m13)
		flags = 1;
	else
		flags = 0;
	if (setsockopt(trans_info->sock_fd, SOL_SOCKET, SO_REUSEADDR, &flags, sizeof(flags)) == -1) {
		G_warning_message_m13("%s(): socket option error\n", __FUNCTION__);
		return_m13(FALSE_m13);
	}
	
	return_m13(TRUE_m13);
}


tern	TR_set_socket_reuse_port_m13(TR_INFO_m13 *trans_info, tern set)
{
#if defined MACOS_m13 || defined LINUX_m13
	si4	flags;
#endif
#ifdef WINDOWS_m13
	si1	flags;
#endif
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// set socket reuse port option
	// pass TRUE_m13 to set, FALSE_m13 to unset

#ifdef SO_REUSEPORT
	// Notes:
	//	SO_REUSEPORT available on Linux since version 3.9
	//	Permits multiple AF_INET or AF_INET6 sockets to be bound to an
	//	identical socket address.  This option must be set on each
	//	socket (including the first socket) prior to calling bind(2)
	//	on the socket.  To prevent port hijacking, all of the
	//	processes binding to the same address must have the same
	//	effective UID.  This option can be employed with both TCP and
	//	UDP sockets.

	if (set == TRUE_m13)
		flags = 1;
	else
		flags = 0;
	if (setsockopt(trans_info->sock_fd, SOL_SOCKET, SO_REUSEPORT, &flags, sizeof(flags)) == -1) {
		G_warning_message_m13("%s(): socket option error\n", __FUNCTION__);
		return_m13(FALSE_m13);
	}
	
	return_m13(TRUE_m13);
#else
	return_m13(UNKNOWN_m13);
#endif
}


tern	TR_set_socket_timeout_m13(TR_INFO_m13 *trans_info)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

#if defined MACOS_m13 || defined LINUX_m13
	struct timeval	tv;
	
	tv.tv_sec = (time_t) trans_info->timeout;
	tv.tv_usec = (time_t) ((((sf8) trans_info->timeout - (sf8) tv.tv_sec) * (sf8) 1e6) + (sf8) 0.5);
	setsockopt(trans_info->sock_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(struct timeval));
#endif
#ifdef WINDOWS_m13
	si1	timeout_str[16];
	si8 	len, timeout_ms;
	
	timeout_ms = (si8) (((sf8) trans_info->timeout * (sf8) 1000.0) + (sf8) 0.5);
	len = sprintf_m13(timeout_str, "%ld", timeout_ms) + 1;  // leave room for terminal zero
	setsockopt(trans_info->sock_fd, SOL_SOCKET, SO_RCVTIMEO, timeout_str, len);
#endif
	return_m13(TRUE_m13);
}


tern	TR_show_message_m13(TR_HDR_m13 *header)
{
	ui1			type;
	si1			*msg;
	TR_MESSAGE_HDR_m13	*msg_header;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif


	type = header->type;
	
	switch (type) {
		case TR_TYPE_OPERATION_SUCCEEDED_m13:
			G_message_m13("operation succeeded\n");
			return_m13(TRUE_m13);
		case TR_TYPE_OPERATION_FAILED_m13:
			G_warning_message_m13("operation failed\n", __FUNCTION__);
			return_m13(TRUE_m13);
		case TR_TYPE_OPERATION_SUCCEEDED_WITH_MESSAGE_m13:
		case TR_TYPE_MESSAGE_m13:
		case TR_TYPE_OPERATION_FAILED_WITH_WARNING_MESSAGE_m13:
		case TR_TYPE_OPERATION_FAILED_WITH_ERROR_MESSAGE_m13:
			msg_header = (TR_MESSAGE_HDR_m13 *) (header + 1);
			msg = (si1 *) (msg_header + 1);
			break;
		default:
			return_m13(FALSE_m13);
	}

	switch (type) {
		case TR_TYPE_OPERATION_SUCCEEDED_WITH_MESSAGE_m13:
		case TR_TYPE_MESSAGE_m13:
			G_message_m13("%s", msg);
			return_m13(TRUE_m13);
		case TR_TYPE_OPERATION_FAILED_WITH_WARNING_MESSAGE_m13:
			G_warning_message_m13("%s", msg);
			return_m13(TRUE_m13);
		case TR_TYPE_OPERATION_FAILED_WITH_ERROR_MESSAGE_m13:
			G_set_error_m13(E_UNKN_m13, "%s", msg);
			return_m13(TRUE_m13);
	}
	
	return_m13(FALSE_m13);  // never gets here - just to shut compiler up
}


tern	TR_show_transmission_m13(TR_INFO_m13 *trans_info)
{
	tern			blocking;
	si1			hex_str[HEX_STR_BYTES_m13(sizeof(ui4), 0)];
	TR_HDR_m13		*header;
		
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif


	// transmission info
	printf_m13("-------------- Transmission Info - START ------------\n");
	if (trans_info->buffer == NULL)
		printf_m13("Buffer: NULL\n");
	else
		printf_m13("Buffer: allocated\n");
	printf_m13("Buffer Bytes: %ld\n", trans_info->buffer_bytes);
	if (trans_info->data == trans_info->buffer + TR_HDR_BYTES_m13)
		printf_m13("Data: set\n");
	else
		printf_m13("Data: not set\n");
	if (trans_info->password == NULL)
		printf_m13("Password: NULL\n");
	else if (*trans_info->password == 0)
		printf_m13("Password: empty\n");
	else
		printf_m13("Password: %s\n", trans_info->password);
	if (trans_info->expanded_key == NULL)
		printf_m13("Expanded Key: NULL\n");
	else
		printf_m13("Expanded Key: set\n");
	if (trans_info->expanded_key_allocated == TRUE_m13)
		printf_m13("Expanded Key Allocated: true\n");
	if (trans_info->expanded_key_allocated == FALSE_m13)
		printf_m13("Expanded Key Allocated: false\n");
	else
		printf_m13("Expanded Key Allocated: not set\n");
	if (trans_info->mode == TR_MODE_SEND_m13)
		printf_m13("Mode: send\n");
	else if (trans_info->mode == TR_MODE_RECV_m13)
		printf_m13("Mode: receive\n");
	else if (trans_info->mode == TR_MODE_NONE_m13)
		printf_m13("Mode: not set\n");
	else if (trans_info->mode == TR_MODE_FORCE_CLOSE_m13)
		printf_m13("Mode: force close\n");
	else
		printf_m13("Mode: invalid value (%hhu)\n", trans_info->mode);
	printf_m13("Socket File Descriptor: %d\n", trans_info->sock_fd);
	if (*trans_info->dest_addr == 0)
		printf_m13("Destination Address: any\n");
	else
		printf_m13("Destination Address: %s\n", trans_info->dest_addr);
	if (trans_info->dest_port == 0)
		printf_m13("Destination Port: any\n");
	else
		printf_m13("Destination Port: %hu\n", trans_info->dest_port);
	if (*trans_info->iface_addr == 0)
		printf_m13("Interface Address: any\n");
	else
		printf_m13("Interface Address: %s\n", trans_info->iface_addr);
	if (trans_info->iface_port == 0)
		printf_m13("Interface Port: any\n");
	else
		printf_m13("Interface Port: %hu\n", trans_info->iface_port);
	if (trans_info->timeout == (sf4) 0.0)
		printf_m13("Timeout (seconds): never\n");
	else
		printf_m13("Timeout (seconds): %0.2f\n", trans_info->timeout);
	if (trans_info->mss == 0)
		printf_m13("Maximum Segment Size (bytes): not set\n");
	else
		printf_m13("Maximum Segment Size (bytes): %hu\n", trans_info->mss);
	printf_m13("--------------- Transmission Info - END -------------\n");
	
	// header
	printf_m13("-------------- Transmission Header - START ------------\n");
	header = trans_info->header;
	if (header == NULL) {
		printf_m13("Header not set\n--------------- Transmission Header - END -------------\n");
		return_m13(TRUE_m13);
	}
	if (header->crc == CRC_NO_ENTRY_m13) {
		printf_m13("CRC: no entry\n");
	} else {
		STR_hex_m13(hex_str, (ui1 *) &header->crc, sizeof(ui4), NULL, TRUE_m13);
		printf_m13("CRC: 0x%s\n", hex_str);
	}
	printf_m13("Packet Bytes: %hu\n", header->packet_bytes);
	printf_m13("Flags (%hu): ", header->flags);
	if (header->flags & TR_FLAGS_BIG_ENDIAN_m13)
		printf_m13("BIG_ENDIAN");
	else
		printf_m13("LITTLE_ENDIAN");
	if (header->flags & TR_FLAGS_UDP_m13)
		printf_m13(", UDP");
	else
		printf_m13(", TCP");
	if (header->flags & TR_FLAGS_ENCRYPT_m13)
		printf_m13(", ENCRYPT");
	if (header->flags & TR_FLAGS_INCLUDE_KEY_m13)
		printf_m13(", INCLUDE_KEY");
	if (header->flags & TR_FLAGS_CLOSE_m13)
		printf_m13(", CLOSE");
	if (header->flags & TR_FLAGS_ACKNOWLEDGE_m13)
		printf_m13(", ACKNOWLEDGE");
	if (header->flags & TR_FLAGS_CRC_m13)
		printf_m13(", CRC");
	if (header->flags & TR_FLAGS_NO_DESTRUCT_m13)
		printf_m13(", NO_DESTRUCT");
	if (header->flags & TR_FLAGS_TO_FILE_m13)
		printf_m13(", TO_FILE");
	
	// socket flags not included in header flags
	blocking = TR_set_socket_blocking_m13(trans_info, UNKNOWN_m13);
	if (blocking == TRUE_m13)
		printf_m13(", BLOCKING");
	else if (blocking == FALSE_m13)
		printf_m13(", NON_BLOCKING");
	printf_m13("\n");
	if (header->ID_code == TR_ID_CODE_NO_ENTRY_m13) {
		printf_m13("ID String: no entry\n");
	} else {
		STR_hex_m13(hex_str, (ui1 *) &header->ID_code, sizeof(ui4), NULL, TRUE_m13);
		printf_m13("ID String: %s (0x%s)\n", header->ID_string, hex_str);
	}
	if (header->type == TR_TYPE_NO_ENTRY_m13)
		printf_m13("Type: %hhu (no entry)\n", header->type);
	else
		printf_m13("Type: %hhu\n", header->type);
	if (header->subtype == TR_TYPE_NO_ENTRY_m13)
		printf_m13("Subtype: %hhu (no entry)\n", header->subtype);
	else
		printf_m13("Subtype: %hhu\n", header->subtype);
	if (header->version == TR_VERSION_NO_ENTRY_m13)
		printf_m13("Version: %hhu (no entry)\n", header->version);
	else
		printf_m13("Version: %hhu\n", header->version);
	printf_m13("Transmission Bytes: %ld\n", header->transmission_bytes);
	printf_m13("Offset: %ld\n", header->offset);
	printf_m13("--------------- Transmission Header - END -------------\n");

	// body
	// body
	printf_m13("--------------- Transmission Body - START -------------\n");
	if (header->type <= TR_TYPE_GENERIC_MAX_m13) {  // generic type codes
		switch (header->type) {
			case TR_TYPE_NO_ENTRY_m13:
				printf_m13("Type: TR_TYPE_NO_ENTRY_m13\nBody: none\n");
				break;
			case TR_TYPE_KEEP_ALIVE_m13:
				printf_m13("Type: TR_TYPE_KEEP_ALIVE_m13\nBody: none\n");
				break;
			case TR_TYPE_ACK_OK_m13:
				printf_m13("Type: TR_TYPE_ACK_OK_m13\nBody: none\n");
				break;
			case TR_TYPE_MESSAGE_m13:
				printf_m13("Type: TR_TYPE_MESSAGE_m13\nBody: none\n");
				break;
			case TR_TYPE_OPERATION_SUCCEEDED_m13:
				printf_m13("Type: TR_TYPE_OPERATION_SUCCEEDED_m13\nBody: none\n");
				break;
			case TR_TYPE_OPERATION_SUCCEEDED_WITH_MESSAGE_m13:
				printf_m13("Type: TR_TYPE_OPERATION_SUCCEEDED_WITH_MESSAGE_m13\nBody: ");
				TR_show_message_m13(header);
				putchar_m13('\n');
				break;
			case TR_TYPE_OPERATION_FAILED_m13:
				printf_m13("Type: TR_TYPE_OPERATION_FAILED_m13\nBody: none\n");
				break;
			case TR_TYPE_OPERATION_FAILED_WITH_WARNING_MESSAGE_m13:
				printf_m13("Type: TR_TYPE_OPERATION_FAILED_WITH_WARNING_MESSAGE_m13\nBody: ");
				TR_show_message_m13(header);
				putchar_m13('\n');
				break;
			case TR_TYPE_OPERATION_FAILED_WITH_ERROR_MESSAGE_m13:
				printf_m13("Type: TR_TYPE_OPERATION_FAILED_WITH_ERROR_MESSAGE_m13\nBody: ");
				TR_show_message_m13(header);
				putchar_m13('\n');
				break;
			default:
				break;
		}
	} else {  // app-specific type codes (not done)
//		switch (header->ID_code) {
//			case XXXX:
//				switch (header->type) {
//					case YYYY:
//						break;
//					default:
//						break;
//				}
//				break;
//			default:
//				break;
//		}
	}
	printf_m13("---------------- Transmission Body - END --------------\n\n");

	return_m13(TRUE_m13);
}


si1	*TR_strerror_m13(si4 err_num)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	switch(err_num) {
		case TR_E_NONE_m13:
			return_m13(TR_E_NONE_STR_m13);
		case TR_E_UNKN_m13:
			return_m13(TR_E_UNKN_STR_m13);
		case TR_E_SOCK_FAILED_m13:
			return_m13(TR_E_SOCK_FAILED_STR_m13);
		case TR_E_SOCK_OPEN_m13:
			return_m13(TR_E_SOCK_OPEN_STR_m13);
		case TR_E_SOCK_CLOSED_m13:
			return_m13(TR_E_SOCK_CLOSED_STR_m13);
		case TR_E_SOCK_TIMED_OUT_m13:
			return_m13(TR_E_SOCK_TIMED_OUT_STR_m13);
		case TR_E_DATA_m13:
			return_m13(TR_E_DATA_STR_m13);
		case TR_E_ID_m13:
			return_m13(TR_E_ID_STR_m13);
		case TR_E_TRANS_FAILED_m13:
			return_m13(TR_E_TRANS_FAILED_STR_m13);
		case TR_E_CRC_m13:
			return_m13(TR_E_CRC_STR_m13);
		case TR_E_ACK_m13:
			return_m13(TR_E_ACK_STR_m13);
		default:
			return_m13("unknown error code");
	}
}
	


//********************************//
// MARK: UNICODE FUNCTIONS  (UTF8)
//********************************//

#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	UTF8_1_byte_char_m13(si1 *c)
{
	// 1 byte (0xxx xxxx)

	if (*c & 0x80)
		return(FALSE_m13);
	
	return(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	UTF8_2_byte_char_m13(si1 *c)
{
	// 2 byte (110x xxxx + 1 continuation byte)

	if ((*c++ & 0xe0) == 0xc0)
		if ((*c & 0xc0) == 0x80)  // continuation
			return(TRUE_m13);
	
	return(FALSE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	UTF8_3_byte_char_m13(si1 *c)
{
	// 3 byte (1110 xxxx + 2 continuation bytes)

	if ((*c++ & 0xf0) == 0xe0)
		if ((*c++ & 0xc0) == 0x80)  // continuation
			if ((*c & 0xc0) == 0x80)  // continuation
				return(TRUE_m13);

	return(FALSE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	UTF8_4_byte_char_m13(si1 * c)
{
	// 4 byte (1111 0xxx + 3 continuation bytes)

	if ((*c++ & 0xf8) == 0xf0)
		if ((*c++ & 0xc0) == 0x80)  // continuation
			if ((*c++ & 0xc0) == 0x80)  // continuation
				if ((*c & 0xc0) == 0x80)  // continuation
					return(TRUE_m13);

	return(FALSE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	UTF8_char_bytes_m13(si1 *c)
{
	if (UTF8_1_byte_char_m13(c) == TRUE_m13)
		return(1);
	
	if (UTF8_2_byte_char_m13(c) == TRUE_m13)
		return(2);
	
	if (UTF8_3_byte_char_m13(c) == TRUE_m13)
		return(3);
	
	if (UTF8_4_byte_char_m13(c) == TRUE_m13)
		return(4);

	return(0);
}


size_t	UTF8_strlen_m13(si1 *s)
{
	size_t	len;
	
	for (len = 0; *s;)
		if ((*s++ & 0xc0) != 0x80)  // not continuation
			++len;
	
	return(len);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	UTF8_valid_char_m13(si1 *c)
{
	if (UTF8_char_bytes_m13(c))
		return(TRUE_m13);

	return(FALSE_m13);
}


tern	UTF8_valid_str_m13(si1 *s)
{
	size_t	c_bytes;
   

	while (*s) {
		c_bytes = UTF8_char_bytes_m13(s);
	
		if (c_bytes)
			s += c_bytes;
		else
			return(FALSE_m13);
	}
    
	return(TRUE_m13);
}



//******************************//
// MARK: WINDOWS FUNCTIONS  (WN)
//******************************//


tern	WN_cleanup_m13(void)
{
#ifdef WINDOWS_m13
	#ifdef FT_DEBUG_m13
		G_push_function_m13();
	#endif

	#ifdef WIN_SOCKETS_m13
		WSACleanup();
	#endif
	
	#ifndef MATLAB_m13
		WN_reset_terminal_m13();
	#endif
	
	return_m13(TRUE_m13);
#endif
	
	return(FALSE_m13);
}
	

tern	WN_clear_m13(void)
{
#ifdef WINDOWS_m13

	HANDLE				hStdout;
	CONSOLE_SCREEN_BUFFER_INFO	csbi;
	SMALL_RECT			scrollRect;
	COORD				scrollTarget;
	CHAR_INFO			fill;

	#ifdef FT_DEBUG_m13
	G_push_function_m13();
	#endif
	
	hStdout = GetStdHandle(STD_OUTPUT_HANDLE);

	// Get the number of character cells in the current buffer.
	if (!GetConsoleScreenBufferInfo(hStdout, &csbi))
		return_m13(FALSE_m13);
	
	// Scroll the rectangle of the entire buffer.
	scrollRect.Left = 0;
	scrollRect.Top = 0;
	scrollRect.Right = csbi.dwSize.X;
	scrollRect.Bottom = csbi.dwSize.Y;
	
	// Scroll it upwards off the top of the buffer with a magnitude of the entire height.
	scrollTarget.X = 0;
	scrollTarget.Y = (SHORT) (0 - csbi.dwSize.Y);
	
	// Fill with empty spaces with the buffer's default text attribute.
	fill.Char.UnicodeChar = TEXT(' ');
	fill.Attributes = csbi.wAttributes;
	
	// Do the scroll
	ScrollConsoleScreenBuffer(hStdout, &scrollRect, NULL, scrollTarget, &fill);
	
	// Move the cursor to the top left corner too.
	csbi.dwCursorPosition.X = 0;
	csbi.dwCursorPosition.Y = 0;
	
	SetConsoleCursorPosition(hStdout, csbi.dwCursorPosition);
	
	return_m13(TRUE_m13);
#endif
	
	return(FALSE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si8	WN_DATE_to_uutc_m13(sf8 date)
{
	sf8	secs, uutc;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// DATE == days since 29 Dec 1899 00:00:00 UTC
	secs = (date * (sf8) 86400.0) - (sf8) 2209161600.0;
	uutc = (si8) round(secs * (sf8) 1e6);
	
	return_m13(uutc);
}


// for conversion of windows file time to uutc on any platform
si8	WN_filetime_to_uutc_m13(ui1 *win_filetime)  // pass pointer to beginning of FILETIME structure as ui1 pointer
{
	ui1	*ui1_p;
	si8	uutc, leftovers;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// A Windows time is the number of 100-nanosecond intervals since 12:00 AM January 1, 1601 UTC (excluding leap seconds).
	ui1_p = (ui1 *) &uutc;  // can't guarantee alignment so copy bytewise to uutc variable
	*ui1_p++ = *win_filetime++; *ui1_p++ = *win_filetime++; *ui1_p++ = *win_filetime++; *ui1_p++ = *win_filetime++;
	*ui1_p++ = *win_filetime++; *ui1_p++ = *win_filetime++; *ui1_p++ = *win_filetime++; *ui1_p = *win_filetime;
	leftovers = uutc % (si8) WIN_TICKS_PER_USEC_m13;
	leftovers = ((leftovers << 1) + WIN_TICKS_PER_USEC_m13) / (WIN_TICKS_PER_USEC_m13 << 1);
	uutc /= (si8) WIN_TICKS_PER_USEC_m13;
	uutc -= (WIN_USECS_TO_EPOCH_m13 - leftovers);
	
	return_m13(uutc);
}


tern	WN_init_terminal_m13(void)
{
#if defined WINDOWS_m13 && !defined MATLAB_m13
	
	HANDLE	hOut;
	DWORD	dwOriginalOutMode, dwRequestedOutModes, dwOutMode;
	
	#ifdef FT_DEBUG_m13
	G_push_function_m13();
	#endif

	// Set output mode to handle virtual terminal sequences
	hOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if (hOut == INVALID_HANDLE_VALUE)
		return_m13(FALSE_m13);

	dwOriginalOutMode = 0;
	if (!GetConsoleMode(hOut, &dwOriginalOutMode))
		return_m13(FALSE_m13);

	dwRequestedOutModes = ENABLE_VIRTUAL_TERMINAL_PROCESSING | DISABLE_NEWLINE_AUTO_RETURN;

	dwOutMode = dwOriginalOutMode | dwRequestedOutModes;
	if (!SetConsoleMode(hOut, dwOutMode)) {  // failed to set both modes, try to step down mode gracefully
	  dwRequestedOutModes = ENABLE_VIRTUAL_TERMINAL_PROCESSING;
	  dwOutMode = dwOriginalOutMode | dwRequestedOutModes;
	  if (!SetConsoleMode(hOut, dwOutMode))  // failed to set any VT mode, can't do anything here
		  return_m13(FALSE_m13);
	}

	return_m13(TRUE_m13);
#endif
	
	return(FALSE_m13);
}


si4	WN_ls_1d_to_buf_m13(const si1 **dir_strs, si4 n_dirs, tern full_path, si1 **buffer)  // replacement for unix "ls -1d (on a directory list)"
{
#ifdef WINDOWS_m13
	si1			*file_name, *dir_name, enclosing_directory[PATH_BYTES_m13];
	si1			tmp_dir[PATH_BYTES_m13];
	ui4			fe;
	si4			i, n_files, file_name_size;
	WIN32_FIND_DATAA 	ffd;
	HANDLE 		  	find_h;
	FILE			*fp;
	
	#ifdef FT_DEBUG_m13
	G_push_function_m13();
	#endif

	// returns number of files or -1 for error
	// dir_strs can include "*" & "?" regex characters
	// right now, *buffer should not be allocated
	
	if (dir_strs == NULL)
		return_m13(-1);
	if (dir_strs[0] == NULL)
		return_m13(-1);
	if (n_dirs < 1)
		return_m13(-1);
	
	if (buffer == NULL) {
		G_warning_message_m13("%s(): buffer is NULL\n", __FUNCTION__);
		return_m13(-1);
	}

	if (full_path == TRUE_m13)
		file_name_size = PATH_BYTES_m13;
	else
		file_name_size = SEG_NAME_BYTES_m13;
		
	if (*buffer == NULL) {
		*buffer = (si1 *) malloc_m13((size_t) file_name_size);
	} else if (freeable_m13((void *) *buffer) == FALSE_m13) {
		G_warning_message_m13("%s(): *buffer cannot be statically allocated\n", __FUNCTION__);
		return_m13(-1);
	}
	**buffer = 0;
	
	find_h = INVALID_HANDLE_VALUE;
	n_files = 0;
	for (i = 0; i < n_dirs; ++i) {
		dir_name = (si1 *) dir_strs[i];
		if (STR_contains_regex_m13(dir_name) == FALSE_m13) {
			fe = G_exists_m13(dir_name);
			// a plain directory name will not list it's contents => must append "\*"
			if (fe == DIR_EXISTS_m13) {
				sprintf(tmp_dir, "%s\\*", dir_name);
				dir_name = tmp_dir;
			} else if (fe == DOES_NOT_EXIST_m13) {
				continue;
			}
			// regular files will list
		}
		find_h = FindFirstFileA((LPCSTR) dir_name, &ffd);
		if (find_h == INVALID_HANDLE_VALUE)
			continue;
		if (full_path == TRUE_m13) {
			G_full_path_m13(dir_name, dir_name);
			G_path_parts_m13(dir_name, enclosing_directory, NULL, NULL);
		}
		do {
			file_name = ffd.cFileName;
			// exclude files/directories starting with "$"
			if (*file_name == '$')
				continue;
			// exclude ".", "..", & files/directories starting with "._"
			// invisible files (".<file_name>") are not excluded
			if (*file_name == '.') {
				if (file_name[1] == 0 || file_name[1] == '.' || file_name[1] == '_')
					continue;
			}
			++n_files;
			*buffer = (si1 *) realloc_m13(*buffer, (size_t) (n_files * file_name_size));
			if (full_path == TRUE_m13)
				sprintf_m13(*buffer, "%s%s\\%s\n", *buffer, enclosing_directory, file_name);
			else
				sprintf_m13(*buffer, "%s%s\n", *buffer, file_name);
		} while (FindNextFileA(find_h, &ffd));
		
		FindClose(find_h);
	}
		
	if (find_h == INVALID_HANDLE_VALUE && n_files == 0)
		return_m13(-1);
	
	return_m13(n_files);
#endif
	
	return(FALSE_m13);
}


si4	WN_ls_1d_to_tmp_m13(const si1 **dir_strs, si4 n_dirs, tern full_path, si1 *temp_file)  // replacement for unix "ls -1d > temp_file (on a directory list)"
{
#ifdef WINDOWS_m13
	si1			*file_name, *dir_name, enclosing_directory[PATH_BYTES_m13];
	si1			tmp_dir[PATH_BYTES_m13];
	ui4			fe;
	si4			i, n_files;
	WIN32_FIND_DATAA 	ffd;
	HANDLE 		  	find_h;
	FILE_m13		*fp;
	
	#ifdef FT_DEBUG_m13
	G_push_function_m13();
	#endif

	// returns number of files or -1 for error
	// dir_strs can include "*" & "?" regex characters
	
	if (dir_strs == NULL)
		return_m13(-1);
	if (dir_strs[0] == NULL)
		return_m13(-1);
	if (n_dirs < 1)
		return_m13(-1);
	
	if (temp_file == NULL)
		temp_file = globals_m13->temp_file;  // not thread safe, but caller can use globals to know its name
	else if (*temp_file == 0)  // generate a unique temp file
		G_unique_temp_file_name_m13(temp_file);
	// else caller passed temp file name
	
	// open temp file
	fp = fopen_m13(temp_file, "w");
	
	find_h = INVALID_HANDLE_VALUE;
	n_files = 0;
	for (i = 0; i < n_dirs; ++i) {
		dir_name = (si1 *) dir_strs[i];
		if (STR_contains_regex_m13(dir_name) == FALSE_m13) {
			fe = G_exists_m13(dir_name);
			// a plain directory name will not list it's contents => must append "\*"
			if (fe == DIR_EXISTS_m13) {
				sprintf(tmp_dir, "%s\\*", dir_name);
				dir_name = tmp_dir;
			} else if (fe == DOES_NOT_EXIST_m13) {
				continue;
			}
			// regular files will list
		}
		find_h = FindFirstFileA((LPCSTR) dir_name, &ffd);
		if (find_h == INVALID_HANDLE_VALUE)
			continue;
		if (full_path == TRUE_m13)
			G_path_parts_m13(dir_name, enclosing_directory, NULL, NULL);
		do {
			file_name = ffd.cFileName;
			// exclude files/directories starting with "$"
			if (*file_name == '$')
				continue;
			// exclude ".", "..", & files/directories starting with "._"
			// invisible files (".<file_name>") are not excluded
			if (*file_name == '.') {
				if (file_name[1] == 0 || file_name[1] == '.' || file_name[1] == '_')
					continue;
			}
			++n_files;
			if (full_path == TRUE_m13)
				fprintf_m13(fp, "%s\\%s\n", enclosing_directory, file_name);
			else
				fprintf_m13(fp, "%s\n", file_name);
		} while (FindNextFileA(find_h, &ffd));
		
		FindClose(find_h);
	}
	fclose_m13(fp);
		
	if (find_h == INVALID_HANDLE_VALUE && n_files == 0)
		return_m13(-1);
	
	return_m13(n_files);
#endif
	
	return(FALSE_m13);
}


void	WN_nap_m13(struct timespec *nap)
{
#ifdef WINDOWS_m13
	
	static tern		use_ms = FALSE_m13;
	si8			hns, ms, rounds;
	LARGE_INTEGER		interval;
	static NTDELAYEXECTYPE	NtDelayExecution = NULL;  // pointer higher resolution sleep function (static so find only once)

		
	// circumvent Windows' Sleep() 1 millisecond resolution
		
	if (use_ms == TRUE_m13)
		goto G_WN_SLEEP_USE_MS;
	
	if (!(nap->tv_nsec % (si8) 10000))  // duration can be expressed in ms
		goto G_WN_SLEEP_USE_MS;

	// load the required NT dylib functions
	if (globals_m13->tables->hNTdll == NULL) {
		ULONG			actual_resolution;
		ZWSETTIMERRESTYPE 	ZwSetTimerResolution;  // pointer to set timer resolution function
		
		globals_m13->tables->hNTdll = LoadLibraryA("ntdll");
		if (globals_m13->tables->hNTdll == NULL) {
			G_warning_message_m13("%s(): error loading NTdll library => using millisecond resolution\n", __FUNCTION__);
			use_ms = TRUE_m13;
			goto G_WN_SLEEP_USE_MS;
		} else {
			ZwSetTimerResolution = (ZWSETTIMERRESTYPE) GetProcAddress(globals_m13->tables->hNTdll, "ZwSetTimerResolution");
			if (ZwSetTimerResolution) {
				ZwSetTimerResolution(1, 1, &actual_resolution);  // call the set timer resolution function (only done once)
			} else {
				G_warning_message_m13("%s(): error loading ZwSetTimerResolution() from NTdll library => using millisecond resolution\n", __FUNCTION__);
				use_ms = TRUE_m13;
				goto G_WN_SLEEP_USE_MS;
			}
			// load the higher resolution sleep function (static)
			NtDelayExecution = (NTDELAYEXECTYPE) GetProcAddress(globals_m13->tables->hNTdll, "NtDelayExecution");
			if (NtDelayExecution == NULL) {
				G_warning_message_m13("%s(): error loading NtDelayExecution() from NTdll library => using millisecond resolution\n", __FUNCTION__);
				use_ms = TRUE_m13;
				goto G_WN_SLEEP_USE_MS;
			}
		}
	}
	
	// convert to 100 ns resolution
	hns = (si8) nap->tv_sec * (si8) 10000000;
	hns += (si8) round((sf8) nap->tv_nsec / (sf8) 100.0);
	interval.QuadPart = (LONGLONG) -hns;  // compiler complains without this cast & assignment
	NtDelayExecution(0, &interval);

	return;

	G_WN_SLEEP_USE_MS:
	
	ms = nap->tv_sec * (si8) 1000;
	ms += (si8) round((sf8) nap->tv_nsec / (sf8) 1e6);
	if (ms == (si8) 0) {
		ms = (si8) 1;  // limited to 1 ms rseolution
	} else if (ms > (si8) 0x7FFFFFFF) {
		rounds = ms / (si8) 0x7FFFFFFF;
		while (rounds--)
			Sleep((si4) 0x7FFFFFFF);  // standard Windows sleep function
		ms %= (si8) 0x7FFFFFFF;  // leftovers
	}
	Sleep((si4) ms);  // standard Windows sleep function
	
	return;
#endif
	
	return;
}


void	*WN_query_information_file_m13(void *fp, si4 info_class, void *fi)
{
#ifdef WINDOWS_m13
	
	tern				alloced;
	size_t				ret_struct_size;
	FILE				*std_fp;
	HANDLE				file_h = NULL;
	static NTQUERYINFOFILETYPE	NtQueryInformationFile = NULL;  // static so only find once
	FILE_INFORMATION_CLASS		enum_class;
	IO_STATUS_BLOCK 		iostatus;

	#ifdef FT_DEBUG_m13
	G_push_function_m13();
	#endif
	
	if (fp == NULL) {
		G_set_error_m13(E_UNKN_m13, "no file ponter passed");
		return_m13(NULL);
	}
	if (FILE_stream_m13(fp) == TRUE_m13)
		std_fp = (FILE *) fp;
	else
		std_fp = ((FILE_m13 *) fp)->fp;
	file_h = (HANDLE) _get_osfhandle(_fileno(std_fp));
	if (file_h == INVALID_HANDLE_VALUE) {
		G_set_error_m13(E_UNKN_m13, "could not get file handle");
		return_m13(NULL);
	}
	
	enum_class = (FILE_INFORMATION_CLASS) info_class;  // cast int into enum
	switch (enum_class) {
		case FileAccessInformation:
			ret_struct_size = sizeof(FILE_ACCESS_INFORMATION);
			break;
		case FileBasicInformation:
			ret_struct_size = sizeof(FILE_BASIC_INFORMATION);
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "unsupported information class => update library");
			return_m13(NULL);
	}
	
	if (fi == NULL) {  // caller takes ownership
		alloced = TRUE_m13;
		fi = calloc_m13((size_t) 1, ret_struct_size);
	} else {
		alloced = FALSE_m13;
	}

	// load library
	if (globals_m13->tables->hNTdll == NULL) {
		globals_m13->tables->hNTdll = LoadLibraryA("ntdll");
		if (globals_m13->tables->hNTdll == NULL) {
			CloseHandle(file_h);
			if (alloced == TRUE_m13)
				free_m13(fi);
			G_set_error_m13(E_UNKN_m13, "could not load NT library");
			return_m13(NULL);
		}
	}

	// find function
	if (NtQueryInformationFile == NULL) {
		NtQueryInformationFile = (NTQUERYINFOFILETYPE) GetProcAddress(globals_m13->tables->hNTdll, "NtQueryInformationFile");
		if (NtQueryInformationFile == NULL) {
			CloseHandle(file_h);
			if (alloced == TRUE_m13)
				free_m13(fi);
			G_set_error_m13(E_UNKN_m13, "could not find NtQueryInformationFile() in NT library");
			return_m13(NULL);
		}
	}

	// get the file information structure
	if (NtQueryInformationFile(file_h, &iostatus, fi, ret_struct_size, enum_class) < 0) {
		CloseHandle(file_h);
		if (alloced == TRUE_m13)
			free_m13(fi);
		G_set_error_m13(E_UNKN_m13, "NtQueryInformationFile() failed");
		return_m13(NULL);
	}

	// clean up
	CloseHandle(file_h);

	return_m13(fi);
#endif
	
	return(NULL);
}

	
tern	WN_reset_terminal_m13(void)
{
#if defined WINDOWS_m13 && !defined MATLAB_m13
	HANDLE	hOut;
	DWORD	dwOriginalOutMode;
	
	#ifdef FT_DEBUG_m13
	G_push_function_m13();
	#endif

	// Set output mode to handle virtual terminal sequences
	hOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if (hOut == INVALID_HANDLE_VALUE)
		return_m13(FALSE_m13);

	dwOriginalOutMode = 3;
	if (!SetConsoleMode(hOut, dwOriginalOutMode))
		return_m13(FALSE_m13);

	return_m13(TRUE_m13);
#endif
	
	return(FALSE_m13);
}


tern	WN_socket_startup_m13(void)
{
#ifdef WINDOWS_m13
	
	WORD		wVersionRequested;
	WSADATA		wsaData;
	si4		err;
	
	#ifdef FT_DEBUG_m13
	G_push_function_m13();
	#endif

	wVersionRequested = MAKEWORD(2, 2);
	err = WSAStartup(wVersionRequested, &wsaData);
	if (err) {
		G_set_error_m13(E_UNKN_m13, "WSAStartup() failed with error: %d", err);
		return_m13(FALSE_m13);
	}
	
	// Confirm that the WinSock DLL supports 2.2.
	if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
		G_set_error_m13(E_UNKN_m13, "could not find a usable version of Winsock.dll");
		WSACleanup();
		return_m13(FALSE_m13);
	}
	
	return_m13(TRUE_m13);
#endif
	
	return(FALSE_m13);
}


si4	WN_system_m13(const si1 *command)  // Windows has a system() function which works fine, but it opens a command prompt window.
{
#ifdef WINDOWS_m13
	
	si1			*tmp_command;
	si1			*cmd_exe_path;
	si4			ret_val;
	si8			len;
	PROCESS_INFORMATION	process_info = {0};
	STARTUPINFOA		startup_info = {0};

	#ifdef FT_DEBUG_m13
	G_push_function_m13();
	#endif

	if (command == NULL)
		return_m13(-1);
	if (*command == 0)
		return_m13(-1);

	len = strlen(command);
	tmp_command = malloc(len + 6);
	tmp_command[0] = 0x2F;  // '/'
	tmp_command[1] = 0x63;  // 'c'
	tmp_command[2] = 0x20;  // <space>
	
	if (command[0] == 0x22) {  // if first character is a double quote, surround the whole command in another set of double quotes (e.g. if path to utility contains a space [e.g. "Program Files"])
		tmp_command[3] = 0x22;  // <double quote>
		memcpy(tmp_command + 4, command, len);
		tmp_command[len + 4] = 0x22;  // <double quote>
		tmp_command[len + 5] = 0;  // <terminal zero>
	} else {
		memcpy(tmp_command + 3, command, len + 1);
	}

	startup_info.cb = sizeof(STARTUPINFOA);
	cmd_exe_path = getenv("COMSPEC");
	_flushall();  // required for Windows system() calls, probably a good idea here too

	if (CreateProcessA(cmd_exe_path, tmp_command, NULL, NULL, 0, CREATE_NO_WINDOW, NULL, NULL, &startup_info, &process_info)) {
		WaitForSingleObject(process_info.hProcess, INFINITE);
		GetExitCodeProcess(process_info.hProcess, &ret_val);
		CloseHandle(process_info.hProcess);
		CloseHandle(process_info.hThread);
	}
	
	free((void *) tmp_command);
	
	return_m13(ret_val);
#endif
	
	return(FALSE_m13);
}


#ifdef WINDOWS_m13  // whole function included because FILETIME argument is unique to Windows
si8	WN_time_to_uutc_m13(FILETIME win_time)
{
	si8	uutc, leftovers;
	
	#ifdef FT_DEBUG_m13
	G_push_function_m13();
	#endif
	
	// A Windows time is the number of 100-nanosecond intervals since 12:00 AM January 1, 1601 UTC (excluding leap seconds).
	uutc = ((si8) win_time.dwHighDateTime << 32) + (si8) win_time.dwLowDateTime;
	leftovers = uutc % (si8) WIN_TICKS_PER_USEC_m13;
	leftovers = ((2 * leftovers) + WIN_TICKS_PER_USEC_m13) / (2 * WIN_TICKS_PER_USEC_m13);
	uutc /= (si8) WIN_TICKS_PER_USEC_m13;
	uutc -= (WIN_USECS_TO_EPOCH_m13 - leftovers);
	
	return_m13(uutc);
}
#endif


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
sf8	WN_uutc_to_date_m13(si8 uutc)
{
	sf8	secs, days;
	
	#ifdef FT_DEBUG_m13
	G_push_function_m13();
	#endif

	// DATE == days since 29 Dec 1899 00:00:00 UTC
	secs = ((sf8) uutc / (sf8) 1e6) + (sf8) 2209161600.0;
	days = secs / (sf8) 86400.0;
	
	return_m13(days);
}


#ifdef WINDOWS_m13  // whole function included because FILETIME return value is unique to Windows
FILETIME	WN_uutc_to_win_time_m13(si8 uutc)
{
	FILETIME ft;
	
	#ifdef FT_DEBUG_m13
	G_push_function_m13();
	#endif

	uutc += WIN_USECS_TO_EPOCH_m13;
	uutc *= WIN_TICKS_PER_USEC_m13;
	
	ft.dwLowDateTime = (ui4) ((ui8) uutc & (ui8) 0x00000000ffffffff);
	ft.dwHighDateTime = (ui4) ((ui8) uutc >> 32);
	
	return_m13(ft);
}
#endif


tern	WN_windify_file_paths_m13(si1 *target, const si1 *source)
{
	si1		*c1, *c2;


	// if target == source, or target == NULL, conversion done in place
	if (source == NULL)
		return(FALSE_m13);
	if (target == NULL)
		target = (si1 *) source;
	else if (target != source)
		strcpy(target, source);

	// Replace all '/' in string except if escaped ("\/" -> note if in string literal, you have to escape the escape "\\/"), or part of "://"

	c1 = c2 = target;
	while (*c2) {
		if (*c2 == '\\') {
			if (*(c2 + 1) == '/') {  // unescape forward slash
				*c1++ = '/';
				c2 += 2;
				continue;
			}
		} else if (*c2 == ':') {
			if (*(c2 + 1) == '/') {  // leave "http://" etc. alone
				if (*(c2 + 2) == '/') {
					while (*c2 && *c2 != ' ')
						*c1++ = *c2++;
					continue;
				}
			}
		} else if (*c2 == '/') {  // replace all other '/' with '\'
			*c1++ = '\\';
			++c2;
			continue;
		}
		*c1++ = *c2++;
	}
	*c1 = 0;
	
	return(TRUE_m13);
}


si1	*WN_windify_format_string_m13(const si1 *fmt)
{
	// changes ld, li, lo, lu, lx, lX to "ll" versions of the same
	si1	*c, *new_c, *new_fmt;
	si4	matches;
	si8	len;
	
	
	if (fmt == NULL)
		return(NULL);
	
	matches = 0;
	c = (si1 *) fmt;
	while (*c) {
		if (*c++ == '%') {
			// skip over numbers & periods
			while ((*c >= '0' && *c <= '9') || *c == '.')
				++c;
			if (*c == 'l') {
				switch (*++c) {
					case 'b':  // binary, supported in Gnu C Library from version 2.35
					case 'B':  // binary, supported in Gnu C Library from version 2.35
					case 'd':
					case 'i':
					case 'o':
					case 'u':
					case 'x':
					case 'X':
						++matches;
						break;
				}
			}
		}
	}
	if (!matches)
		return((si1 *) fmt);
	
	len = (si8) (c - fmt) + matches + 1;  // extra byte for terminal zero
	new_fmt = (si1 *) calloc((size_t) len, sizeof(ui1));
	
	c = (si1 *) fmt;
	new_c = new_fmt;
	while (*c) {
		if (*c == '%') {
			*new_c++ = *c++;
			// copy numbers & periods
			while ((*c >= '0' && *c <= '9') || *c == '.')
				*new_c++ = *c++;
			if (*c == 'l') {
				*new_c++ = *c++;
				switch (*c) {
					case 'b':  // binary, supported in Gnu C Library from version 2.35
					case 'B':  // binary, supported in Gnu C Library from version 2.35
					case 'd':
					case 'i':
					case 'o':
					case 'u':
					case 'x':
					case 'X':
						*new_c++ = 'l';
						break;
				}
			}
		}
		*new_c++ = *c++;
	}
		
	return(new_fmt);
}



//**********************************************//
// MARK: STANDARD LIBRARY FUNCTIONS  (no prefix)
//**********************************************//

// NOTE: these functions are not added to the function stack when using FT_DEBUG_m13

#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4  asprintf_m13(si1 **target, const si1 *fmt, ...)
{
	si4		ret_val;
	va_list		v_args;

	// Note: this function returns a system allocated string whose ownership is transfered to the caller
	// if using AT_DEBUG functions, this memory is not entered into the allocation list, and should be freed with free(), not free_m13()
	
	va_start(v_args, fmt);
	ret_val = vasprintf_m13(target, fmt, v_args);
	va_end(v_args);
	
	return(ret_val);
}


#ifdef AT_DEBUG_m13
void	*AT_calloc_m13(const si1 *function, si4 line, size_t n_members, si8 el_size)
#else
void	*calloc_m13(size_t n_members, si8 el_size)
#endif
{
	tern	is_level_header = FALSE_m13;
	void	*ptr;
		
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// pass negative element size to flag as level header
	
	if (el_size < 0) {
		el_size = -el_size;
		is_level_header = TRUE_m13;
	}
	
	if (n_members == 0 || el_size == 0) {
		G_set_error_m13(E_ALLOC_m13, "members or element size is zero");
		return_m13(NULL);
	}
	
#ifdef MATLAB_PERSISTENT_m13
	ptr = mxCalloc((mwSize) n_members, (mwSize) el_size);
#else
	ptr = calloc(n_members, (size_t) el_size);
#endif
	
	if (ptr == NULL) {
		G_set_error_m13(E_ALLOC_m13, NULL);
		return_m13(NULL);
	}
	
	
	// alloc tracking
#ifdef AT_DEBUG_m13
	AT_add_entry_m13(function, line, ptr, n_members * (size_t) el_size);
#endif

#ifdef MATLAB_PERSISTENT_m13
	mexMakeMemoryPersistent(ptr);
#endif

	if (is_level_header == TRUE_m13)
		((LH_m13 *) ptr)->flags |= LH_ALLOCATED_m13;
	
	return_m13(ptr);
}


// not a standard function, but closely related
#ifdef AT_DEBUG_m13
void	**AT_calloc_2D_m13(const si1 *function, si4 line, size_t dim1, size_t dim2, si8 el_size)
#else
void	**calloc_2D_m13(size_t dim1, size_t dim2, si8 el_size)
#endif
{
	tern		is_level_header = FALSE_m13;
	si8 		i;
	void		**ptr;
	size_t		dim1_bytes, dim2_bytes, content_bytes, total_bytes;
	LH_m13		*lh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Returns pointer to 2 dimensional array (not zeroed) of dim1 by dim2 elements of size el_size
	// ptr[0] points to a one dimensional array of size (dim1 * dim2 * el_size)
	// The whole block can be freed with free(ptr)
	// pass negative el_size size to flag dim2 elements as level headers

	if (el_size < 0) {
		el_size = -el_size;
		is_level_header = TRUE_m13;
	}
	
	if (dim1 == 0 || dim2 == 0 || el_size == 0) {
		G_set_error_m13(E_ALLOC_m13, "dimension 1, dimension 2, or element size is zero");
		return_m13(NULL);
	}
	
	dim1_bytes = dim1 * sizeof(void *);
	dim2_bytes = dim2 * (size_t) el_size;
	content_bytes = dim1 * dim2_bytes;
	total_bytes = dim1_bytes + content_bytes;
#ifdef AT_DEBUG_m13
	ptr = (void **) AT_calloc_m13(function, line, total_bytes, sizeof(ui1));
#else
	#ifdef MATLAB_PERSISTENT_m13
	ptr = (void **) mxCalloc(total_bytes, sizeof(ui1));
	#else
	ptr = (void **) calloc(total_bytes, sizeof(ui1));
	#endif
#endif
	if (ptr == NULL) {
		G_set_error_m13(E_ALLOC_m13, NULL);
		return_m13(NULL);
	}
	
	ptr[0] = (void *) (ptr + dim1);
	for (i = 1; i < dim1; ++i)
		ptr[i] = (void *) ((ui1 *) ptr[i - 1] + dim2_bytes);
	
#ifdef MATLAB_PERSISTENT_m13
	mexMakeMemoryPersistent(ptr);
#endif
	
	if (is_level_header == TRUE_m13) {
		for (i = 0; i < dim1; ++i) {
			lh = (LH_m13 *) ptr[i];
			lh->flags &= ~LH_ALLOCATED_m13;
		}
	}
			
	return_m13(ptr);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
size_t	calloc_size_m13(void *address, size_t element_size)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	return_m13(malloc_size_m13(address) / element_size);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	cp_m13(const si1 *path, const si1 *new_path)
{
	si1	command[(PATH_BYTES_m13 * 2) + 16], tmp_path[PATH_BYTES_m13], tmp_new_path[PATH_BYTES_m13];
	si4	fe, ret_val;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// returns, TRUE_m13 on success, FALSE_m13 on failure, UNKNOWN_m13 if "path" does not exist

	// condition paths
	G_full_path_m13(path, tmp_path);
	path = (const si1 *) tmp_path;
	G_full_path_m13(new_path, tmp_new_path);
	new_path = (const si1 *) tmp_new_path;
	
	fe = G_exists_m13(path);
	
	if (fe == FILE_EXISTS_m13) {
		
		#if defined MACOS_m13 || defined LINUX_m13
		sprintf_m13(command, "cp -f \"%s\" \"%s\"", path, new_path);
		#endif
		#ifdef WINDOWS_m13
		sprintf_m13(command, "copy \\/y \"%s\" \"%s\"", path, new_path);
		#endif
		ret_val = system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
		if (ret_val) {
			G_set_error_m13(E_UNKN_m13, "could not copy \"%s\" to \"%s\"", path, new_path);
			return_m13(FALSE_m13);
		}
	} else if (fe == DIR_EXISTS_m13) {
		#if defined MACOS_m13 || defined LINUX_m13
		sprintf_m13(command, "cp -Rf \"%s\" \"%s\"" , path, new_path);
		#endif
		#ifdef WINDOWS_m13
		sprintf_m13(command, "xcopy \\/s \\/e \\/y \\/c \\/q \"%s\" \"%s\"", path, new_path);
		#endif
		ret_val = system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
		if (ret_val) {
			G_set_error_m13(E_UNKN_m13, "could not copy \"%s\" to \"%s\"", path, new_path);
			return_m13(FALSE_m13);
		}
	} else {
		return_m13(UNKNOWN_m13);
	}
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	errno_m13(void)
{
	// Note: zero errno with errno_reset_m13() before running the function you may need it in
	// Note: Windows errno.h defines almost all the same error codes as Macos & Linux, but the numbers may differ, so use defined names rather than numbers

#if defined MACOS_m13 || defined LINUX_m13
	extern si4	errno;
	
	return(errno);
#endif

#ifdef WINDOWS_m13
	si4	err;
	
	err = (si4) _get_errno(&err);  // Windows runtime
	if (err == 0)
		err = (si4) GetLastError();  // WinAPI
	
	#ifdef WIN_SOCKETS_m13
	if (err == 0)
		err = WSAGetLastError();  // Windows sockets
	#endif
	
	return(err);
#endif
	
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	errno_reset_m13(void)
{
	// use this function to zero errno before function call that may set it

#if defined MACOS_m13 || defined LINUX_m13
	extern si4	errno;
	
	errno = 0;
#endif
	
#ifdef WINDOWS_m13
	_set_errno((si4) 0);  // Windows runtime
	SetLastError((DWORD) 0);  // WinAPI
	#ifdef WIN_SOCKETS_m13
		WSASetLastError((si4) 0);  // Windows sockets
	#endif
#endif
	
	return;
}


void	exit_m13(si4 status)
{
	ui4			behavior;
	
#ifdef FT_DEBUG_m13
	behavior = E_BEHAVIOR_m13;  // display all messages if function tracking enabled
#else
	behavior = G_current_behavior_m13();
#endif
		
	// hold other exiting threads here
	pthread_mutex_lock_m13(&globals_m13->error.exit_mutex);

	if ((behavior & SUPPRESS_ERROR_OUTPUT_m13) == 0) {

		G_show_error_m13();
		
		#ifdef FT_DEBUG_m13
		G_show_function_stack_m13(FALSE_m13);
		#endif

		if (status >= E_NONE_m13 && status < E_NUM_CODES_m13) {
			#ifdef MATLAB_m13
			mexPrintf("Exit Status: %d  [%s]\n\n", status, globals_m13->tables->E_tags_table[status]);
			#else
			fprintf(stderr, "%sExit Status:%s %d  %s[%s]%s\n\n", TC_RED_m13, TC_RESET_m13, status, TC_YELLOW_m13, globals_m13->tables->E_tags_table[status], TC_RESET_m13);
			fflush(stderr);
			#endif
		} else {
			#ifdef MATLAB_m13
			mexPrintf("Exit Status: %d\n\n", status);
			#else
			fprintf(stderr, "%sExit Status:%s %d\n\n", TC_RED_m13, TC_RESET_m13, status);
			fflush(stderr);
			#endif
		}
	}

	#ifdef WINDOWS_m13
	WN_cleanup_m13();  // reset terminal & sockets
	#endif

	#ifdef MATLAB_m13
	mexErrMsgTxt("");  // mex function exits here; message printed above; exit() kills Matlab itself
	#else
	exit(status);
	#endif
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	fclose_m13(void *fp)
{
	tern		closed;
	si4		ret_val;
	FILE		*std_fp;
	FILE_m13	*m13_fp, **m13_fp_ptr;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	// returns -1 if error closing
	// returns 0 under all other circumstances (including already closed, or unclosable [e.g. standard streams])
	// pass &fp to set local FILE_m13 pointer to NULL

	switch (FILE_stream_m13(fp)) {
		case FALSE_m13:
			m13_fp = (FILE_m13 *) fp;
			m13_fp_ptr = NULL;
			break;
		case TRUE_m13:
			m13_fp_ptr = (FILE_m13 **) fp;
			if (FILE_stream_m13(*m13_fp_ptr) == FALSE_m13) {  // address of FILE_m13 pointer passed
				m13_fp = *m13_fp_ptr;
				break;
			}
			std_fp = (FILE *) fp;
			if (fileno_m13(std_fp) <= 2)  // already closed or standard stream
				return_m13(0);
			if (fclose(std_fp)) {
				G_set_error_m13(E_UNKN_m13, "error closing file");
				return_m13(-1);
			}  // else fall through to return(0)
		case UNKNOWN_m13:  // fp == NULL
			return_m13(0);
	}

	// close FILE_m13
	if (m13_fp->fd == FILE_FD_CLOSED_m13)
		closed = TRUE_m13;
	else if (m13_fp->flags & FILE_FLAGS_STD_STREAM_m13)
		closed = TRUE_m13;  // can't close standard streams => treat as closed
	else
		closed = FALSE_m13;
	
	ret_val = 0;
	if (closed == FALSE_m13) {
		if (fclose(m13_fp->fp)) {
			G_set_error_m13(E_UNKN_m13, "error closing file \"%s\"", m13_fp->path);
			ret_val = -1;
		}
	}

	if (m13_fp->flags & FILE_FLAGS_LOCK_m13)
		flock_m13(fp, FLOCK_CLOSE_m13);

	if (m13_fp->flags & FILE_FLAGS_ALLOCED_m13) {
		free_m13(m13_fp);
		if (m13_fp_ptr)
			*m13_fp_ptr = NULL;
	} else {
		m13_fp->fp = NULL;
		m13_fp->fd = FILE_FD_CLOSED_m13;
	}

	return_m13(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	fileno_m13(void *fp)
{
	si4	fd;
	FILE	*std_fp;

	
	switch (FILE_stream_m13(fp)) {
		case TRUE_m13:
			std_fp = (FILE *) fp;
			break;
		case FALSE_m13:
			std_fp = ((FILE_m13 *) fp)->fp;
			break;
		default:
			return(-1);
	}
	
	#if defined MACOS_m13 || defined LINUX_m13
	fd = fileno(std_fp);
	#endif
	#ifdef WINDOWS_m13
	fd = _fileno(std_fp);
	if (fd == -2) {
		G_warning_message_m13("%s(): stdout or stderr not associated with stream\n", __FUNCTION__);
		fd = -1;
	}
	#endif

	return(fd);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	fisopen_m13(void *fp)
{
	si4	fd;
	FILE	*std_fp;
	
	// gets file descriptor to determine if file is open
	// if fp is FILE_m13, uses standard fileno(), not fp->fd, in case fp->fd is zero, or not reset on close
	
	eprintf_m13("");
	switch (FILE_stream_m13(fp)) {
		case FALSE_m13:
			eprintf_m13("");
			std_fp = ((FILE_m13 *) fp)->fp;
			break;
		case TRUE_m13:
			eprintf_m13("");
			std_fp = (FILE *) fp;
			break;
		case UNKNOWN_m13:
			eprintf_m13("");
			return(FALSE_m13);
	}

#if defined MACOS_m13 || defined LINUX_m13
	eprintf_m13("");
	fd = fileno(std_fp);
	eprintf_m13("");
#endif
#ifdef WINDOWS_m13
	fd = _fileno(std_fp);
#endif
	eprintf_m13("");
	if (fd < 0)  // Windows can return -2 under some circumstances
		return(FALSE_m13);
	
	eprintf_m13("");
	return(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
size_t	flen_m13(void *fp)
{
	tern			is_stream;
	si4			fd;
	FILE_m13		*m13_fp;
	struct_stat_m13		sb;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (fp == NULL) {
		G_set_error_m13(E_UNKN_m13, "fp is NULL");
		return_m13(-1);
	}
	
	is_stream = FILE_stream_m13(fp);
	if (is_stream == FALSE_m13) {
		m13_fp = (FILE_m13 *) fp;
		if (m13_fp->flags & FILE_FLAGS_LEN_m13) {
			if (m13_fp->flags & FILE_FLAGS_TIME_m13)
				m13_fp->acc = G_current_uutc_m13();
			return_m13(m13_fp->len);
		}
	}

	fd = fileno_m13(fp);
	fstat_m13(fd, &sb);
	
	if (is_stream == FALSE_m13) {
		if (m13_fp->flags & FILE_FLAGS_LEN_m13)
			m13_fp->len = (si8) sb.st_size;
		if (m13_fp->flags & FILE_FLAGS_TIME_m13)
			m13_fp->acc = G_current_uutc_m13();
	}
	
	return_m13((size_t) sb.st_size);
}
		
		
si4	flock_m13(void *fp, si4 operation, ...)	// varargs(FLOCK_TIMEOUT_m13 bit set): const si1 *nap_str (string to pass to nap_m13())
						// varargs(fp == FILE *): const si1 *file_path, const si1 *nap_str (must pass something for nap_str, but can be NULL)
{
	tern			is_stream, locked;
	const si1		*path, *nap_str;
	ui4			file_id;
	si4			i, n_locks;
	si8			len;
	va_list			v_args;
	pid_t_m13		write_id;
	FILE_m13		*m13_fp;
	FLOCK_LIST_m13		*list;
	FLOCK_ENTRY_m13		*lock, **lock_ptr, *new_locks, **new_lock_ptrs;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// set up
	nap_str = globals_m13->file_lock_timeout;
	is_stream = FILE_stream_m13(fp);
	if (is_stream == TRUE_m13) {
		// get varargs
		va_start(v_args, operation);
		path = va_arg(v_args, const si1 *);
		nap_str = va_arg(v_args, const si1 *);
		va_end(v_args);
		
		// check path
		if (STR_empty_m13(path) == TRUE_m13) {
			G_set_error_m13(E_LOCK_m13, "path is empty");
			return_m13(FLOCK_ERR_m13);
		}
		
		// check nap string
		if (STR_empty_m13(nap_str) == TRUE_m13)
			nap_str = globals_m13->file_lock_timeout;
		
		// don't lock standard streams
		if (fileno_m13(fp) <= 2)
			return_m13(FLOCK_SUCCESS_m13);
		
		// get file id
		len = (si8) strlen(path);
		file_id = CRC_calculate_m13((ui1 *) path, len);
	} else if (is_stream == FALSE_m13) {
		// see if locking enabled
		m13_fp = (FILE_m13 *) fp;
		if (!(m13_fp->flags & FILE_FLAGS_LOCK_m13))
			return_m13(FLOCK_SUCCESS_m13);
		
		// don't lock standard streams
		if (m13_fp->flags & FILE_FLAGS_STD_STREAM_m13)
			return_m13(FLOCK_SUCCESS_m13);

		// get vararg
		if (operation & FLOCK_TIMEOUT_m13) {
			va_start(v_args, operation);
			nap_str = va_arg(v_args, const si1 *);
			va_end(v_args);
			
			// check nap string
			if (STR_empty_m13(nap_str) == TRUE_m13)
				nap_str = globals_m13->file_lock_timeout;
		}
		
		// get file id
		if (m13_fp->fid) {
			file_id = m13_fp->fid;
		} else {
			len = (si8) strlen(m13_fp->path);
			file_id = m13_fp->fid = CRC_calculate_m13((const ui1 *) m13_fp->path, len);
		}
	} else {
		G_set_error_m13(E_LOCK_m13, "fp is NULL");
		return_m13(FLOCK_ERR_m13);
	}
	
	// check operation
	if (operation & (FLOCK_LOCK_m13 | FLOCK_UNLOCK_m13)) {
		if (!(operation & (FLOCK_READ_m13 | FLOCK_WRITE_m13))) {
			G_set_error_m13(E_LOCK_m13, "locking operations require a mode");
			return_m13(FLOCK_ERR_m13);
		}
		if (operation & FLOCK_WRITE_m13)
			write_id = gettid_m13();
	}
	
	// get list mutex
	list = globals_m13->file_lock_list;
	pthread_mutex_lock_m13(&list->mutex);  // lock the list
	
	// find lock in table
	n_locks = list->top_idx + 1;
	lock = NULL;
	lock_ptr = list->lock_ptrs;
	for (i = n_locks; i--; ++lock_ptr) {
		if ((*lock_ptr)->file_id == file_id) {
			lock = *lock_ptr;
			break;
		}
		if (lock)
			continue;
		if ((*lock_ptr)->file_id == 0) {
			lock = *lock_ptr;
		}
	}

	// not in list
	if (i == -1) {
		if (operation & (FLOCK_UNLOCK_m13 | FLOCK_CLOSE_m13)) {  // file to unlock or close is not in list
			pthread_mutex_unlock_m13(&list->mutex);  // unlock the list
			return_m13(FLOCK_SUCCESS_m13);
		}
		// operation == FLOCK_LOCK_m13, FLOCK_LOCK_NB_m13, or FLOCK_OPEN_m13
		if (lock == NULL) {  // expand list (note: allocated en bloc)
			// reallocate lock pointers
			n_locks += GLOBALS_FLOCK_LIST_SIZE_INCREMENT_m13;
			new_lock_ptrs = (FLOCK_ENTRY_m13 **) realloc((void *) list->lock_ptrs, (size_t) n_locks * sizeof(FLOCK_ENTRY_m13 *));
			if (new_lock_ptrs == NULL) {
				pthread_mutex_unlock_m13(&list->mutex);
				G_set_error_m13(E_ALLOC_m13, NULL);
				return_m13(FLOCK_ERR_m13);
			}

			// allocate new locks (calloc so all fields zeroed)
			new_locks = (FLOCK_ENTRY_m13 *) calloc((size_t) GLOBALS_FLOCK_LIST_SIZE_INCREMENT_m13, sizeof(FLOCK_ENTRY_m13));
			if (new_locks == NULL) {
				pthread_mutex_unlock_m13(&list->mutex);
				G_set_error_m13(E_ALLOC_m13, NULL);
				return_m13(FLOCK_ERR_m13);
			}
			
			// assign lock pointers
			list->lock_ptrs = new_lock_ptrs;
			new_lock_ptrs = list->lock_ptrs + list->size;  // new_lock_ptrs incremented in loop
			lock = new_locks;  // new_locks incremented in loop
			for (i = GLOBALS_FLOCK_LIST_SIZE_INCREMENT_m13; i--;)
				*new_lock_ptrs++ = new_locks++;
			list->size = n_locks;
			++list->top_idx;
		}
		lock->file_id = file_id;  // assign lock
		if (!(operation & FLOCK_OPEN_m13))
			lock->opens = 1;  // lock operation called without initial call to fopen_m13() => shouldn't happen, but add the protective open
	}

	// close (called by fclose_m13)
	if (operation & FLOCK_CLOSE_m13) {
		--lock->opens;  // release original open
		if (lock->opens <= 0) {  // recycle lock
			lock->opens = lock->reads = 0;
			lock->file_id = 0;
			lock->write_id = 0;
		}
		pthread_mutex_unlock_m13(&list->mutex);
		return_m13(FLOCK_SUCCESS_m13);
	} else {  // add protective open count to prevent lock from being deleted by another thread
		++lock->opens;
	}
	
	// release list mutex
	pthread_mutex_unlock_m13(&list->mutex);
		
	// open (called by fopen_m13)
	if (operation & FLOCK_OPEN_m13) {
		// protective open count becomes original open count
		lock->file_id = file_id;
		return_m13(FLOCK_SUCCESS_m13);
	}
		
	// force
	if (operation & FLOCK_FORCE_m13) {
		lock->write_id = 0;  // remove ownership
		if (operation & FLOCK_WRITE_m13)
			lock->reads = 0;
		if (operation & FLOCK_UNLOCK_m13) {
			--lock->opens;  // release protective open from search
			return_m13(FLOCK_SUCCESS_m13);
		}
	}
	
	// unlock
	if (operation & FLOCK_UNLOCK_m13) {
		if (operation & FLOCK_WRITE_m13) { // write unlock
			if (lock->write_id == write_id) {  // only owning thread can release write lock (unless forced)
				lock->write_id = 0;  // release ownership
			} else {
				--lock->opens;  // release protective open from search
				return_m13(FLOCK_LOCKED_m13);
			}
		} else {  // read unlock
			if (lock->reads)
				--lock->reads;  // release a read lock
		}  // else no unlock mode
		--lock->opens;  // release protective open from search
		return_m13(FLOCK_SUCCESS_m13);
	}
	
	// lock
	if (lock->write_id)
		locked = TRUE_m13;
	else if ((operation & FLOCK_WRITE_m13) && lock->reads)
		locked = TRUE_m13;
	else
		locked = FALSE_m13;
	
	// wait
	if (locked == TRUE_m13) {
		// non-blocking
		if (operation & FLOCK_NON_BLOCKING_m13)
			if (!(operation & FLOCK_TIMEOUT_m13))  // non-blocking timeout not set
				return_m13(FLOCK_LOCKED_m13);
		// blocking
		do {
			// sleep
			nap_m13(nap_str);
			
			if (lock->write_id)
				locked = TRUE_m13;
			else if ((operation & FLOCK_WRITE_m13) && lock->reads)
				locked = TRUE_m13;
			else
				locked = FALSE_m13;
			
			// non-blocking timeout set (single cycle)
			if (operation & FLOCK_NON_BLOCKING_m13)
				if (locked == TRUE_m13)
					return_m13(FLOCK_LOCKED_m13);
			
		} while (locked == TRUE_m13);
	}
	
	if (operation & FLOCK_READ_m13)
		++lock->reads;
	else  // write
		lock->write_id = write_id;
	
	// release protective open
	--lock->opens;

	return_m13(FLOCK_SUCCESS_m13);
}


FILE_m13	*fopen_m13(const si1 *path, const si1 *mode, ...)  // varargs(mode == NULL): si1 *mode, ui2 flags (as si4), ui2 permissions (as si4)
{
	tern		fexists, read_mode, write_mode, append_mode, plus_mode, trunc_mode;
	si1		*c, main_mode_total, tmp_path[PATH_BYTES_m13];
	ui2 		flags, permissions;
	FILE_m13	*fp;
	si4		sys_mode_flags;
	si8		name_len;
	struct_stat_m13	sb;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// function will create path if it does not exist in write modes
	
	if (STR_empty_m13(path) == TRUE_m13) {
		G_set_error_m13(E_OPEN_m13, "path is empty");
		return_m13(NULL);
	}
	G_full_path_m13(path, tmp_path);
	path = tmp_path;
	
	// get varargs
	flags = permissions = 0;
	if (mode == NULL) {
		va_list	v_args;
		
		va_start(v_args, mode);
		mode = va_arg(v_args, si1 *);
		flags = (ui2) va_arg(v_args, si4);
		permissions = (ui2) va_arg(v_args, si4);
		va_end(v_args);
	}
	
	if (STR_empty_m13(mode) == TRUE_m13) {
		G_set_error_m13(E_OPEN_m13, "mode is empty");
		return_m13(NULL);
	}
	
	// get new FILE_m13
	fp = FILE_init_m13(NULL);
	if (fp == NULL)
		return_m13(NULL);
	name_len = strcpy_m13(fp->path, path);
	if (permissions)
		fp->perms = permissions;  // custom permissions (may be modified by process umask or system)
	else
		fp->perms = permissions = FILE_PERM_DEFAULT_m13;  // default permissions (may be modified by process umask or system)
	if (flags)
		fp->flags = flags | FILE_FLAGS_ALLOCED_m13;  // set alloced flag, but otherwise override default flags with passed flags
	if (G_MED_type_code_from_string_m13((si1 *) path + (name_len - 4)) != NO_TYPE_CODE_m13)
		fp->flags |= FILE_FLAGS_MED_m13;

	// check mode
	if (STR_empty_m13(mode) == TRUE_m13) {
		G_set_error_m13(E_OPEN_m13, "mode is empty");
		return_m13(NULL);
	}
	read_mode = write_mode = append_mode = plus_mode = trunc_mode = UNKNOWN_m13;
	
	c = (si1 *) mode - 1;
	while (*++c) {
		switch (*c) {
			case 'R':
			case 'r':
				read_mode = TRUE_m13;
				break;
			case 'W':
			case 'w':
				write_mode = TRUE_m13;
				break;
			case 'A':
			case 'a':
				append_mode = TRUE_m13;
				break;
			case 'N':
			case 'n':
				trunc_mode = FALSE_m13;
				break;
			case 'C':
			case 'c':
				trunc_mode = TRUE_m13;
				break;
			case '+':
				plus_mode = TRUE_m13;
				break;
			default:  // skip 't' & 'b'; 'b' added below
				break;
		}
	}

	main_mode_total = read_mode + write_mode + append_mode;
	if (main_mode_total != 1) {
		free_m13((void *) fp);
		G_set_error_m13(E_OPEN_m13, "invalid mode: \"%s\"", mode);
		return_m13(NULL);
	}
	if (write_mode == TRUE_m13) {
		if (trunc_mode == NOT_SET_m13)
			trunc_mode = TRUE_m13;  // default "w" behavior is to clobber
	} else if (append_mode == TRUE_m13) {
		if (trunc_mode == NOT_SET_m13)
			trunc_mode = FALSE_m13;  // default "a" behavior is not to clobber
	}

	// create path
	if (write_mode == TRUE_m13 || append_mode == TRUE_m13) {
		si1	*dir, command[PATH_BYTES_m13 + 16];
		
		dir = command;
		G_path_parts_m13(path, dir, NULL, NULL);
		if (G_exists_m13(dir) != DIR_EXISTS_m13)
			if (md_m13(dir) == FALSE_m13)
				return_m13(NULL);
	}

	errno_reset_m13();
#if defined MACOS_m13 || defined LINUX_m13
	sys_mode_flags = 0;
	if (read_mode == TRUE_m13) {
		// do not create
		if (plus_mode == TRUE_m13)
			sys_mode_flags = O_RDWR;  // read & write
		else
			sys_mode_flags = O_RDONLY;  // read only
	} else {  // write_mode == TRUE_m13 || append_mode == TRUE_m13
		sys_mode_flags = O_CREAT;  // create if doesn't exist
		if (append_mode == TRUE_m13)
			sys_mode_flags |= O_APPEND;  // append all writes
		if (plus_mode == TRUE_m13)
			sys_mode_flags |= O_RDWR;  // read & write
		else
			sys_mode_flags |= O_WRONLY;  // write only
		if (trunc_mode == TRUE_m13)
			sys_mode_flags |= O_TRUNC;  // clobber if exists
	}
	fp->fd = open(path, sys_mode_flags, (mode_t) permissions);
	if (fp->fd >= 0)
		fp->fp = fdopen(fp->fd, mode);
		
#endif
#ifdef WINDOWS_m13
	si1 	local_mode[8];  // don't modify passed mode & make sure room for 'b' component
	si4	perm_mode;
	
	c = local_mode;
	*c++ = 'b';
	sys_mode_flags = _O_BINARY;  // all MED files are binary
	perm_mode = WN_PERM_MODE_DEFAULT_m13;
	if (read_mode == TRUE_m13) {
		// do not create
		*c++ = 'r';
		if (plus_mode == TRUE_m13) {
			sys_mode_flags = _O_RDWR;  // read & write
			*c++ = '+';
		} else {
			sys_mode_flags = _O_RDONLY;  // read only
		}
	} else {  // write_mode || append_mode
		sys_mode_flags = _O_CREAT;  // create if doesn't exist
		if (append_mode == TRUE_m13) {
			*c++ = 'a';
			sys_mode_flags |= _O_APPEND;  // append all writes
		} else {
			*c++ = 'w';
		}
		if (plus_mode == TRUE_m13) {
			sys_mode_flags |= _O_RDWR;  // read & write
			*c++ = '+';
		} else {
			sys_mode_flags |= _O_WRONLY;  // write only
		}
		if (trunc_mode == TRUE_m13)
			sys_mode_flags |= _O_TRUNC;  // clobber if exists
	}
	*c = 0;

	fp->fd = _open(path, sys_mode_flags, perm_mode);
	if (fp->fd >= 0)
		fp->fp = _fdopen(fp->fd, local_mode);
#endif
	
	// handle open error
	if (fp->fp == NULL) {
		free_m13((void *) fp);
		fexists = G_exists_m13(path);
		if (read_mode == TRUE_m13) {
			if (fexists == TRUE_m13)
				G_set_error_m13(E_OPEN_m13, "failed to open file \"%s\"", path);
			else
				G_set_error_m13(E_OPEN_m13, "file \"%s\" does not exist", path);
		} else {  // write & append modes
			if (fexists == TRUE_m13)
				G_set_error_m13(E_OPEN_m13, "failed to open file \"%s\"", path);
			else
				G_set_error_m13(E_OPEN_m13, "failed to create file \"%s\"", path);
		}
		return_m13(NULL);
	}
	
	// len & pos
	fstat_m13(fp->fd, &sb);
	if (fp->flags & FILE_FLAGS_LEN_m13)
		fp->len = (si8) sb.st_size;
	if (fp->flags & FILE_FLAGS_POS_m13) {
		if (append_mode == TRUE_m13) {
			if (fp->flags & FILE_FLAGS_LEN_m13)
				fp->pos = fp->len;
			else
				fp->pos = (si8) sb.st_size;
		}
	}

	// locking
	if (globals_m13->file_lock_mode == FLOCK_MODE_ALL_m13) {
		fp->flags |= FILE_FLAGS_LOCK_m13;
	} else if (globals_m13->file_lock_mode == FLOCK_MODE_MED_m13) {
		if (fp->flags & FILE_FLAGS_MED_m13)
			fp->flags |= FILE_FLAGS_LOCK_m13;
	}
	if (fp->flags & FILE_FLAGS_LOCK_m13) {
		fp->fid = CRC_calculate_m13((const ui1 *) fp->path, name_len);
		flock_m13(fp, FLOCK_OPEN_m13);  // create entry in locking table, don't lock
	}

	// open modes
	if (plus_mode == TRUE_m13)
		fp->flags |= (FILE_FLAGS_READ_m13 | FILE_FLAGS_WRITE_m13);
	else if (read_mode == TRUE_m13)
		fp->flags |= FILE_FLAGS_READ_m13;
	else if (write_mode == TRUE_m13)
		fp->flags |= FILE_FLAGS_WRITE_m13;
	if (append_mode == TRUE_m13)
		fp->flags |= FILE_FLAGS_APPEND_m13;

	// set permissions to file system values (may have been altered by umask)
	#if defined MACOS_m13 || defined LINUX_m13
	fp->perms = (ui2) sb.st_mode & FILE_PERM_STAT_MASK_m13;
	#endif
	#ifdef WINDOWS_m13
	if (sb.st_mode & _S_IREAD)
		fp->perms = FILE_PERM_UGO_R_m13;
	if (sb.st_mode & _S_IWRITE)
		fp->perms = FILE_PERM_UGO_W_m13;
	#endif
	
	// update access time
	if (fp->flags & FILE_FLAGS_TIME_m13)
		fp->acc = G_current_uutc_m13();
		
	return_m13(fp);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	fprintf_m13(void *fp, const si1 *fmt, ...)
{
	tern		is_stream;
	si1		*tmp_str;
	si4		ret_val;
	va_list		v_args;
	FILE		*std_fp;
	FILE_m13	*m13_fp;


	is_stream = FILE_stream_m13(fp);
	if (is_stream == FALSE_m13) {
		m13_fp = (FILE_m13 *) fp;
		std_fp = m13_fp->fp;
		if (m13_fp->flags & FILE_FLAGS_LOCK_m13)
			flock_m13(m13_fp, FLOCK_WRITE_LOCK_m13);
	} else {
		std_fp = (FILE *) fp;
	}

	va_start(v_args, fmt);
	ret_val = vasprintf_m13(&tmp_str, fmt, v_args);  // could just call vfprintf_m13() here & be done, but it's hardly any extra code, so duplicate & skip extra function call
	va_end(v_args);
	
	if (ret_val >= 0) {
#ifdef MATLAB_m13
		if (std_fp == stderr || std_fp == stdout)
			ret_val = mexPrintf("%s", tmp_str);
		else
#endif
		ret_val = fprintf(std_fp, "%s", tmp_str);
		free((void *) tmp_str);
	} else {
		G_set_error_m13(E_WRITE_m13, NULL);
	}

	if (is_stream == FALSE_m13) {
		if (m13_fp->flags & FILE_FLAGS_POS_m13)
			m13_fp->pos = ftell_m13(m13_fp);
		if (m13_fp->flags & FILE_FLAGS_LEN_m13)
			m13_fp->len = flen_m13(m13_fp);
		if (m13_fp->flags & FILE_FLAGS_LOCK_m13)
			flock_m13(m13_fp, FLOCK_WRITE_UNLOCK_m13);
		if (m13_fp->flags & FILE_FLAGS_TIME_m13)
			m13_fp->acc = G_current_uutc_m13();
	}

	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	fputc_m13(si4 c, void *fp)
{
	tern		is_stream;
	si4		ret_val;
	FILE		*std_fp;
	FILE_m13	*m13_fp;

	is_stream = FILE_stream_m13(fp);
	if (is_stream == FALSE_m13) {
		m13_fp = (FILE_m13 *) fp;
		std_fp = m13_fp->fp;
		if (m13_fp->flags & FILE_FLAGS_LOCK_m13)
			flock_m13(m13_fp, FLOCK_WRITE_LOCK_m13);
	} else {
		std_fp = (FILE *) fp;
	}

#ifdef MATLAB_m13
	if (std_fp == stderr || std_fp == stdout)
		ret_val = mexPrintf("%c", c);
	else
#endif
	ret_val = fputc(c, std_fp);
	
	if (is_stream == FALSE_m13) {
		if (m13_fp->flags & FILE_FLAGS_POS_m13)
			m13_fp->pos = ftell_m13(m13_fp);
		if (m13_fp->flags & FILE_FLAGS_LEN_m13)
			m13_fp->len = flen_m13(m13_fp);
		if (m13_fp->flags & FILE_FLAGS_LOCK_m13)
			flock_m13(m13_fp, FLOCK_WRITE_UNLOCK_m13);
		if (m13_fp->flags & FILE_FLAGS_TIME_m13)
			m13_fp->acc = G_current_uutc_m13();
	}

	if (ret_val >= 0) {
		if (is_stream == TRUE_m13)
			G_set_error_m13(E_WRITE_m13, NULL);
		else
			G_set_error_m13(E_WRITE_m13, "error writing to file \"%s\"", m13_fp->path);
	}
	
	return(ret_val);
}


size_t	fread_m13(void *ptr, size_t el_size, size_t n_elements, void *fp, ...)  // varargs(n_elements negative): tern (as si4) non_blocking
{
	tern		is_stream, non_blocking = FALSE_m13;
	size_t		nr;
	FILE		*std_fp;
	FILE_m13	*m13_fp;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// vararg
	if (n_elements < 0) {
		va_list		v_arg;
		
		n_elements = -n_elements;
		va_start(v_arg, fp);
		non_blocking = (tern) va_arg(v_arg, si4);
		va_end(v_arg);
	}
	
	is_stream = FILE_stream_m13(fp);
	if (is_stream == TRUE_m13) {
		std_fp = (FILE *) fp;
	} else {
		m13_fp = (FILE_m13 *) fp;
		std_fp = m13_fp->fp;
		if (m13_fp->flags & FILE_FLAGS_LOCK_m13) {
			if (non_blocking == TRUE_m13) {
				if (flock_m13(m13_fp, FLOCK_READ_LOCK_NB_m13) == FLOCK_LOCKED_m13)
					return_m13((size_t) FLOCK_LOCKED_m13);  // negative (can distinguish from number of elements read)
			} else {
				flock_m13(m13_fp, FLOCK_READ_LOCK_m13);
			}
		}
	}
	
	nr = fread(ptr, el_size, n_elements, std_fp);

	if (is_stream == TRUE_m13) {
		if (nr != n_elements)
			G_set_error_m13(E_READ_m13, NULL);
	} else {
		if (m13_fp->flags & FILE_FLAGS_LOCK_m13)
			flock_m13(m13_fp, FLOCK_READ_UNLOCK_m13);
		if (m13_fp->flags & FILE_FLAGS_POS_m13)
			m13_fp->pos += (el_size * n_elements);
		if (m13_fp->flags & FILE_FLAGS_TIME_m13)
			m13_fp->acc = G_current_uutc_m13();
		if (nr != n_elements)
			G_set_error_m13(E_READ_m13, "failed to read file \"%s\"", m13_fp->path);
	}

	return_m13(nr);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
#ifndef AT_DEBUG_m13
void	free_m13(void *ptr)
#else
void	AT_free_m13(const si1 *function, si4 line, void *ptr)
#endif
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
#ifdef AT_DEBUG_m13
	if (AT_remove_entry_m13(ptr, function, line) == FALSE_m13)
		return_void_m13;
#endif
	
	if (ptr) {
		#ifdef MATLAB_PERSISTENT_m13
		mxFree(ptr);
		#else
		free(ptr);
		#endif
	}
	
	return_void_m13;
}


// not a standard function, but closely related
#ifndef AT_DEBUG_m13
void	free_2D_m13(void **ptr, size_t dim1)
#else
void	AT_free_2D_m13(const si1 *function, si4 line, void **ptr, size_t dim1)
#endif
{
	si8 i;
	void	*base_address;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// dim1 == 0 indicates allocated en bloc per caller (caller could just use free_m13() in this case, as here)
	
	if (dim1 == 0) {
		#ifdef AT_DEBUG_m13
		AT_free_m13(function, line, (void *) ptr);
		#else
		free_m13((void *) ptr);
		#endif
		return_void_m13;
	}
		
	// allocated en bloc  (check all addresses because pointers may have been sorted)
	base_address = (void *) ((ui1 *) ptr + (dim1 * sizeof(void *)));
	for (i = 0; i < dim1; ++i) {
		if (ptr[i] == base_address) {
			#ifdef AT_DEBUG_m13
			AT_free_m13(function, line, (void *) ptr);
			#else
			free_m13((void *) ptr);
			#endif
			return_void_m13;
		}
	}

	// allocated separately
	for (i = 0; i < dim1; ++i) {
		#ifdef AT_DEBUG_m13
		AT_free_m13(function, line, ptr[i]);
		#else
		free_m13(ptr[i]);
		#endif
	}
	
	#ifdef AT_DEBUG_m13
	AT_free_m13(function, line, (void *) ptr);
	#else
	free_m13((void *) ptr);
	#endif

	return_void_m13;
}


// not a standard function, but closely related
#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	freeable_m13(void *address)
{
	ui8			address_val;
	HW_PARAMS_m13		*hw_params;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// returns whether address is freeable
	// heap starts at heap base & grows upward
	// MacOS & Linux stack base > heap_max_address & grows downward
	// Windows stack base < heap base & generally grows toward heap base (this may not always be true, but I have never seen it happen)
	// if getting unexpected results, consider compiling with AT_DEBUG_m13 to track down where errors occur
	// NOTE: not tested under 32-bit hardware or compilation

	if (address == NULL)
		return_m13(FALSE_m13);

#ifdef AT_DEBUG_m13
	return_m13(AT_freeable_m13(address));  // this will always work
#endif

	// all allocated heap addresses are at least divisible by 8
	address_val = (ui8) address;
	if (address_val & (ui8) 7)
		return_m13(FALSE_m13);

	// check if address in heap
	hw_params = &globals_m13->tables->HW_params;
	if (address_val > hw_params->heap_max_address)
		return_m13(FALSE_m13);
#ifndef MATLAB_m13  // true heap base in Matlab is from Matlab itself and so far below first allocated medlib variable
	if (address_val < hw_params->heap_base_address)  // covers NULL address case & Windows stack
		return_m13(FALSE_m13);
#endif

#ifdef MACOS_m13
	// check if address in allocation table
	if (malloc_size(address) == 0)
		return_m13(FALSE_m13);
#endif
	
	// Can't use malloc_size_m13() if address not allocated:
	// LINUX_m13: malloc_usable_size() generates unrecoverable segmentation fault
	// WINDOWS_m13: _msize() terminates process without signal

#ifdef LINUX_m13
	si4	err;
	
	// check that current protection can be changed
	err = mprotect(address, (size_t) 1, PROT_READ | PROT_WRITE);
	if (err)  // errno set: EACCES (not permitted), EINVAL (not page aligned), or ENOMEM (outside process address range)
		return_m13(FALSE_m13);
#endif

#ifdef WINDOWS_m13
	DWORD	err, curr_protection;

	// check that current protection can be changed
	err = VirtualProtect(address, (size_t) 1, (DWORD) PAGE_READONLY, &curr_protection);
	if (err == 0)  // errno set: probably ERROR_INVALID_ADDRESS
		return_m13(FALSE_m13);
	
	// reset protection if successful
	VirtualProtect(address, (size_t) 1, curr_protection, &err);  // second protection parameter cannot be NULL
#endif

	// checked all that we can check, possibly still false though
	return_m13(TRUE_m13);
}


void	*freopen_m13(const si1 *path, const si1 *mode, void *fp)
{
	tern		is_stream, mode_matches, read_mode, write_mode, append_mode, plus_mode, trunc_mode;
	si1		*c, tmp_path[PATH_BYTES_m13], sys_mode[8];
	si4		fd, main_mode_total;
	si8		len;
	FILE		*std_fp;
	FILE_m13	*m13_fp;
	struct_stat_m13	sb;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// condition path
	if (STR_empty_m13(path) == FALSE_m13) {
		G_full_path_m13(path, tmp_path);  // don't modify passed path
		path = tmp_path;
	}
	
	// get pointer type
	is_stream = FILE_stream_m13(fp);
	switch (is_stream) {
		case FALSE_m13:
			m13_fp = (FILE_m13 *) fp;
			std_fp = m13_fp->fp;
			if (STR_empty_m13(path) == FALSE_m13)  // passed path overrides
				strcpy(m13_fp->path, path);
			else
				path = m13_fp->path;
			if (m13_fp->flags & FILE_FLAGS_LOCK_m13)
				flock_m13(m13_fp, FLOCK_CLOSE_m13);
			break;
		case TRUE_m13:
			std_fp = (FILE *) fp;
			break;
		case UNKNOWN_m13:
			G_set_error_m13(E_OPEN_m13, "fp is empty");
			return_m13(NULL);
	}

	// check mode
	if (STR_empty_m13(mode) == TRUE_m13) {
		G_set_error_m13(E_OPEN_m13, "mode is empty");
		return_m13(NULL);
	}
	
	// check path
	if (STR_empty_m13(path) == TRUE_m13) {
		G_set_error_m13(E_OPEN_m13, "path is empty");
		return_m13(NULL);
	}
	
	eprintf_m13("");
	// check if closed
	if (fisopen_m13(fp) == FALSE_m13) {
		eprintf_m13("");
		if (is_stream == TRUE_m13) {
			eprintf_m13("");
			std_fp = fopen(path, mode);
			eprintf_m13("");
			if (std_fp == NULL) {
				G_set_error_m13(E_OPEN_m13, "error opening file \"%s\"", path);
				return_m13(NULL);
			}
			eprintf_m13("");
			return_m13(std_fp);  // if passed standard fp, return standard fp
			eprintf_m13("");
		} else if (is_stream == FALSE_m13) {
			eprintf_m13("");
			if (m13_fp->flags & FILE_FLAGS_ALLOCED_m13)
				free_m13(fp);
			eprintf_m13("");
		}
		eprintf_m13("");
		return_m13(fopen_m13(path, mode));  // return m13 fp
	}
	eprintf_m13("");
	
	// parse mode
	read_mode = write_mode = append_mode = plus_mode = trunc_mode = UNKNOWN_m13;
	c = (si1 *) mode - 1;
	while (*++c) {
		switch (*c) {
			case 'R':
			case 'r':
				read_mode = TRUE_m13;
				break;
			case 'W':
			case 'w':
				write_mode = TRUE_m13;
				break;
			case 'A':
			case 'a':
				append_mode = TRUE_m13;
				break;
			case 'N':
			case 'n':  // modifies 'w' mode, e.g. "wn" (random write without truncation)
				trunc_mode = FALSE_m13;
				break;
			case 'C':
			case 'c':  // modifies 'a' mode, e.g. "ac" (append write with truncation) ['c' for "clobber" because 't' is valid modifier in Windows]
				trunc_mode = TRUE_m13;
				break;
			case '+':
				plus_mode = TRUE_m13;
				break;
			default:  // skip 't' & 'b'; 'b' added below
				break;
		}
	}
	main_mode_total = read_mode + write_mode + append_mode;
	if (main_mode_total != 1) {
		free_m13(fp);
		G_set_error_m13(E_OPEN_m13, "invalid mode: \"%s\"", mode);
		return_m13(NULL);
	}
	if (write_mode == TRUE_m13) {
		if (trunc_mode == NOT_SET_m13)
			trunc_mode = TRUE_m13;  // default "w" behavior is to clobber
	} else if (append_mode == TRUE_m13) {
		if (trunc_mode == NOT_SET_m13)
			trunc_mode = FALSE_m13;  // default "a" behavior is not to clobber
	}
	
	// check if file already open in requested mode
	mode_matches = TRUE_m13;
	fd = fileno_m13(fp);
	if (is_stream == TRUE_m13) {
		#if defined MACOS_m13 || defined LINUX_m13
		si4	curr_mode;
		
		curr_mode = fcntl(fd, F_GETFL);
		if (plus_mode == TRUE_m13) {
			if ((curr_mode & O_RDWR) == 0)
				mode_matches = FALSE_m13;
		} else if (read_mode == TRUE_m13) {
			if ((curr_mode & O_RDONLY) == 0)
				mode_matches = FALSE_m13;
		} else if (write_mode == TRUE_m13 || append_mode == TRUE_m13) {
			if ((curr_mode & O_WRONLY) == 0)
				mode_matches = FALSE_m13;
		}
		if (append_mode == TRUE_m13) {
			if ((curr_mode & O_APPEND) == 0)
				mode_matches = FALSE_m13;
		}
		#endif
		#ifdef WINDOWS_m13
		FILE_ACCESS_INFORMATION	access_info;
		ui8			curr_mode;

		if (WN_query_information_file_m13(std_fp, (si4) FileAccessInformation, (void *) &access_info)) {
			curr_mode = (ui8) access_info.AccessFlags;
			mode_matches = TRUE_m13;
			if (plus_mode == TRUE_m13) {
				if ((curr_mode & GENERIC_READ) == 0)
					mode_matches = FALSE_m13;
				if ((curr_mode & GENERIC_WRITE) == 0)
					mode_matches = FALSE_m13;
			} else if (read_mode == TRUE_m13) {
				if ((curr_mode & GENERIC_READ) == 0)
					mode_matches = FALSE_m13;
			} else if (write_mode == TRUE_m13) {
				if ((curr_mode & GENERIC_WRITE) == 0)
					mode_matches = FALSE_m13;
			}
			if (append_mode == TRUE_m13) {
				if ((curr_mode & FILE_APPEND_DATA) == 0)
					mode_matches = FALSE_m13;
			}
		} else {
			mode_matches = FALSE_m13;
		}
		#endif
	} else {  // FILE_m13
		if (plus_mode == TRUE_m13) {
			if ((m13_fp->flags & FILE_FLAGS_READ_m13) == 0)
				mode_matches = FALSE_m13;
			if ((m13_fp->flags & FILE_FLAGS_WRITE_m13) == 0)
				mode_matches = FALSE_m13;
		} else if (read_mode == TRUE_m13) {
			if ((m13_fp->flags & FILE_FLAGS_READ_m13) == 0)
				mode_matches = FALSE_m13;
		} else if (write_mode == TRUE_m13) {
			if ((m13_fp->flags & FILE_FLAGS_WRITE_m13) == 0)
				mode_matches = FALSE_m13;
		}
		if (append_mode == TRUE_m13) {
			if ((m13_fp->flags & FILE_FLAGS_APPEND_m13) == 0)
				mode_matches = FALSE_m13;
		}
	}

	if (mode_matches == TRUE_m13) {
		if (trunc_mode == TRUE_m13) {  // handle clobber
			if (ftruncate_m13(fd, 0))
				return_m13(NULL);
			if (is_stream == FALSE_m13)
				m13_fp->pos = m13_fp->len = 0;
		} else {
			fseek_m13(fp, 0, SEEK_SET);
		}
		return_m13(fp);
	}
	
	// build system mode string
	c = (si1 *) sys_mode;
#ifdef WINDOWS_m13
	*c++ = 'b';
#endif
	if (read_mode == TRUE_m13) {
		*c++ = 'r';
	} else if (write_mode == TRUE_m13) {
		if (trunc_mode == TRUE_m13) {
			*c++ = 'w';
		} else { // trunc_mode == FALSE_m13, change system mide to "r+"
			*c++ = 'r';
			plus_mode = TRUE_m13;
		}
	} else { // append_mode == TRUE_m13
		*c++ = 'a';
	}
	if (plus_mode == TRUE_m13) {
		read_mode = write_mode = TRUE_m13;
		*c++ = '+';
	}
	*c = 0;
	
	eprintf_m13("sys_mode = %s", sys_mode);
	// reopen
	errno_reset_m13();
	std_fp = freopen(path, sys_mode, std_fp);
	if (std_fp == NULL) {
		G_set_error_m13(E_OPEN_m13, "can't reopen file \"%s\" with mode \"%s\"", path, sys_mode);
		return_m13(NULL);
	}

	// handle "ac" mode (done after because possible write permissions added in reopen)
#if defined MACOS_m13 || defined LINUX_m13
	fd = fileno(std_fp);
#endif
#ifdef WINDOWS_m13
	fd = _fileno(std_fp);
#endif
	if (append_mode == TRUE_m13 && trunc_mode == TRUE_m13)
		if (ftruncate_m13(fd, 0))
			return_m13(NULL);
	
	// rest of function sets FILE_m13 info
	if (is_stream == TRUE_m13)
		return_m13((void *) std_fp);
	
	// set FILE pointer & descriptor
	m13_fp->fp = std_fp;
	m13_fp->fd = fd;
	
	// update flags
	m13_fp->flags &= ~FILE_FLAGS_MODE_MASK_m13;
	if (plus_mode == TRUE_m13)
		m13_fp->flags |= (FILE_FLAGS_READ_m13 | FILE_FLAGS_WRITE_m13);
	else if (read_mode == TRUE_m13)
		m13_fp->flags |= FILE_FLAGS_READ_m13;
	else if (write_mode == TRUE_m13)
		m13_fp->flags |= FILE_FLAGS_WRITE_m13;
	if (append_mode == TRUE_m13)
		m13_fp->flags |= FILE_FLAGS_APPEND_m13;

	// set permissions
	fstat_m13(m13_fp->fd, &sb);
	#if defined MACOS_m13 || defined LINUX_m13
	m13_fp->perms = (ui2) sb.st_mode & FILE_PERM_STAT_MASK_m13;
	#endif
	#ifdef WINDOWS_m13
	if (sb.st_mode & _S_IREAD)
		m13_fp->perms = FILE_PERM_UGO_R_m13;
	if (sb.st_mode & _S_IWRITE)
		m13_fp->perms = FILE_PERM_UGO_W_m13;
	#endif
	
	// file length
	if (m13_fp->flags & FILE_FLAGS_LEN_m13)
		m13_fp->len = (si8) sb.st_size;
	
	// file position
	if (m13_fp->flags & FILE_FLAGS_POS_m13) {
		if (append_mode == TRUE_m13) {
			if (m13_fp->flags & FILE_FLAGS_LEN_m13)
				m13_fp->pos = m13_fp->len;
			else
				m13_fp->len = (si8) sb.st_size;
		} else {
			m13_fp->pos = 0;
		}
	}
	
	// locking
	if (globals_m13->file_lock_mode == FLOCK_MODE_ALL_m13) {
		m13_fp->flags |= FILE_FLAGS_LOCK_m13;
	} else if (globals_m13->file_lock_mode == FLOCK_MODE_MED_m13) {
		if (m13_fp->flags & FILE_FLAGS_MED_m13)
			m13_fp->flags |= FILE_FLAGS_LOCK_m13;
	}
	if (m13_fp->flags & FILE_FLAGS_LOCK_m13) {
		len = strlen(m13_fp->path);
		m13_fp->fid = CRC_calculate_m13((const ui1 *) m13_fp->path, len);
		flock_m13(m13_fp, FLOCK_OPEN_m13);  // create entry in locking table, don't lock
	}

	// access time
	if (m13_fp->flags & FILE_FLAGS_TIME_m13)
		m13_fp->acc = G_current_uutc_m13();
			
	return_m13(fp);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	fscanf_m13(void *fp, const si1 *fmt, ...)
{
	tern		is_stream;
	si4		ret_val;
	va_list		v_args;
	FILE		*std_fp;
	FILE_m13	*m13_fp;
	

	is_stream = FILE_stream_m13(fp);
	if (is_stream == TRUE_m13) {
		std_fp = (FILE *) fp;
	} else {
		m13_fp = (FILE_m13 *) fp;
		std_fp = m13_fp->fp;
		if (m13_fp->flags & FILE_FLAGS_LOCK_m13)
			flock_m13(m13_fp, FLOCK_READ_LOCK_m13);
	}

#ifdef WINDOWS_m13
	si1	*new_fmt = NULL;
	
	// convert format string
	new_fmt = WN_windify_format_string_m13(fmt);
	
	va_start(v_args, fmt);
	ret_val = vfscanf(std_fp, new_fmt, v_args);
	va_end(v_args);
	
	if (new_fmt != fmt)
		free((void *) new_fmt);
#endif
	
#if defined MACOS_m13 || defined LINUX_m13
	va_start(v_args, fmt);
	ret_val = vfscanf(std_fp, fmt, v_args);
	va_end(v_args);
#endif
	
	if (is_stream == FALSE_m13) {
		if (m13_fp->flags & FILE_FLAGS_POS_m13)  // ret_val is number of items converted
			m13_fp->pos = ftell_m13(m13_fp);
		if (m13_fp->flags & FILE_FLAGS_LOCK_m13)
			flock_m13(m13_fp, FLOCK_READ_UNLOCK_m13);
		if (m13_fp->flags & FILE_FLAGS_TIME_m13)
			m13_fp->acc = G_current_uutc_m13();
	}
	
	if (ret_val <= 0)
		G_set_error_m13(E_WRITE_m13, NULL);

	return(ret_val);
}


si4	fseek_m13(void *fp, si8 offset, si4 whence)
{
	tern		is_stream;
	si4		err;
	FILE		*std_fp;
	FILE_m13	*m13_fp;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	is_stream = FILE_stream_m13(fp);
	if (is_stream == TRUE_m13) {
		std_fp = (FILE *) fp;
	} else {
		m13_fp = (FILE_m13 *) fp;
		std_fp = m13_fp->fp;
	}

	errno_reset_m13();
#if defined MACOS_m13 || defined LINUX_m13
	err = fseek(std_fp, offset, whence);
#endif
#ifdef WINDOWS_m13
	err = _fseeki64(std_fp, offset, whence);
#endif

	if (err == 0) {
		if (is_stream == FALSE_m13) {
			if (m13_fp->flags & FILE_FLAGS_POS_m13) {
				switch (whence) {
					case SEEK_SET:
						m13_fp->pos = offset;
						break;
					case SEEK_CUR:
						m13_fp->pos += offset;
						break;
					case SEEK_END:
						if ((m13_fp->flags & FILE_FLAGS_LEN_m13) == 0)
							m13_fp->len = flen_m13(m13_fp);
						m13_fp->pos = m13_fp->len - offset;
						break;
				}
			}
		}
		return_m13(0);
	}
	
	return_m13(-1);
}
		
	
#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	fstat_m13(si4 fd, struct_stat_m13 *sb)
{
	si4	ret_val;
	
	
#if defined MACOS_m13 || defined LINUX_m13
	ret_val = fstat(fd, sb);
#endif
#ifdef WINDOWS_m13
	ret_val = _fstat64(fd, sb);
#endif
	
	return(ret_val);
}


si8	ftell_m13(void *fp)
{
	tern		is_stream;
	si8		pos;
	FILE		*std_fp;
	FILE_m13	*m13_fp;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	is_stream = FILE_stream_m13(fp);
	if (is_stream == FALSE_m13) {
		m13_fp = (FILE_m13 *) fp;
		std_fp = m13_fp->fp;
		if (m13_fp->flags & FILE_FLAGS_POS_m13) {
			if (m13_fp->flags & FILE_FLAGS_TIME_m13)
				m13_fp->acc = G_current_uutc_m13();
			return_m13(m13_fp->pos);
		}
	} else {
		std_fp = (FILE *) fp;
	}
	
#if defined MACOS_m13 || defined LINUX_m13
	pos = ftell(std_fp);
#endif
#ifdef WINDOWS_m13
	pos = _ftelli64(std_fp);
#endif
	
	if (is_stream == FALSE_m13)
		if (m13_fp->flags & FILE_FLAGS_TIME_m13)
			m13_fp->acc = G_current_uutc_m13();

	// error
	if (pos == -1) {
		if (is_stream == TRUE_m13)
			G_set_error_m13(E_UNKN_m13, "failed obtain the file current location");
		else
			G_set_error_m13(E_UNKN_m13, "failed obtain the current location in file \"%s\"", m13_fp->path);
	}

	return_m13(pos);
}
		
		
#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	ftruncate_m13(si4 fd, off_t len)
{
	si4	err;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// truncate or extend file described by fd to len bytes in size
	// if the file size is smaller than len, the extended region is filled with zeros
	
#if defined MACOS_m13 || defined LINUX_m13
	err = ftruncate(fd, len);
#endif
#ifdef WINDOWS_m13
	err = (si4) _chsize_s(fd, (__int64) len);
#endif
	
	return_m13(err);
}


size_t	fwrite_m13(void *ptr, size_t el_size, size_t n_elements, void *fp, ...)  // varargs(n_elements negative): si4 non_blocking
{
	tern		is_stream, non_blocking = FALSE_m13;
	size_t		nw;
	FILE		*std_fp;
	FILE_m13	*m13_fp;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// vararg
	if (n_elements < 0) {
		va_list	v_arg;
		
		n_elements = -n_elements;
		va_start(v_arg, fp);
		non_blocking = (tern) va_arg(v_arg, si4);
		va_end(v_arg);
	}

	is_stream = FILE_stream_m13(fp);
	if (is_stream == FALSE_m13) {
		m13_fp = (FILE_m13 *) fp;
		std_fp = m13_fp->fp;
		if (m13_fp->flags & FILE_FLAGS_LOCK_m13) {
			if (non_blocking == TRUE_m13) {
				if (flock_m13(m13_fp, FLOCK_WRITE_LOCK_NB_m13) == FLOCK_LOCKED_m13)
					return_m13(FLOCK_LOCKED_m13);
			} else {  // blocking
				flock_m13(m13_fp, FLOCK_WRITE_LOCK_m13);
			}
		}
		
		// get pos & len before write if needed
		if (m13_fp->flags & FILE_FLAGS_POS_m13)
			if ((m13_fp->flags & FILE_FLAGS_LEN_m13) == 0)
				m13_fp->len = flen_m13(m13_fp);
		if (m13_fp->flags & FILE_FLAGS_LEN_m13)
			if ((m13_fp->flags & FILE_FLAGS_POS_m13) == 0)
				m13_fp->pos = ftell_m13(m13_fp);
	} else {
		std_fp = (FILE *) fp;
	}
	
	nw = fwrite(ptr, el_size, n_elements, std_fp);
	if (nw != n_elements) {
		if (is_stream == TRUE_m13) {
			G_set_error_m13(E_READ_m13, NULL);
		} else {
			if (m13_fp->flags & FILE_FLAGS_LOCK_m13)
				flock_m13(m13_fp, FLOCK_WRITE_UNLOCK_m13);
			G_set_error_m13(E_READ_m13, "failed to write file \"%s\"", m13_fp->path);
		}
		return_m13(nw);
	}

	if (is_stream == FALSE_m13) {
		if ((m13_fp->flags & FILE_FLAGS_LEN_m13) || (m13_fp->flags & FILE_FLAGS_LEN_m13)) {
			if (m13_fp->flags & FILE_FLAGS_APPEND_m13) {  // append mode always appends regardless of prior file pointer position
				m13_fp->len += (el_size * n_elements);
				m13_fp->pos = m13_fp->len;
			} else {
				m13_fp->pos += (el_size * n_elements);
				if (m13_fp->pos > m13_fp->len)
					m13_fp->len = m13_fp->pos;
			}
		}
		if (m13_fp->flags & FILE_FLAGS_LOCK_m13)
			flock_m13(m13_fp, FLOCK_WRITE_UNLOCK_m13);
		if (m13_fp->flags & FILE_FLAGS_TIME_m13)
			m13_fp->acc = G_current_uutc_m13();
	}
	
	return_m13(nw);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si1	*getcwd_m13(si1 *buf, size_t size)
{
	// pass NULL for buf to just get pointer global string (size not used in this case)
	
#ifdef MATLAB_m13
	G_set_error_m13(E_UNKN_m13, "the current working directory is not defined for Matlab mex files => pass full path");
	return(NULL);
#endif

	if (*globals_m13->cwd == 0) {
		#if defined MACOS_m13 || defined LINUX_m13
		getcwd(globals_m13->cwd, (size_t) PATH_BYTES_m13);
		#endif
		#ifdef WINDOWS_m13
		_getcwd(globals_m13->cwd, (size_t) PATH_BYTES_m13);
		#endif
	}
	
	if (buf) {
		if (size > (size_t) PATH_BYTES_m13)
			size = (size_t) PATH_BYTES_m13;
		strncpy(buf, globals_m13->cwd, size);
		return(buf);
	}
	
	return(globals_m13->cwd);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
pid_t_m13	getpid_m13(void)
{
#if defined MACOS_m13 || defined LINUX_m13
	return(getpid());
#endif
#ifdef WINDOWS_m13
	return(GetCurrentProcessId());
#endif
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
pid_t_m13	gettid_m13(void)
{
#ifdef LINUX_m13
	return(gettid());
#endif
	
#ifdef MACOS_m13
	pid_t_m13	tid;
	
	pthread_threadid_np(NULL, &tid);  // NULL for thread returns current thread id
	return(tid);
#endif
	
#ifdef WINDOWS_m13
	return(GetCurrentThreadId());
#endif
}


#ifndef AT_DEBUG_m13
void	*malloc_m13(si8 n_bytes)
#else
void	*AT_malloc_m13(const si1 *function, si4 line, si8 n_bytes)
#endif
{
	tern	is_level_header = FALSE_m13;
	void	*ptr;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// pass negative n_bytes size to flag as level header
	
	if (n_bytes < 0) {
		n_bytes = -n_bytes;
		is_level_header = TRUE_m13;
	}
	
	if (n_bytes == 0) {
		G_set_error_m13(E_ALLOC_m13, "requested bytes is zero");
		return_m13(NULL);
	}
	
#ifdef MATLAB_PERSISTENT_m13
	ptr = mxMalloc((mwSize) n_bytes);
#else
	ptr = malloc((size_t) n_bytes);
#endif
	if (ptr == NULL) {
		G_set_error_m13(E_ALLOC_m13, NULL);
		return_m13(NULL);
	}
	
	// alloc tracking
#ifdef AT_DEBUG_m13
	AT_add_entry_m13(function, line, ptr, (size_t) n_bytes);
#endif

#ifdef MATLAB_PERSISTENT_m13
	mexMakeMemoryPersistent(ptr);
#endif
	
	if (is_level_header == TRUE_m13)
		((LH_m13 *) ptr)->flags |= LH_ALLOCATED_m13;
	
	return_m13(ptr);
}
		

// not a standard function, but closely related
#ifdef AT_DEBUG_m13
void	**AT_malloc_2D_m13(const si1 *function, si4 line, size_t dim1, si8 dim2_bytes)
#else
void	**malloc_2D_m13(size_t dim1, si8 dim2_bytes)
#endif
{
	tern		is_level_header = FALSE_m13;
	si8 		i;
	void		**ptr;
	size_t  	dim1_bytes, content_bytes, total_bytes;
	LH_m13		*lh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Returns pointer to 2 dimensional array (not zeroed) of dim1 by dim2 elements of size el_size
	// ptr[0] points to a one dimensional array of size (dim1 * dim2 * el_size)
	// The whole block can be freed with free(ptr)
	// pass negative el_size size to flag dim2 elements as level headers

	if (dim2_bytes < 0) {
		dim2_bytes = -dim2_bytes;
		is_level_header = TRUE_m13;
	}
	
	if (dim1 == 0 || dim2_bytes == 0) {
		G_set_error_m13(E_ALLOC_m13, "dimension 1 or dimension 2 bytes is zero");
		return_m13(NULL);
	}
	
	dim1_bytes = dim1 * sizeof(void *);
	content_bytes = dim1 * (size_t) dim2_bytes;
	total_bytes = dim1_bytes + content_bytes;
#ifdef AT_DEBUG_m13
	G_push_behavior_m13(SUPPRESS_ERROR_OUTPUT_m13);
	ptr = (void **) AT_malloc_m13(function, line, total_bytes);
	G_pop_behavior_m13();
#else
	#ifdef MATLAB_PERSISTENT_m13
	ptr = (void **) mxMalloc(total_bytes);
	#else
	ptr = (void **) malloc(total_bytes);
	#endif
#endif
	if (ptr == NULL) {
		G_set_error_m13(E_ALLOC_m13, NULL);
		return_m13(NULL);
	}

	ptr[0] = (void *) (ptr + dim1);
	for (i = 1; i < dim1; ++i)
		ptr[i] = (void *) ((ui1 *) ptr[i - 1] + dim2_bytes);
		
	if (is_level_header == TRUE_m13) {
		for (i = 0; i < dim1; ++i) {
			lh = (LH_m13 *) ptr[i];
			lh->flags &= ~LH_ALLOCATED_m13;
		}
	}

#ifdef MATLAB_PERSISTENT_m13
	mexMakeMemoryPersistent(ptr);
#endif

	return_m13(ptr);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
size_t	malloc_size_m13(void *address)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (address == NULL)
		return_m13(0);
	
#ifdef AT_DEBUG_m13
	si8		i;
	AT_ENTRY_m13	*ate;
	
	ate = globals_m13->AT_list->entries;
	for (i = globals_m13->AT_list->top_idx + 1; i--; ++ate) {
		if (ate->address == address)
			return_m13(ate->actual_bytes);
	}
	return_m13((size_t) 0);
#endif
	
#ifdef MACOS_m13
	return_m13(malloc_size(address));
#endif

#ifdef LINUX_m13
	// seg faults if address not allocated (no way around it)
	return_m13(malloc_usable_size(address));
#endif
	
#ifdef WINDOWS_m13
	// process terminates without signal on non-allocated pointer (no way around it without using Windows DEBUG functions)
	return_m13(_msize(address));
#endif
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	md_m13(const si1 *dir)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	return_m13(mkdir_m13(dir));
}


void	*memset_m13(void *ptr, si4 val, size_t n_members, ...)  // vargargs(n_members < 0): const void *el_val (val == el_size)
{
	si8		i;
	si2		*si2_p, si2_val;
	si4		*si4_p, si4_val;
	si8		*si8_p, si8_val;
	const void	*el_val;
	size_t		el_size, buf_len;
	va_list		v_arg;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (n_members < 0) {
		n_members = -n_members;
		va_start(v_arg, n_members);
		el_val = va_arg(v_arg, const void *);
		va_end(v_arg);
		el_size = (size_t) val;
	} else {  // standard call: single byte pattern
		el_val = (const void *) &val;
		el_size = (size_t) 1;
	}
	buf_len = n_members * el_size;
	
	// regular memset()
	if (el_size == 1) {
		memset(ptr, (si4) *((si1 *) el_val), buf_len);
		return_m13(ptr);
	}
	
#ifdef MACOS_m13
	switch (el_size) {  // optimized versions currently only for MacOS
		case 4:
			memset_pattern4(ptr, el_val, buf_len);
			return_m13(ptr);
		case 8:
			memset_pattern8(ptr, el_val, buf_len);
			return_m13(ptr);
		case 16:
			memset_pattern16(ptr, el_val, buf_len);
			return_m13(ptr);
	}
#endif
	
	switch (el_size) {
		case 2:
			si2_p = (si2 *) ptr;
			si2_val = *((si2 *) el_val);
			for (i = buf_len >> 1; i--;)
				*si2_p++ = si2_val;
			return_m13(ptr);
		case 4:
			si4_p = (si4 *) ptr;
			si4_val = *((si4 *) el_val);
			for (i = buf_len >> 2; i--;)
				*si4_p++ = si4_val;
			return_m13(ptr);
		case 8:
			si8_p = (si8 *) ptr;
			si8_val = *((si8 *) el_val);
			for (i = buf_len >> 3; i--;)
				*si8_p++ = si8_val;
			return_m13(ptr);
		// case 16:  removed because some OSs silently implement sf16 as sf8, which would be quite bad with this usage
		default:
			G_set_error_m13(E_UNKN_m13, "unsupported element size (%ld)", el_size);
			return_m13(NULL);
	}
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	mkdir_m13(const si1 *dir)
{
	si1	command[PATH_BYTES_m13 + 16], tmp_dir[PATH_BYTES_m13];
	si4	ret_val;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif
	
	// condition path
	G_full_path_m13(dir, tmp_dir);
	dir = (const si1 *) tmp_dir;

	#if defined MACOS_m13 || defined LINUX_m13
	sprintf_m13(command, "mkdir -p \"%s\"", dir);
	#endif
	#ifdef WINDOWS_m13
	sprintf_m13(command, "mkdir \"%s\"", dir);
	#endif
	
	ret_val = system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
	if (ret_val) {
		G_set_error_m13(E_OPEN_m13, "cannot create path");
		return_m13(FALSE_m13);
	}
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	mlock_m13(void *addr, size_t len, ...)  // varargs(addr == NULL): void *addr, size_t len, tern (as si4) zero_data)
{
	tern		zero_data;
	si4		ret_val;
	va_list		v_args;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	if (addr == NULL) {
		va_start(v_args, len);
		addr = va_arg(v_args, void *);
		len = va_arg(v_args, size_t);
		zero_data = (tern) va_arg(v_args, si4);
		va_end(v_args);
	} else {
		zero_data = FALSE_m13;
	}
	errno_reset_m13();

	#if defined MACOS_m13 || defined LINUX_m13
	ret_val = mlock(addr, len);
	#endif
	
	#ifdef WINDOWS_m13
	if (VirtualLock(addr, len))
		ret_val = 0;
	else
		ret_val = -1;
	#endif
	
	if (ret_val == 0) {
		if (zero_data == TRUE_m13)
			memset(addr, 0, len);  // force OS to give real memory before return (otherwise there can be a lag)
		return_m13(TRUE_m13);
	}
			
	return_m13(FALSE_m13);
}

	  
#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	mprotect_m13(void *address, size_t len, si4 protection)
{
	si4	ret_val, err;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// address must be page-aligned
	// PROT_NONE: set block to no access
	// PROT_READ: allow block to be read
	// PROT_WRITE: allow block to be written
	// PROT_EXEC: allow block to be executed
	// The passed protection mode can be ored: e.g read/write access == (PROT_READ | PROT_WRITE)
	// This function will replace the existing protection on the block with the passed value; it will or the passed value with the existing value
	
	// returns zero on success or:
	// EACCES: requested protection conflicts with the access permissions of the process on the specified address range
	// EINVAL: address is not page-aligned
	// ENOMEM: specified address range is outside of the address range of the process or includes an unmapped page
	// ENOTSUP: the combination of accesses requested in protection is not supported
	
	ret_val = 0;
	errno_reset_m13();

#if defined MACOS_m13 || defined LINUX_m13
	err = mprotect(address, len, protection);
	if (err) {
		G_set_error_m13(E_UNKN_m13, NULL);
		ret_val = errno_m13();
	}
#endif

#ifdef WINDOWS_m13
	switch(protection) {
		case PROT_NONE:
			protection = (si4) PAGE_NOACCESS;
			break;
		case PROT_READ:
			protection = (si4) PAGE_READONLY;
			break;
		case PROT_WRITE:
		case (PROT_READ | PROT_WRITE):
			protection = (si4) PAGE_READWRITE;  // no pure write mode in Windows
			break;
		case PROT_EXEC:
			protection = (si4) PAGE_EXECUTE;
			break;
		case (PROT_READ | PROT_EXEC):
			protection = (si4) PAGE_EXECUTE_READ;
			break;
		case (PROT_READ | PROT_WRITE | PROT_EXEC):
			protection = (si4) PAGE_EXECUTE_READWRITE;
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "unsupported mode");
			return_m13(ENOTSUP);
	}

	err = (si4) VirtualProtect(address, len, (DWORD) protection, NULL);
	
	if (err == 0) {
		ret_val = errno_m13();
		switch(ret_val) {
			case ERROR_INVALID_ADDRESS:
				G_set_error_m13(E_UNKN_m13, "invalid address");
				ret_val = EINVAL;
				break;
			// the following need to be figured out for Windows
			// case EACCES:
			// case ENOMEM:
			// case ENOTSUP:
			default:
				G_set_error_m13(E_UNKN_m13, NULL);
				ret_val = EINVAL;
				break;
		}
	}
#endif

	return_m13(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	munlock_m13(void *addr, size_t len)
{
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

#if defined MACOS_m13 || defined LINUX_m13
	if (munlock(addr, len) == 0)
		return_m13(TRUE_m13);
	#endif
	
	#ifdef WINDOWS_m13
	if (VirtualUnlock(addr, len))  // returns non-zero on success
		return_m13(TRUE_m13);
	#endif
		
	return_m13(FALSE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	mv_m13(const si1 *path, const si1 *new_path)
{
	si1	command[(PATH_BYTES_m13 * 2) + 16], tmp_path[PATH_BYTES_m13], tmp_new_path[PATH_BYTES_m13], enc_dir[PATH_BYTES_m13];
	si4	fe, ret_val;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// condition paths
	G_full_path_m13(path, tmp_path);
	path = (const si1 *) tmp_path;
	G_full_path_m13(new_path, tmp_new_path);
	new_path = (const si1 *) tmp_new_path;

	// check source exists
	fe = G_exists_m13(path);
	if (fe == FALSE_m13) {
		G_set_error_m13(E_UNKN_m13, "\"%s\" does not exist", path);
		return_m13(FALSE_m13);
	}
	
	// make target enclosing directory
	G_path_parts_m13(new_path, enc_dir, NULL, NULL);
	if (G_exists_m13(enc_dir) == FALSE_m13) {
		if (md_m13(enc_dir) == FALSE_m13) {
			G_set_error_m13(E_UNKN_m13, "could not create \"%s\"", enc_dir);
			return_m13(FALSE_m13);
		}
	}
	
	// move (use system() rather tha rename() so works across different file systems)
	#if defined MACOS_m13 || defined LINUX_m13
	sprintf_m13(command, "mv -f \"%s\" \"%s\"", path, new_path);
	#endif
	#ifdef WINDOWS_m13
	sprintf_m13(command, "move \\/y \"%s\" \"%s\"", path, new_path);
	#endif
	ret_val = system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
	if (ret_val) {
		G_set_error_m13(E_UNKN_m13, "could not move \"%s\" to \"%s\"", path, new_path);
		return_m13(FALSE_m13);
	}
	
	return_m13(TRUE_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
void	nap_m13(const si1 *nap_str)
{
	si1 *c;
	struct timespec nap;
	si8 num;
	

	// string format: <number>[<space>]<unit letter(s)>
	// e.g. to sleep for 1 millisecond:
	// "1 millisecond" == "1millisecond" == "1 ms" == "1ms" == "1 m" == "1m"

	if (STR_empty_m13(nap_str) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "NULL input string");
		return;
	}

	c = (si1 *) nap_str;
	num = *c++ - '0';
	while (*c >= '0' && *c <= '9' && *c) {
		num *= 10;
		num += *c++ - '0';
	}
	
	// optional space
	if (*c == 32)
		++c;

	// units: ns, us (or microseconds), ms (or milliseconds), sec, min, hours
	switch(*c) {
		case 'h':  // hours
			nap.tv_sec = num * (ui8) 3600;
			nap.tv_nsec = 0;
			break;
		case 'm':  // microseconds, milliseconds (default), or minutes
			if( *(c + 1) == 'i') {
				if (*(c + 2) == 'c') {  // microseconds
					nap.tv_sec = 0;
					nap.tv_nsec = num * (ui8) 1e3;
					break;
				}
				if (*(c + 2) == 'n') {  // minutes
					nap.tv_sec = num * (ui8) 60;
					nap.tv_nsec = 0;
					break;
				}
			}
			// milliseconds
			nap.tv_sec = 0;
			nap.tv_nsec = num * (ui8) 1e6;
			break;
		case 'n':  // nanoseconds
			nap.tv_sec = 0;
			nap.tv_nsec = num;
			break;
		case 's':  // seconds
			nap.tv_sec = num;
			nap.tv_nsec = 0;
			break;
		case 'u':  // microseconds
			nap.tv_sec = 0;
			nap.tv_nsec = num * (ui8) 1e3;
			break;
		default:
			G_set_error_m13(E_UNKN_m13, "\"%s\" is not a valid input string", nap_str);
			return;
	}
	
	// overflow
	if (nap.tv_nsec >= (ui8) 1e9) {
		nap.tv_sec = nap.tv_nsec / (ui8) 1e9;
		nap.tv_nsec -= (nap.tv_sec * (ui8) 1e9);
	}
	
	// sleep
#if defined MACOS_m13 || defined LINUX_m13
	nanosleep(&nap, NULL);
#endif
#ifdef WINDOWS_m13
	WN_nap_m13(&nap);
#endif

	return;
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	printf_m13(const si1 *fmt, ...)
{
	si1		*tmp_str;
	si4		ret_val;
	va_list		v_args;
	

	va_start(v_args, fmt);
	ret_val = vasprintf_m13(&tmp_str, fmt, v_args);  // could just call vprintf_m13() here & be done, but it's hardly any extra code, so duplicate & skip extra function call
	va_end(v_args);

	if (ret_val >= 0) {
#ifdef MATLAB_m13
		ret_val = mexPrintf("%s", tmp_str);
#else
		ret_val = printf("%s", tmp_str);
#endif
		free((void *) tmp_str);
	}
		
	return(ret_val);
}


si1	*pthread_getname_m13(pthread_t_m13 thread, si1 *thread_name, size_t name_len)
{
	// pass zero for thread_id to get name of calling thread
	// pass null thread_name to allocate
	
	pid_t_m13	_id;
	

	if (thread_name == NULL) {
		name_len = (size_t) PROC_THREAD_NAME_LEN_DEFAULT_m13;
	#ifdef AT_DEBUG_m13
		G_warning_message_m13("%s(): allocated thread name will not be tracked\n", __FUNCTION__);
		thread_name = (si1 *) malloc(name_len * sizeof(si1));
		if (thread_name == NULL) {
			G_error_message_m13("%s(): malloc() error\n", __FUNCTION__);
			return(NULL);
		}
	#else
		thread_name = (si1 *) malloc_m13(name_len * sizeof(si1));
	#endif
	}
	*thread_name = 0;
	
	if (thread == 0) {
		thread = pthread_self_m13();
		_id = gettid_m13();
	} else {
		_id = PROC_id_for_thread_m13(&thread);
	}
	
	// name main process
	if (_id == globals_m13->main_id) {
		strncpy_m13(thread_name, "main process", name_len);
		return(thread_name);
	}

# if defined MACOS_m13 || defined LINUX_m13
	pthread_getname_np(thread, thread_name, name_len);
# endif
		
# ifdef WINDOWS_m13
	HRESULT		res;
	
	res = GetThreadDescription(thread, (PWSTR *) &thread_name);
	if (SUCCEEDED(res))
		STR_wchar2char_m13(thread_name, (wchar_t *) thread_name);
# endif
	
	if (*thread_name == 0)
		strncpy_m13(thread_name, "<unnamed>", name_len);

	return(thread_name);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	pthread_join_m13(pthread_t_m13 thread, void **value_ptr)
{
	si4	ret_val;
	

#if defined MACOS_m13 || defined LINUX_m13
	ret_val = pthread_join(thread, value_ptr);
#endif
#ifdef WINDOWS_m13
	if (WaitForSingleObject(thread, INFINITE) == WAIT_OBJECT_0)
		ret_val = 0;
	else
		ret_val = -1;
#endif

	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	pthread_kill_m13(pthread_t_m13 thread, si4 signal)
{
	si4	ret_val;

	
#if defined MACOS_m13 || defined LINUX_m13
	// (signal == zero): thread killed without calling thread-local traps
	
	ret_val = pthread_kill(thread, signal);
#endif
	
#ifdef WINDOWS_m13
	// (signal == zero): thread exits with exit value zero (error)
	
	errno_reset_m13();
	ret_val = TerminateThread(thread, (DWORD) signal);
	if (ret_val)  // no-zero == success
		ret_val = 0;
	else
		ret_val = errno_m13();
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	pthread_mutex_destroy_m13(pthread_mutex_t_m13 *mutex)
{
	si4	ret_val;

#if defined MACOS_m13 || defined LINUX_m13
	ret_val = pthread_mutex_destroy(mutex);
#endif
#ifdef WINDOWS_m13
	ret_val = (si4) CloseHandle(*mutex) - (si4) 1;  // CloseHandle returns zero on fail
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	pthread_mutex_init_m13(pthread_mutex_t_m13 *mutex, pthread_mutexattr_t_m13 *attr)
{
	si4	ret_val;
	
#if defined MACOS_m13 || defined LINUX_m13
	ret_val = pthread_mutex_init(mutex, attr);
#endif
#ifdef WINDOWS_m13
	if ((*mutex = CreateMutex(attr, 0, NULL)) == NULL)
		ret_val = -1;
	else
		ret_val = 0;
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	pthread_mutex_lock_m13(pthread_mutex_t_m13 *mutex)
{
	si4	ret_val;
	
#if defined MACOS_m13 || defined LINUX_m13
	ret_val = pthread_mutex_lock(mutex);
#endif
#ifdef WINDOWS_m13
	if (WaitForSingleObject(*mutex, INFINITE) == WAIT_OBJECT_0)
		ret_val = 0;
	else
		ret_val = -1;
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	pthread_mutex_trylock_m13(pthread_mutex_t_m13 *mutex)
{
	si4	ret_val;
	
	// Non-blocking version of pthread_mutex_lock_m13()
	// If the mutex is valid & unlocked: locks the mutex & returns zero
	// If the mutex is valid & locked: returns EBUSY
	// If the mutex is invalid: returns EINVAL

#if defined MACOS_m13 || defined LINUX_m13
	ret_val = pthread_mutex_trylock(mutex);
#endif
	 
#ifdef WINDOWS_m13
	DWORD	win_ret_val;
	
	win_ret_val = WaitForSingleObject(mutex, (DWORD) 0);
	switch (win_ret_val) {
		case WAIT_ABANDONED:  // owning thread terminated - mutex given to calling thread
		case WAIT_OBJECT_0:  // mutex not owned - given to calling thread
			ret_val = 0;
			break;
		case WAIT_TIMEOUT:
			ret_val = EBUSY;
			break;
		case WAIT_FAILED:
		default:
			ret_val = EINVAL;
			break;
	}
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	pthread_mutex_unlock_m13(pthread_mutex_t_m13 *mutex)
{
	si4	ret_val;
	
#if defined MACOS_m13 || defined LINUX_m13
	ret_val = pthread_mutex_unlock(mutex);
#endif
#ifdef WINDOWS_m13
	if (ReleaseMutex(*mutex) == 0)
		ret_val = -1;
	else
		ret_val = 0;
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
pthread_t_m13	pthread_self_m13(void)
{
#if defined MACOS_m13 || defined LINUX_m13
	return(pthread_self());
#endif
	
#ifdef WINDOWS_m13
	return(GetCurrentThread());
#endif
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	putc_m13(si4 c, void *fp)
{
	return(fputc_m13(c, fp));
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	putch_m13(si4 c)
{
	si4	ret_val;

#ifdef MATLAB_m13
	ret_val = mexPrintf("%c", c);
#else
	#ifdef WINDOWS_m13
		ret_val = _putch(c);
	#endif
	#if defined MACOS_m13 || defined LINUX_m13
		ret_val = fputc(c, stdout);
	#endif
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	putchar_m13(si4 c)
{
#ifdef MATLAB_m13
	return(mexPrintf("%c", c));
#else
	return(fputc(c, stdout));
#endif
}


#ifdef AT_DEBUG_m13
void	*AT_realloc_m13(const si1 *function, si4 line, void *ptr, si8 n_bytes)
#else
void	*realloc_m13(void *ptr, si8 n_bytes)
#endif
{
	tern	is_level_header = FALSE_m13;
	void	*new_ptr;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// pass negative n_bytes size to flag as level header
	
	if (n_bytes < 0) {
		n_bytes = -n_bytes;
		is_level_header = TRUE_m13;
	} else if (n_bytes == 0) {
		return_m13(NULL);
	}
	
#ifdef AT_DEBUG_m13
	ui8	alloced_bytes;

	// see if already has enough memory
	alloced_bytes = AT_actual_size_m13(ptr);
	if (alloced_bytes >= n_bytes) {
		// update requested bytes field
		alloced_bytes = AT_requested_size_m13(ptr);
		if (n_bytes > alloced_bytes)
			AT_update_entry_m13(function, line, ptr, ptr, (size_t) n_bytes);
		return_m13(ptr);
	}
#endif
	
#ifdef MATLAB_PERSISTENT_m13
	new_ptr = mxRealloc(ptr, (mwSize) n_bytes);
#else
	new_ptr = realloc(ptr, (size_t) n_bytes);
#endif
	if (new_ptr == NULL) {
		G_set_error_m13(E_ALLOC_m13, "realloc failed");
		return_m13(NULL);
	}
	
	// alloc tracking
#ifdef AT_DEBUG_m13
	if (ptr)
		AT_update_entry_m13(function, line, ptr, new_ptr, (size_t) n_bytes);
	else
		AT_add_entry_m13(function, line, new_ptr, (size_t) n_bytes);
#endif
#ifdef MATLAB_PERSISTENT_m13
	mexMakeMemoryPersistent(new_ptr);
#endif
	
	if (is_level_header == TRUE_m13)
		((LH_m13 *) new_ptr)->flags |= LH_ALLOCATED_m13;
	
	return_m13(new_ptr);
}


// not a standard function, but closely related
#ifdef AT_DEBUG_m13
void	**AT_realloc_2D_m13(const si1 *function, si4 line, void **ptr, size_t curr_dim1, size_t new_dim1, size_t curr_dim2_bytes, si8 new_dim2_bytes)
#else
void	**realloc_2D_m13(void **ptr, size_t curr_dim1, size_t new_dim1, size_t curr_dim2_bytes, si8 new_dim2_bytes)
#endif
{
	tern	is_level_header = FALSE_m13;
	si8	i;
	void	**new_ptr;
	size_t	least_dim1, least_dim2_bytes;
	LH_m13	*lh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Returns pointer to a reallocated 2 dimensional array of new_dim1 by new_dim2_bytes elements (new unused elements are not zeroed)
	// ptr[0] points to a one dimensional array of size (new_dim1 * new_dim2_bytes)
	// The whole block can be freed with free(ptr)
	// Assumes memory was allocated with malloc_2D_m13() or calloc_2D_m13()
	// pass negative new_dim2_bytes to flag as level header
	
	if (new_dim2_bytes < 0) {
		new_dim2_bytes = -new_dim2_bytes;
		is_level_header = TRUE_m13;
	}

	if (new_dim1 == 0 || new_dim2_bytes == 0)
		return_m13(NULL);

	if (new_dim1 < curr_dim1)
		G_warning_message_m13("%s(): re-allocating first dimension to smaller size\n", __FUNCTION__);
	if (new_dim2_bytes < curr_dim2_bytes)
		G_warning_message_m13("%s(): re-allocating second dimension to smaller size\n", __FUNCTION__);
	
#ifdef AT_DEBUG_m13
	new_ptr = AT_malloc_2D_m13(function, line, new_dim1, new_dim2_bytes);
#else
	new_ptr = malloc_2D_m13(new_dim1, new_dim2_bytes);
#endif
	if (new_ptr == NULL) {
		G_set_error_m13(E_ALLOC_m13, "realloc failed");
		return_m13(NULL);
	}

	least_dim1 = (curr_dim1 <= new_dim1) ? curr_dim1 : new_dim1;
	least_dim2_bytes = (curr_dim2_bytes <= (size_t) new_dim2_bytes) ? curr_dim2_bytes : (size_t) new_dim2_bytes;
	for (i = 0; i < least_dim1; ++i)
		memcpy(new_ptr[i], ptr[i], least_dim2_bytes);
	
	free_m13((void *) ptr);
	
	if (is_level_header == TRUE_m13) {
		for (i = curr_dim1; i < new_dim1; ++i) {
			lh = (LH_m13 *) ptr[i];
			lh->flags &= ~LH_ALLOCATED_m13;
		}
	}

	return_m13(new_ptr);
}
		

// not a standard function, but closely related
#ifdef AT_DEBUG_m13
void	*AT_recalloc_m13(const si1 *function, si4 line, void *ptr, size_t curr_members, size_t new_members, si8 el_size)
#else
void	*recalloc_m13(void *ptr, size_t curr_members, size_t new_members, si8 el_size)
#endif
{
	tern	is_level_header = FALSE_m13;
	size_t	curr_bytes, new_bytes;
	void	*new_ptr;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// pass negative el_size size to flag as level header
	
	if (el_size < 0) {
		el_size = -el_size;
		is_level_header = TRUE_m13;
	}
	
	if (ptr == NULL || curr_members == 0 || new_members == 0 || el_size == 0)
		return_m13(NULL);
	
	curr_bytes = curr_members * (size_t) el_size;
	new_bytes = new_members * (size_t) el_size;
		
#ifdef MATLAB_PERSISTENT_m13
	new_ptr = mxRealloc(ptr, (mwSize) new_bytes);
#else
	new_ptr = realloc(ptr, new_bytes);
#endif
	if (new_ptr == NULL) {
		G_set_error_m13(E_ALLOC_m13, NULL);
		return_m13(NULL);
	}
	
	// zero new bytes
	if (new_bytes > curr_bytes)
		memset((ui1 *) new_ptr + curr_bytes, 0, new_bytes - curr_bytes);
	
	// alloc tracking
#ifdef AT_DEBUG_m13
	if (ptr)
		AT_update_entry_m13(function, line, ptr, new_ptr, new_bytes);
	else
		AT_add_entry_m13(function, line, new_ptr, new_bytes);
#endif
	
#ifdef MATLAB_PERSISTENT_m13
	mexMakeMemoryPersistent(new_ptr);
#endif
		
	if (is_level_header == TRUE_m13)
		((LH_m13 *) new_ptr)->flags |= LH_ALLOCATED_m13;
	
	return_m13(new_ptr);
}


#ifdef AT_DEBUG_m13
void	**AT_recalloc_2D_m13(const si1 *function, si4 line, void **ptr, size_t curr_dim1, size_t new_dim1, size_t curr_dim2, size_t new_dim2, si8 el_size)
#else
void	**recalloc_2D_m13(void **ptr, size_t curr_dim1, size_t new_dim1, size_t curr_dim2, size_t new_dim2, si8 el_size)
#endif
{
	tern	is_level_header = FALSE_m13;
	si8	i;
	void	**new_ptr;
	size_t	least_dim1, least_dim2, dim2_content_bytes, new_dim2_bytes;
	LH_m13	*lh;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// Returns pointer to a reallocated 2 dimensional array of new_dim1 by new_dim2 elements of size el_size (new unused elements are zeroed)
	// ptr[0] points to a one dimensional array of size (dim1 * dim2 * el_size)
	// Zeros any additionally allocated memory
	// The whole block can be freed with free(ptr)
	// Assumes memory was allocated with malloc_2D_m13() or calloc_2D_m13()
	// pass negative el_size size to flag as level header
	
	if (el_size < 0) {
		el_size = -el_size;
		is_level_header = TRUE_m13;
	}

	if (new_dim1 == 0 || new_dim2 == 0 || el_size == 0)
		return_m13(NULL);

	if (new_dim1 < curr_dim1)
		G_warning_message_m13("%s(): re-allocating first dimension to smaller size\n", __FUNCTION__);
	if (new_dim2 < curr_dim2)
		G_warning_message_m13("%s(): re-allocating second dimension to smaller size\n", __FUNCTION__);

#ifdef AT_DEBUG_m13
	new_ptr = AT_malloc_2D_m13(function, line, new_dim1, new_dim2 * (size_t) el_size);
#else
	new_ptr = malloc_2D_m13(new_dim1, new_dim2 * (size_t) el_size);
#endif
	if (new_ptr == NULL) {
		G_set_error_m13(E_ALLOC_m13, "realloc failed");
		return_m13(NULL);
	}

	least_dim1 = (curr_dim1 <= new_dim1) ? curr_dim1 : new_dim1;
	least_dim2 = (curr_dim2 <= new_dim2) ? curr_dim2 : new_dim2;

	dim2_content_bytes = least_dim2 * (size_t) el_size;
	new_dim2_bytes = new_dim2 * (size_t) el_size;
	if (new_dim2_bytes > dim2_content_bytes)
		new_dim2_bytes -= dim2_content_bytes;
	else
		new_dim2_bytes = 0;
	
	for (i = 0; i < least_dim1; ++i)
		memcpy(new_ptr[i], ptr[i], least_dim2 * (size_t) el_size);
	
	free_m13((void *) ptr);
	
	for (i = 0; i < new_dim1; ++i) {
		if (i < least_dim1) {
			if (new_dim2_bytes)
				memset((void *) ((ui1 *) new_ptr[i] + dim2_content_bytes), (si4) 0, new_dim2_bytes);
		} else {
			memset((void *) new_ptr[i], (si4) 0, dim2_content_bytes);
		}
	}

	if (is_level_header == TRUE_m13) {
		for (i = curr_dim1; i < new_dim1; ++i) {
			lh = (LH_m13 *) ptr[i];
			lh->flags &= ~LH_ALLOCATED_m13;
		}
	}

	return_m13(new_ptr);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
tern	rm_m13(const si1 *path)
{
	si1	command[PATH_BYTES_m13 + 16], tmp_path[PATH_BYTES_m13];
	si4	fe, ret_val;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// condition path
	G_full_path_m13(path, tmp_path);
	path = (const si1 *) tmp_path;

	fe = G_exists_m13(path);
	
	if (fe == FILE_EXISTS_m13) {
		ret_val = remove(path);
		if (ret_val) {
			G_set_error_m13(E_UNKN_m13, "could not remove file \"%s\"", path);
			return_m13(FALSE_m13);
		}
		return_m13(TRUE_m13);
	} else if (fe == DIR_EXISTS_m13) {
		#if defined MACOS_m13 || defined LINUX_m13
		sprintf_m13(command, "rm -Rf \"\%s\"", path);
		#endif
		#ifdef WINDOWS_m13
		sprintf_m13(command, "rmdir \\/s \\/q \"%s\"", path);
		#endif
		ret_val = system_m13(NULL, command, TRUE_m13, RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
		if (ret_val) {
			G_set_error_m13(E_UNKN_m13, "could not remove directory \"%s\"", path);
			return_m13(FALSE_m13);
		}
		return_m13(TRUE_m13);
	}
	
	return_m13(UNKNOWN_m13);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	scanf_m13(const si1 *fmt, ...)
{
	si4		ret_val;
	va_list		v_args;
	
#ifdef WINDOWS_m13
	si1* new_fmt = NULL;
	
	// convert format string
	new_fmt = WN_windify_format_string_m13(fmt);
	
	va_start(v_args, fmt);
	ret_val = vscanf(new_fmt, v_args);
	va_end(v_args);
	
	if (new_fmt != fmt)
		free((void *) new_fmt);
#endif
	
#if defined MACOS_m13 || defined LINUX_m13
	va_start(v_args, fmt);
	ret_val = vscanf(fmt, v_args);
	va_end(v_args);
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	snprintf_m13(si1 *target, si4 target_field_bytes, const si1 *fmt, ...)
{
	si4		ret_val;
	va_list		v_args;
	
	// as opposed to standard snprintf(), snprintf_m13() allows source & target strings to overlap
	
	va_start(v_args, fmt);
	ret_val = vsnprintf_m13(target, target_field_bytes, fmt, v_args);
	va_end(v_args);
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	sprintf_m13(si1 *target, const si1 *fmt, ...)
{
	si1		*tmp_str;
	si4		ret_val;
	va_list		v_args;
	

	// as opposed to standard sprintf(), sprintf_m13() allows source & target strings to overlap
		
	va_start(v_args, fmt);
	ret_val = vasprintf_m13(&tmp_str, fmt, v_args);  	// could just call vsprintf_m13() here & be done, but it's hardly any extra code, so duplicate & skip extra function call
	va_end(v_args);
	
	memcpy(target, tmp_str, ret_val + 1);
	free((void *) tmp_str);

	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	sscanf_m13(si1 *target, const si1 *fmt, ...)
{
	si4		ret_val;
	va_list		v_args;
	
#ifdef WINDOWS_m13
	si1* new_fmt = NULL;
	
	// convert format string
	new_fmt = WN_windify_format_string_m13(fmt);
	
	va_start(v_args, fmt);
	ret_val = vsscanf(target, new_fmt, v_args);
	va_end(v_args);
	
	if (new_fmt != fmt)
		free((void *) new_fmt);
#endif
	
#if defined MACOS_m13 || defined LINUX_m13
	va_start(v_args, fmt);
	ret_val = vsscanf(target, fmt, v_args);
	va_end(v_args);
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	stat_m13(const si1 *path, struct_stat_m13 *sb)
{
	si4	ret_val;
#if defined MACOS_m13 || defined LINUX_m13
	ret_val = stat(path, sb);
#endif
#ifdef WINDOWS_m13
	ret_val = _stat64(path, sb);
#endif
	
	return(ret_val);
}


si8	strcat_m13(si1 *target, const si1 *source)
{
	si1	*c;
	

	// appends a copy of "source" to "target", including terminal zero
	// "target"  must have sufficient space to hold the result
	// returns final length of "target" (not including terminal zero)
	// in contrast to standard strcat(), this function does not return a pointer to "target"
	
	if (target == NULL)
		return_m13((si8) 0);
	if (source == NULL) {
		c = target - 1;
		while (*++c);
		return((si8) (c - target));
	}
	
	for (c = target - 1; *++c;);
	while ((*c++ = *source++));
	
	return((si8) ((c - target) - 1));
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	strcmp_m13(const si1 *string_1, const si1 *string_2)
{
	// lexicographically compares "string_1" & "string_2"
	// returns 0 if equal, -1 (FALSE_m13) if not
	// note this version may be faster than standard strcmp() as it does not determine a string comparison value, only whether equal

	if (string_1 == string_2)
		return((si4) 0);
	
	if (string_1 == NULL || string_2 == NULL)
		return((si4) -1);

	while (*string_1 && *string_2)
		if (*string_1++ != *string_2++)
			return((si4) -1);
	
	if (*string_1 || *string_2)
		return((si4) -1);
	
	return((si4) 0);
}


si8	strcpy_m13(si1 *target, const si1 *source)
{
	const si1	*c2;
	si1		*c;
	si8		i, len;
	

	// returns final length of "target" (not including terminal zero)
	// in contrast to standard strcpy(), this function does not return a pointer to "target"
	// strings may overlap
	
	if (target == NULL || source == NULL)
		return(0);

	if (target <= source) {
		c = target - 1;
		c2 = source - 1;
		while ((*++c = *++c2));
		len = (si8) (c2 - source);
	} else {  // overwrite possible, copy backwards
		c2 = source - 1;
		while (*++c2);
		len = (si8) (c2 - source);

		c = target + len;
		c2 = source + len;
		i = len + 1;
		while (i--)
			*c-- = *c2--;
	}
	
	return(len);
}


si8	strncat_m13(si1 *target, const si1 *source, size_t n_chars)
{
	const si1	*c2;
	si1		*c;
	si8		i, len;
	

	// appends not more than "n_chars" characters from "source" to "target"
	// "n_chars" does not include the terminal zero
	// "target"  must have sufficient space to hold the result
	// returns the final length of "target" (not including terminal zero)
	// in contrast to standard strncat(), this function does not return a pointer to "target"
	// if final length is less than "n_chars", target is filled to "n_chars" with zeros

	if (target == NULL)
		return_m13((si8) 0);
	if (source == NULL) {
		c = target - 1;
		while (*++c);
		return((si8) (c - target));
	}
	
	for (c = target - 1; *++c;);
	for (--c, c2 = source - 1; (*++c = *++c2);) {
		if (n_chars--)
			continue;
		*c = 0;
		break;
	}
	len = (si8) (c - target);
	
	if (len < n_chars)
		for (i = n_chars - len; i--;)
			*c++ = 0;
		
	return(len);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	strncmp_m13(const si1 *string_1, const si1 *string_2, size_t n_chars)
{
	si8	len;
	

	// lexicographically compares "string_1" & "string_2" up to a maximum of "n_chars" characters
	// returns 0 if equal, -1 (FALSE_m13) if not
	// strings that are equal up to their terminal zeros they are considered equal even if they are less than "n_chars" in length
	// strings may overlap
	// note this version may be faster than standard strcmp() as it does not determine a string comparison value, only whether equal

	if (string_1 == string_2)
		return((si4) 0);
	
	if (string_1 == NULL || string_2 == NULL)
		return((si4) -1);

	len = (si8) n_chars;  // (size_t is unsigned)
	while (*string_1 && *string_2 && len--)
		if (*string_1++ != *string_2++)
			return((si4) -1);
	
	// fewer than n_chars matched
	if (len > 0)
		if (*string_1 || *string_2)  // one of strings did not terminate
			return((si4) -1);
	
	return((si4) 0);  // both strings terminated
}


si8	strncpy_m13(si1 *target, const si1 *source, size_t n_chars)
{
	const si1	*c2;
	si1		*c;
	si8		i, len;
	

	// copies not more than "n_chars" characters from "source" to "target"
	// returns final length of "target" (not including terminal zero)
	// in contrast to standard strncpy(), this function does not return a pointer to "target"
	// strings may overlap
	// if final length is less than "n_chars", target is filled to "n_chars" with zeros

	if (target == NULL || source == NULL)
		return(0);

	// get length of source
	c2 = source - 1;
	i = (si8) n_chars;
	while (*++c2) {
		if (i--)
			continue;
		break;
	}
	len = (si8) (c2 - source);
	
	if (target <= source) {  // copy forwards
		c = target;
		c2 = source;
		for (i = len; i--;)
			*c++ = *c2++;
		*c = 0;
	} else {  // overwrite possible, copy backwards
		c = target + len;
		*c-- = 0;
		c2 = source + (len - 1);
		for (i = len; i--;)
			*c-- = *c2--;
	}
	
	// zero remaining bytes
	if (len < n_chars) {
		c = target + len;
		for (i = n_chars - len; i--;)
			*c++ = 0;
	}
	
	return(len);
}


si4	system_m13(const si1 *command, ...) // varargs(command = NULL): si1 *command, tern (as si4) null_std_streams, ui4 behavior;
{
	tern	null_std_streams;
	ui4	behavior;
	si1	*temp_command;
	si4	ret_val, len, err;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	null_std_streams = FALSE_m13;
	if (command == NULL) {
		va_list		v_args;
		
		va_start(v_args, command);
		command = va_arg(v_args, si1 *);
		null_std_streams = (tern) va_arg(v_args, si4);
		behavior = (tern) va_arg(v_args, ui4);
		va_end(v_args);
	} else {
		behavior = CURRENT_BEHAVIOR_m13;
	}
	if (behavior == CURRENT_BEHAVIOR_m13)
		behavior = G_current_behavior_m13();
	
	if (null_std_streams == TRUE_m13) {
		len = strlen(command);
		temp_command = malloc(len + (PATH_BYTES_m13 << 1) + 16);
		sprintf(temp_command, "%s 1> %s 2> %s", command, NULL_DEVICE_m13, NULL_DEVICE_m13);  // don't use sprintf_m13() here - can screw up Windows options
		command = temp_command;
	}
	
	err = 0;
	errno_reset_m13();
#if defined MACOS_m13 || defined LINUX_m13
	ret_val = system(command);
	if (ret_val) {  // shell can return values in bytes 2-4 that do not indicate error
		err = errno_m13();
		if (err == 0)
			ret_val = 0;
	}
#endif
#ifdef WINDOWS_m13
	ret_val = WN_system_m13(command);
	err = errno_m13();
#endif
	if (ret_val) {
		if (behavior & RETRY_ONCE_m13) {
			nap_m13("1 ms");  // wait 1 ms
			errno_reset_m13();
			#if defined MACOS_m13 || defined LINUX_m13
			ret_val = system(command);
			if (ret_val) {  // shell can return values in bytes 2-4 that do not indicate error
				err = errno_m13();
				if (err == 0)
					ret_val = 0;
			}
			#endif
			#ifdef WINDOWS_m13
			ret_val = WN_system_m13(command);
			err = errno_m13();
			#endif
		}
	}
	if (null_std_streams == TRUE_m13)
		free((void *) temp_command);
	
	if (ret_val)
		if (!(behavior & IGNORE_SYSTEM_ERRORS_m13))
			G_set_error_m13(E_UNKN_m13, "command: \"%s\" failed", command);
	
	return_m13(err);
}


// not a standard function, but closely related
#if defined MACOS_m13 || defined LINUX_m13
si4	system_pipe_m13(si1 **buffer_ptr, si8 buf_len, const si1 *command, ui4 flags, ...)  // varargs(SP_SEPERATE_STREAMS_m13 set): si1 **e_buffer_ptr, si8 e_buf_len
{
	tern	command_needs_shell, pipe_failure, buffer_initially_null, e_buffer_initially_null;
	tern	free_buffer, free_e_buffer, assign_buffer, assign_e_buffer, realloc_buffer, realloc_e_buffer;
	si1	**e_buffer_ptr, *buffer, *e_buffer, *c, *command_p;
	ui4	behavior;
	si4	ret_val, status, err, BUFFER_SIZE_INC, stdout_pipe[2], stderr_pipe[2], retry_count;
	si8	bytes_in_buffer, bytes_in_e_buffer, bytes_avail, e_buf_len, tot_buf_len;
	pid_t	child_pid;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// executes command (for output, more efficient than redirecting to temp file & reading)
	// if buffer_ptr == NULL, no buffer is returned
	// if *buffer_ptr == NULL buffer is allocated (caller responsible for freeing)
	// else if *buffer_ptr is heap allocated, it will be dynamically reallocated as needed
	// *buffer_ptr will contains a NULL terminated string from the system command, if passed
	// if SP_SEPARATE_STREAMS_m13 flag is set, buffer string length returned in e_buf_len
	// if buffer_ptr or e_buffer_ptr are NULL, they will be freed upon return
	// if *buffer_ptr or *e_buffer_ptr are NULL:
	//	if there is content they will be allocated, ownership transfers to caller
	//	if there is no content, they will remain NULL
	// if *buffer_ptr or *e_buffer_ptr are not NULL:
	//	if the pointers are assignable, they will be reallocated as needed
	//	if they are NOT assignable, returned output will be restricted to the passed buffer sizes on overflow
	// 		if buf_len or e_buf_len are zero, the command will be executed with no output returned, only the system result
	// 		the output will still be read, so if SP_TEE_TO_TERMINAL_m13 is set, output still be displayed
	// returns system result code (0 on success or error code)
	
	if (STR_empty_m13(command) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "no command");
		return_m13(-1);
	}
	
	// see if shell required
	command_p = (si1 *) command;
	command_needs_shell = FALSE_m13;
	c = --command_p;  // (command re-incremented below)
	while (*++c) {
		switch (*c) {
			case '>':
			case '<':
			case '&':
			case '|':
			case '*':
			case '?':
			case '^':
			case '$':
			case '[':
			case '{':
			case 39:  // single quote / apostrophe
			case 96:  // grave accent
				command_needs_shell = TRUE_m13;
				goto SYSTEM_PIPE_NEEDS_SHELL_m13;  // break out of while loop
		}
	} SYSTEM_PIPE_NEEDS_SHELL_m13:
	
	// skip any leading spaces in command (& re-increment from above)
	while (*++command_p == 32);
	
	// discern calling configuration
	BUFFER_SIZE_INC = globals_m13->tables->HW_params.system_page_size;
	if (buffer_ptr == NULL) {
		free_buffer = TRUE_m13;
		assign_buffer = FALSE_m13;
		realloc_buffer = TRUE_m13;
		buffer = NULL;
		buf_len = 0;
	} else {
		free_buffer = FALSE_m13;
		buffer = *buffer_ptr;
		if (buffer == NULL) {  // no buffer passed, do with local buffers but do not return anything
			buffer_initially_null = TRUE_m13;
			assign_buffer = TRUE_m13;
			realloc_buffer = TRUE_m13;
			buf_len = 0;
		} else {  // buffer pointer passed
			assign_buffer = freeable_m13((void *) buffer);
			if (assign_buffer == TRUE_m13) {  // pointer can be modified
				buffer_initially_null = FALSE_m13;
				realloc_buffer = TRUE_m13;
				if (buf_len == 0)
					buf_len = malloc_size_m13((void *) buffer);
			} else {  // pointer cannot be modified
				if (buf_len == 0) {  // no length passed, do with local buffers but do not return anything
					free_buffer = TRUE_m13;
					realloc_buffer = TRUE_m13;
					buffer = NULL;
				} else {  // finite length passed, restrict output to passed length
					realloc_buffer = FALSE_m13;
				}
			}
		}
	}
	if (buf_len == 0) {
		buf_len = BUFFER_SIZE_INC;
		buffer = (si1 *) malloc_m13((size_t) buf_len);
	}
	
	// get varargs & set up error buffer
	if (flags & SP_SEPARATE_STREAMS_m13) {
		va_list		v_args;
		
		va_start(v_args, flags);
		e_buffer_ptr = va_arg(v_args, si1 **);
		e_buf_len = va_arg(v_args, si8);
		va_end(v_args);
	} else {
		e_buffer_ptr = NULL;
		e_buf_len = 0;
	}
	
	if (e_buffer_ptr == NULL) {
		free_e_buffer = TRUE_m13;
		assign_e_buffer = FALSE_m13;
		realloc_e_buffer = TRUE_m13;
		e_buffer = NULL;
		e_buf_len = 0;
	} else {
		free_e_buffer = FALSE_m13;
		e_buffer = *e_buffer_ptr;
		if (e_buffer == NULL) {  // no buffer passed, do with local buffers but do not return anything
			e_buffer_initially_null = TRUE_m13;
			assign_e_buffer = TRUE_m13;
			realloc_e_buffer = TRUE_m13;
			e_buf_len = 0;
		} else {  // buffer pointer passed
			assign_e_buffer = freeable_m13((void *) e_buffer);
			if (assign_e_buffer == TRUE_m13) {  // pointer can be modified
				e_buffer_initially_null = FALSE_m13;
				realloc_e_buffer = TRUE_m13;
				if (e_buf_len == 0)
					e_buf_len = malloc_size_m13((void *) buffer);
			} else {  // pointer cannot be modified
				if (e_buf_len == 0) {  // no length passed, do with local buffers but do not return anything
					free_e_buffer = TRUE_m13;
					realloc_e_buffer = TRUE_m13;
					e_buffer = NULL;
				} else {  // finite length passed, restrict output to passed length
					realloc_e_buffer = FALSE_m13;
				}
			}
		}
	}
	if (e_buf_len == 0) {
		e_buf_len = BUFFER_SIZE_INC;
		e_buffer = (si1 *) malloc_m13((size_t) e_buf_len);
	}
	
	behavior = G_current_behavior_m13();
	if (behavior & RETRY_ONCE_m13)
		retry_count = 1;
	else
		retry_count = 0;;

SYSTEM_PIPE_RETRY_m13:
	
	pipe_failure = FALSE_m13;
	err = 0;

	// spawn child
	*buffer = *e_buffer = 0;
	stdout_pipe[READ_END_m13] = stdout_pipe[WRITE_END_m13] = stderr_pipe[READ_END_m13] = stderr_pipe[WRITE_END_m13] = 0;
	if (pipe(stdout_pipe) || pipe(stderr_pipe)) {
		pipe_failure = TRUE_m13;
		goto SYSTEM_PIPE_FAIL_m13;
	}
		
	child_pid = fork();
	if (child_pid == -1) {
		pipe_failure = TRUE_m13;
		goto SYSTEM_PIPE_FAIL_m13;
	}
	
	if (child_pid == 0) {  // child process
		
		si1		*tmp_command, **args, *c2, *c3;
		si4		arg_cnt, alloced_args, ALLOCED_ARGS_INC;
		si8		command_len;
		
		
		// allocate argument pointers
		if (command_needs_shell == TRUE_m13)
			ALLOCED_ARGS_INC = 3;
		else
			ALLOCED_ARGS_INC = 10;
		alloced_args = ALLOCED_ARGS_INC;
		args = (si1 **) malloc((size_t) (alloced_args + 1) * sizeof(si1 *));
		
		// use shell to expand regex (less efficient, but simplest)
		if (command_needs_shell == TRUE_m13) {
#ifdef MACOS_m13
			args[0] = "/bin/sh";
#endif
#ifdef LINUX_m13
			args[0] = "/usr/bin/sh";
#endif
			args[1] = "-c";
			args[2] = command_p;
			args[3] = (char *) NULL;
			tmp_command = NULL;
		} else {  // parse args
			
			// copy command so not modified
			command_len = strlen(command_p) + 1;
			tmp_command = (si1 *) malloc((size_t) command_len);
			memcpy((void *) tmp_command, (void *) command_p, (size_t) command_len);
			c = tmp_command;
			
			arg_cnt = 0;
			args[arg_cnt++] = c;
			while (*c) {
				if (arg_cnt == alloced_args) {
					alloced_args += ALLOCED_ARGS_INC;
					args = (si1 **) realloc((void *) args, (size_t) (alloced_args + 1) * sizeof(si1 *));
				}
				if (*c == 34) {  // double quote, include all characters
					args[arg_cnt++] = ++c;  // skip initial quote
					while (*c != 34 && *c)
						++c;
					*c++ = 0;  // zero terminal quote
					continue;
				}
				if (*c == 32) {  // space delimiter
					if (*(c - 1) == 92) {  // escaped space, move rest of command back one character (shell would remove escape characters)
						c2 = c - 1;
						c3 = c;
						while ((*c2++ = *c3++));
						continue;
					}
					if (*(c + 1)) {
						*c = 0;
						args[arg_cnt++] = ++c;
						continue;
					}
				}
				++c;
			}
			args[arg_cnt] = (si1 *) NULL;  // terminal NULL argument
		}
		
		dup2(stdout_pipe[WRITE_END_m13], STDOUT_FILENO);  // change child stdout to write end of stdout pipe
		close(stdout_pipe[READ_END_m13]);  // close read end of stdout
		dup2(stderr_pipe[WRITE_END_m13], STDERR_FILENO);  // change child stderr fd to write end of stderr pipe
		close(stderr_pipe[READ_END_m13]);  // close read end of stderr
		
		// convert child to command
		// if execvp() is successful, it does not return
		// "p" version uses environment path if no "/" in args[0]
		// child-allocated memory will be freed by kernel on exit
		
		if (execvp(args[0], args) == -1) {
			close(stdout_pipe[WRITE_END_m13]);  // close write end of stdout
			close(stderr_pipe[WRITE_END_m13]);  // close write end of stderr
			free((void *) args);
			if (tmp_command)
				free((void *) tmp_command);
			exit(PIPE_FAILURE_SEND_m13);
		}
	}  // rest is parent
	
	// read child output
	
	// close write ends of pipes
	close(stdout_pipe[WRITE_END_m13]);
	close(stderr_pipe[WRITE_END_m13]);
	
	// read stdout
	bytes_in_buffer = 0;
	bytes_avail = buf_len;
	while (bytes_avail > 1) {
		ret_val = read(stdout_pipe[READ_END_m13], buffer + bytes_in_buffer, bytes_avail - 1);  // leave room for terminal zero
		if (ret_val <= 0)
			break;
		bytes_in_buffer += ret_val;
		bytes_avail -= ret_val;
		if (realloc_buffer == TRUE_m13) {
			if (bytes_avail < 2) {
				buf_len += BUFFER_SIZE_INC;
				buffer = (si1 *) realloc_m13((void *) buffer, (size_t) buf_len);
				bytes_avail += BUFFER_SIZE_INC;
			}
		}
	}
	buffer[bytes_in_buffer] = 0;  // set terminal zero
	
	// read stderr
	bytes_in_e_buffer = 0;
	bytes_avail = e_buf_len;
	while (bytes_avail > 1) {
		ret_val = read(stderr_pipe[READ_END_m13], e_buffer + bytes_in_e_buffer, bytes_avail - 1);  // leave room for terminal zero
		if (ret_val <= 0)
			break;
		bytes_in_e_buffer += ret_val;
		bytes_avail -= ret_val;
		if (realloc_e_buffer == TRUE_m13) {
			if (bytes_avail < 2) {
				e_buf_len += BUFFER_SIZE_INC;
				e_buffer = (si1 *) realloc_m13((void *) e_buffer, (size_t) e_buf_len);
				bytes_avail += BUFFER_SIZE_INC;
			}
		}
	}
	e_buffer[bytes_in_e_buffer] = 0;  // set terminal zero
	
	// wait for child
	waitpid(child_pid, &status, 1);  // "1": wait specifically & only for this child
	err = WEXITSTATUS(status);  // save any error code
	
	// errors
	if (bytes_in_e_buffer)
		goto SYSTEM_PIPE_FAIL_m13;
	if (err == PIPE_FAILURE_m13) {
		pipe_failure = TRUE_m13;
		goto SYSTEM_PIPE_FAIL_m13;
	}

	// close read ends of pipes
	close(stdout_pipe[READ_END_m13]);
	close(stderr_pipe[READ_END_m13]);
	
	// tee
	if (flags & SP_TEE_TO_TERMINAL_m13) {
		if (bytes_in_buffer || bytes_in_e_buffer) {
			G_message_m13("[%scmd%s]: %s\n", TC_BLUE_m13, TC_RESET_m13, command_p);
			if (bytes_in_buffer)
				G_message_m13("[%sout%s]: %s", TC_GREEN_m13, TC_RESET_m13, buffer);
			if (bytes_in_e_buffer)
				G_message_m13("[%serr%s]: %s", TC_RED_m13, TC_RESET_m13, e_buffer);
		}
	}
	
	// fuse buffers
	if ((flags & SP_SEPARATE_STREAMS_m13) == 0 && bytes_in_e_buffer) {
		tot_buf_len = bytes_in_buffer + bytes_in_e_buffer;
		if (tot_buf_len > buf_len) {
			if (realloc_buffer == TRUE_m13) {
				buf_len = tot_buf_len;
				buffer = (si1 *) realloc_m13((void *) buffer, (size_t) buf_len);
			}
		}
		strncat(buffer, e_buffer, buf_len);
	}

	if (free_buffer == TRUE_m13)
		free_m13((void *) buffer);
	if (free_e_buffer == TRUE_m13)
		free_m13((void *) e_buffer);
	if (assign_buffer == TRUE_m13) {
		if (*buffer) {
			*buffer_ptr = buffer;
		} else if (buffer_initially_null == TRUE_m13)
			free_m13((void *) buffer);
	}
	if (assign_e_buffer == TRUE_m13) {
		if (*e_buffer)
			*e_buffer_ptr = e_buffer;
		else if (e_buffer_initially_null == TRUE_m13)
			free_m13((void *) e_buffer);
	}

	return_m13(0);
	
SYSTEM_PIPE_FAIL_m13:

	// close read ends of pipes, if open
	if (stdout_pipe[READ_END_m13])
		close(stdout_pipe[READ_END_m13]);
	if (stderr_pipe[READ_END_m13])
		close(stderr_pipe[READ_END_m13]);

	if (retry_count) {
		nap_m13("1 ms");  // wait 1 ms
		--retry_count;
		G_warning_message_m13("%s(): initial attempt failed => retrying\n", __FUNCTION__);
		goto SYSTEM_PIPE_RETRY_m13;
	}

	// try with file redirection
	if (pipe_failure == TRUE_m13) {
		
		si1		*tmp_command, *tmp_file, *e_tmp_file;
		si8		len;
		FILE_m13	*fp;
		

		G_warning_message_m13("%s(): pipe mechanism failed => using file redirection\n", __FUNCTION__);

		len = strlen(command_p) + (2 * PATH_BYTES_m13) + 16;
		tmp_command = (si1 *) malloc_m13(len);
		tmp_file = G_unique_temp_file_name_m13(NULL);
		e_tmp_file = G_unique_temp_file_name_m13(NULL);
		sprintf_m13(tmp_command, "%s 1> %s 2> %s", command_p, tmp_file, e_tmp_file);
		err = system_m13(tmp_command);
		free((void *) tmp_command);
		
		fp = fopen_m13(tmp_file, "r");
		bytes_in_buffer = flen_m13(fp);
		if (realloc_buffer == TRUE_m13) {
			if (bytes_in_buffer >= buf_len) {
				buf_len = bytes_in_buffer + 1;
				buffer = (si1 *) realloc_m13((void *) buffer, (size_t) buf_len);  // allow for terminal zero
			}
		} else {
			bytes_in_buffer = buf_len - 1;
		}
		fread_m13((void *) buffer, sizeof(si1), (size_t) bytes_in_buffer, fp);
		fclose_m13(fp);
		buffer[bytes_in_buffer] = 0;  // terminal zero
		rm_m13(tmp_file);  // delete temp file
		free_m13((void *) tmp_file);

		fp = fopen_m13(e_tmp_file, "r");
		bytes_in_e_buffer = flen_m13(fp);
		if (realloc_e_buffer == TRUE_m13) {
			if (bytes_in_e_buffer >= e_buf_len) {
				e_buf_len = bytes_in_e_buffer + 1;
				e_buffer = (si1 *) realloc_m13((void *) buffer, (size_t) e_buf_len);  // allow for terminal zero
			}
		} else {
			bytes_in_e_buffer = e_buf_len - 1;
		}
		fread_m13((void *) e_buffer, sizeof(si1), (size_t) bytes_in_e_buffer, fp);
		fclose_m13(fp);
		e_buffer[bytes_in_e_buffer] = 0;  // terminal zero
		rm_m13(e_tmp_file);  // delete temp file
		free_m13((void *) e_tmp_file);

		if (err && bytes_in_e_buffer == 0) // there are many benign error codes => if no error text, ignore
			err = 0;
	}
	
	// errors (may not be if redirection worked)
	if (err) {
		if (!(behavior & IGNORE_SYSTEM_ERRORS_m13)) {
			G_set_error_m13(E_UNKN_m13, "command failed with message \"%s\" (err #%d)", strerror(err), err);
			if (!(behavior & SUPPRESS_ERROR_OUTPUT_m13))
				flags |= SP_TEE_TO_TERMINAL_m13;
		}
	}
	
	// tee
	if (flags & SP_TEE_TO_TERMINAL_m13) {
		if (bytes_in_buffer || bytes_in_e_buffer) {
			G_message_m13("[%scmd%s]: %s\n", TC_BLUE_m13, TC_RESET_m13, command_p);
			if (bytes_in_buffer)
				G_message_m13("[%sout%s]: %s", TC_GREEN_m13, TC_RESET_m13, buffer);
			if (bytes_in_e_buffer)
				G_message_m13("[%serr%s]: %s", TC_RED_m13, TC_RESET_m13, e_buffer);
		}
	}
	
	// fuse buffers
	if ((flags & SP_SEPARATE_STREAMS_m13) == 0 && bytes_in_e_buffer) {
		tot_buf_len = bytes_in_buffer + bytes_in_e_buffer;
		if (tot_buf_len > buf_len) {
			if (realloc_buffer == TRUE_m13) {
				buf_len = tot_buf_len;
				buffer = (si1 *) realloc_m13((void *) buffer, (size_t) buf_len);
			}
		}
		strncat(buffer, e_buffer, buf_len);
	}

	if (free_buffer == TRUE_m13)
		free_m13((void *) buffer);
	if (free_e_buffer == TRUE_m13)
		free_m13((void *) e_buffer);
	if (assign_buffer == TRUE_m13) {
		if (*buffer)
			*buffer_ptr = buffer;
		else if (buffer_initially_null == TRUE_m13)
			free_m13((void *) buffer);
	}
	if (assign_e_buffer == TRUE_m13) {
		if (*e_buffer)
			*e_buffer_ptr = e_buffer;
		else if (e_buffer_initially_null == TRUE_m13)
			free_m13((void *) e_buffer);
	}

	return_m13(err);
}
#endif  // MACOS_m13 || LINUX_m13


// not a standard function, but closely related
#ifdef WINDOWS_m13
si4	system_pipe_m13(si1 **buffer_ptr, si8 buf_len, const si1 *command, ui4 flags, ...)  // varargs(SP_SEPERATE_STREAMS_m13 set): si1 **e_buffer_ptr, si8 e_buf_len
{
	tern			pipe_failure, buffer_initially_null, e_buffer_initially_null;
	tern			free_buffer, free_e_buffer, assign_buffer, assign_e_buffer, realloc_buffer, realloc_e_buffer;
	si1			**e_buffer_ptr, *buffer, *e_buffer, cmd_exe_path[MAX_PATH], *tmp_command, *command_p;
	ui4			behavior;
	si4			BUFFER_SIZE_INC, err, retry_count;
	si8			len, e_buf_len, tot_buf_len;
	PROCESS_INFORMATION	process_info;
	STARTUPINFOA		startup_info;
	SECURITY_ATTRIBUTES 	sec_attr;
	HANDLE 			read_h, e_read_h, write_h, e_write_h;
	DWORD 			n_bytes_read, bytes_in_buffer, bytes_in_e_buffer, bytes_avail, exit_code;
	BOOL 			success;

#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// executes command (for output, more efficient than redirecting to temp file & reading)
	// if buffer_ptr == NULL, no buffer is returned
	// if *buffer_ptr == NULL buffer is allocated (caller responsible for freeing)
	// else if *buffer_ptr is heap allocated, it will be dynamically reallocated as needed
	// *buffer_ptr will contains a NULL terminated string from the system command, if passed
	// if SP_SEPARATE_STREAMS_m13 flag is set, buffer string length returned in e_buf_len
	// if buffer_ptr or e_buffer_ptr are NULL, they will be freed upon return
	// if *buffer_ptr or *e_buffer_ptr are NULL:
	//	if there is content they will be allocated, ownership transfers to caller
	//	if there is no content, they will remain NULL
	// if *buffer_ptr or *e_buffer_ptr are not NULL:
	//	if the pointers are assignable, they will be reallocated as needed
	//	if they are NOT assignable, returned output will be restricted to the passed buffer sizes on overflow
	// 		if buf_len or e_buf_len are zero, the command will be executed with no output returned, only the system result
	// 		the output will still be read, so if SP_TEE_TO_TERMINAL_m13 is set, output still be displayed
	// returns system result code (0 on success or error code)

	if (STR_empty_m13(command) == TRUE_m13) {
		G_set_error_m13(E_UNKN_m13, "no command");
		return_m13(-1);
	}
	
	// skip any leading spaces in command (& re-increment from above)
	command_p = (si1 *) command - 1;
	while (*++command_p == 32);
	
	// discern calling configuration
	BUFFER_SIZE_INC = globals_m13->tables->HW_params.system_page_size;
	if (buffer_ptr == NULL) {
		free_buffer = TRUE_m13;
		assign_buffer = FALSE_m13;
		realloc_buffer = TRUE_m13;
		buffer = NULL;
		buf_len = 0;
	} else {
		free_buffer = FALSE_m13;
		buffer = *buffer_ptr;
		if (buffer == NULL) {  // no buffer passed, do with local buffers but do not return anything
			buffer_initially_null = TRUE_m13;
			assign_buffer = TRUE_m13;
			realloc_buffer = TRUE_m13;
			buf_len = 0;
		} else {  // buffer pointer passed
			assign_buffer = freeable_m13((void *) buffer);
			if (assign_buffer == TRUE_m13) {  // pointer can be modified
				buffer_initially_null = FALSE_m13;
				realloc_buffer = TRUE_m13;
				if (buf_len == 0)
					buf_len = malloc_size_m13((void *) buffer);
			} else {  // pointer cannot be modified
				if (buf_len == 0) {  // no length passed, do with local buffers but do not return anything
					free_buffer = TRUE_m13;
					realloc_buffer = TRUE_m13;
					buffer = NULL;
				} else {  // finite length passed, restrict output to passed length
					realloc_buffer = FALSE_m13;
				}
			}
		}
	}
	if (buf_len == 0) {
		buf_len = BUFFER_SIZE_INC;
		buffer = (si1 *) malloc_m13((size_t) buf_len);
	}
	
	// get varargs & set up error buffer
	if (flags & SP_SEPARATE_STREAMS_m13) {
		va_list		v_args;
		
		va_start(v_args, flags);
		e_buffer_ptr = va_arg(v_args, si1 **);
		e_buf_len = va_arg(v_args, si8);
		va_end(v_args);
	} else {
		e_buffer_ptr = NULL;
		e_buf_len = 0;
	}
	
	if (e_buffer_ptr == NULL) {
		free_e_buffer = TRUE_m13;
		assign_e_buffer = FALSE_m13;
		realloc_e_buffer = TRUE_m13;
		e_buffer = NULL;
		e_buf_len = 0;
	} else {
		free_e_buffer = FALSE_m13;
		e_buffer = *e_buffer_ptr;
		if (e_buffer == NULL) {  // no buffer passed, do with local buffers but do not return anything
			e_buffer_initially_null = TRUE_m13;
			assign_e_buffer = TRUE_m13;
			realloc_e_buffer = TRUE_m13;
			e_buf_len = 0;
		} else {  // buffer pointer passed
			assign_e_buffer = freeable_m13((void *) e_buffer);
			if (assign_e_buffer == TRUE_m13) {  // pointer can be modified
				e_buffer_initially_null = FALSE_m13;
				realloc_e_buffer = TRUE_m13;
				if (e_buf_len == 0)
					e_buf_len = malloc_size_m13((void *) buffer);
			} else {  // pointer cannot be modified
				if (e_buf_len == 0) {  // no length passed, do with local buffers but do not return anything
					free_e_buffer = TRUE_m13;
					realloc_e_buffer = TRUE_m13;
					e_buffer = NULL;
				} else {  // finite length passed, restrict output to passed length
					realloc_e_buffer = FALSE_m13;
				}
			}
		}
	}
	if (e_buf_len == 0) {
		e_buf_len = BUFFER_SIZE_INC;
		e_buffer = (si1 *) malloc_m13((size_t) e_buf_len);
	}

	behavior = G_current_behavior_m13();
	if (behavior & RETRY_ONCE_m13)
		retry_count = 1;
	else
		retry_count = 0;;
	
SYSTEM_PIPE_RETRY_m13:
	
	pipe_failure = FALSE_m13;
	errno_reset_m13();  // parent globals
	err = 0;

	tmp_command = NULL;
	read_h = e_read_h = NULL;
	write_h = e_write_h = NULL;
	ZeroMemory(&process_info, sizeof(PROCESS_INFORMATION));
	ZeroMemory(&startup_info, sizeof(STARTUPINFO));

	// create pipes
	sec_attr.nLength = sizeof(SECURITY_ATTRIBUTES);
	sec_attr.lpSecurityDescriptor = NULL;
	sec_attr.bInheritHandle = TRUE;
	if (CreatePipe(&read_h, &write_h, &sec_attr, 0) == FALSE) {
		pipe_failure = TRUE_m13;
		goto SYSTEM_PIPE_FAIL_m13;
	}
	if (SetHandleInformation(read_h, HANDLE_FLAG_INHERIT, 0) == FALSE) {  // process should not inherit read handle of read pipe
		pipe_failure = TRUE_m13;
		goto SYSTEM_PIPE_FAIL_m13;
	}
	if (CreatePipe(&e_read_h, &e_write_h, &sec_attr, 0) == FALSE) {
		pipe_failure = TRUE_m13;
		goto SYSTEM_PIPE_FAIL_m13;
	}
	if (SetHandleInformation(e_read_h, HANDLE_FLAG_INHERIT, 0) == FALSE) {  // process should not inherit read handle of read pipe
		pipe_failure = TRUE_m13;
		goto SYSTEM_PIPE_FAIL_m13;
	}
	
	// set up process
	GetEnvironmentVariableA("COMSPEC", cmd_exe_path, MAX_PATH);
	len = 5;
	len += strlen(cmd_exe_path);
	len += strlen(command_p);
	tmp_command = (si1 *) malloc((size_t) len);
	sprintf(tmp_command, "%s /c %s", cmd_exe_path, command);

	startup_info.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;  // make nShowWindow member valid
	startup_info.wShowWindow = SW_HIDE;
	startup_info.hStdOutput = write_h;
	if (flags & SP_SEPARATE_STREAMS_m13)
		startup_info.hStdError = e_write_h;
	else
		startup_info.hStdError = write_h;  // put stdout & stderr on same pipe
	
	// start process
	errno_reset_m13();
	if (CreateProcessA(cmd_exe_path, tmp_command, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &startup_info, &process_info) == 0) {
		pipe_failure = TRUE_m13;
		goto SYSTEM_PIPE_FAIL_m13;
	}
	free((void *) tmp_command);

	// close unused pipe ends
	CloseHandle(write_h);
	CloseHandle(e_write_h);

	// read combined or stdout pipe
	bytes_in_buffer = 0;
	bytes_avail = buf_len;
	while (bytes_avail > 1) {
		success = ReadFile(read_h, buffer + bytes_in_buffer, bytes_avail - 1, &n_bytes_read, NULL);  // leave room for terminal zero
		if (success == FALSE || n_bytes_read == 0)
			break;
		bytes_in_buffer += n_bytes_read;
		bytes_avail -= n_bytes_read;
		if (realloc_buffer == TRUE_m13) {
			if (bytes_avail < 2) {
				buf_len += BUFFER_SIZE_INC;
				buffer = (si1 *) realloc_m13((void *) buffer, (size_t) buf_len);
				bytes_avail += BUFFER_SIZE_INC;
			}
		}
	}
	buffer[bytes_in_buffer] = 0;  // set terminal zero

	bytes_in_e_buffer = 0;
	bytes_avail = e_buf_len;
	while (bytes_avail > 1) {
		success = ReadFile(read_h, buffer + bytes_in_buffer, bytes_avail - 1, &n_bytes_read, NULL);  // leave room for terminal zero
		if (success == FALSE || n_bytes_read == 0)
			break;
		bytes_in_e_buffer += n_bytes_read;
		bytes_avail -= n_bytes_read;
		if (realloc_e_buffer == TRUE_m13) {
			if (bytes_avail < 2) {
				e_buf_len += BUFFER_SIZE_INC;
				e_buffer = (si1 *) realloc_m13((void *) e_buffer, (size_t) e_buf_len);
				bytes_avail += BUFFER_SIZE_INC;
			}
		}
	}
	buffer[bytes_in_e_buffer] = 0;  // set terminal zero

	// check process
	if (GetExitCodeProcess(process_info.hProcess, &exit_code))  // call to GetExitCodeProcess() succeeded, not the process itself
		err = (si4) exit_code;
	else
		err = errno_m13();

	// close process & read ends of pipes
	CloseHandle(read_h);
	CloseHandle(e_read_h);
	CloseHandle(process_info.hProcess);  // process handle
	CloseHandle(process_info.hThread);  // process' primary thread handle
	
	// errors
	if (pipe_failure == TRUE_m13)
		goto SYSTEM_PIPE_FAIL_m13;
	if (err) {
		if (bytes_in_e_buffer == 0)  // there are many benign error codes => if no error text, ignore
			err = 0;
		else
			goto SYSTEM_PIPE_FAIL_m13;
	}

	// tee
	if (flags & SP_TEE_TO_TERMINAL_m13) {
		if (bytes_in_buffer || bytes_in_e_buffer) {
			G_message_m13("[%scmd%s]: %s\n", TC_BLUE_m13, TC_RESET_m13, command_p);
			if (bytes_in_buffer)
				G_message_m13("[%sout%s]: %s", TC_GREEN_m13, TC_RESET_m13, buffer);
			if (bytes_in_e_buffer)
				G_message_m13("[%serr%s]: %s", TC_RED_m13, TC_RESET_m13, e_buffer);
		}
	}

	// fuse buffers
	if ((flags & SP_SEPARATE_STREAMS_m13) == 0 && bytes_in_e_buffer) {
		tot_buf_len = bytes_in_buffer + bytes_in_e_buffer;
		if (tot_buf_len > buf_len) {
			if (realloc_buffer == TRUE_m13) {
				buf_len = tot_buf_len;
				buffer = (si1 *) realloc_m13((void *) buffer, (size_t) buf_len);
			}
		}
		strncat(buffer, e_buffer, buf_len);
	}

	if (free_buffer == TRUE_m13)
		free_m13((void *) buffer);
	if (free_e_buffer == TRUE_m13)
		free_m13((void *) e_buffer);
	if (assign_buffer == TRUE_m13) {
		if (*buffer)
			*buffer_ptr = buffer;
		else if (buffer_initially_null == TRUE_m13)
			free_m13((void *) buffer);
	}
	if (assign_e_buffer == TRUE_m13) {
		if (*e_buffer)
			*e_buffer_ptr = e_buffer;
		else if (e_buffer_initially_null == TRUE_m13)
			free_m13((void *) e_buffer);
	}

	return_m13(0);

SYSTEM_PIPE_FAIL_m13:
	
	if (tmp_command)
		free((void *) tmp_command);
	if (read_h)
		CloseHandle(read_h);
	if (e_read_h)
		CloseHandle(e_read_h);
	if (process_info.hProcess)
		CloseHandle(process_info.hProcess);
	if (process_info.hThread)
		CloseHandle(process_info.hThread);

	if (retry_count) {
		nap_m13("1 ms");  // wait 1 ms
		--retry_count;
		G_warning_message_m13("%s(): initial attempt failed => retrying\n", __FUNCTION__);
		goto SYSTEM_PIPE_RETRY_m13;
	}

	// try with file redirection
	if (pipe_failure == TRUE_m13) {
		si1		*tmp_file, *e_tmp_file;
		FILE_m13	*fp;
		
		G_warning_message_m13("%s(): pipe mechanism failed => using file redirection\n", __FUNCTION__);

		len = strlen(command_p) + (2 * PATH_BYTES_m13) + 16;
		tmp_command = (si1 *) malloc((size_t) len);
		tmp_file = G_unique_temp_file_name_m13(NULL);
		if (flags & SP_SEPARATE_STREAMS_m13)
			e_tmp_file = G_unique_temp_file_name_m13(NULL);
		else
			e_tmp_file = tmp_file;
		sprintf_m13(tmp_command, "%s 1> %s 2> %s", command, tmp_file, e_tmp_file);
		err = system_m13(tmp_command);
		free((void *) tmp_command);
		fp = fopen_m13(tmp_file, "r");
		bytes_in_buffer = flen_m13(fp);
		if (realloc_buffer == TRUE_m13) {
			if (bytes_in_buffer >= buf_len) {
				buf_len = bytes_in_buffer + 1;
				buffer = (si1 *) realloc_m13((void *) buffer, (size_t) buf_len);  // allow for terminal zero
			}
		} else {
			bytes_in_buffer = buf_len - 1;
		}
		fread_m13((void *) buffer, sizeof(si1), (size_t) bytes_in_buffer, fp);
		fclose_m13(fp);
		buffer[bytes_in_buffer] = 0;  // terminal zero
		rm_m13(tmp_file);  // delete temp file
		free_m13((void *) tmp_file);
		
		fp = fopen_m13(e_tmp_file, "r");
		bytes_in_e_buffer = flen_m13(fp);
		if (realloc_e_buffer == TRUE_m13) {
			if (bytes_in_e_buffer >= e_buf_len) {
				e_buf_len = bytes_in_e_buffer +  1;
				e_buffer = (si1 *) realloc_m13((void *) buffer, (size_t) e_buf_len);  // allow for terminal zero
			}
		} else {
			bytes_in_e_buffer = e_buf_len - 1;
		}
		fread_m13((void *) e_buffer, sizeof(si1), (size_t) e_buf_len, fp);
		fclose_m13(fp);
		e_buffer[bytes_in_e_buffer] = 0;  // terminal zero
		rm_m13(e_tmp_file);  // delete temp file
		free_m13((void *) e_tmp_file);
	}
	
	// errors (may not be if redirection worked)
	if (err) {
		if (!(behavior & IGNORE_SYSTEM_ERRORS_m13)) {
			G_set_error_m13(E_UNKN_m13, "command failed with message \"%s\" (err #%d)", strerror(err), err);
			if (!(behavior & SUPPRESS_ERROR_OUTPUT_m13))
				flags |= SP_TEE_TO_TERMINAL_m13;
		}
	}

	// tee
	if (flags & SP_TEE_TO_TERMINAL_m13) {
		if (bytes_in_buffer || bytes_in_e_buffer) {
			G_message_m13("[%scmd%s]: %s\n", TC_BLUE_m13, TC_RESET_m13, command_p);
			if (bytes_in_buffer)
				G_message_m13("[%sout%s]: %s", TC_GREEN_m13, TC_RESET_m13, buffer);
			if (bytes_in_e_buffer)
				G_message_m13("[%serr%s]: %s", TC_RED_m13, TC_RESET_m13, e_buffer);
		}
	}
	
	// fuse buffers
	if ((flags & SP_SEPARATE_STREAMS_m13) == 0 && bytes_in_e_buffer) {
		tot_buf_len = bytes_in_buffer + bytes_in_e_buffer;
		if (tot_buf_len > buf_len) {
			if (realloc_buffer == TRUE_m13) {
				buf_len = tot_buf_len;
				buffer = (si1 *) realloc_m13((void *) buffer, (size_t) buf_len);
			}
		}
		strncat(buffer, e_buffer, buf_len);
	}

	if (free_buffer == TRUE_m13)
		free_m13((void *) buffer);
	if (free_e_buffer == TRUE_m13)
		free_m13((void *) e_buffer);
	if (assign_buffer == TRUE_m13) {
		if (*buffer)
			*buffer_ptr = buffer;
		else if (buffer_initially_null == TRUE_m13)
			free_m13((void *) buffer);
	}
	if (assign_e_buffer == TRUE_m13) {
		if (*e_buffer)
			*e_buffer_ptr = e_buffer;
		else if (e_buffer_initially_null == TRUE_m13)
			free_m13((void *) e_buffer);
	}

	return_m13(err);
}

#endif  // WINDOWS_m13
		  

#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	truncate_m13(const si1 *path, off_t len)
{
	si4		err;
	FILE_m13	*fp;
	
#ifdef FT_DEBUG_m13
	G_push_function_m13();
#endif

	// truncate or extend file named by path to len bytes in size
	// if the file size is smaller than len, the extended region is filled with zeros
	
	fp = fopen_m13(path, "r+");
	err = ftruncate_m13(fp->fd, len);
	fclose_m13(fp);
	
	return_m13(err);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	vasprintf_m13(si1 **target, const si1 *fmt, va_list args)
{
	si4	ret_val;
	

	// Note: this function returns a system allocated string whose ownership is transfered to the caller
	// if using AT_DEBUG functions, this memory is not entered into the allocation list, and should be freed with free(), not free_m13()
	
#ifdef WINDOWS_m13  // no vasprintf() in Windows
	va_list		args_copy;
	
	*target = (si1 *) calloc((size_t) PRINTF_BUF_LEN_m13, sizeof(si1));
	va_copy(args_copy, args);  // save a copy before use in case need to realloc
	G_push_behavior_m13(RETURN_ON_FAIL_m13 | SUPPRESS_OUTPUT_m13);
	ret_val = vsnprintf_m13(*target, PRINTF_BUF_LEN_m13, fmt, args);
	G_pop_behavior_m13();
	
	// release excess memory (OS may not), or expand memory to required size
	*target = (si1 *) realloc((void *) *target, (size_t) (ret_val + 1));
	if (ret_val >= PRINTF_BUF_LEN_m13)
		ret_val = vsnprintf_m13(*target, ret_val + 1, fmt, args_copy);
#endif
	
#if defined MACOS_m13 || defined LINUX_m13
	ret_val = vasprintf(target, fmt, args);
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	vfprintf_m13(void *fp, const si1 *fmt, va_list args)
{
	tern		is_stream;
	si1		*tmp_str;
	si4		ret_val;
	FILE		*std_fp;
	FILE_m13	*m13_fp;


	is_stream = FILE_stream_m13(fp);
	if (is_stream == FALSE_m13) {
		m13_fp = (FILE_m13 *) fp;
		std_fp = m13_fp->fp;
		if (m13_fp->flags & FILE_FLAGS_LOCK_m13)
			flock_m13(m13_fp, FLOCK_WRITE_LOCK_m13);
	} else {
		std_fp = (FILE *) fp;
	}

	ret_val = vasprintf_m13(&tmp_str, fmt, args);
	
	if (ret_val >= 0) {
#ifdef MATLAB_m13
		if (stream == stderr || stream == stdout)
			ret_val = mexPrintf("%s", tmp_str);
		else
#endif
		ret_val = fprintf(std_fp, "%s", tmp_str);
		free((void *) tmp_str);
	}

	if (is_stream == FALSE_m13) {
		if (m13_fp->flags & FILE_FLAGS_POS_m13)
			m13_fp->pos = ftell_m13(fp);
		if (m13_fp->flags & FILE_FLAGS_LEN_m13)
			m13_fp->len = flen_m13(m13_fp);
		if (m13_fp->flags & FILE_FLAGS_LOCK_m13)
			flock_m13(m13_fp, FLOCK_WRITE_UNLOCK_m13);
		if (m13_fp->flags & FILE_FLAGS_TIME_m13)
			m13_fp->acc = G_current_uutc_m13();
	}
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	vprintf_m13(const si1 *fmt, va_list args)
{
	si1	*tmp_str;
	si4	ret_val;
	

	ret_val = vasprintf_m13(&tmp_str, fmt, args);
	
	if (ret_val >= 0) {
#ifdef MATLAB_m13
		ret_val = mexPrintf("%s", tmp_str);
#else
		ret_val = printf("%s", tmp_str);
#endif
		free((void *) tmp_str);
	}
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	vsnprintf_m13(si1 *target, si4 target_field_bytes, const si1 *fmt, va_list args)
{
	si4	ret_val;
	si1	*tmp_str;
	

	//******** vsnprintf_m13() CONTAINS THE WINDOWS FORMATTING FOR ALL MED PRINTF FUNCTIONS ********//
	
	// as opposed to standard vsnprintf(), vsnprintf_m13() allows source & target strings to overlap
	
	if (target_field_bytes <= 1) {
		if (target_field_bytes == 1) {
			*target = 0;
			return_m13(0);
		}
		return(-1);
	}
	
#ifdef WINDOWS_m13
	tern	free_fmt = FALSE_m13;
	si1	*new_fmt;
	
	// convert format string
	new_fmt = WN_windify_format_string_m13(fmt);
	
	if (new_fmt != fmt) {
		fmt = new_fmt;
		free_fmt = TRUE_m13;
	}
#endif
	// Guarantee zeros in unused bytes per MED requirements
	tmp_str = (si1 *) calloc((size_t) target_field_bytes, sizeof(si1));
	ret_val = vsnprintf(tmp_str, target_field_bytes, fmt, args);
	
	// Guarantee terminal zero on overflow (not done in Linux & Windows)
	if (ret_val >= target_field_bytes) {
		tmp_str[target_field_bytes - 1] = 0;
		G_warning_message_m13("%s(): target string truncated\n", __FUNCTION__);
	}
	memcpy(target, tmp_str, target_field_bytes);
	free((void *) tmp_str);
	
#ifdef WINDOWS_m13
	// convert file system paths
	WN_windify_file_paths_m13(NULL, target);

	// clean up
	if (free_fmt == TRUE_m13)
		free((void *) new_fmt);
#endif
	
	return(ret_val);
}


#ifndef WINDOWS_m13  // inline causes linking problem in Windows
inline
#endif
si4	vsprintf_m13(si1 *target, const si1 *fmt, va_list args)
{
	si1		*tmp_str;
	si4		ret_val;
	

	// as opposed to standard vsprintf(), vsprintf_m13() allows source & target strings to overlap
	
	ret_val = vasprintf_m13(&tmp_str, fmt, args);
	
	memcpy(target, tmp_str, ret_val + 1);
	free((void *) tmp_str);

	return(ret_val);
}

